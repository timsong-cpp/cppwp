<!DOCTYPE html><html lang='en'><head><title>[class.init]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>10</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>10.9</a> Initialization <a class='abbr_ref'>[class.init]</a></h2><span class='indexparent'><a class='index' id=':initialization,class_object'></a></span><span class='indexparent'><a class='index' id=':initialization,default_constructor_and'></a></span><span class='indexparent'><a class='index' id=':initialization,constructor_and'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5498'>#</a></div><div id='1.sentence-1' class='sentence'>When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
<span class='texttt'>()</span>,
the object is initialized as specified in <a href='dcl.init'>[dcl.init]</a><a class='hidden_link' href='#1.sentence-1'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5505'>#</a></div><div id='2.sentence-1' class='sentence'>An object of class type (or array thereof) can be explicitly initialized;
see <a href='#class.expl.init'>[class.expl.init]</a> and <a href='#class.base.init'>[class.base.init]</a><a class='hidden_link' href='#2.sentence-1'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5509'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':order_of_execution,constructor_and_array'></a></span>When an array of class objects is initialized
(either explicitly or implicitly) and the elements are initialized by constructor,
the constructor shall be called for each element of the array,
following the subscript order; see <a href='dcl.array'>[dcl.array]</a><a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-2' class='sentence'>Destructors for the array elements are called in reverse order of their
construction<a class='hidden_link' href='#3.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div id='class.expl.init' class='section'><h3 ><a class='secnum' href='#class.expl.init' style='min-width:103pt'>10.9.1</a> Explicit initialization <a class='abbr_ref' href='class.expl.init'>[class.expl.init]</a></h3><span class='indexparent'><a class='index' id=':initialization,explicit'></a></span><span class='indexparent'><a class='index' id=':initialization,constructor_and_'></a></span><div class='para' id='class.expl.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5524'>#</a></div><div id='class.expl.init-1.sentence-1' class='sentence'>An object of class type can be initialized with a parenthesized
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
where the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
is construed as an argument list for a constructor
that is called to initialize the object<a class='hidden_link' href='#class.expl.init-1.sentence-1'>.</a></div> <div id='class.expl.init-1.sentence-2' class='sentence'>Alternatively, a single
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
can be specified as an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>
using the
<span class='texttt'>=</span>
form of initialization<a class='hidden_link' href='#class.expl.init-1.sentence-2'>.</a></div> <div id='class.expl.init-1.sentence-3' class='sentence'>Either direct-initialization semantics or copy-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a><a class='hidden_link' href='#class.expl.init-1.sentence-3'>.</a></div> <div id='class.expl.init-1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.expl.init-1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>complex(double)</span> with argument <span class='tcode_in_codeblock'>1</span>
</span>complex b = a;                  <span class='comment'>// initialized as a copy of <span class='tcode_in_codeblock'>a</span>
</span>complex c = complex(1,2);       <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>complex(double,double)</span> with arguments <span class='tcode_in_codeblock'>1</span> and <span class='tcode_in_codeblock'>2</span>
</span>complex d = sqrt(b,c);          <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>sqrt(complex,complex)</span> with <span class='tcode_in_codeblock'>d</span> as its result object
</span>complex e;                      <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>complex()</span>
</span>complex f = 3;                  <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>complex(double)</span> with argument <span class='tcode_in_codeblock'>3</span>
</span>complex g = { 1, 2 };           <span class='comment'>// initialized by calling <span class='tcode_in_codeblock'>complex(double, double)</span> with arguments <span class='tcode_in_codeblock'>1</span> and <span class='tcode_in_codeblock'>2</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.expl.init-1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.expl.init-1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.expl.init-1.sentence-4' class='sentence'><span class='indexparent'><a class='index' id=':initialization,overloaded_assignment_and'></a></span>Overloading of the assignment operator (<a href='over.ass'>[over.ass]</a>)
has no effect on initialization<a class='hidden_link' href='#class.expl.init-1.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.expl.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5565'>#</a></div><div id='class.expl.init-2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,array_of_class_objects'></a></span><span class='indexparent'><a class='index' id=':constructor,array_of_class_objects_and'></a></span>An object of class type can also be initialized by a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i><a class='hidden_link' href='#class.expl.init-2.sentence-1'>.</a></div> <div id='class.expl.init-2.sentence-2' class='sentence'>List-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a> and <a href='dcl.init.list'>[dcl.init.list]</a><a class='hidden_link' href='#class.expl.init-2.sentence-2'>.</a></div> <div id='class.expl.init-2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.expl.init-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
complex v[6] = { 1, complex(1,2), complex(), 2 };</pre><div id='class.expl.init-2.sentence-3' class='sentence'>Here,
<span class='texttt'>complex&#x200b;::&#x200b;complex(double)</span>
is called for the initialization of
<span class='texttt'>v[0]</span>
and
<span class='texttt'>v[3]</span>,
<span class='texttt'>complex&#x200b;::&#x200b;complex(&#x200b;double, double)</span>
is called for the initialization of
<span class='texttt'>v[1]</span>,
<span class='texttt'>complex&#x200b;::&#x200b;complex()</span>
is called for the initialization
<span class='texttt'>v[2]</span>,
<span class='texttt'>v[4]</span>,
and
<span class='texttt'>v[5]</span><a class='hidden_link' href='#class.expl.init-2.sentence-3'>.</a></div> <div id='class.expl.init-2.sentence-4' class='sentence'>For another example,</div><pre class='codeblock'>
struct X {
  int i;
  float f;
  complex c;
} x = { 99, 88.8, 77.7 };</pre><div id='class.expl.init-2.sentence-5' class='sentence'>Here,
<span class='texttt'>x.i</span>
is initialized with 99,
<span class='texttt'>x.f</span>
is initialized with 88.8, and
<span class='texttt'>complex&#x200b;::&#x200b;complex(double)</span>
is called for the initialization of
<span class='texttt'>x.c</span><a class='hidden_link' href='#class.expl.init-2.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.expl.init-2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.expl.init-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.expl.init-2.sentence-6' class='sentence'>Braces can be elided in the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see <a href='dcl.init.aggr'>[dcl.init.aggr]</a><a class='hidden_link' href='#class.expl.init-2.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.expl.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5617'>#</a></div><div id='class.expl.init-3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.expl.init-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.expl.init-3.sentence-1' class='sentence'>If
<span class='texttt'>T</span>
is a class type with no default constructor,
any declaration of an object of type
<span class='texttt'>T</span>
(or array thereof) is ill-formed if no
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>
is explicitly specified (see <a href='#class.init'>[class.init]</a> and <a href='dcl.init'>[dcl.init]</a>)<a class='hidden_link' href='#class.expl.init-3.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.expl.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5629'>#</a></div><div id='class.expl.init-4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.expl.init-4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.expl.init-4.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':order_of_execution,constructor_and_static_objects'></a></span>The order in which objects with static or thread storage duration
are initialized is described in <a href='basic.start.dynamic'>[basic.start.dynamic]</a> and <a href='stmt.dcl'>[stmt.dcl]</a><a class='hidden_link' href='#class.expl.init-4.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div></div><div id='class.base.init' class='section'><h3 ><a class='secnum' href='#class.base.init' style='min-width:103pt'>10.9.2</a> Initializing bases and members <a class='abbr_ref' href='class.base.init'>[class.base.init]</a></h3><span class='indexparent'><a class='index' id=':initialization,base_class'></a></span><span class='indexparent'><a class='index' id=':initialization,member'></a></span><div class='para' id='class.base.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5640'>#</a></div><div id='class.base.init-1.sentence-1' class='sentence'>In the definition of a constructor for a class,
initializers for direct and virtual base class subobjects and
non-static data members can be specified by a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>,
which has the form</div><pre class='bnf'><a class='nontermdef' href='#nt:ctor-initializer' id='nt:ctor-initializer'>ctor-initializer:</a>
&#9;<span class='terminal'>:</span> <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i>
</pre><pre class='bnf'><a class='nontermdef' href='#nt:mem-initializer-list' id='nt:mem-initializer-list'>mem-initializer-list:</a>
&#9;<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class="mjx-chtml"><span class="mjx-math" aria-label="Subscript o p t"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
&#9;<i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> <span class='terminal'>,</span> <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class="mjx-chtml"><span class="mjx-math" aria-label="Subscript o p t"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
</pre><pre class='bnf'><a class='nontermdef' href='#nt:mem-initializer' id='nt:mem-initializer'>mem-initializer:</a>
&#9;<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="Subscript o p t"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>)</span>
&#9;<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
</pre><pre class='bnf'><a class='nontermdef' href='#nt:mem-initializer-id' id='nt:mem-initializer-id'>mem-initializer-id:</a>
&#9;<i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i>
&#9;<i ><a href='lex.name#nt:identifier'>identifier</a></i>
</pre></div><div class='para' id='class.base.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5670'>#</a></div><div id='class.base.init-2.sentence-1' class='sentence'>In a <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> an initial unqualified
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is looked up in the scope of the constructor's class
and, if not found in that scope, it is looked up in the scope containing the
constructor's definition<a class='hidden_link' href='#class.base.init-2.sentence-1'>.</a></div> <div id='class.base.init-2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-2.sentence-3' class='sentence'>If the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
naming the member or base class and composed of a single identifier
refers to the class member<a class='hidden_link' href='#class.base.init-2.sentence-3'>.</a></div> <div id='class.base.init-2.sentence-4' class='sentence'>A
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
for the hidden base class may be specified using a qualified name<a class='hidden_link' href='#class.base.init-2.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.base.init-2.sentence-2' class='sentence'>
Unless the
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
names the constructor's class,
a non-static data member of the constructor's class, or
a direct or virtual base of that class,
the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is ill-formed<a class='hidden_link' href='#class.base.init-2.sentence-2'>.</a></div></div><div class='para' id='class.base.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5694'>#</a></div><div id='class.base.init-3.sentence-1' class='sentence'>A
<i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i>
can initialize a base class using any <i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i> that denotes that base class type<a class='hidden_link' href='#class.base.init-3.sentence-1'>.</a></div> <div id='class.base.init-3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }          <span class='comment'>// mem-initializer for base <span class='tcode_in_codeblock'>A</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5709'>#</a></div><div id='class.base.init-4.sentence-1' class='sentence'>If a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
is ambiguous because it designates both a direct non-virtual base class and
an inherited virtual base class, the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is ill-formed<a class='hidden_link' href='#class.base.init-4.sentence-1'>.</a></div> <div id='class.base.init-4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 <span class='comment'>// ill-formed: which <span class='tcode_in_codeblock'>A</span>?
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-5'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5726'>#</a></div><div id='class.base.init-5.sentence-1' class='sentence'>A
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
may initialize a variant member of the
constructor's class<a class='hidden_link' href='#class.base.init-5.sentence-1'>.</a></div> <div id='class.base.init-5.sentence-2' class='sentence'>If a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
specifies more than one
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
for the same member or for the same base class,
the
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
is ill-formed<a class='hidden_link' href='#class.base.init-5.sentence-2'>.</a></div></div><div class='para' id='class.base.init-6'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5740'>#</a></div><div id='class.base.init-6.sentence-1' class='sentence'>A <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> can delegate to another
constructor of the constructor's class using any
<i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i> that denotes the constructor's class itself<a class='hidden_link' href='#class.base.init-6.sentence-1'>.</a></div> <div id='class.base.init-6.sentence-2' class='sentence'>If a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> designates the constructor's class,
it shall be the only <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>; the constructor
is a <a class='hidden_link' href='#def:delegating_constructor' id='def:delegating_constructor'><i>delegating constructor</i></a>, and the constructor selected by the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> is the <a class='hidden_link' href='#def:target_constructor' id='def:target_constructor'><i>target constructor</i></a><a class='hidden_link' href='#class.base.init-6.sentence-2'>.</a></div> <div id='class.base.init-6.sentence-3' class='sentence'>The target constructor is selected by overload resolution<a class='hidden_link' href='#class.base.init-6.sentence-3'>.</a></div> <div id='class.base.init-6.sentence-4' class='sentence'>Once the target constructor returns, the body of the delegating constructor
is executed<a class='hidden_link' href='#class.base.init-6.sentence-4'>.</a></div> <div id='class.base.init-6.sentence-5' class='sentence'>If a constructor delegates to itself directly or indirectly,
the program is ill-formed, no diagnostic required<a class='hidden_link' href='#class.base.init-6.sentence-5'>.</a></div> <div id='class.base.init-6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct C {
  C( int ) { }                  <span class='comment'>// #1: non-delegating constructor
</span>  C(): C(42) { }                <span class='comment'>// #2: delegates to #1
</span>  C( char c ) : C(42.0) { }     <span class='comment'>// #3: ill-formed due to recursion with #4
</span>  C( double d ) : C('a') { }    <span class='comment'>// #4: ill-formed due to recursion with #3
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-7'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5763'>#</a></div><div id='class.base.init-7.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,base_class_'></a></span><span class='indexparent'><a class='index' id=':initialization,member_object'></a></span>The
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
in a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is used to initialize the
designated subobject (or, in the case of a delegating constructor, the complete class object)
according to the initialization rules of <a href='dcl.init'>[dcl.init]</a> for direct-initialization<a class='hidden_link' href='#class.base.init-7.sentence-1'>.</a></div> <div id='class.base.init-7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct B1 { B1(int); <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
struct B2 { B2(int); <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
struct D : B1, B2 {
  D(int);
  B1 b;
  const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
D d(10);</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.base.init-7.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-7.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-7.sentence-3' class='sentence'>
The initialization
performed by each <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
constitutes a full-expression (<a href='intro.execution'>[intro.execution]</a>)<a class='hidden_link' href='#class.base.init-7.sentence-3'>.</a></div> <div id='class.base.init-7.sentence-4' class='sentence'>Any expression in
a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is evaluated as part of the full-expression that performs the initialization<a class='hidden_link' href='#class.base.init-7.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.base.init-7.sentence-2' class='sentence'>
A <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> where the <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> denotes
a virtual base class is ignored during execution of a constructor of any class that is
not the most derived class<a class='hidden_link' href='#class.base.init-7.sentence-2'>.</a></div></div><div class='para' id='class.base.init-8'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5802'>#</a></div><div id='class.base.init-8.sentence-1' class='sentence'>A temporary expression bound to a reference member in a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is ill-formed<a class='hidden_link' href='#class.base.init-8.sentence-1'>.</a></div> <div id='class.base.init-8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  A() : v(42) { }   <span class='comment'>// error
</span>  const int&amp; v;
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-9'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5814'>#</a></div><div id='class.base.init-9.sentence-1' class='sentence'>In a non-delegating constructor, if
a given potentially constructed subobject is not designated by a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
(including the case where there is no
<i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i>
because the constructor has no
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>),
then</div><div id='class.base.init-9.sentence-2' class='sentence'><ul class='itemize'><li id='class.base.init-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-9.1'>(9.1)</a></div><div id='class.base.init-9.1.sentence-1' class='sentence'>if the entity is a non-static data member that has
a default member initializer (<a href='class.mem'>[class.mem]</a>) and either</div><div id='class.base.init-9.1.sentence-2' class='sentence'><ul class='itemize'><li id='class.base.init-9.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.base.init-9.1.1'>(9.1.1)</a></div><div id='class.base.init-9.1.1.sentence-1' class='sentence'>the constructor's class is a union (<a href='class.union'>[class.union]</a>), and no other variant
member of that union is designated by a <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> or</div></li><li id='class.base.init-9.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.base.init-9.1.2'>(9.1.2)</a></div><div id='class.base.init-9.1.2.sentence-1' class='sentence'>the constructor's class is not a union, and, if the entity is a member of an
anonymous union, no other member of that union is designated by a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>,</div></li></ul></div><div id='class.base.init-9.1.sentence-3' class='sentence'>the entity is initialized from its default member initializer
as specified in <a href='dcl.init'>[dcl.init]</a>;</div></li><li id='class.base.init-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-9.2'>(9.2)</a></div><div id='class.base.init-9.2.sentence-1' class='sentence'>otherwise, if the entity is an anonymous union or a variant member (<a href='class.union.anon'>[class.union.anon]</a>), no initialization is performed;</div></li><li id='class.base.init-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-9.3'>(9.3)</a></div><div id='class.base.init-9.3.sentence-1' class='sentence'>otherwise, the entity is default-initialized (<a href='dcl.init'>[dcl.init]</a>)<a class='hidden_link' href='#class.base.init-9.3.sentence-1'>.</a></div></li></ul></div><div id='class.base.init-9.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-9.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-9.sentence-4' class='sentence'>An abstract class (<a href='class.abstract'>[class.abstract]</a>) is never a most derived
class, thus its constructors never initialize virtual base classes, therefore the
corresponding <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i><span class='textit'>s</span> may be omitted<a class='hidden_link' href='#class.base.init-9.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.base.init-9.sentence-3' class='sentence'>
An attempt to initialize more than one non-static data member of a union renders the
program ill-formed<a class='hidden_link' href='#class.base.init-9.sentence-3'>.</a></div> <span class='indexparent'><a class='index' id=':initialization,const_member'></a></span><span class='indexparent'><a class='index' id=':initialization,reference_member'></a></span><div id='class.base.init-9.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-9.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-9.sentence-5' class='sentence'>After the call to a constructor for class
<span class='texttt'>X</span>
for an object with automatic or dynamic storage duration
has completed, if
the constructor was not invoked as part of value-initialization and
a member of
<span class='texttt'>X</span>
is neither initialized nor
given a value
during execution of the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the body of the constructor,
the member has an indeterminate value<a class='hidden_link' href='#class.base.init-9.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> 
<div id='class.base.init-9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  A();
};

struct B {
  B(int);
};

struct C {
  C() { }               <span class='comment'>// initializes members as follows:
</span>  A a;                  <span class='comment'>// OK: calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;A()</span>
</span>  const B b;            <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> has no default constructor
</span>  int i;                <span class='comment'>// OK: <span class='tcode_in_codeblock'>i</span> has indeterminate value
</span>  int j = 5;            <span class='comment'>// OK: <span class='tcode_in_codeblock'>j</span> has the value <span class='tcode_in_codeblock'>5</span>
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-10'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5885'>#</a></div><div id='class.base.init-10.sentence-1' class='sentence'>If a given non-static data member has both a default member initializer
and a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>, the initialization specified by the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> is performed, and the non-static data member's
default member initializer is ignored<a class='hidden_link' href='#class.base.init-10.sentence-1'>.</a></div> <div id='class.base.init-10.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='class.base.init-10.sentence-2' class='sentence'>Given
<pre class='codeblock'>
struct A {
  int i = /* some integer expression with side effects */ ;
  A(int arg) : i(arg) { }
  <span class='comment'>// ...
</span>};</pre></div><div id='class.base.init-10.sentence-3' class='sentence'>the <span class='texttt'>A(int)</span> constructor will simply initialize <span class='texttt'>i</span> to the value of
<span class='texttt'>arg</span>, and the
<span class='indexparent'><a class='index' id=':side_effects'></a></span>side effects in <span class='texttt'>i</span>'s default member initializer
will not take place<a class='hidden_link' href='#class.base.init-10.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-11'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5909'>#</a></div><div id='class.base.init-11.sentence-1' class='sentence'>A temporary expression bound to a reference member from a
default member initializer is ill-formed<a class='hidden_link' href='#class.base.init-11.sentence-1'>.</a></div> <div id='class.base.init-11.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-11.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  A() = default;        <span class='comment'>// OK
</span>  A(int v) : v(v) { }   <span class='comment'>// OK
</span>  const int&amp; v = 42;    <span class='comment'>// OK
</span>};
A a1;                   <span class='comment'>// error: ill-formed binding of temporary to reference
</span>A a2(1);                <span class='comment'>// OK, unfortunately
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-12'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5924'>#</a></div><div id='class.base.init-12.sentence-1' class='sentence'>In a non-delegating constructor, the destructor for each potentially constructed
subobject of class type is potentially invoked (<a href='class.dtor'>[class.dtor]</a>)<a class='hidden_link' href='#class.base.init-12.sentence-1'>.</a></div> <div id='class.base.init-12.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-12.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-12.sentence-2' class='sentence'>This provision ensures that destructors can be called for fully-constructed
subobjects in case an exception is thrown (<a href='except.ctor'>[except.ctor]</a>)<a class='hidden_link' href='#class.base.init-12.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-13'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5930'>#</a></div><div id='class.base.init-13.sentence-1' class='sentence'>In a non-delegating constructor, initialization
proceeds in the following order:
<ul class='itemize'><li id='class.base.init-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-13.1'>(13.1)</a></div><div id='class.base.init-13.1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,order_of_virtual_base_class'></a></span>First, and only for the constructor of the most derived class (<a href='intro.object'>[intro.object]</a>),
virtual base classes are initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where “left-to-right” is the order of appearance of the base classes
in the derived class
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i><a class='hidden_link' href='#class.base.init-13.1.sentence-1'>.</a></div></li><li id='class.base.init-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-13.2'>(13.2)</a></div><div id='class.base.init-13.2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,order_of_base_class'></a></span>Then, direct base classes are initialized in declaration order
as they appear in the
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>
(regardless of the order of the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i><span class='textit'>s</span>)<a class='hidden_link' href='#class.base.init-13.2.sentence-1'>.</a></div></li><li id='class.base.init-13.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-13.3'>(13.3)</a></div><div id='class.base.init-13.3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,order_of_member'></a></span>Then, non-static data members are initialized in the order
they were declared in the class definition
(again regardless of the order of the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i><span class='textit'>s</span>)<a class='hidden_link' href='#class.base.init-13.3.sentence-1'>.</a></div></li><li id='class.base.init-13.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.base.init-13.4'>(13.4)</a></div><div id='class.base.init-13.4.sentence-1' class='sentence'>Finally, the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the constructor
body  is executed<a class='hidden_link' href='#class.base.init-13.4.sentence-1'>.</a></div></li></ul></div><div id='class.base.init-13.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-13.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-13.sentence-2' class='sentence'>The declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization<a class='hidden_link' href='#class.base.init-13.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-14'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L5966'>#</a></div><div id='class.base.init-14.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-14.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct V {
  V();
  V(int);
};

struct A : virtual V {
  A();
  A(int);
};

struct B : virtual V {
  B();
  B(int);
};

struct C : A, B, virtual V {
  C();
  C(int);
};

A::A(int i) : V(i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
B::B(int i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
C::C(int i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }

V v(1);             <span class='comment'>// use <span class='tcode_in_codeblock'>V(int)</span>
</span>A a(2);             <span class='comment'>// use <span class='tcode_in_codeblock'>V(int)</span>
</span>B b(3);             <span class='comment'>// use <span class='tcode_in_codeblock'>V()</span>
</span>C c(4);             <span class='comment'>// use <span class='tcode_in_codeblock'>V()</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-15'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6000'>#</a></div><div id='class.base.init-15.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initializer,scope_of_member'></a></span>Names in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
of a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor for which the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is specified<a class='hidden_link' href='#class.base.init-15.sentence-1'>.</a></div> <div id='class.base.init-15.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-15.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class X {
  int a;
  int b;
  int i;
  int j;
public:
  const int&amp; r;
  X(int i): r(a), b(i), i(i), j(this-&gt;i) { }
};</pre><div id='class.base.init-15.sentence-2' class='sentence'>initializes
<span class='texttt'>X&#x200b;::&#x200b;r</span>
to refer to
<span class='texttt'>X&#x200b;::&#x200b;a</span>,
initializes
<span class='texttt'>X&#x200b;::&#x200b;b</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
initializes
<span class='texttt'>X&#x200b;::&#x200b;i</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
and initializes
<span class='texttt'>X&#x200b;::&#x200b;j</span>
with the value of
<span class='texttt'>X&#x200b;::&#x200b;i</span>;
this takes place each time an object of class
<span class='texttt'>X</span>
is created<a class='hidden_link' href='#class.base.init-15.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='class.base.init-15.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-15.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-15.sentence-3' class='sentence'>Because the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor, the
<span class='texttt'>this</span>
pointer can be used in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
of a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
to refer to the object being initialized<a class='hidden_link' href='#class.base.init-15.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-16'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6056'>#</a></div><div id='class.base.init-16.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initialization,member_function_call_during'></a></span>Member functions (including virtual member functions, <a href='class.virtual'>[class.virtual]</a>) can be
called for an object under construction<a class='hidden_link' href='#class.base.init-16.sentence-1'>.</a></div> <div id='class.base.init-16.sentence-2' class='sentence'>Similarly, an object under construction can be the operand of the
<span class='texttt'>typeid</span>
operator (<a href='expr.typeid'>[expr.typeid]</a>) or of a
<span class='texttt'>dynamic_&shy;cast</span> (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>)<a class='hidden_link' href='#class.base.init-16.sentence-2'>.</a></div> <div id='class.base.init-16.sentence-3' class='sentence'>However, if these operations are performed in a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
(or in a function called directly or indirectly from a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>)
before all the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i><span class='textit'>s</span>
for base classes have completed, the program has undefined behavior<a class='hidden_link' href='#class.base.init-16.sentence-3'>.</a></div> <div id='class.base.init-16.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-16.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class A {
public:
  A(int);
};

class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     <span class='comment'>// undefined: calls member function but base <span class='tcode_in_codeblock'>A</span> not yet initialized
</span>  j(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;
public:
  D() : C(f()),     <span class='comment'>// undefined: calls member function but base <span class='tcode_in_codeblock'>C</span> not yet initialized
</span>  i(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-17'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6100'>#</a></div><div id='class.base.init-17.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.base.init-17.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.base.init-17.sentence-1' class='sentence'><a href='#class.cdtor'>[class.cdtor]</a> describes the result of virtual function calls,
<span class='texttt'>typeid</span>
and
<span class='texttt'>dynamic_&shy;cast</span>s
during construction for the well-defined cases;
that is, describes the
<a class='hidden_link' href='#def:polymorphic_behavior' id='def:polymorphic_behavior'><i>polymorphic behavior</i></a>
of an object under construction<a class='hidden_link' href='#class.base.init-17.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.base.init-18'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-18'>18</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6112'>#</a></div><div id='class.base.init-18.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':initializer,pack_expansion'></a></span>A <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> followed by an ellipsis is
a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>) that initializes the base
classes specified by a pack expansion in the <i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>
for the class<a class='hidden_link' href='#class.base.init-18.sentence-1'>.</a></div> <div id='class.base.init-18.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.base.init-18.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class... Mixins&gt;
class X : public Mixins... {
public:
  X(const Mixins&amp;... mixins) : Mixins(mixins)... { }
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div></div><div id='class.inhctor.init' class='section'><h3 ><a class='secnum' href='#class.inhctor.init' style='min-width:103pt'>10.9.3</a> Initialization by inherited constructor <a class='abbr_ref' href='class.inhctor.init'>[class.inhctor.init]</a></h3><span class='indexparent'><a class='index' id=':initialization,by_inherited_constructor'></a></span><div class='para' id='class.inhctor.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6132'>#</a></div><div id='class.inhctor.init-1.sentence-1' class='sentence'>When a constructor for type <span class='texttt'>B</span> is invoked
to initialize an object of a different type <span class='texttt'>D</span>
(that is, when the constructor was inherited (<a href='namespace.udecl'>[namespace.udecl]</a>)),
initialization proceeds as if a defaulted default constructor
were used to initialize the <span class='texttt'>D</span> object and
each base class subobject from which the constructor was inherited,
except that the <span class='texttt'>B</span> subobject is initialized
by the invocation of the inherited constructor<a class='hidden_link' href='#class.inhctor.init-1.sentence-1'>.</a></div> <div id='class.inhctor.init-1.sentence-2' class='sentence'>The complete initialization is considered to be a single function call;
in particular, the initialization of the inherited constructor's parameters
is sequenced before the initialization of any part of the <span class='texttt'>D</span> object<a class='hidden_link' href='#class.inhctor.init-1.sentence-2'>.</a></div> <div id='class.inhctor.init-1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.inhctor.init-1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct B1 {
  B1(int, ...) { }
};

struct B2 {
  B2(double) { }
};

int get();

struct D1 : B1 {
  using B1::B1;     <span class='comment'>// inherits <span class='tcode_in_codeblock'>B1(int, ...)</span>
</span>  int x;
  int y = get();
};

void test() {
  D1 d(2, 3, 4);    <span class='comment'>// OK: <span class='tcode_in_codeblock'>B1</span> is initialized by calling <span class='tcode_in_codeblock'>B1(2, 3, 4)</span>,
</span>                    <span class='comment'>// then <span class='tcode_in_codeblock'>d.x</span> is default-initialized (no initialization is performed),
</span>                    <span class='comment'>// then <span class='tcode_in_codeblock'>d.y</span> is initialized by calling <span class='tcode_in_codeblock'>get()</span>
</span>  D1 e;             <span class='comment'>// error: <span class='tcode_in_codeblock'>D1</span> has a deleted default constructor
</span>}

struct D2 : B2 {
  using B2::B2;
  B1 b;
};

D2 f(1.0);          <span class='comment'>// error: <span class='tcode_in_codeblock'>B1</span> has a deleted default constructor
</span>
struct W { W(int); };
struct X : virtual W { using W::W; X() = delete; };
struct Y : X { using X::X; };
struct Z : Y, virtual W { using Y::Y; };
Z z(0);             <span class='comment'>// OK: initialization of <span class='tcode_in_codeblock'>Y</span> does not invoke default constructor of <span class='tcode_in_codeblock'>X</span>
</span>
template&lt;class T&gt; struct Log : T {
  using T::T;       <span class='comment'>// inherits all constructors from class <span class='tcode_in_codeblock'>T</span>
</span>  ~Log() { std::clog &lt;&lt; "Destroying wrapper" &lt;&lt; std::endl; }
};</pre> <div id='class.inhctor.init-1.sentence-3' class='sentence'>
Class template <span class='texttt'>Log</span> wraps any class and forwards all of its constructors,
while writing a message to the standard log
whenever an object of class <span class='texttt'>Log</span> is destroyed<a class='hidden_link' href='#class.inhctor.init-1.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.inhctor.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6192'>#</a></div><div id='class.inhctor.init-2.sentence-1' class='sentence'>If the constructor was inherited from multiple base class subobjects
of type <span class='texttt'>B</span>, the program is ill-formed<a class='hidden_link' href='#class.inhctor.init-2.sentence-1'>.</a></div> <div id='class.inhctor.init-2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.inhctor.init-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { A(int); };
struct B : A { using A::A; };

struct C1 : B { using B::B; };
struct C2 : B { using B::B; };

struct D1 : C1, C2 {
  using C1::C1;
  using C2::C2;
};

struct V1 : virtual B { using B::B; };
struct V2 : virtual B { using B::B; };

struct D2 : V1, V2 {
  using V1::V1;
  using V2::V2;
};

D1 d1(0);           <span class='comment'>// ill-formed: ambiguous
</span>D2 d2(0);           <span class='comment'>// OK: initializes virtual <span class='tcode_in_codeblock'>B</span> base class, which initializes the <span class='tcode_in_codeblock'>A</span> base class
</span>                    <span class='comment'>// then initializes the <span class='tcode_in_codeblock'>V1</span> and <span class='tcode_in_codeblock'>V2</span> base classes as if by a defaulted default constructor
</span>
struct M { M(); M(int); };
struct N : M { using M::M; };
struct O : M {};
struct P : N, O { using N::N; using O::O; };
P p(0);             <span class='comment'>// OK: use <span class='tcode_in_codeblock'>M(0)</span> to initialize <span class='tcode_in_codeblock'>N</span>'s base class,
</span>                    <span class='comment'>// use <span class='tcode_in_codeblock'>M()</span> to initialize <span class='tcode_in_codeblock'>O</span>'s base class
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.inhctor.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6229'>#</a></div><div id='class.inhctor.init-3.sentence-1' class='sentence'>When an object is initialized by an inherited constructor,
initialization of the object is complete
when the initialization of all subobjects is complete<a class='hidden_link' href='#class.inhctor.init-3.sentence-1'>.</a></div> </div></div><div id='class.cdtor' class='section'><h3 ><a class='secnum' href='#class.cdtor' style='min-width:103pt'>10.9.4</a> Construction and destruction <a class='abbr_ref' href='class.cdtor'>[class.cdtor]</a></h3><span class='indexparent'><a class='index' id=':construction'></a></span><span class='indexparent'><a class='index' id=':destruction'></a></span><div class='para' id='class.cdtor-1'><div class='marginalizedparent'><a class='marginalized' href='#class.cdtor-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6239'>#</a></div><div id='class.cdtor-1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,member_access'></a></span><span class='indexparent'><a class='index' id=':destruction,member_access'></a></span>For an object with a non-trivial constructor, referring to any non-static member
or base class of the object before the constructor begins execution results in
undefined behavior<a class='hidden_link' href='#class.cdtor-1.sentence-1'>.</a></div> <div id='class.cdtor-1.sentence-2' class='sentence'>For an object with a non-trivial destructor, referring to
any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior<a class='hidden_link' href='#class.cdtor-1.sentence-2'>.</a></div> <div id='class.cdtor-1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.cdtor-1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct X { int i; };
struct Y : X { Y(); };                  <span class='comment'>// non-trivial
</span>struct A { int a; };
struct B : public A { int j; Y y; };    <span class='comment'>// non-trivial
</span>
extern B bobj;
B* pb = &amp;bobj;                          <span class='comment'>// OK
</span>int* p1 = &amp;bobj.a;                      <span class='comment'>// undefined, refers to base class member
</span>int* p2 = &amp;bobj.y.i;                    <span class='comment'>// undefined, refers to member's member
</span>
A* pa = &amp;bobj;                          <span class='comment'>// undefined, upcast to a base class type
</span>B bobj;                                 <span class='comment'>// definition of <span class='tcode_in_codeblock'>bobj</span>
</span>
extern X xobj;
int* p3 = &amp;xobj.i;                      <span class='comment'>// OK, <span class='tcode_in_codeblock'>X</span> is a trivial class
</span>X xobj;</pre> <div id='class.cdtor-1.sentence-3' class='sentence'>
For another example,
<pre class='codeblock'>
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() : p(&amp;x.j) {   <span class='comment'>// undefined, <span class='tcode_in_codeblock'>x</span> is not yet constructed
</span>    }
};</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.cdtor-2'><div class='marginalizedparent'><a class='marginalized' href='#class.cdtor-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6279'>#</a></div><div id='class.cdtor-2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,pointer_to_member_or_base'></a></span><span class='indexparent'><a class='index' id=':destruction,pointer_to_member_or_base'></a></span>To explicitly or implicitly convert a pointer (a glvalue) referring to
an object of class
<span class='texttt'>X</span>
to a pointer (reference) to a direct or indirect base class
<span class='texttt'>B</span>
of
<span class='texttt'>X</span>,
the construction of
<span class='texttt'>X</span>
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
<span class='texttt'>B</span>
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior<a class='hidden_link' href='#class.cdtor-2.sentence-1'>.</a></div> <div id='class.cdtor-2.sentence-2' class='sentence'>To form a pointer to (or access the value of) a direct non-static member of
an object
<span class='texttt'>obj</span>,
the construction of
<span class='texttt'>obj</span>
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior<a class='hidden_link' href='#class.cdtor-2.sentence-2'>.</a></div> <div id='class.cdtor-2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.cdtor-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    <span class='comment'>// undefined: upcast from <span class='tcode_in_codeblock'>E*</span> to <span class='tcode_in_codeblock'>A*</span> might use path <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>D*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span>
</span>                    <span class='comment'>// but <span class='tcode_in_codeblock'>D</span> is not constructed
</span>
                    <span class='comment'>// “<span class='tcode_in_codeblock'>D((C*)this)</span>” would be defined: <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>C*</span> is defined because <span class='tcode_in_codeblock'>E()</span> has started,
</span>                    <span class='comment'>// and <span class='tcode_in_codeblock'>C*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span> is defined because <span class='tcode_in_codeblock'>C</span> is fully constructed
</span>
  X(this) {}        <span class='comment'>// defined: upon construction of <span class='tcode_in_codeblock'>X</span>, <span class='tcode_in_codeblock'>C/B/D/A</span> sublattice is fully constructed
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.cdtor-3'><div class='marginalizedparent'><a class='marginalized' href='#class.cdtor-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6324'>#</a></div><div id='class.cdtor-3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':virtual_function_call,constructor_and'></a></span><span class='indexparent'><a class='index' id=':virtual_function_call,destructor_and'></a></span><span class='indexparent'><a class='index' id=':construction,virtual_function_call'></a></span><span class='indexparent'><a class='index' id=':destruction,virtual_function_call'></a></span>Member functions, including virtual functions (<a href='class.virtual'>[class.virtual]</a>), can be called
during construction or destruction (<a href='#class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#class.cdtor-3.sentence-1'>.</a></div> <div id='class.cdtor-3.sentence-2' class='sentence'>When a virtual function is called directly or indirectly from a constructor
or from a destructor,
including during the construction or destruction of the class's non-static data
members,
and the object to which the call applies is the object (call it <span class='texttt'>x</span>) under construction or
destruction,
the function called is the
final overrider in the constructor's or destructor's class and not one
overriding it in a more-derived class<a class='hidden_link' href='#class.cdtor-3.sentence-2'>.</a></div> <div id='class.cdtor-3.sentence-3' class='sentence'>If the virtual function call uses an explicit class member access (<a href='expr.ref'>[expr.ref]</a>)
and the object expression refers to
the complete object of <span class='texttt'>x</span> or one of that object's base class subobjects
but not <span class='texttt'>x</span> or one of its base class subobjects, the behavior
is undefined<a class='hidden_link' href='#class.cdtor-3.sentence-3'>.</a></div> <div id='class.cdtor-3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.cdtor-3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V*, A*);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  f();              <span class='comment'>// calls <span class='tcode_in_codeblock'>V&#x200b;::&#x200b;f</span>, not <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span>
</span>  g();              <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>, not <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;g</span>
</span>  v-&gt;g();           <span class='comment'>// <span class='tcode_in_codeblock'>v</span> is base of <span class='tcode_in_codeblock'>B</span>, the call is well-defined, calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>
</span>  a-&gt;f();           <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span>'s type not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.cdtor-4'><div class='marginalizedparent'><a class='marginalized' href='#class.cdtor-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6377'>#</a></div><div id='class.cdtor-4.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,typeid_operator'></a></span><span class='indexparent'><a class='index' id=':destruction,typeid_operator'></a></span><span class='indexparent'><a class='index' id=':typeid,construction_and'></a></span><span class='indexparent'><a class='index' id=':typeid,destruction_and'></a></span>The
<span class='texttt'>typeid</span>
operator (<a href='expr.typeid'>[expr.typeid]</a>) can be used during construction or destruction (<a href='#class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#class.cdtor-4.sentence-1'>.</a></div> <div id='class.cdtor-4.sentence-2' class='sentence'>When
<span class='texttt'>typeid</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or default member initializer (<a href='class.mem'>[class.mem]</a>)
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction,
<span class='texttt'>typeid</span>
yields the
<span class='texttt'>std&#x200b;::&#x200b;type_&shy;info</span>
object representing the constructor or destructor's class<a class='hidden_link' href='#class.cdtor-4.sentence-2'>.</a></div> <div id='class.cdtor-4.sentence-3' class='sentence'>If the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the behavior is undefined<a class='hidden_link' href='#class.cdtor-4.sentence-3'>.</a></div></div><div class='para' id='class.cdtor-5'><div class='marginalizedparent'><a class='marginalized' href='#class.cdtor-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6404'>#</a></div><div id='class.cdtor-5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id=':destruction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id=':cast,dynamic,construction_and'></a></span><span class='indexparent'><a class='index' id=':cast,dynamic,destruction_and'></a></span><span class='texttt'>dynamic_&shy;cast</span>s (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>) can be used during construction
or destruction (<a href='#class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#class.cdtor-5.sentence-1'>.</a></div> <div id='class.cdtor-5.sentence-2' class='sentence'>When a
<span class='texttt'>dynamic_&shy;cast</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or default member initializer
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class<a class='hidden_link' href='#class.cdtor-5.sentence-2'>.</a></div> <div id='class.cdtor-5.sentence-3' class='sentence'>If the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
<span class='texttt'>dynamic_&shy;cast</span>
results in undefined behavior<a class='hidden_link' href='#class.cdtor-5.sentence-3'>.</a></div> <div id='class.cdtor-5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.cdtor-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);                <span class='comment'>// <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*v);                   <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>*v</span> has type <span class='tcode_in_codeblock'>V</span>, a base of <span class='tcode_in_codeblock'>B</span> yields <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*a);                   <span class='comment'>// undefined behavior: type <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>  dynamic_cast&lt;B*&gt;(v);          <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>v</span> of type <span class='tcode_in_codeblock'>V*</span>, <span class='tcode_in_codeblock'>V</span> base of <span class='tcode_in_codeblock'>B</span> results in <span class='tcode_in_codeblock'>B*</span>
</span>  dynamic_cast&lt;B*&gt;(a);          <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span> has type <span class='tcode_in_codeblock'>A*</span>, <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  </div></div><div id='class.copy.elision' class='section'><h3 ><a class='secnum' href='#class.copy.elision' style='min-width:103pt'>10.9.5</a> Copy/move elision <a class='abbr_ref' href='class.copy.elision'>[class.copy.elision]</a></h3><div class='para' id='class.copy.elision-1'><div class='marginalizedparent'><a class='marginalized' href='#class.copy.elision-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6458'>#</a></div><div id='class.copy.elision-1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id=':constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id=':side_effects_'></a></span>side effects<a class='hidden_link' href='#class.copy.elision-1.sentence-1'>.</a></div> <div id='class.copy.elision-1.sentence-2' class='sentence'>In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object<a class='hidden_link' href='#class.copy.elision-1.sentence-2'>.</a></div> <div id='class.copy.elision-1.sentence-3' class='sentence'>If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization<a class='hidden_link' href='#class.copy.elision-1.sentence-3'>.</a><a class='footnotenum' href='#footnote-119'>119</a></div> <div id='class.copy.elision-1.sentence-4' class='sentence'>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id=':constructor,copy,elision_'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision_'></a></span><a class='hidden_link' href='#def:copy_elision' id='def:copy_elision'><i>copy elision</i></a>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</div><div id='class.copy.elision-1.sentence-5' class='sentence'><ul class='itemize'><li id='class.copy.elision-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.copy.elision-1.1'>(1.1)</a></div><div id='class.copy.elision-1.1.sentence-1' class='sentence'>in a <span class='texttt'>return</span> statement in a function with a class return type,
when the <i ><a href='expr.comma#nt:expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#nt:handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</div></li><li id='class.copy.elision-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.copy.elision-1.2'>(1.2)</a></div><div id='class.copy.elision-1.2.sentence-1' class='sentence'>in a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i>, when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the exception object (<a href='except.throw'>[except.throw]</a>) can be omitted by
constructing the automatic object directly into the exception object</div></li><li id='class.copy.elision-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.copy.elision-1.3'>(1.3)</a></div><div id='class.copy.elision-1.3.sentence-1' class='sentence'>when the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of an
exception handler (<a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the exception
object (<a href='except.throw'>[except.throw]</a>), the copy operation can be omitted by treating
the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i><a class='hidden_link' href='#class.copy.elision-1.3.sentence-1'>.</a></div> <div id='class.copy.elision-1.3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.copy.elision-1.3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.copy.elision-1.3.sentence-2' class='sentence'>There cannot be a move from the exception object because it is
always an lvalue<a class='hidden_link' href='#class.copy.elision-1.3.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul>
Copy elision is required
where an expression is evaluated in a context
requiring a constant expression (<a href='expr.const'>[expr.const]</a>)
and in constant initialization (<a href='basic.start.static'>[basic.start.static]</a>)<a class='hidden_link' href='#class.copy.elision-1.sentence-5'>.</a></div> <div id='class.copy.elision-1.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.copy.elision-1.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.copy.elision-1.sentence-6' class='sentence'>Copy elision might not be performed
if the same expression
is evaluated in another context<a class='hidden_link' href='#class.copy.elision-1.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.copy.elision-2'><div class='marginalizedparent'><a class='marginalized' href='#class.copy.elision-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6528'>#</a></div><div id='class.copy.elision-2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.copy.elision-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&amp;);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;          <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>a.p</span> points to <span class='tcode_in_codeblock'>a</span>
</span>constexpr A b = g();    <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>b.p</span> points to <span class='tcode_in_codeblock'>b</span>
</span>
void h() {
  A c = g();            <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>c.p</span> may point to <span class='tcode_in_codeblock'>c</span> or to an ephemeral temporary
</span>}</pre> <div id='class.copy.elision-2.sentence-1' class='sentence'>
Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f()</span>,
which is the global object
<span class='texttt'>t2</span><a class='hidden_link' href='#class.copy.elision-2.sentence-1'>.</a></div> <div id='class.copy.elision-2.sentence-2' class='sentence'>Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit<a class='hidden_link' href='#class.copy.elision-2.sentence-2'>.</a></div> <div id='class.copy.elision-2.sentence-3' class='sentence'>Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided<a class='hidden_link' href='#class.copy.elision-2.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.copy.elision-3'><div class='marginalizedparent'><a class='marginalized' href='#class.copy.elision-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6581'>#</a></div><div id='class.copy.elision-3.sentence-1' class='sentence'>In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
<ul class='itemize'><li id='class.copy.elision-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.copy.elision-3.1'>(3.1)</a></div><div id='class.copy.elision-3.1.sentence-1' class='sentence'>If the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <span class='texttt'>return</span> statement (<a href='stmt.return'>[stmt.return]</a>)
is a (possibly parenthesized) <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, or</div></li><li id='class.copy.elision-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.copy.elision-3.2'>(3.2)</a></div><div id='class.copy.elision-3.2.sentence-1' class='sentence'>if the operand of a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i>
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one),</div></li></ul>
overload resolution to select the constructor
for the copy is first performed as if the object were designated by an
rvalue<a class='hidden_link' href='#class.copy.elision-3.sentence-1'>.</a></div> <div id='class.copy.elision-3.sentence-2' class='sentence'>If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue<a class='hidden_link' href='#class.copy.elision-3.sentence-2'>.</a></div> <div id='class.copy.elision-3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#class.copy.elision-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='class.copy.elision-3.sentence-3' class='sentence'>This two-stage overload resolution must be performed regardless
of whether copy elision will occur<a class='hidden_link' href='#class.copy.elision-3.sentence-3'>.</a></div> <div id='class.copy.elision-3.sentence-4' class='sentence'>It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided<a class='hidden_link' href='#class.copy.elision-3.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='class.copy.elision-4'><div class='marginalizedparent'><a class='marginalized' href='#class.copy.elision-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/012f107cc796a2be49c4136718ecf322a920dcd8/source/classes.tex#L6610'>#</a></div><div id='class.copy.elision-4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#class.copy.elision-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&amp;&amp;);
private:
  Thing(const Thing&amp;);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='tcode_in_codeblock'>t</span>
</span>  return t;             <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='tcode_in_codeblock'>t</span>
</span>}

Thing t2 = f(false);    <span class='comment'>// OK: no extra copy/move performed, <span class='tcode_in_codeblock'>t2</span> constructed by call to <span class='tcode_in_codeblock'>f</span>
</span>
struct Weird {
  Weird();
  Weird(Weird&amp;);
};

Weird g() {
  Weird w;
  return w;             <span class='comment'>// OK: first overload resolution fails, second overload resolution selects <span class='tcode_in_codeblock'>Weird(Weird&amp;)</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-119'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-119'>119)</a></div><div id='footnote-119.sentence-1' class='sentence'>Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed<a class='hidden_link' href='#footnote-119.sentence-1'>.</a></div></div></div></div></body></html>