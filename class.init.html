<!DOCTYPE html><html lang='en'><head><title>[class.init]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.init'><h2 ><a class='secnum' style='min-width:88pt'>12.6</a> Initialization <a class='abbr_ref'>[class.init]</a></h2><p ><span class='indexparent'><a class='index' id='initialization!class~object'></a></span><span class='indexparent'><a class='index' id='initialization!default constructor and'></a></span><span class='indexparent'><a class='index' id='initialization!constructor~and'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
<span class='texttt'>()</span>,
the object is initialized as specified in <a href='dcl.init'>[dcl.init]</a>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >An object of class type (or array thereof) can be explicitly initialized;
see <a href='class.expl.init'>[class.expl.init]</a> and <a href='class.base.init'>[class.base.init]</a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='order~of~execution!constructor~and array'></a></span>When an array of class objects is initialized
(either explicitly or implicitly) and the elements are initialized by constructor,
the constructor shall be called for each element of the array,
following the subscript order; see <a href='dcl.array'>[dcl.array]</a>.
[&nbsp;<i>Note:</i><span class='space'></span>
Destructors for the array elements are called in reverse order of their
construction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='class.expl.init'><h3 ><a class='secnum' href='#class.expl.init' style='min-width:103pt'>12.6.1</a> Explicit initialization <a class='abbr_ref' href='class.expl.init'>[class.expl.init]</a></h3><p ><span class='indexparent'><a class='index' id='initialization!explicit'></a></span><span class='indexparent'><a class='index' id='initialization!constructor~and'></a></span>
</p><div class='para' id='class.expl.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-1'>1</a></div><p >An object of class type can be initialized with a parenthesized
<i ><a href='expr.post#expression-list'>expression-list</a></i>,
where the
<i ><a href='expr.post#expression-list'>expression-list</a></i>
is construed as an argument list for a constructor
that is called to initialize the object.
Alternatively, a single
<i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i>
can be specified as an
<i ><a href='dcl.init#initializer'>initializer</a></i>
using the
<span class='texttt'>=</span>
form of initialization.
Either direct-initialization semantics or copy-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a>.
<span class='indexparent'><a class='index' id='example!constructor~and initialization'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex(double)</span>
</span>complex b = a;                  <span class='comment'>// initialize by a copy of <span class='texttt'>a</span>
</span>complex c = complex(1,2);       <span class='comment'>// construct <span class='texttt'>complex(1,2)</span>
</span>                                <span class='comment'>// using <span class='texttt'>complex(double,double)</span>
</span>                                <span class='comment'>// copy/move it into <span class='texttt'>c</span>
</span>complex d = sqrt(b,c);          <span class='comment'>// call <span class='texttt'>sqrt(complex,complex)</span>
</span>                                <span class='comment'>// and copy/move the result into <span class='texttt'>d</span>
</span>complex e;                      <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex()</span>
</span>complex f = 3;                  <span class='comment'>// construct <span class='texttt'>complex(3)</span> using
</span>                                <span class='comment'>// <span class='texttt'>complex(double)</span>
</span>                                <span class='comment'>// copy/move it into <span class='texttt'>f</span>
</span>complex g = { 1, 2 };           <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex(double, double)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='initialization!overloaded assignment~and'></a></span>overloading of the assignment operator (<a href='over.ass'>[over.ass]</a>)
has no effect on initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-2'>2</a></div><p ><span class='indexparent'><a class='index' id='initialization!array~of class~objects'></a></span><span class='indexparent'><a class='index' id='constructor!array~of class~objects~and'></a></span>An object of class type can also be initialized by a
<i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i>. List-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a> and <a href='dcl.init.list'>[dcl.init.list]</a>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
complex v[6] = { 1, complex(1,2), complex(), 2 };
</pre><p >Here,
<span class='texttt'>complex::complex(double)</span>
is called for the initialization of
<span class='texttt'>v[0]</span>
and
<span class='texttt'>v[3]</span>,
<span class='texttt'>complex::complex(<span class='discretionary'></span>double, double)</span>
is called for the initialization of
<span class='texttt'>v[1]</span>,
<span class='texttt'>complex::complex()</span>
is called for the initialization
<span class='texttt'>v[2]</span>,
<span class='texttt'>v[4]</span>,
and
<span class='texttt'>v[5]</span>.
For another example,</p><pre class='codeblock'>
struct X {
  int i;
  float f;
  complex c;
} x = { 99, 88.8, 77.7 };
</pre><p >Here,
<span class='texttt'>x.i</span>
is initialized with 99,
<span class='texttt'>x.f</span>
is initialized with 88.8, and
<span class='texttt'>complex::complex(double)</span>
is called for the initialization of
<span class='texttt'>x.c</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Braces can be elided in the
<i ><a href='dcl.init#initializer-list'>initializer-list</a></i>
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see <a href='dcl.init.aggr'>[dcl.init.aggr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
If
<span class='texttt'>T</span>
is a class type with no default constructor,
any declaration of an object of type
<span class='texttt'>T</span>
(or array thereof) is ill-formed if no
<i ><a href='dcl.init#initializer'>initializer</a></i>
is explicitly specified (see <a href='class.init'>[class.init]</a> and <a href='dcl.init'>[dcl.init]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='order~of~execution!constructor~and static~objects'></a></span>the order in which objects with static or thread storage duration
are initialized is described in <a href='basic.start.dynamic'>[basic.start.dynamic]</a> and <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='class.base.init'><h3 ><a class='secnum' href='#class.base.init' style='min-width:103pt'>12.6.2</a> Initializing bases and members <a class='abbr_ref' href='class.base.init'>[class.base.init]</a></h3><p ><span class='indexparent'><a class='index' id='initialization!base~class'></a></span><span class='indexparent'><a class='index' id='initialization!member'></a></span></p><div class='para' id='class.base.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-1'>1</a></div><p >In the definition of a constructor for a class,
initializers for direct and virtual base subobjects and
non-static data members can be specified by a
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>,
which has the form</p><pre class='bnf'><a id='ctor-initializer'>ctor-initializer:</a>
    <span class='terminal'>:</span> <i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i></pre><pre class='bnf'><a id='mem-initializer-list'>mem-initializer-list:</a>
    <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i> <span class='terminal'>,</span> <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='mem-initializer'>mem-initializer:</a>
    <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
    <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='mem-initializer-id'>mem-initializer-id:</a>
    <i ><a href='class.derived#class-or-decltype'>class-or-decltype</a></i>
    <i ><a href='lex.name#identifier'>identifier</a></i></pre></div><div class='para' id='class.base.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-2'>2</a></div><p >In a <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> an initial unqualified
<i ><a href='lex.name#identifier'>identifier</a></i> is looked up in the scope of the constructor's class
and, if not found in that scope, it is looked up in the scope containing the
constructor's definition.
[&nbsp;<i>Note:</i><span class='space'></span>
If the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>
naming the member or base class and composed of a single identifier
refers to the class member.
A
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>
for the hidden base class may be specified using a qualified name.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Unless the
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>
names the constructor's class,
a non-static data member of the constructor's class, or
a direct or virtual base of that class,
the
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is ill-formed.</p></div><div class='para' id='class.base.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-3'>3</a></div><p >A
<i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i>
can initialize a base class using any <i ><a href='class.derived#class-or-decltype'>class-or-decltype</a></i> that denotes that base class type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }        <span class='comment'>// mem-initializer for base <span class='texttt'>A</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-4'>4</a></div><p >If a
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>
is ambiguous because it designates both a direct non-virtual base class and
an inherited virtual base class, the
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 <span class='comment'>// ill-formed: which <span class='texttt'>A</span>?
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-5'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-5'>5</a></div><p >A
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>
may initialize a variant member of the
constructor's class.
If a
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>
specifies more than one
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
for the same member or for the same base class,
the
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>
is ill-formed.</p></div><div class='para' id='class.base.init-6'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-6'>6</a></div><p >A <i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i> can delegate to another
constructor of the constructor's class using any
<i ><a href='class.derived#class-or-decltype'>class-or-decltype</a></i> that denotes the constructor's class itself. If a
<span class='small'></span><span class='rmfamily'></span><i> mem-initializer-id</i> designates the constructor's class,
it shall be the only <span class='small'></span><span class='rmfamily'></span><i> mem-initializer</i>; the constructor
is a <i>delegating constructor</i>, and the constructor selected by the
<span class='small'></span><span class='rmfamily'></span><i> mem-initializer</i> is the <i>target constructor</i>.
The <i>principal constructor</i> is the first constructor invoked in
the construction of an object (that is, not a target constructor for that
object's construction). The target constructor is selected by overload resolution.
Once the target constructor returns, the body of the delegating constructor
is executed. If a constructor delegates to itself directly or indirectly,
the program is ill-formed; no diagnostic is required. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct C {
  C( int ) { }                  <span class='comment'>// #1: non-delegating constructor
</span>  C(): C(42) { }                <span class='comment'>// #2: delegates to #1
</span>  C( char c ) : C(42.0) { }     <span class='comment'>// #3: ill-formed due to recursion with #4
</span>  C( double d ) : C('a') { }    <span class='comment'>// #4: ill-formed due to recursion with #3
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-7'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-7'>7</a></div><p ><span class='indexparent'><a class='index' id='initialization!base~class'></a></span><span class='indexparent'><a class='index' id='initialization!member~object'></a></span>The
<i ><a href='expr.post#expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i>
in a
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is used to initialize the
designated subobject (or, in the case of a delegating constructor, the complete class object)
according to the initialization rules of <a href='dcl.init'>[dcl.init]</a> for direct-initialization.</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct B1 { B1(int); <span class='comment'>/* ... */</span> };
struct B2 { B2(int); <span class='comment'>/* ... */</span> };
struct D : B1, B2 {
  D(int);
  B1 b;
  const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
  { <span class='comment'>/* ... */</span> }
D d(10);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The initialization
performed by each <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
constitutes a full-expression.
Any expression in
a
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is evaluated as part of the full-expression that performs the initialization.
A <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> where the <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> denotes
a virtual base class is ignored during execution of a constructor of any class that is
not the most derived class.</p></div><div class='para' id='class.base.init-8'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-8'>8</a></div><p >A temporary expression bound to a reference member in a <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  A() : v(42) { }  <span class='comment'>// error
</span>  const int&amp; v;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-9'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-9'>9</a></div><p >In a non-delegating constructor, if
a given potentially constructed subobject is not designated by a
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>
(including the case where there is no
<i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i>
because the constructor has no
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>),
then</p><ul ><li ><p >if the entity is a non-static data member that has
a default member initializer (<a href='class.mem'>[class.mem]</a>) and either</p><ul ><li ><p >the constructor's class is a union (<a href='class.union'>[class.union]</a>), and no other variant
member of that union is designated by a <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> or</p></li><li ><p >the constructor's class is not a union, and, if the entity is a member of an
anonymous union, no other member of that union is designated by a
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>,
</p></li></ul><p >the entity is initialized from its default member initializer
as specified in <a href='dcl.init'>[dcl.init]</a>;</p></li><li ><p >otherwise, if the entity is an anonymous union or a variant member (<a href='class.union.anon'>[class.union.anon]</a>), no initialization is performed;</p></li><li ><p >otherwise, the entity is default-initialized (<a href='dcl.init'>[dcl.init]</a>).
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span> An abstract class (<a href='class.abstract'>[class.abstract]</a>) is never a most derived
class, thus its constructors never initialize virtual base classes, therefore the
corresponding <i ><a href='class.base.init#mem-initializer'>mem-initializers</a></i> may be omitted. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
An attempt to initialize more than one non-static data member of a union renders the
program ill-formed.
<span class='indexparent'><a class='index' id='initialization!const member'></a></span><span class='indexparent'><a class='index' id='initialization!reference member'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
After the call to a constructor for class
<span class='texttt'>X</span>
for an object with automatic or dynamic storage duration
has completed, if
the constructor was not invoked as part of value-initialization and
a member of
<span class='texttt'>X</span>
is neither initialized nor
given a value
during execution of the <i ><a href='stmt.block#compound-statement'>compound-statement</a></i> of the body of the constructor,
the member has an indeterminate value.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  A();
};

struct B {
  B(int);
};

struct C {
  C() { }               <span class='comment'>// initializes members as follows:
</span>  A a;                    <span class='comment'>// OK: calls <span class='texttt'>A::A()</span>
</span>  const B b;              <span class='comment'>// error: <span class='texttt'>B</span> has no default constructor
</span>  int i;                  <span class='comment'>// OK: <span class='texttt'>i</span> has indeterminate value
</span>  int j = 5;              <span class='comment'>// OK: <span class='texttt'>j</span> has the value <span class='texttt'>5</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-10'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-10'>10</a></div><p >If a given non-static data member has both a default member initializer
and a <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>, the initialization specified by the
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> is performed, and the non-static data member's 
default member initializer is ignored.
[&nbsp;<i>Example:</i><span class='space'></span> Given
</p><pre class='codeblock'>
struct A {
  int i = <span class='comment'>/* some integer expression with side effects */</span> ;
  A(int arg) : i(arg) { }
  <span class='comment'>// ...
</span>};
</pre><p >the <span class='texttt'>A(int)</span> constructor will simply initialize <span class='texttt'>i</span> to the value of
<span class='texttt'>arg</span>, and the
<span class='indexparent'><a class='index' id='side effects'></a></span>side effects in <span class='texttt'>i</span>'s default member initializer 
will not take place.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-11'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-11'>11</a></div><p >A temporary expression bound to a reference member from a
default member initializer is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  A() = default;          <span class='comment'>// OK
</span>  A(int v) : v(v) { }     <span class='comment'>// OK
</span>  const int&amp; v = 42;      <span class='comment'>// OK
</span>};
A a1;                     <span class='comment'>// error: ill-formed binding of temporary to reference
</span>A a2(1);                  <span class='comment'>// OK, unfortunately
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-12'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-12'>12</a></div><p >In a non-delegating constructor, the destructor for each potentially constructed
subobject of class type is potentially invoked (<a href='class.dtor'>[class.dtor]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This provision ensures that destructors can be called for fully-constructed
sub-objects in case an exception is thrown (<a href='except.ctor'>[except.ctor]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-13'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-13'>13</a></div><p >In a non-delegating constructor, initialization
proceeds in the following order:</p><ul ><li ><p ><span class='indexparent'><a class='index' id='initialization!order~of virtual~base~class'></a></span>First, and only for the constructor of the most derived class (<a href='intro.object'>[intro.object]</a>),
virtual base classes are initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where “left-to-right” is the order of appearance of the base classes
in the derived class
<i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i>.
</p></li><li ><p ><span class='indexparent'><a class='index' id='initialization!order~of base~class'></a></span>Then, direct base classes are initialized in declaration order
as they appear in the
<i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i>
(regardless of the order of the
<span class='grammarterm'>mem-initializers</span>).
</p></li><li ><p ><span class='indexparent'><a class='index' id='initialization!order~of member'></a></span>Then, non-static data members are initialized in the order
they were declared in the class definition
(again regardless of the order of the
<span class='grammarterm'>mem-initializers</span>).
</p></li><li ><p >Finally, the <i ><a href='stmt.block#compound-statement'>compound-statement</a></i> of the constructor
body  is executed.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
The declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-14'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-14'>14</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct V {
  V();
  V(int);
};

struct A : virtual V {
  A();
  A(int);
};

struct B : virtual V {
  B();
  B(int);
};

struct C : A, B, virtual V {
  C();
  C(int);
};

A::A(int i) : V(i) { <span class='comment'>/* ... */</span> }
B::B(int i) { <span class='comment'>/* ... */</span> }
C::C(int i) { <span class='comment'>/* ... */</span> }

V v(1);             <span class='comment'>// use <span class='texttt'>V(int)</span>
</span>A a(2);             <span class='comment'>// use <span class='texttt'>V(int)</span>
</span>B b(3);             <span class='comment'>// use <span class='texttt'>V()</span>
</span>C c(4);             <span class='comment'>// use <span class='texttt'>V()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-15'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-15'>15</a></div><p ><span class='indexparent'><a class='index' id='initializer!scope~of member'></a></span>Names in the
<i ><a href='expr.post#expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i>
of a
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor for which the
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
is specified.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class X {
  int a;
  int b;
  int i;
  int j;
public:
  const int&amp; r;
  X(int i): r(a), b(i), i(i), j(this-&gt;i) { }
};
</pre><p >initializes
<span class='texttt'>X::r</span>
to refer to
<span class='texttt'>X::a</span>,
initializes
<span class='texttt'>X::b</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
initializes
<span class='texttt'>X::i</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
and initializes
<span class='texttt'>X::j</span>
with the value of
<span class='texttt'>X::i</span>;
this takes place each time an object of class
<span class='texttt'>X</span>
is created.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Because the
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor, the
<span class='texttt'>this</span>
pointer can be used in the
<i ><a href='expr.post#expression-list'>expression-list</a></i>
of a
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>
to refer to the object being initialized.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-16'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-16'>16</a></div><p ><span class='indexparent'><a class='index' id='initialization!member function call during'></a></span>Member functions (including virtual member functions, <a href='class.virtual'>[class.virtual]</a>) can be
called for an object under construction.
Similarly, an object under construction can be the operand of the
<span class='texttt'>typeid</span>
operator (<a href='expr.typeid'>[expr.typeid]</a>) or of a
<span class='texttt'>dynamic_cast</span> (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>).
However, if these operations are performed in a
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>
(or in a function called directly or indirectly from a
<i ><a href='class.base.init#ctor-initializer'>ctor-initializer</a></i>)
before all the
<i ><a href='class.base.init#mem-initializer'>mem-initializers</a></i>
for base classes have completed, the result of the operation is undefined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class A {
public:
  A(int);
};

class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     <span class='comment'>// undefined: calls member function
</span>                    <span class='comment'>// but base <span class='texttt'>A</span> not yet initialized
</span>  j(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;
public:
  D() : C(f()),     <span class='comment'>// undefined: calls member function
</span>                    <span class='comment'>// but base <span class='texttt'>C</span> not yet initialized
</span>  i(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-17'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-17'>17</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<a href='class.cdtor'>[class.cdtor]</a> describes the result of virtual function calls,
<span class='texttt'>typeid</span>
and
<span class='texttt'>dynamic_cast</span>s
during construction for the well-defined cases;
that is, describes the
<i>polymorphic behavior</i>
of an object under construction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-18'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-18'>18</a></div><p ><span class='indexparent'><a class='index' id='initializer!pack expansion'></a></span>A <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> followed by an ellipsis is
a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>) that initializes the base
classes specified by a pack expansion in the <i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i>
for the class. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class... Mixins&gt;
class X : public Mixins... {
public:
  X(const Mixins&amp;... mixins) : Mixins(mixins)... { }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='initialization!class~object'></a></span></p></div></div><div id='class.inhctor.init'><h3 ><a class='secnum' href='#class.inhctor.init' style='min-width:103pt'>12.6.3</a> Initialization by inherited constructor <a class='abbr_ref' href='class.inhctor.init'>[class.inhctor.init]</a></h3><p ><span class='indexparent'><a class='index' id='initialization!by~inherited~constructor'></a></span></p><div class='para' id='class.inhctor.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-1'>1</a></div><p >When a constructor for type <span class='texttt'>B</span> is invoked
to initialize an object of a different type <span class='texttt'>D</span>
(that is, when the constructor was inherited (<a href='namespace.udecl'>[namespace.udecl]</a>)),
initialization proceeds as if a defaulted default constructor
were used to initialize the <span class='texttt'>D</span> object and
each base class subobject from which the constructor was inherited,
except that the <span class='texttt'>B</span> subobject is initialized
by the invocation of the inherited constructor.
The complete initialization is considered to be a single function call;
in particular, the initialization of the inherited constructor's parameters
is sequenced before the initialization of any part of the <span class='texttt'>D</span> object.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct B1 {
  B1(int, ...) { }
};

struct B2 {
  B2(double) { }
};

int get();

struct D1 : B1 {
  using B1::B1;  <span class='comment'>// inherits <span class='texttt'>B1(int, ...)</span>
</span>  int x;
  int y = get();
};

void test() {
  D1 d(2, 3, 4); <span class='comment'>// OK: <span class='texttt'>B1</span> is initialized by calling <span class='texttt'>B1(2, 3, 4)</span>,
</span>                 <span class='comment'>// then <span class='texttt'>d.x</span> is default-initialized (no initialization is performed),
</span>                 <span class='comment'>// then <span class='texttt'>d.y</span> is initialized by calling <span class='texttt'>get()</span>
</span>  D1 e;          <span class='comment'>// error: <span class='texttt'>D1</span> has a deleted default constructor
</span>}

struct D2 : B2 {
  using B2::B2;
  B1 b;
};

D2 f(1.0);       <span class='comment'>// error: <span class='texttt'>B1</span> has a deleted default constructor
</span>
struct W { W(int); };
struct X : virtual W { using W::W; X() = delete; };
struct Y : X { using X::X; };
struct Z : Y, virtual W { using Y::Y; };
Z z(0); <span class='comment'>// OK: initialization of <span class='texttt'>Y</span> does not invoke default constructor of <span class='texttt'>X</span>
</span>
template&lt;class T&gt; struct Log : T {
  using T::T;    <span class='comment'>// inherits all constructors from class <span class='texttt'>T</span>
</span>  ~Log() { std::clog &lt;&lt; "Destroying wrapper" &lt;&lt; std::endl; }
};
</pre><p >Class template <span class='texttt'>Log</span> wraps any class and forwards all of its constructors,
while writing a message to the standard log
whenever an object of class <span class='texttt'>Log</span> is destroyed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.inhctor.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-2'>2</a></div><p >If the constructor was inherited from multiple base class subobjects
of type <span class='texttt'>B</span>, the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { A(int); };
struct B : A { using A::A; };

struct C1 : B { using B::B; };
struct C2 : B { using B::B; };

struct D1 : C1, C2 {
  using C1::C1;
  using C2::C2;
};

struct V1 : virtual B { using B::B; };
struct V2 : virtual B { using B::B; };

struct D2 : V1, V2 {
  using V1::V1;
  using V2::V2;
};

D1 d1(0); <span class='comment'>// ill-formed: ambiguous
</span>D2 d2(0); <span class='comment'>// OK: initializes virtual <span class='texttt'>B</span> base class, which initializes the <span class='texttt'>A</span> base class
</span>          <span class='comment'>// then initializes the <span class='texttt'>V1</span> and <span class='texttt'>V2</span> base classes as if by a defaulted default constructor
</span>
struct M { M(); M(int); };
struct N : M { using M::M; };
struct O : M {};
struct P : N, O { using N::N; using O::O; };
P p(0); <span class='comment'>// OK: use <span class='texttt'>M(0)</span> to initialize <span class='texttt'>N</span>'s base class,
</span>        <span class='comment'>// use <span class='texttt'>M()</span> to initialize <span class='texttt'>O</span>'s base class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.inhctor.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.inhctor.init-3'>3</a></div><p >When an object is initialized by an inheriting constructor,
the principal constructor (<a href='class.base.init'>[class.base.init]</a>, <a href='except.ctor'>[except.ctor]</a>)
for the object is considered to have completed execution
when the initialization of all subobjects is complete.</p></div></div></div></div></body></html>