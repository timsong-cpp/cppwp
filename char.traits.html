<!DOCTYPE html><html lang='en'><head><title>[char.traits]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Strings library <a class='abbr_ref' href='./#strings'>[strings]</a></h1><div id='char.traits'><h2 ><a class='secnum' style='min-width:88pt'>21.2</a> Character traits <a class='abbr_ref'>[char.traits]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause defines requirements on classes representing
<i>character traits</i>,
and defines a class template
<span class='texttt'>char_traits&lt;charT&gt;</span>,
along with four specializations,
<span class='texttt'>char_traits&lt;char&gt;</span>,
<span class='texttt'>char_traits&lt;char16_t&gt;</span>,<br/>
<span class='texttt'>char_traits&lt;char32_t&gt;</span>,
and
<span class='texttt'>char_traits&lt;wchar_t&gt;</span>,
that satisfy those requirements.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Most classes specified in Clauses <a href='string.classes'>[string.classes]</a>
and <a href='input.output'>[input.output]</a> need a set of related types and functions to complete
the definition of their semantics.  These types and functions are provided as a
set of member <i ><a href='dcl.typedef#typedef-name'>typedef-names</a></i> and functions in the template
parameter `traits' used by each such template.  This subclause defines the
semantics of these members.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >To specialize those templates to generate a string or
iostream class to handle a particular character container type
<span class='texttt'>CharT</span>,
that and its related character traits class
<span class='texttt'>Traits</span>
are passed as a pair of parameters to the string or iostream template as
parameters
<span class='texttt'>charT</span>
and
<span class='texttt'>traits</span>.
<span class='texttt'>Traits::char_type</span>
shall be the same as
<span class='texttt'>CharT</span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >This subclause specifies a class template,
<span class='texttt'>char_traits&lt;charT&gt;</span>,
and four explicit specializations of it,
<span class='texttt'>char_traits&lt;<span class='discretionary'></span>char&gt;</span>,
<span class='texttt'>char_traits&lt;char16_t&gt;</span>,
<span class='texttt'>char_traits&lt;char32_t&gt;</span>,
and
<span class='texttt'>char_traits&lt;wchar_t&gt;</span>,
all of which appear in the header
<span class='texttt'>&lt;string&gt;</span>
and satisfy the requirements below.</p></div><div id='require'><h3 ><a class='secnum' href='#require' style='min-width:103pt'>21.2.1</a> Character traits requirements <a class='abbr_ref' href='char.traits.require'>[char.traits.require]</a></h3><div class='para' id='require-1'><div class='marginalizedparent'><a class='marginalized' href='#require-1'>1</a></div><p >In Table <a href='#tab:char.traits.require'>[tab:char.traits.require]</a>,
<span class='texttt'>X</span>
denotes a Traits class defining types and functions for the
character container type
<span class='texttt'>CharT</span>;
<span class='texttt'>c</span>
and
<span class='texttt'>d</span>
denote values of type
<span class='texttt'>CharT</span>;
<span class='texttt'>p</span>
and
<span class='texttt'>q</span>
denote values of type
<span class='texttt'>const CharT*</span>;
<span class='texttt'>s</span>
denotes a value of type
<span class='texttt'>CharT*</span>;
<span class='texttt'>n</span>,
<span class='texttt'>i</span>
and
<span class='texttt'>j</span>
denote values of type
<span class='texttt'>size_t</span>;
<span class='texttt'>e</span>
and
<span class='texttt'>f</span>
denote values of type
<span class='texttt'>X::int_type</span>;
<span class='texttt'>pos</span>
denotes a value of type
<span class='texttt'>X::pos_type</span>;
<span class='texttt'>state</span>
denotes a value of type
<span class='texttt'>X::state_type</span>;
and
<span class='texttt'>r</span>
denotes an lvalue of type
<span class='texttt'>CharT</span>.
Operations on Traits shall not throw exceptions.</p><div class='numberedTable' id='tab:char.traits.require'>Table <a href='#tab:char.traits.require'>47</a> â€” Character traits requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
                        </td><td class='left'>                       </td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>               </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>X::char_type</span>    </td><td class='left'>   <span class='texttt'>charT</span>       </td><td class='left'>
(described in <a href='char.traits.typedefs'>[char.traits.typedefs]</a>)   </td><td class='left'>   compile-time    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::int_type</span> </td><td class='left'>                       </td><td class='left'>
(described in <a href='char.traits.typedefs'>[char.traits.typedefs]</a>)   </td><td class='left'>   compile-time    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::off_type</span> </td><td class='left'>                       </td><td class='left'>
(described in <a href='char.traits.typedefs'>[char.traits.typedefs]</a>)   </td><td class='left'>   compile-time    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::pos_type</span> </td><td class='left'>                       </td><td class='left'>
(described in <a href='char.traits.typedefs'>[char.traits.typedefs]</a>)   </td><td class='left'>   compile-time    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::state_type</span>   </td><td class='left'>                       </td><td class='left'>
(described in <a href='char.traits.typedefs'>[char.traits.typedefs]</a>)   </td><td class='left'>   compile-time    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::eq(c,d)</span>      </td><td class='left'>   <span class='texttt'>bool</span>        </td><td class='left'>
yields: whether <span class='texttt'>c</span> is to be treated as equal to <span class='texttt'>d</span>.   </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::lt(c,d)</span>      </td><td class='left'>   <span class='texttt'>bool</span>        </td><td class='left'>
yields: whether <span class='texttt'>c</span> is to be treated as less than <span class='texttt'>d</span>.  </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::compare(p,q,n)</span>   </td><td class='left'>   <span class='texttt'>int</span>     </td><td class='left'>
yields: <span class='texttt'>0</span> if for each <span class='texttt'>i</span> in <span class='texttt'>[0,n)</span>, <span class='texttt'>X::eq(p[i],q[i])</span>
is true; else, a negative value if, for some <span class='texttt'>j</span> in <span class='texttt'>[0,n)</span>,
<span class='texttt'>X::lt(p[j],q[j])</span> is true and for each <span class='texttt'>i</span> in <span class='texttt'>[0,j)</span>
<span class='texttt'>X::eq(p[i],q[i])</span> is true; else a positive value.            </td><td class='left'>   linear      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::length(p)</span>    </td><td class='left'>   <span class='texttt'>size_t</span>     </td><td class='left'>
yields: the smallest <span class='texttt'>i</span> such that <span class='texttt'>X::eq(p[i],charT())</span> is true.  </td><td class='left'>   linear  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::find(p,n,c)</span>  </td><td class='left'>   <span class='texttt'>const X::char_type*</span> </td><td class='left'>
yields: the smallest <span class='texttt'>q</span> in <span class='texttt'>[p,p+n)</span> such that
<span class='texttt'>X::eq(*q,c)</span> is true, zero otherwise.                        </td><td class='left'>   linear      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::move(s,p,n)</span>  </td><td class='left'>   <span class='texttt'>X::char_type*</span>   </td><td class='left'>
for each <span class='texttt'>i</span> in <span class='texttt'>[0,n)</span>, performs <span class='texttt'>X::assign(s[i],p[i])</span>.
Copies correctly even where the ranges <span class='texttt'>[p,p+n)</span> and <span class='texttt'>[s,s+n)</span> overlap. yields: <span class='texttt'>s</span>.    </td><td class='left'>   linear  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::copy(s,p,n)</span>  </td><td class='left'>   <span class='texttt'>X::char_type*</span>   </td><td class='left'>
pre: <span class='texttt'>p</span> not in <span class='texttt'>[s,s+n)</span>. yields: <span class='texttt'>s</span>. for each <span class='texttt'>i</span> in
<span class='texttt'>[0,n)</span>, performs <span class='texttt'>X::assign(s[i],p[i])</span>.               </td><td class='left'>   linear      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::assign(r,d)</span>  </td><td class='left'>   (not used)          </td><td class='left'>
assigns <span class='texttt'>r=d</span>.                            </td><td class='left'>   constant        </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::assign(s,n,c)</span>  </td><td class='left'>   <span class='texttt'>X::char_type*</span>   </td><td class='left'>
for each <span class='texttt'>i</span> in <span class='texttt'>[0,n)</span>, performs
<span class='texttt'>X::assign(s[i],c)</span>. yields: <span class='texttt'>s</span>.                       </td><td class='left'>   linear      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::not_eof(e)</span>   </td><td class='left'>   <span class='texttt'>int_type</span>        </td><td class='left'>
yields: <span class='texttt'>e</span> if <span class='texttt'>X::eq_int_type(e,X::eof())</span> is false,
otherwise a value <span class='texttt'>f</span> such that
<span class='texttt'>X::eq_int_type(f,X::eof())</span> is false.                       </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::to_char_type(e)</span>    </td><td class='left'>   <span class='texttt'>X::char_type</span>    </td><td class='left'>
yields: if for some <span class='texttt'>c</span>, <span class='texttt'>X::eq_int_type(e,X::to_int_type(c))</span>
is true, <span class='texttt'>c</span>; else some unspecified value.                    </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::to_int_type(c)</span> </td><td class='left'>   <span class='texttt'>X::int_type</span> </td><td class='left'>
yields: some value <span class='texttt'>e</span>, constrained by the definitions of
<span class='texttt'>to_char_type</span> and <span class='texttt'>eq_int_type</span>.                  </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::eq_int_type(e,f)</span>   </td><td class='left'>   <span class='texttt'>bool</span>            </td><td class='left'>
yields: for all <span class='texttt'>c</span> and <span class='texttt'>d</span>, <span class='texttt'>X::eq(c,d)</span> is equal to
<span class='texttt'>X::eq_int_type(X::to_int_type(c), X::to_int_type(d))</span>; otherwise, yields true
if <span class='texttt'>e</span> and <span class='texttt'>f</span> are both copies of <span class='texttt'>X::eof()</span>; otherwise, yields false if
one of <span class='texttt'>e</span> and <span class='texttt'>f</span> is a copy of <span class='texttt'>X::eof()</span> and the other is not; otherwise
the value is unspecified.                                           </td><td class='left'>   constant    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::eof()</span>                </td><td class='left'>   <span class='texttt'>X::int_type</span> </td><td class='left'>
yields: a value <span class='texttt'>e</span> such that <span class='texttt'>X::eq_int_type(e,X::to_int_type(c))</span>
is false for all values <span class='texttt'>c</span>.                                  </td><td class='left'>   constant    </td></tr></table></div></div><div class='para' id='require-2'><div class='marginalizedparent'><a class='marginalized' href='#require-2'>2</a></div><p >The class template</p><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
template&lt;class charT&gt; struct char_traits;
</pre><p >shall be provided in the header
<span class='texttt'>&lt;string&gt;</span>
as a basis for explicit specializations.</p></div></div><div id='typedefs'><h3 ><a class='secnum' href='#typedefs' style='min-width:103pt'>21.2.2</a> traits typedefs <a class='abbr_ref' href='char.traits.typedefs'>[char.traits.typedefs]</a></h3><p ><span class='indexparent'><a class='index' id='char_type!char_traits'></a></span><span class='indexparent'><a class='index' id='char_traits!char_type'></a></span><code class='itemdecl'>
using char_type = CHAR_T;
</code></p><div class='itemdescr'></div><div class='para' id='typedefs-1'><div class='marginalizedparent'><a class='marginalized' href='#typedefs-1'>1</a></div><div class='itemdescr'><p >The type
<span class='texttt'>char_type</span>
is used to refer to the character container type
in the implementation of the library classes defined in <a href='string.classes'>[string.classes]</a> and Clause <a href='input.output'>[input.output]</a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='int_type!char_traits'></a></span><span class='indexparent'><a class='index' id='char_traits!int_type'></a></span><code class='itemdecl'>
using int_type = INT_T;
</code></p><div class='itemdescr'></div><div class='para' id='typedefs-2'><div class='marginalizedparent'><a class='marginalized' href='#typedefs-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
For a certain character container type
<span class='texttt'>char_type</span>,
a related container type
<span class='texttt'>INT_T</span>
shall be a type or class which can represent all of the
valid characters converted from the corresponding
<span class='texttt'>char_type</span>
values, as well as an end-of-file value,
<span class='texttt'>eof()</span>.
The type
<span class='texttt'>int_type</span>
represents a character container type
which can hold end-of-file to be used as a return type
of the iostream class member functions.<a class='footnotenum' href='#footnote-228'>228</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='off_type!char_traits'></a></span><span class='indexparent'><a class='index' id='char_traits!off_type'></a></span><span class='indexparent'><a class='index' id='pos_type!char_traits'></a></span><span class='indexparent'><a class='index' id='char_traits!pos_type'></a></span><code class='itemdecl'>
using off_type = <i>implementation-defined</i>;
using pos_type = <i>implementation-defined</i>;
</code></p><div class='itemdescr'></div><div class='para' id='typedefs-3'><div class='marginalizedparent'><a class='marginalized' href='#typedefs-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
Requirements for
<span class='texttt'>off_type</span>
and
<span class='texttt'>pos_type</span>
are described in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='state_type!char_traits'></a></span><span class='indexparent'><a class='index' id='char_traits!state_type'></a></span><code class='itemdecl'>
using state_type = STATE_T;
</code></p><div class='itemdescr'></div><div class='para' id='typedefs-4'><div class='marginalizedparent'><a class='marginalized' href='#typedefs-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>state_type</span>
shall meet the requirements of
<span class='texttt'>CopyAssignable</span> (Table <a href='utility.arg.requirements#tab:copyassignable'>[tab:copyassignable]</a>),
<span class='texttt'>CopyConstructible</span> (Table <a href='utility.arg.requirements#tab:copyconstructible'>[tab:copyconstructible]</a>), and
<span class='texttt'>DefaultConstructible</span> (Table <a href='utility.arg.requirements#tab:defaultconstructible'>[tab:defaultconstructible]</a>) types.
</p></div></div><div class='footnote' id='footnote-228'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-228'>228)</a></div><p >If
<span class='texttt'>eof()</span>
can be held in
<span class='texttt'>char_type</span>
then some iostreams operations may give surprising results.</p></div></div><div id='specializations'><h3 ><a class='secnum' href='#specializations' style='min-width:103pt'>21.2.3</a> <span class='texttt'>char_traits</span> specializations <a class='abbr_ref' href='char.traits.specializations'>[char.traits.specializations]</a></h3><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;&gt; struct char_traits&lt;char&gt;;
  template&lt;&gt; struct char_traits&lt;char16_t&gt;;
  template&lt;&gt; struct char_traits&lt;char32_t&gt;;
  template&lt;&gt; struct char_traits&lt;wchar_t&gt;;
}
</pre><div class='para' id='specializations-1'><div class='marginalizedparent'><a class='marginalized' href='#specializations-1'>1</a></div><p >The header
<span class='texttt'>&lt;string&gt;</span>
shall define four
specializations of the class template
<span class='texttt'>char_traits</span>:
<span class='texttt'>char_traits&lt;<span class='discretionary'></span>char&gt;</span>,
<span class='texttt'>char_traits&lt;char16_t&gt;</span>,
<span class='texttt'>char_traits&lt;char32_t&gt;</span>,
and
<span class='texttt'>char_traits&lt;wchar_t&gt;</span>.</p></div><div class='para' id='specializations-2'><div class='marginalizedparent'><a class='marginalized' href='#specializations-2'>2</a></div><p >The requirements for the members of these specializations are given in
Clause <a href='char.traits.require'>[char.traits.require]</a>.</p></div><div id='specializations.char'><h4 ><a class='secnum' href='#specializations.char' style='min-width:118pt'>21.2.3.1</a> <span class='texttt'>struct char_traits&lt;char&gt;</span> <a class='abbr_ref' href='char.traits.specializations.char'>[char.traits.specializations.char]</a></h4><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;&gt; struct char_traits&lt;char&gt; {
    using char_type  = char;
    using int_type   = int;
    using off_type   = streamoff;
    using pos_type   = streampos;
    using state_type = mbstate_t;

    static void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                 const char_type&amp; a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
</pre><div class='para' id='specializations.char-1'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-1'>1</a></div><p >The defined types for
<span class='texttt'>int_type</span>,
<span class='texttt'>pos_type</span>,
<span class='texttt'>off_type</span>,
and
<span class='texttt'>state_type</span>
shall be
<span class='texttt'>int</span>,
<span class='texttt'>streampos</span>,
<span class='texttt'>streamoff</span>,
and
<span class='texttt'>mbstate_t</span>
respectively.</p></div><div class='para' id='specializations.char-2'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-2'>2</a></div><p >The type
<span class='texttt'>streampos</span>
shall be an <span class='indexparent'><a class='index' id='type of streampos'></a></span>implementation-defined type that satisfies the requirements for
<span class='texttt'>pos_type</span>
in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.</p></div><div class='para' id='specializations.char-3'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-3'>3</a></div><p >The type
<span class='texttt'>streamoff</span>
shall be an <span class='indexparent'><a class='index' id='type of streamoff'></a></span>implementation-defined type that satisfies the requirements for
<span class='texttt'>off_type</span>
in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.</p></div><div class='para' id='specializations.char-4'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-4'>4</a></div><p >The type
<span class='texttt'>mbstate_t</span>
is defined in
<span class='texttt'>&lt;cwchar&gt;</span>
and can represent any of the conversion states that can occur in an
<span class='indexparent'><a class='index' id='supported multibyte character encoding rules'></a></span>implementation-defined set of supported multibyte
character encoding rules.</p></div><div class='para' id='specializations.char-5'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-5'>5</a></div><p >The two-argument member <span class='texttt'>assign</span> shall be defined identically to the
built-in operator <span class='texttt'>=</span>. The two-argument members <span class='texttt'>eq</span>
and <span class='texttt'>lt</span> shall be defined identically to the built-in operators
<span class='texttt'>==</span> and <span class='texttt'>&lt;</span> for type <span class='texttt'>unsigned</span>
<span class='texttt'>char</span>.</p></div><div class='para' id='specializations.char-6'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char-6'>6</a></div><p >The member
<span class='texttt'>eof()</span>
shall return
<span class='texttt'>EOF</span>.</p></div></div><div id='specializations.char16_t'><h4 ><a class='secnum' href='#specializations.char16_t' style='min-width:118pt'>21.2.3.2</a> <span class='texttt'>struct char_traits&lt;char16_t&gt;</span> <a class='abbr_ref' href='char.traits.specializations.char16_t'>[char.traits.specializations.char16_t]</a></h4><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    using char_type  = char16_t;
    using int_type   = uint_least16_t;
    using off_type   = streamoff;
    using pos_type   = u16streampos;
    using state_type = mbstate_t;

    static void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                                 const char_type&amp; a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
</pre><div class='para' id='specializations.char16_t-1'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char16_t-1'>1</a></div><p >The type
<span class='texttt'>u16streampos</span>
shall be an <span class='indexparent'><a class='index' id='type of u16streampos'></a></span>implementation-defined type that satisfies the requirements
for pos_type in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.</p></div><div class='para' id='specializations.char16_t-2'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char16_t-2'>2</a></div><p >The two-argument members <span class='texttt'>assign</span>,
<span class='texttt'>eq</span>, and <span class='texttt'>lt</span> shall be defined identically to
the built-in operators <span class='texttt'>=</span>, <span class='texttt'>==</span>, and
<span class='texttt'>&lt;</span> respectively.</p></div><div class='para' id='specializations.char16_t-3'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char16_t-3'>3</a></div><p >The member <span class='texttt'>eof()</span> shall return an
<span class='indexparent'><a class='index' id='return value of char_traits<char16_t>::eof'></a></span>implementation-defined constant that cannot appear
as a valid UTF-16 code unit.</p></div></div><div id='specializations.char32_t'><h4 ><a class='secnum' href='#specializations.char32_t' style='min-width:118pt'>21.2.3.3</a> <span class='texttt'>struct char_traits&lt;char32_t&gt;</span> <a class='abbr_ref' href='char.traits.specializations.char32_t'>[char.traits.specializations.char32_t]</a></h4><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    using char_type  = char32_t;
    using int_type   = uint_least32_t;
    using off_type   = streamoff;
    using pos_type   = u32streampos;
    using state_type = mbstate_t;

    static void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                 const char_type&amp; a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
</pre><div class='para' id='specializations.char32_t-1'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char32_t-1'>1</a></div><p >The type
<span class='texttt'>u32streampos</span>
shall be an <span class='indexparent'><a class='index' id='type of u32streampos'></a></span>implementation-defined type that satisfies the requirements
for pos_type in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.</p></div><div class='para' id='specializations.char32_t-2'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char32_t-2'>2</a></div><p >The two-argument members <span class='texttt'>assign</span>,
<span class='texttt'>eq</span>, and <span class='texttt'>lt</span> shall be defined identically to
the built-in operators <span class='texttt'>=</span>, <span class='texttt'>==</span>, and
<span class='texttt'>&lt;</span> respectively.</p></div><div class='para' id='specializations.char32_t-3'><div class='marginalizedparent'><a class='marginalized' href='#specializations.char32_t-3'>3</a></div><p >The member <span class='texttt'>eof()</span> shall return an
<span class='indexparent'><a class='index' id='return value of char_traits<char32_t>::eof'></a></span>implementation-defined constant that cannot appear as a Unicode
code point.</p></div></div><div id='specializations.wchar.t'><h4 ><a class='secnum' href='#specializations.wchar.t' style='min-width:118pt'>21.2.3.4</a> <span class='texttt'>struct char_traits&lt;wchar_t&gt;</span> <a class='abbr_ref' href='char.traits.specializations.wchar.t'>[char.traits.specializations.wchar.t]</a></h4><p ><span class='indexparent'><a class='index' id='char_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;&gt; struct char_traits&lt;wchar_t&gt; {
    using char_type  = wchar_t;
    using int_type   = wint_t;
    using off_type   = streamoff;
    using pos_type   = wstreampos;
    using state_type = mbstate_t;

    static void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                 const char_type&amp; a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
</pre><div class='para' id='specializations.wchar.t-1'><div class='marginalizedparent'><a class='marginalized' href='#specializations.wchar.t-1'>1</a></div><p >The defined types for
<span class='texttt'>int_type</span>,
<span class='texttt'>pos_type</span>,
and
<span class='texttt'>state_type</span>
shall be
<span class='texttt'>wint_t</span>,
<span class='texttt'>wstreampos</span>,
and
<span class='texttt'>mbstate_t</span>
respectively.</p></div><div class='para' id='specializations.wchar.t-2'><div class='marginalizedparent'><a class='marginalized' href='#specializations.wchar.t-2'>2</a></div><p >The type
<span class='texttt'>wstreampos</span>
shall be an <span class='indexparent'><a class='index' id='type of wstreampos'></a></span>implementation-defined type that satisfies the requirements
for pos_type in <a href='iostreams.limits.pos'>[iostreams.limits.pos]</a> and <a href='iostream.forward'>[iostream.forward]</a>.</p></div><div class='para' id='specializations.wchar.t-3'><div class='marginalizedparent'><a class='marginalized' href='#specializations.wchar.t-3'>3</a></div><p >The type
<span class='texttt'>mbstate_t</span>
is defined in
<span class='texttt'>&lt;cwchar&gt;</span>
and can represent any of the conversion states that can occur in an <span class='indexparent'><a class='index' id='supported multibyte character encoding rules'></a></span>implementation-defined set of supported multibyte character encoding rules.</p></div><div class='para' id='specializations.wchar.t-4'><div class='marginalizedparent'><a class='marginalized' href='#specializations.wchar.t-4'>4</a></div><p >The two-argument members
<span class='texttt'>assign</span>,
<span class='texttt'>eq</span>,
and
<span class='texttt'>lt</span>
shall be defined identically
to the built-in operators
<span class='texttt'>=</span>,
<span class='texttt'>==</span>,
and
<span class='texttt'>&lt;</span>
respectively.</p></div><div class='para' id='specializations.wchar.t-5'><div class='marginalizedparent'><a class='marginalized' href='#specializations.wchar.t-5'>5</a></div><p >The member
<span class='texttt'>eof()</span>
shall return
<span class='texttt'>WEOF</span>.</p></div></div></div></div></div></body></html>