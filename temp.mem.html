<!DOCTYPE html><html lang='en'><head><title>[temp.mem]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.mem'>[temp.decls]</a></h2><div id='temp.mem'><h3 ><a class='secnum' style='min-width:103pt'>14.5.2</a> Member templates <a class='abbr_ref'>[temp.mem]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1574'>#</a></div><p >A template can be declared within a class or class template; such a template
is called a member template.
A member template can be defined within or outside its class definition or
class template definition.
A member template of a class template that is defined outside of its class
template definition shall be specified with the
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span>
of the class template followed by the
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span>
of the member template.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><p ><pre class='codeblock'>
template&lt;class T&gt; struct string {
  template&lt;class T2&gt; int compare(const T2&amp;);
  template&lt;class T2&gt; string(const string&lt;T2&gt;&amp; s) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
};

template&lt;class T&gt; template&lt;class T2&gt; int string&lt;T&gt;::compare(const T2&amp; s) {
}</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1597'>#</a></div><p >A local class of non-closure type shall not have member templates.
Access control rules (Clause <a href='class.access'>[class.access]</a>)
apply to member template names.
A destructor shall not be a member
template.
A non-template member function (<a href='dcl.fct'>[dcl.fct]</a>) with a given name
and type and a member function template of the same name, which could be
used to generate a specialization of the same type, can both be
declared in a class.
When both exist, a use of that name and type refers to the
non-template member unless an explicit template argument list is supplied.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><p ><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class T2&gt; void f(T2);
};

template &lt;&gt; void A&lt;int&gt;::f(int) { }                 <span class='comment'>// non-template member function
</span>template &lt;&gt; template &lt;&gt; void A&lt;int&gt;::f&lt;&gt;(int) { }   <span class='comment'>// member function template specialization
</span>
int main() {
  A&lt;char&gt; ac;
  ac.f(1);          <span class='comment'>// non-template
</span>  ac.f('c');        <span class='comment'>// template
</span>  ac.f&lt;&gt;(1);        <span class='comment'>// template
</span>}</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1629'>#</a></div><p >A member function template shall not be virtual.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><p ><pre class='codeblock'>
template &lt;class T&gt; struct AA {
  template &lt;class C&gt; virtual void g(C);   <span class='comment'>// error
</span>  virtual void f();                       <span class='comment'>// OK
</span>};</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1641'>#</a></div><p >A specialization of
a member function template does not override a virtual function from a
base class.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><p ><pre class='codeblock'>
class B {
  virtual void f(int);
};

class D : public B {
  template &lt;class T&gt; void f(T); <span class='comment'>// does not override <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f(int)</span>
</span>  void f(int i) { f&lt;&gt;(i); }     <span class='comment'>// overriding function that calls the template instantiation
</span>};</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1658'>#</a></div><p >A specialization of a
conversion function template
is referenced in
the same way as a non-template conversion function that converts to
the same type.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><p ><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T*();
};
template &lt;class T&gt; A::operator T*(){ return 0; }
template &lt;&gt; A::operator char*(){ return 0; }    <span class='comment'>// specialization
</span>template A::operator void*();                   <span class='comment'>// explicit instantiation
</span>
int main() {
  A a;
  int* ip;
  ip = a.operator int*();       <span class='comment'>// explicit call to template operator <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;operator int*()</span>
</span>}</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Because the explicit template argument list follows the function template
name, and because conversion member function templates and constructor
member function templates are called without using a function name,
there is no way to provide an explicit template argument list for these
function templates.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1689'>#</a></div><p >A specialization of a
conversion function template
is not found by name
lookup.
Instead, any
conversion function templates
visible in the
context of the use are considered.
For each such operator, if argument
deduction succeeds (<a href='temp.deduct.conv'>[temp.deduct.conv]</a>), the resulting specialization is
used as if found by name lookup.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1702'>#</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> in a derived class cannot refer to a specialization
of a
conversion function template
in a base class.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33f16cb3417ad21949769d82cae36c1b653e4519/source/templates.tex#L1708'>#</a></div><p ><a href='over.ics.rank'>Overload resolution</a> and <a href='temp.func.order'>partial
ordering</a> are used to select the best conversion function
among multiple
specializations of conversion function templates
and/or non-template
conversion functions.</p></div></div></div></body></html>