<!DOCTYPE html><html lang='en'><head><title>[temp.over]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>17</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>17.8</a> Function template specializations <a class='abbr_ref' href='temp.fct.spec#temp.over'>[temp.fct.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>17.8.3</a> Overload resolution <a class='abbr_ref'>[temp.over]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/32fffbe4796ab0852f7bdf66b6d48d2e2b5e61ea/source/templates.tex#L7455'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,resolution,function_template'></a></span>A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>When a call to that name is written (explicitly, or implicitly using the
operator notation), <a href='temp.deduct'>template argument deduction</a>
and checking of any explicit <a href='temp.arg'>template arguments</a> are performed
for each function template to find the template argument values (if any) that
can be used with that function template to instantiate a function template
specialization that can be invoked with the call arguments<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>For each function template, if the argument deduction and checking succeeds,
the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i><span class='textit'>s</span>
(deduced and/or explicit)
are used to synthesize the declaration of
a single function template specialization which is
added to the candidate functions set to be used in overload resolution<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>If, for a given function template, argument deduction fails or
the synthesized function template specialization would be ill-formed,
no such function is added to the set of candidate functions for that template<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of
the same name<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>The synthesized declarations are
treated like any other functions in
the remainder of overload resolution, except as explicitly noted
in <a href='over.match.best'>[over.match.best]</a><a class='hidden_link' href='#1.sentence-6'>.</a><a class='footnotenum' href='#footnote-143'>143</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/32fffbe4796ab0852f7bdf66b6d48d2e2b5e61ea/source/templates.tex#L7493'>#</a></div><div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            <span class='comment'>// <span class='tcode_in_codeblock'>max(int a, int b)</span>
</span>  char m2 = max(c,d);           <span class='comment'>// <span class='tcode_in_codeblock'>max(char a, char b)</span>
</span>  int m3 = max(a,c);            <span class='comment'>// error: cannot generate <span class='tcode_in_codeblock'>max(int,char)</span>
</span>}</pre><div id='2.sentence-1' class='sentence'>Adding the non-template function</div><pre class='codeblock'>
int max(int,int);</pre><div id='2.sentence-2' class='sentence'>to the example above would resolve the third call, by providing a function that
could be called for
<span class='texttt'>max(a,c)</span>
after using the standard conversion of
<span class='texttt'>char</span>
to
<span class='texttt'>int</span>
for
<span class='texttt'>c</span><a class='hidden_link' href='#2.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/32fffbe4796ab0852f7bdf66b6d48d2e2b5e61ea/source/templates.tex#L7522'>#</a></div><div id='3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='3.sentence-1' class='sentence'>Here is an example involving conversions on a function argument involved in
<span class='grammarterm'>template-argument</span>
deduction:
<pre class='codeblock'>
template&lt;class T&gt; struct B { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class T&gt; struct D : public B&lt;T&gt; { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class T&gt; void f(B&lt;T&gt;&amp;);

void g(B&lt;int&gt;&amp; bi, D&lt;int&gt;&amp; di) {
  f(bi);            <span class='comment'>// <span class='tcode_in_codeblock'>f(bi)</span>
</span>  f(di);            <span class='comment'>// <span class='tcode_in_codeblock'>f((B&lt;int&gt;&amp;)di)</span>
</span>}</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/32fffbe4796ab0852f7bdf66b6d48d2e2b5e61ea/source/templates.tex#L7539'>#</a></div><div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='4.sentence-1' class='sentence'>Here is an example involving conversions on a function argument not involved in
<span class='grammarterm'>template-parameter</span>
deduction:
<pre class='codeblock'>
template&lt;class T&gt; void f(T*,int);       <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T,char);       <span class='comment'>// #2
</span>
void h(int* pi, int i, char c) {
  f(pi,i);          <span class='comment'>// #1: <span class='tcode_in_codeblock'>f&lt;int&gt;(pi,i)</span>
</span>  f(pi,c);          <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int*&gt;(pi,c)</span>
</span>
  f(i,c);           <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int&gt;(i,c);</span>
</span>  f(i,i);           <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int&gt;(i,char(i))</span>
</span>}</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/32fffbe4796ab0852f7bdf66b6d48d2e2b5e61ea/source/templates.tex#L7558'>#</a></div><div id='5.sentence-1' class='sentence'>Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.sentence-2' class='sentence'>Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate<a class='hidden_link' href='#5.sentence-2'>.</a></div> <div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T&gt; void f(T);    <span class='comment'>// declaration
</span>
void g() {
  f("Annemarie");               <span class='comment'>// call of <span class='tcode_in_codeblock'>f&lt;const char*&gt;</span>
</span>}</pre><div id='5.sentence-3' class='sentence'>The call of
<span class='texttt'>f</span>
is well-formed even if the template
<span class='texttt'>f</span>
is only declared and not defined at the point of the call<a class='hidden_link' href='#5.sentence-3'>.</a></div> <div id='5.sentence-4' class='sentence'>The program will be ill-formed unless a specialization for
<span class='texttt'>f&lt;const char*&gt;</span>,
either implicitly or explicitly generated,
is present in some translation unit<a class='hidden_link' href='#5.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-143'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-143'>143)</a></div><div id='footnote-143.sentence-1' class='sentence'>The parameters of function template
specializations contain no
template parameter types<a class='hidden_link' href='#footnote-143.sentence-1'>.</a></div> <div id='footnote-143.sentence-2' class='sentence'>The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions<a class='hidden_link' href='#footnote-143.sentence-2'>.</a></div> <div id='footnote-143.sentence-3' class='sentence'>Non-deduced arguments allow the full range of conversions<a class='hidden_link' href='#footnote-143.sentence-3'>.</a></div> <div id='footnote-143.sentence-4' class='sentence'>Note also that <a href='over.match.best'>[over.match.best]</a> specifies that a non-template function will
be given preference over a template specialization if the two functions
are otherwise equally good candidates for an overload match<a class='hidden_link' href='#footnote-143.sentence-4'>.</a></div></div></div></body></html>