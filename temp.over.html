<!DOCTYPE html><html lang='en'><head><title>[temp.over]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.8</a> Function template specializations <a class='abbr_ref' href='temp.fct.spec#temp.over'>[temp.fct.spec]</a></h2><div id='temp.over'><h3 ><a class='secnum' style='min-width:103pt'>14.8.3</a> Overload resolution <a class='abbr_ref'>[temp.over]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/templates.tex#L7475'>#</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,function_template'></a></span>A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name.
When a call to that name is written (explicitly, or implicitly using the
operator notation), <a href='temp.deduct'>template argument deduction</a>
and checking of any explicit <a href='temp.arg'>template arguments</a> are performed
for each function template to find the template argument values (if any) that
can be used with that function template to instantiate a function template
specialization that can be invoked with the call arguments.
For each function template, if the argument deduction and checking succeeds,
the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>s
(deduced and/or explicit)
are used to synthesize the declaration of
a single function template specialization which is
added to the candidate functions set to be used in overload resolution.
If, for a given function template, argument deduction fails or
the synthesized function template specialization would be ill-formed,
no such function is added to the set of candidate functions for that template.
The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of
the same name.
The synthesized declarations are
treated like any other functions in
the remainder of overload resolution, except as explicitly noted
in <a href='over.match.best'>[over.match.best]</a>.<a class='footnotenum' href='#footnote-143'>143</a></p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/templates.tex#L7513'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
template&lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            <span class='comment'>// <span class='tcode_in_codeblock'>max(int a, int b)</span>
</span>  char m2 = max(c,d);           <span class='comment'>// <span class='tcode_in_codeblock'>max(char a, char b)</span>
</span>  int m3 = max(a,c);            <span class='comment'>// error: cannot generate <span class='tcode_in_codeblock'>max(int,char)</span>
</span>}</pre><p >Adding the non-template function</p><pre class='codeblock'>
int max(int,int);</pre><p >to the example above would resolve the third call, by providing a function that
could be called for
<span class='texttt'>max(a,c)</span>
after using the standard conversion of
<span class='texttt'>char</span>
to
<span class='texttt'>int</span>
for
<span class='texttt'>c</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/templates.tex#L7542'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
Here is an example involving conversions on a function argument involved in
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; struct B { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class T&gt; struct D : public B&lt;T&gt; { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class T&gt; void f(B&lt;T&gt;&amp;);

void g(B&lt;int&gt;&amp; bi, D&lt;int&gt;&amp; di) {
  f(bi);            <span class='comment'>// <span class='tcode_in_codeblock'>f(bi)</span>
</span>  f(di);            <span class='comment'>// <span class='tcode_in_codeblock'>f((B&lt;int&gt;&amp;)di)</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/templates.tex#L7560'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
Here is an example involving conversions on a function argument not involved in
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; void f(T*,int);       <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T,char);       <span class='comment'>// #2
</span>
void h(int* pi, int i, char c) {
  f(pi,i);          <span class='comment'>// #1: <span class='tcode_in_codeblock'>f&lt;int&gt;(pi,i)</span>
</span>  f(pi,c);          <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int*&gt;(pi,c)</span>
</span>
  f(i,c);           <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int&gt;(i,c);</span>
</span>  f(i,i);           <span class='comment'>// #2: <span class='tcode_in_codeblock'>f&lt;int&gt;(i,char(i))</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/templates.tex#L7580'>#</a></div><p >Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions.
Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);    <span class='comment'>// declaration
</span>
void g() {
  f("Annemarie");               <span class='comment'>// call of <span class='tcode_in_codeblock'>f&lt;const char*&gt;</span>
</span>}</pre><p >The call of
<span class='texttt'>f</span>
is well-formed even if the template
<span class='texttt'>f</span>
is only declared and not defined at the point of the call.
The program will be ill-formed unless a specialization for
<span class='texttt'>f&lt;const char*&gt;</span>,
either implicitly or explicitly generated,
is present in some translation unit.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div><div class='footnote' id='footnote-143'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-143'>143)</a></div><p >The parameters of function template
specializations contain no
template parameter types.
The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions.
Non-deduced arguments allow the full range of conversions.
Note also that <a href='over.match.best'>[over.match.best]</a> specifies that a non-template function will
be given preference over a template specialization if the two functions
are otherwise equally good candidates for an overload match.</p></div></div></div></body></html>