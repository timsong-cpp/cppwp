<!DOCTYPE html><html lang='en'><head><title>[localization]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='localization'><h1 ><a class='secnum' style='min-width:73pt'>22</a> Localization library <a class='abbr_ref' href='./#localization'>[localization]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>22.1</a> General <a class='abbr_ref' href='localization.general'>[localization.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes components that C++ programs may use to
encapsulate (and therefore be more portable when confronting)
cultural differences.
The locale facility includes internationalization
support for character classification and string collation, numeric,
monetary, and date/time formatting and parsing, and message retrieval.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The following subclauses describe components for
locales themselves, the standard facets, and facilities
from the ISO C library, as summarized in Table <a href='#tab:localization.lib.summary'>[tab:localization.lib.summary]</a>.</p><div class='numberedTable' id='tab:localization.lib.summary'>Table <a href='#tab:localization.lib.summary'>63</a> — Localization library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='locales'>[locales]</a> </td><td class='left'> Locales                   </td><td class='left'>   <span class='texttt'>&lt;locale&gt;</span>    </td></tr><tr ><td class='left'>
<a href='locale.categories'>[locale.categories]</a> </td><td class='left'> Standard <span class='texttt'>locale</span> Categories </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<a href='locale.stdcvt'>[locale.stdcvt]</a> </td><td class='left'> Standard code conversion facets  </td><td class='left'>   <span class='texttt'>&lt;codecvt&gt;</span> </td></tr><tr class='rowsep'><td class='left'> 
<a href='c.locales'>[c.locales]</a> </td><td class='left'> C library locales       </td><td class='left'>   <span class='texttt'>&lt;clocale&gt;</span>   </td></tr></table></div></div></div><div id='locale.syn'><h2 ><a class='secnum' href='#locale.syn' style='min-width:88pt'>22.2</a> Header <span class='texttt'>&lt;locale&gt;</span> synopsis <a class='abbr_ref' href='locale.syn'>[locale.syn]</a></h2><p ><span class='indexparent'><a class='index' id='locale'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='locale'>[locale]</a>, locale:
</span>  class locale;
  template &lt;class Facet&gt; const Facet&amp; use_facet(const locale&amp;);
  template &lt;class Facet&gt; bool         has_facet(const locale&amp;) noexcept;

  <span class='comment'>// <a href='locale.convenience'>[locale.convenience]</a>, convenience interfaces:
</span>  template &lt;class charT&gt; bool isspace (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isprint (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool iscntrl (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isupper (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool islower (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isalpha (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isdigit (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool ispunct (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isxdigit(charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isalnum (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isgraph (charT c, const locale&amp; loc);
  template &lt;class charT&gt; bool isblank (charT c, const locale&amp; loc);
  template &lt;class charT&gt; charT toupper(charT c, const locale&amp; loc);
  template &lt;class charT&gt; charT tolower(charT c, const locale&amp; loc);
  template &lt;class Codecvt, class Elem = wchar_t,
    class Wide_alloc = std::allocator&lt;Elem&gt;,
    class Byte_alloc = std::allocator&lt;char&gt;&gt; class wstring_convert;
  template &lt;class Codecvt, class Elem = wchar_t,
     class Tr = char_traits&lt;Elem&gt;&gt; class wbuffer_convert;

  <span class='comment'>// <a href='category.ctype'>[category.ctype]</a>, ctype:
</span>  class ctype_base;
  template &lt;class charT&gt; class ctype;
  template &lt;&gt;            class ctype&lt;char&gt;;             <span class='comment'>// specialization
</span>  template &lt;class charT&gt; class ctype_byname;
  class codecvt_base;
  template &lt;class internT, class externT, class stateT&gt; class codecvt;
  template &lt;class internT, class externT, class stateT&gt; class codecvt_byname;

  <span class='comment'>// <a href='category.numeric'>[category.numeric]</a>, numeric:
</span>  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;  class num_get;
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt; class num_put;
  template &lt;class charT&gt; class numpunct;
  template &lt;class charT&gt; class numpunct_byname;

  <span class='comment'>// <a href='category.collate'>[category.collate]</a>, collation:
</span>  template &lt;class charT&gt; class collate;
  template &lt;class charT&gt; class collate_byname;

  <span class='comment'>// <a href='category.time'>[category.time]</a>, date and time:
</span>  class time_base;
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
    class time_get;
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
    class time_get_byname;
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
    class time_put;
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
    class time_put_byname;

  <span class='comment'>// <a href='category.monetary'>[category.monetary]</a>, money:
</span>  class money_base;
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;  class money_get;
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt; class money_put;
  template &lt;class charT, bool Intl = false&gt; class moneypunct;
  template &lt;class charT, bool Intl = false&gt; class moneypunct_byname;

  <span class='comment'>// <a href='category.messages'>[category.messages]</a>, message retrieval:
</span>  class messages_base;
  template &lt;class charT&gt; class messages;
  template &lt;class charT&gt; class messages_byname;
}
</pre><div class='para' id='locale.syn-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.syn-1'>1</a></div><p >The header
<span class='texttt'>&lt;locale&gt;</span>
defines classes and declares functions that encapsulate and manipulate
the information peculiar to a locale.<a class='footnotenum' href='#footnote-231'>231</a></p></div><div class='footnote' id='footnote-231'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-231'>231)</a></div><p >In this subclause, the type name
<span class='texttt'>struct tm</span>
is an incomplete type that is defined in
<span class='indexparent'><a class='index' id='ctime'></a></span><span class='texttt'>&lt;ctime&gt;</span>.</p></div></div><div id='locales'><h2 ><a class='secnum' href='#locales' style='min-width:88pt'>22.3</a> Locales <a class='abbr_ref' href='locales'>[locales]</a></h2><div id='locale'><h3 ><a class='secnum' href='#locale' style='min-width:103pt'>22.3.1</a> Class <span class='texttt'>locale</span> <a class='abbr_ref' href='locale'>[locale]</a></h3><p ><span class='indexparent'><a class='index' id='locale'></a></span></p><pre class='codeblock'>
namespace std {
  class locale {
  public:
    <span class='comment'>// types:
</span>    class facet;
    class id;
    using category = int;
    static const category   <span class='comment'>// values assigned here are for exposition only
</span>      none     = 0,
      collate  = 0x010, ctype    = 0x020,
      monetary = 0x040, numeric  = 0x080,
      time     = 0x100, messages = 0x200,
      all = collate | ctype | monetary | numeric | time  | messages;

    <span class='comment'>// construct/copy/destroy:
</span>    locale() noexcept;
    locale(const locale&amp; other) noexcept;
    explicit locale(const char* std_name);
    explicit locale(const string&amp; std_name);
    locale(const locale&amp; other, const char* std_name, category);
    locale(const locale&amp; other, const string&amp; std_name, category);
    template &lt;class Facet&gt; locale(const locale&amp; other, Facet* f);
    locale(const locale&amp; other, const locale&amp; one, category);
    ~locale();                  <span class='comment'>// not virtual
</span>    const locale&amp; operator=(const locale&amp; other) noexcept;
    template &lt;class Facet&gt; locale combine(const locale&amp; other) const;

    <span class='comment'>// locale operations:
</span>    basic_string&lt;char&gt;                  name() const;

    bool operator==(const locale&amp; other) const;
    bool operator!=(const locale&amp; other) const;

    template &lt;class charT, class traits, class Allocator&gt;
      bool operator()(const basic_string&lt;charT,traits,Allocator&gt;&amp; s1,
                      const basic_string&lt;charT,traits,Allocator&gt;&amp; s2) const;

    <span class='comment'>// global locale objects:
</span>    static       locale  global(const locale&amp;);
    static const locale&amp; classic();
  };
}
</pre><div class='para' id='locale-1'><div class='marginalizedparent'><a class='marginalized' href='#locale-1'>1</a></div><p >Class
<span class='texttt'>locale</span>
implements a type-safe polymorphic set of facets, indexed by facet
<i>type</i>.
In other words, a facet has a dual role: in one
sense, it's just a class interface; at the same time, it's an index
into a locale's set of facets.</p></div><div class='para' id='locale-2'><div class='marginalizedparent'><a class='marginalized' href='#locale-2'>2</a></div><p >Access to the facets of a
<span class='texttt'>locale</span>
is via two function templates,
<span class='texttt'>use_facet&lt;&gt;</span>
and
<span class='texttt'>has_facet&lt;&gt;</span>.</p></div><div class='para' id='locale-3'><div class='marginalizedparent'><a class='marginalized' href='#locale-3'>3</a></div><p >[&nbsp;<i>Example:</i>
An iostream
<span class='texttt'>operator&lt;&lt;</span>
might be implemented as:<a class='footnotenum' href='#footnote-232'>232</a></p><pre class='codeblock'>
template &lt;class charT, class traits&gt;
basic_ostream&lt;charT,traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT,traits&gt;&amp; s, Date d) {
  typename basic_ostream&lt;charT,traits&gt;::sentry cerberos(s);
  if (cerberos) {
    ios_base::iostate err = ios_base::iostate::goodbit;
    tm tmbuf; d.extract(tmbuf);
    use_facet&lt;time_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt;&gt; &gt;(
      s.getloc()).put(s, s, s.fill(), err, &amp;tmbuf, 'x');
    s.setstate(err);            <span class='comment'>// might throw
</span>  }
  return s;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='locale-4'><div class='marginalizedparent'><a class='marginalized' href='#locale-4'>4</a></div><p >In the call to
<span class='texttt'>use_facet&lt;Facet&gt;(loc)</span>,
the type argument chooses a facet, making available all members
of the named type.
If
<span class='texttt'>Facet</span>
is not present in a
locale,
it throws the standard exception
<span class='texttt'>bad_cast</span>.
A C++ program can check if a locale implements a particular
facet with the
function template
<span class='texttt'>has_facet&lt;Facet&gt;()</span>.
User-defined facets may be installed in a locale, and used identically as
may standard facets (<a href='facets.examples'>[facets.examples]</a>).</p></div><div class='para' id='locale-5'><div class='marginalizedparent'><a class='marginalized' href='#locale-5'>5</a></div><p >[&nbsp;<i>Note:</i>
All locale semantics are accessed via
<span class='texttt'>use_facet&lt;&gt;</span>
and
<span class='texttt'>has_facet&lt;&gt;</span>,
except that:</p><ul class='itemize'><li id='locale-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale-5.1'>(5.1)</a></div><p >A member operator template
<span class='texttt'>operator()(const basic_string&lt;C, T, A&gt;&amp;, const basic_string&lt;C, T, A&gt;&amp;)</span>
is provided so that a locale may be used as a predicate argument to
the standard collections, to collate strings.
</p></li><li id='locale-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale-5.2'>(5.2)</a></div><p >Convenient global interfaces are provided for traditional
<span class='texttt'>ctype</span>
functions such as
<span class='texttt'>isdigit()</span>
and
<span class='texttt'>isspace()</span>,
so that given a locale
object <span class='texttt'>loc</span> a C++ program can call
<span class='texttt'>isspace(c,loc)</span>.
(This eases upgrading existing extractors (<a href='istream.formatted'>[istream.formatted]</a>).)
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='locale-6'><div class='marginalizedparent'><a class='marginalized' href='#locale-6'>6</a></div><p >Once a facet reference is obtained from a locale object by calling
<span class='texttt'>use_facet&lt;&gt;</span>,
that reference remains usable, and the results from member functions
of it may be cached and re-used, as long as some locale object refers
to that facet.</p></div><div class='para' id='locale-7'><div class='marginalizedparent'><a class='marginalized' href='#locale-7'>7</a></div><p >In successive calls to a locale facet member function on a facet object
installed in the same locale, the returned result shall be identical.</p></div><div class='para' id='locale-8'><div class='marginalizedparent'><a class='marginalized' href='#locale-8'>8</a></div><p >A
<span class='texttt'>locale</span>
constructed from a name string (such as <span class='texttt'>"POSIX"</span>), or from parts of
two named locales, has a name; all others do not.
Named locales may be compared for equality; an unnamed locale is equal
only to (copies of) itself.
For an unnamed locale,
<span class='texttt'>locale::name()</span>
returns the string
<span class='texttt'>"*"</span>.</p></div><div class='para' id='locale-9'><div class='marginalizedparent'><a class='marginalized' href='#locale-9'>9</a></div><p >Whether there is one global locale object for the entire program or one global locale
object per thread is <span class='indexparent'><a class='index' id='whether_locale_object_is_global_or_per-thread'></a></span>implementation-defined.
Implementations should provide one global locale object per
thread. If there is a single global locale object for the entire program,
implementations are not required to avoid data races on it (<a href='res.on.data.races'>[res.on.data.races]</a>).</p></div><div class='footnote' id='footnote-232'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-232'>232)</a></div><p >Note that in the call to
<span class='texttt'>put</span>
the stream is implicitly converted to an
<span class='texttt'>ostreambuf_iterator&lt;charT,traits&gt;</span>.</p></div><div id='locale.types'><h4 ><a class='secnum' href='#locale.types' style='min-width:118pt'>22.3.1.1</a> <span class='texttt'>locale</span> types <a class='abbr_ref' href='locale.types'>[locale.types]</a></h4><div id='locale.category'><h4 ><a class='secnum' href='#locale.category' style='min-width:133pt'>22.3.1.1.1</a> Type <span class='texttt'>locale::category</span> <a class='abbr_ref' href='locale.category'>[locale.category]</a></h4><p ><span class='indexparent'><a class='index' id='locale,category'></a></span><span class='indexparent'><a class='index' id='category,locale'></a></span><code class='itemdecl'>
using category = int;
</code></p><div class='para' id='locale.category-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-1'>1</a></div><p ><i>Valid</i>
<span class='texttt'>category</span>
values include the
<span class='texttt'>locale</span>
member bitmask elements
<span class='texttt'>collate</span>,
<span class='texttt'>ctype</span>,
<span class='texttt'>monetary</span>,
<span class='texttt'>numeric</span>,
<span class='texttt'>time</span>,
and
<span class='texttt'>messages</span>,
each of which represents a single locale category.
In addition,
<span class='texttt'>locale</span>
member bitmask constant
<span class='texttt'>none</span>
is defined as zero and represents no category. And
<span class='texttt'>locale</span>
member bitmask constant
<span class='texttt'>all</span>
is defined such that the expression</p><pre class='codeblock'>
(collate | ctype | monetary | numeric | time | messages | all) == all
</pre><p >is
<span class='texttt'>true</span>,
and represents the union of all categories.
Further, the expression
<span class='texttt'>(X | Y)</span>,
where
<span class='texttt'>X</span>
and
<span class='texttt'>Y</span>
each represent a single category, represents the union of the two categories.</p></div><div class='para' id='locale.category-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-2'>2</a></div><p ><span class='texttt'>locale</span>
member functions expecting a
<span class='texttt'>category</span>
argument require one of the
<span class='texttt'>category</span>
values defined above, or the union of two or more such values.
Such a
<span class='texttt'>category</span>
value identifies a set of locale categories.
Each locale category,
in turn, identifies a set of locale facets, including at least those
shown in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a>.</p><div class='numberedTable' id='tab:localization.category.facets'>Table <a href='#tab:localization.category.facets'>64</a> — Locale category facets<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Category</b></td><td colspan='1' class='center'><b>Includes facets</b></td></tr><tr class='capsep'><td class='left'> 
collate     </td><td class='left'>   <span class='texttt'>collate&lt;char&gt;</span>, <span class='texttt'>collate&lt;wchar_t&gt;</span>                 </td></tr><tr class='rowsep'><td class='left'> 
ctype       </td><td class='left'>   <span class='texttt'>ctype&lt;char&gt;</span>, <span class='texttt'>ctype&lt;wchar_t&gt;</span>                     </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt&lt;char,char,mbstate_t&gt;</span>                            </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt&lt;char16_t,char,mbstate_t&gt;</span>        </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt&lt;char32_t,char,mbstate_t&gt;</span>        </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt&lt;wchar_t,char,mbstate_t&gt;</span>                         </td></tr><tr class='rowsep'><td class='left'> 
monetary    </td><td class='left'>   <span class='texttt'>moneypunct&lt;char&gt;</span>, <span class='texttt'>moneypunct&lt;wchar_t&gt;</span>           </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>moneypunct&lt;char,true&gt;</span>, <span class='texttt'>moneypunct&lt;wchar_t,true&gt;</span> </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>money_get&lt;char&gt;</span>, <span class='texttt'>money_get&lt;wchar_t&gt;</span>             </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>money_put&lt;char&gt;</span>, <span class='texttt'>money_put&lt;wchar_t&gt;</span>             </td></tr><tr class='rowsep'><td class='left'> 
numeric     </td><td class='left'>   <span class='texttt'>numpunct&lt;char&gt;</span>, <span class='texttt'>numpunct&lt;wchar_t&gt;</span>               </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>num_get&lt;char&gt;</span>, <span class='texttt'>num_get&lt;wchar_t&gt;</span>                 </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>num_put&lt;char&gt;</span>, <span class='texttt'>num_put&lt;wchar_t&gt;</span>                 </td></tr><tr class='rowsep'><td class='left'> 
time        </td><td class='left'>   <span class='texttt'>time_get&lt;char&gt;</span>, <span class='texttt'>time_get&lt;wchar_t&gt;</span>               </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_put&lt;char&gt;</span>, <span class='texttt'>time_put&lt;wchar_t&gt;</span>               </td></tr><tr class='rowsep'><td class='left'> 
messages    </td><td class='left'>   <span class='texttt'>messages&lt;char&gt;</span>, <span class='texttt'>messages&lt;wchar_t&gt;</span>               </td></tr></table></div></div><div class='para' id='locale.category-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-3'>3</a></div><p >For any locale <span class='texttt'>loc</span>
either constructed, or returned by
<span class='texttt'>locale::classic()</span>,
and any facet <span class='texttt'>Facet</span>
shown in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a>,
<span class='texttt'>has_facet&lt;Facet&gt;(loc)</span>
is <span class='texttt'>true</span>.
Each
<span class='texttt'>locale</span>
member function which takes a
<span class='texttt'>locale::category</span>
argument operates on the corresponding set of facets.</p></div><div class='para' id='locale.category-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-4'>4</a></div><p >An implementation is required to provide those specializations for
facet templates identified as members of a category, and for those
shown in Table <a href='#tab:localization.required.specializations'>[tab:localization.required.specializations]</a>.</p><div class='numberedTable' id='tab:localization.required.specializations'>Table <a href='#tab:localization.required.specializations'>65</a> — Required specializations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Category</b></td><td colspan='1' class='center'><b>Includes facets</b></td></tr><tr class='capsep'><td class='left'> 
collate     </td><td class='left'>   <span class='texttt'>collate_byname&lt;char&gt;</span>, <span class='texttt'>collate_byname&lt;wchar_t&gt;</span>       </td></tr><tr class='rowsep'><td class='left'> 
ctype       </td><td class='left'>   <span class='texttt'>ctype_byname&lt;char&gt;</span>, <span class='texttt'>ctype_byname&lt;wchar_t&gt;</span>           </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt_byname&lt;char,char,mbstate_t&gt;</span>                         </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt_byname&lt;char16_t,char,mbstate_t&gt;</span>     </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt_byname&lt;char32_t,char,mbstate_t&gt;</span>     </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>codecvt_byname&lt;wchar_t,char,mbstate_t&gt;</span>                      </td></tr><tr class='rowsep'><td class='left'> 
monetary    </td><td class='left'>   <span class='texttt'>moneypunct_byname&lt;char,International&gt;</span>                       </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>moneypunct_byname&lt;wchar_t,International&gt;</span>                    </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>money_get&lt;C,InputIterator&gt;</span>                                  </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>money_put&lt;C,OutputIterator&gt;</span>                                 </td></tr><tr class='rowsep'><td class='left'> 
numeric     </td><td class='left'>   <span class='texttt'>numpunct_byname&lt;char&gt;</span>, <span class='texttt'>numpunct_byname&lt;wchar_t&gt;</span>     </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>num_get&lt;C,InputIterator&gt;</span>, <span class='texttt'>num_put&lt;C,OutputIterator&gt;</span> </td></tr><tr class='rowsep'><td class='left'> 
time        </td><td class='left'>   <span class='texttt'>time_get&lt;char,InputIterator&gt;</span>                                </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_get_byname&lt;char,InputIterator&gt;</span>                         </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_get&lt;wchar_t,InputIterator&gt;</span>                             </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_get_byname&lt;wchar_t,InputIterator&gt;</span>                      </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_put&lt;char,OutputIterator&gt;</span>                               </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_put_byname&lt;char,OutputIterator&gt;</span>                        </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_put&lt;wchar_t,OutputIterator&gt;</span>                            </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>time_put_byname&lt;wchar_t,OutputIterator&gt;</span>                     </td></tr><tr class='rowsep'><td class='left'> 
messages    </td><td class='left'>   <span class='texttt'>messages_byname&lt;char&gt;</span>, <span class='texttt'>messages_byname&lt;wchar_t&gt;</span>     </td></tr></table></div></div><div class='para' id='locale.category-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-5'>5</a></div><p >The provided implementation of members of facets
<span class='texttt'>num_get&lt;charT&gt;</span>
and
<span class='texttt'>num_put&lt;charT&gt;</span>
calls
<span class='texttt'>use_facet&nbsp;&lt;F&gt;&nbsp;(l)</span>
only for facet
<span class='texttt'>F</span>
of types
<span class='texttt'>numpunct&lt;charT&gt;</span>
and
<span class='texttt'>ctype&lt;charT&gt;</span>,
and for locale
<span class='texttt'>l</span>
the value obtained
by calling member
<span class='texttt'>getloc()</span>
on the
<span class='texttt'>ios_base&amp;</span>
argument to these functions.</p></div><div class='para' id='locale.category-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.category-6'>6</a></div><p >In declarations of facets, a template parameter with name
<span class='texttt'>InputIterator</span>
or
<span class='texttt'>OutputIterator</span>
indicates the set of
all possible specializations on parameters that satisfy the
requirements of an Input Iterator or an Output Iterator, respectively (<a href='iterator.requirements'>[iterator.requirements]</a>).
A template parameter with name
<span class='texttt'>C</span>
represents the set
of types containing <span class='texttt'>char</span>, <span class='texttt'>wchar_t</span>, and any other
<span class='indexparent'><a class='index' id='set_of_character_types_that_iostreams_templates_can_be_instantiated_for'></a></span>implementation-defined
character types that satisfy
the requirements for a character on which any of the iostream
components can be instantiated.
A template parameter with name
<span class='texttt'>International</span>
represents the set of all possible specializations on a bool parameter.</p></div></div><div id='locale.facet'><h4 ><a class='secnum' href='#locale.facet' style='min-width:133pt'>22.3.1.1.2</a> Class <span class='texttt'>locale::facet</span> <a class='abbr_ref' href='locale.facet'>[locale.facet]</a></h4><p ><span class='indexparent'><a class='index' id='locale,facet'></a></span><span class='indexparent'><a class='index' id='facet,locale'></a></span></p><pre class='codeblock'>
namespace std {
  class locale::facet {
  protected:
    explicit facet(size_t refs = 0);
    virtual ~facet();
    facet(const facet&amp;) = delete;
    void operator=(const facet&amp;) = delete;
  };
}
</pre><div class='para' id='locale.facet-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.facet-1'>1</a></div><p >Template parameters in this Clause which are required to be facets are those named
<span class='texttt'>Facet</span>
in declarations.
A program that passes a type that is
<i>not</i>
a facet, or a type that refers to a volatile-qualified facet, as an
(explicit or deduced) template parameter to a locale
function expecting a facet, is ill-formed. A const-qualified facet is a
valid template argument to any locale function that expects a Facet template
parameter.</p></div><div class='para' id='locale.facet-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.facet-2'>2</a></div><p >The <span class='texttt'>refs</span>
argument to the constructor is used for lifetime management.
For
<span class='texttt'>refs == 0</span>,
the implementation performs
<span class='texttt'>delete static_cast&lt;locale::facet*&gt;(f)</span>
(where
<span class='texttt'>f</span>
is a pointer to the facet) when the last
<span class='texttt'>locale</span>
object containing the facet is destroyed;
for
<span class='texttt'>refs == 1</span>,
the implementation never destroys the facet.</p></div><div class='para' id='locale.facet-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.facet-3'>3</a></div><p >Constructors of all
facets defined in this Clause take such an argument and pass it
along to their
<span class='texttt'>facet</span>
base class constructor.
All one-argument constructors defined
in this Clause are
<a class='hidden_link' href='#def:explicit' id='def:explicit'><i>explicit</i></a>,
preventing their participation in automatic conversions.</p></div><div class='para' id='locale.facet-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.facet-4'>4</a></div><p >For some standard facets a standard
“<span class='math'>&hellip;</span><span class='texttt'>_byname</span>”
class, derived from it, implements the virtual function semantics
equivalent to that facet of the locale constructed by
<span class='texttt'>locale(const char*)</span>
with the same name.
Each such facet provides a constructor that takes a
<span class='texttt'>const char*</span>
argument, which names the locale, and a <span class='texttt'>refs</span>
argument, which is passed to the base class constructor.
Each such facet also provides a constructor that takes a
<span class='texttt'>string</span> argument <span class='texttt'>str</span> and a <span class='texttt'>refs</span>
argument, which has the same effect as calling the first constructor with the
two arguments <span class='texttt'>str.c_str()</span> and <span class='texttt'>refs</span>.
If there is no
“<span class='math'>&hellip;</span><span class='texttt'>_byname</span>”
version of a facet, the base class implements named locale
semantics itself by reference to other facets.</p></div></div><div id='locale.id'><h4 ><a class='secnum' href='#locale.id' style='min-width:133pt'>22.3.1.1.3</a> Class <span class='texttt'>locale::id</span> <a class='abbr_ref' href='locale.id'>[locale.id]</a></h4><p ><span class='indexparent'><a class='index' id='locale,id'></a></span><span class='indexparent'><a class='index' id='id,locale'></a></span></p><pre class='codeblock'>
namespace std {
  class locale::id {
  public:
    id();
    void operator=(const id&amp;) = delete;
    id(const id&amp;) = delete;
  };
}
</pre><div class='para' id='locale.id-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.id-1'>1</a></div><p >The class <span class='texttt'>locale::id</span> provides identification of a locale facet
interface, used as an index for lookup
and to encapsulate initialization.</p></div><div class='para' id='locale.id-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.id-2'>2</a></div><p >[&nbsp;<i>Note:</i>
Because facets are used by iostreams, potentially while static constructors are
running, their initialization cannot depend on programmed static
initialization.
One initialization strategy is for
<span class='texttt'>locale</span>
to initialize each facet's
<span class='texttt'>id</span>
member the first time an instance of the facet is installed into a locale.
This depends only on static storage being zero before constructors run (<a href='basic.start.static'>[basic.start.static]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='locale.cons'><h4 ><a class='secnum' href='#locale.cons' style='min-width:118pt'>22.3.1.2</a> <span class='texttt'>locale</span> constructors and destructor <a class='abbr_ref' href='locale.cons'>[locale.cons]</a></h4><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
locale() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-1'>1</a></div><div class='itemdescr'><p >Default constructor: a snapshot of the current global locale.</p></div></div><div class='para' id='locale.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a copy of the argument last passed to
<span class='texttt'>locale::global(locale&amp;)</span>,
if it has been called; else, the resulting facets have virtual
function semantics identical to those of
<span class='texttt'>locale::classic()</span>.
[&nbsp;<i>Note:</i>
This constructor is commonly used as the default value for arguments
of functions that take a
<span class='texttt'>const locale&amp;</span>
argument.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
locale(const locale&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale which is a copy of <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
explicit locale(const char* std_name);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale using standard C locale names, e.g., <span class='texttt'>"POSIX"</span>.
The resulting locale implements semantics defined to be associated
with that name.</p></div></div><div class='para' id='locale.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>runtime_error</span>
if the argument is not valid, or is null.</p></div></div><div class='para' id='locale.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The set of valid string argument values is <span class='texttt'>"C"</span>, <span class='texttt'>""</span>,
and any <span class='indexparent'><a class='index' id='locale_names'></a></span>implementation-defined values.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
explicit locale(const string&amp; std_name);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> The same as <span class='texttt'>locale(std_name.c_str())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
locale(const locale&amp; other, const char* std_name, category);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale as a copy of
<span class='texttt'>other</span>
except for the facets identified by the
<span class='texttt'>category</span>
argument, which instead implement the same semantics as
<span class='texttt'>locale(std_name)</span>.</p></div></div><div class='para' id='locale.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>runtime_error</span>
if the argument is not valid, or is null.</p></div></div><div class='para' id='locale.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The locale has a name if and only if
<span class='texttt'>other</span>
has a name.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
locale(const locale&amp; other, const string&amp; std_name, category cat);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> The same as <span class='texttt'>locale(other, std_name.c_str(), cat)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
template &lt;class Facet&gt; locale(const locale&amp; other, Facet* f);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale incorporating all facets from the first
argument except that of type
<span class='texttt'>Facet</span>,
and installs the second argument as the remaining facet.
If <span class='texttt'>f</span>
is null, the resulting object is a copy of <span class='texttt'>other</span>.</p></div></div><div class='para' id='locale.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-13'>13</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The resulting locale has no name.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,constructor'></a></span><code class='itemdecl'>
locale(const locale&amp; other, const locale&amp; one, category cats);
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale incorporating all facets from the first argument
except those that implement
<span class='texttt'>cats</span>,
which are instead incorporated from the second argument.</p></div></div><div class='para' id='locale.cons-15'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-15'>15</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The resulting locale has a name if and only if the first two arguments
have names.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,locale'></a></span><span class='indexparent'><a class='index' id='locale,operator='></a></span><code class='itemdecl'>
const locale&amp; operator=(const locale&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-16'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>
Creates a copy of <span class='texttt'>other</span>, replacing the current value.</p></div></div><div class='para' id='locale.cons-17'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,destructor'></a></span><code class='itemdecl'>
~locale();
</code></p><div class='itemdescr'></div><div class='para' id='locale.cons-18'><div class='marginalizedparent'><a class='marginalized' href='#locale.cons-18'>18</a></div><div class='itemdescr'><p >A non-virtual destructor that throws no exceptions.
</p></div></div></div><div id='locale.members'><h4 ><a class='secnum' href='#locale.members' style='min-width:118pt'>22.3.1.3</a> <span class='texttt'>locale</span> members <a class='abbr_ref' href='locale.members'>[locale.members]</a></h4><p ><span class='indexparent'><a class='index' id='locale,combine'></a></span><span class='indexparent'><a class='index' id='combine,locale'></a></span><code class='itemdecl'>
template &lt;class Facet&gt; locale combine(const locale&amp; other) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a locale incorporating
all facets from
<span class='texttt'>*this</span>
except for that one facet of
<span class='texttt'>other</span>
that is identified by
<span class='texttt'>Facet</span>.</p></div></div><div class='para' id='locale.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The newly created locale.</p></div></div><div class='para' id='locale.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.members-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>runtime_error</span>
if
<span class='texttt'>has_facet&lt;Facet&gt;(other)</span>
is <span class='texttt'>false</span>.</p></div></div><div class='para' id='locale.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.members-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The resulting locale has no name.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,name'></a></span><span class='indexparent'><a class='index' id='name,locale'></a></span><code class='itemdecl'>
basic_string&lt;char&gt; name() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
The name of
<span class='texttt'>*this</span>,
if it has one; otherwise, the string <span class='texttt'>"*"</span>.
If
<span class='texttt'>*this</span>
has a name, then
<span class='texttt'>locale(name().c_str())</span>
is equivalent to
<span class='texttt'>*this</span>.
Details of the contents of the resulting string are otherwise <span class='indexparent'><a class='index' id='return_value_of_locale::name'></a></span>implementation-defined.
</p></div></div></div><div id='locale.operators'><h4 ><a class='secnum' href='#locale.operators' style='min-width:118pt'>22.3.1.4</a> <span class='texttt'>locale</span> operators <a class='abbr_ref' href='locale.operators'>[locale.operators]</a></h4><p ><span class='indexparent'><a class='index' id='locale,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,locale'></a></span><code class='itemdecl'>
bool operator==(const locale&amp; other) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.operators-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if both arguments are the same locale, or one is a copy of the
other, or each has a name and the names are identical;
<span class='texttt'>false</span>
otherwise.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,locale'></a></span><code class='itemdecl'>
bool operator!=(const locale&amp; other) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.operators-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(*this == other)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),locale'></a></span><code class='itemdecl'>
template &lt;class charT, class traits, class Allocator&gt;
  bool operator()(const basic_string&lt;charT,traits,Allocator&gt;&amp; s1,
                  const basic_string&lt;charT,traits,Allocator&gt;&amp; s2) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.operators-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Compares two strings according to the
<span class='texttt'>collate&lt;charT&gt;</span>
facet.</p></div></div><div class='para' id='locale.operators-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This member operator template (and therefore
<span class='texttt'>locale</span>
itself) satisfies requirements for a comparator predicate template argument
(Clause <a href='algorithms'>[algorithms]</a>) applied to strings.</p></div></div><div class='para' id='locale.operators-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>use_facet&lt;collate&lt;charT&gt;&gt;(*this).compare(s1.data(), s1.data() + s1.size(),<br/>
s2.data(), s2.data() + s2.size()) &lt; 0</span>.</p></div></div><div class='para' id='locale.operators-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.operators-6'>6</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
A vector of strings
<span class='texttt'>v</span>
can be collated according to collation rules in locale
<span class='texttt'>loc</span>
simply by (<a href='alg.sort'>[alg.sort]</a>, <a href='vector'>[vector]</a>):</p><pre class='codeblock'>
std::sort(v.begin(), v.end(), loc);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='locale.statics'><h4 ><a class='secnum' href='#locale.statics' style='min-width:118pt'>22.3.1.5</a> <span class='texttt'>locale</span> static members <a class='abbr_ref' href='locale.statics'>[locale.statics]</a></h4><p ><span class='indexparent'><a class='index' id='locale,global'></a></span><span class='indexparent'><a class='index' id='global,locale'></a></span><code class='itemdecl'>
static locale global(const locale&amp; loc);
</code></p><div class='itemdescr'></div><div class='para' id='locale.statics-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-1'>1</a></div><div class='itemdescr'><p >Sets the global locale to its argument.</p></div></div><div class='para' id='locale.statics-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Causes future calls to the constructor
<span class='texttt'>locale()</span>
to return a copy of the argument.
If the argument has a name, does</p><pre class='codeblock'>
std::setlocale(LC_ALL, loc.name().c_str());
</pre><p >otherwise, the effect on the C locale, if any, is <span class='indexparent'><a class='index' id='effect_on_C_locale_of_calling_locale::global'></a></span>implementation-defined.
No library function other than
<span class='texttt'>locale::global()</span>
shall affect the value returned by
<span class='texttt'>locale()</span>.
[&nbsp;<i>Note:</i> See <a href='c.locales'>[c.locales]</a> for data race considerations when
<span class='texttt'>setlocale</span> is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.statics-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
The previous value of
<span class='texttt'>locale()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,classic'></a></span><span class='indexparent'><a class='index' id='classic,locale'></a></span><code class='itemdecl'>
static const locale&amp; classic();
</code></p><div class='itemdescr'></div><div class='para' id='locale.statics-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-4'>4</a></div><div class='itemdescr'><p >The <span class='texttt'>"C"</span> locale.</p></div></div><div class='para' id='locale.statics-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A locale that implements the classic <span class='texttt'>"C"</span> locale semantics, equivalent
to the value <span class='texttt'>locale("C")</span>.</p></div></div><div class='para' id='locale.statics-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.statics-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This locale, its facets, and their member functions, do not change
with time.
</p></div></div></div></div><div id='locale.global.templates'><h3 ><a class='secnum' href='#locale.global.templates' style='min-width:103pt'>22.3.2</a> <span class='texttt'>locale</span> globals <a class='abbr_ref' href='locale.global.templates'>[locale.global.templates]</a></h3><p ><span class='indexparent'><a class='index' id='locale,use_facet'></a></span><span class='indexparent'><a class='index' id='use_facet,locale'></a></span><code class='itemdecl'>
template &lt;class Facet&gt; const Facet&amp; use_facet(const locale&amp; loc);
</code></p><div class='itemdescr'></div><div class='para' id='locale.global.templates-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.global.templates-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>Facet</span>
is a facet class whose definition contains the public static member
<span class='texttt'>id</span>
as defined in <a href='locale.facet'>[locale.facet]</a>.</p></div></div><div class='para' id='locale.global.templates-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.global.templates-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A reference to the corresponding facet of <span class='texttt'>loc</span>, if present.</p></div></div><div class='para' id='locale.global.templates-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.global.templates-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_cast</span>
if
<span class='texttt'>has_facet&lt;Facet&gt;(loc)</span>
is
<span class='texttt'>false</span>.</p></div></div><div class='para' id='locale.global.templates-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.global.templates-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The reference returned remains valid at least as long as any copy of
<span class='texttt'>loc</span> exists.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale,has_facet'></a></span><span class='indexparent'><a class='index' id='has_facet,locale'></a></span><code class='itemdecl'>
template &lt;class Facet&gt; bool has_facet(const locale&amp; loc) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.global.templates-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.global.templates-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if the facet requested is present in <span class='texttt'>loc</span>; otherwise <span class='texttt'>false</span>.
</p></div></div></div><div id='locale.convenience'><h3 ><a class='secnum' href='#locale.convenience' style='min-width:103pt'>22.3.3</a> Convenience interfaces <a class='abbr_ref' href='locale.convenience'>[locale.convenience]</a></h3><div id='classification'><h4 ><a class='secnum' href='#classification' style='min-width:118pt'>22.3.3.1</a> Character classification <a class='abbr_ref' href='classification'>[classification]</a></h4><p ><span class='indexparent'><a class='index' id='isspace'></a></span><span class='indexparent'><a class='index' id='isprint'></a></span><span class='indexparent'><a class='index' id='iscntrl'></a></span><span class='indexparent'><a class='index' id='isupper'></a></span><span class='indexparent'><a class='index' id='islower'></a></span><span class='indexparent'><a class='index' id='isalpha'></a></span><span class='indexparent'><a class='index' id='isdigit'></a></span><span class='indexparent'><a class='index' id='ispunct'></a></span><span class='indexparent'><a class='index' id='isxdigit'></a></span><span class='indexparent'><a class='index' id='isalnum'></a></span><span class='indexparent'><a class='index' id='isgraph'></a></span><span class='indexparent'><a class='index' id='isblank'></a></span><code class='itemdecl'>
template &lt;class charT&gt; bool isspace (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isprint (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool iscntrl (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isupper (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool islower (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isalpha (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isdigit (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool ispunct (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isxdigit(charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isalnum (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isgraph (charT c, const locale&amp; loc);
template &lt;class charT&gt; bool isblank (charT c, const locale&amp; loc);
</code></p><div class='para' id='classification-1'><div class='marginalizedparent'><a class='marginalized' href='#classification-1'>1</a></div><p >Each of these functions
<span class='texttt'>is<i>F</i></span>
returns the result of the expression:</p><pre class='codeblock'>
use_facet&lt;ctype&lt;charT&gt;&gt;(loc).is(ctype_base::<i>F</i>, c)
</pre><p >where <span class='texttt'><i>F</i></span> is the
<span class='texttt'>ctype_base::mask</span>
value corresponding to that function (<a href='category.ctype'>[category.ctype]</a>).<a class='footnotenum' href='#footnote-233'>233</a></p></div><div class='footnote' id='footnote-233'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-233'>233)</a></div><p >When
used in a loop, it is faster to cache the
<span class='texttt'>ctype&lt;&gt;</span>
facet and use it directly, or use the vector form of
<span class='texttt'>ctype&lt;&gt;::is</span>.</p></div></div><div id='conversions'><h4 ><a class='secnum' href='#conversions' style='min-width:118pt'>22.3.3.2</a> Conversions <a class='abbr_ref' href='conversions'>[conversions]</a></h4><div id='conversions.character'><h4 ><a class='secnum' href='#conversions.character' style='min-width:133pt'>22.3.3.2.1</a> Character conversions <a class='abbr_ref' href='conversions.character'>[conversions.character]</a></h4><p ><span class='indexparent'><a class='index' id='toupper'></a></span><code class='itemdecl'>
template &lt;class charT&gt; charT toupper(charT c, const locale&amp; loc);
</code></p><div class='itemdescr'></div><div class='para' id='conversions.character-1'><div class='marginalizedparent'><a class='marginalized' href='#conversions.character-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(loc).toupper(c)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tolower'></a></span><code class='itemdecl'>
template &lt;class charT&gt; charT tolower(charT c, const locale&amp; loc);
</code></p><div class='itemdescr'></div><div class='para' id='conversions.character-2'><div class='marginalizedparent'><a class='marginalized' href='#conversions.character-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(loc).tolower(c)</span>.
</p></div></div></div><div id='conversions.string'><h4 ><a class='secnum' href='#conversions.string' style='min-width:133pt'>22.3.3.2.2</a> <span class='texttt'>string</span> conversions <a class='abbr_ref' href='conversions.string'>[conversions.string]</a></h4><div class='para' id='conversions.string-1'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-1'>1</a></div><p >Class template <span class='texttt'>wstring_convert</span> performs conversions between a wide
string and a byte string. It lets you specify a code conversion facet
(like class template <span class='texttt'>codecvt</span>) to perform the conversions, without
affecting any streams or locales. [&nbsp;<i>Example:</i> If you want to use the code
conversion facet <span class='texttt'>codecvt_utf8</span> to output to <span class='texttt'>cout</span> a UTF-8
multibyte sequence corresponding to a wide string, but you don't want to
alter the locale for <span class='texttt'>cout</span>, you can write something like:</p><pre class='codeblock'>
wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout &lt;&lt; mbstring;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='conversions.string-2'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-2'>2</a></div><p ><b>Class template <span class='texttt'>wstring_convert</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='wstring_convert'></a></span></p><pre class='codeblock'>
namespace std {
template&lt;class Codecvt, class Elem = wchar_t,
    class Wide_alloc = std::allocator&lt;Elem&gt;,
    class Byte_alloc = std::allocator&lt;char&gt;&gt; class wstring_convert {
  public:
    using byte_string = std::basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;;
    using wide_string = std::basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;;
    using state_type  = typename Codecvt::state_type;
    using int_type    = typename wide_string::traits_type::int_type;

    explicit wstring_convert(Codecvt* pcvt = new Codecvt);
    wstring_convert(Codecvt* pcvt, state_type state);
    explicit wstring_convert(const byte_string&amp; byte_err,
                             const wide_string&amp; wide_err = wide_string());
    ~wstring_convert();

    wstring_convert(const wstring_convert&amp;) = delete;
    wstring_convert&amp; operator=(const wstring_convert&amp;) = delete;

    wide_string from_bytes(char byte);
    wide_string from_bytes(const char* ptr);
    wide_string from_bytes(const byte_string&amp; str);
    wide_string from_bytes(const char* first, const char* last);

    byte_string to_bytes(Elem wchar);
    byte_string to_bytes(const Elem* wptr);
    byte_string to_bytes(const wide_string&amp; wstr);
    byte_string to_bytes(const Elem* first, const Elem* last);

    size_t converted() const noexcept;
    state_type state() const;
  private:
    byte_string byte_err_string;    <span class='comment'>// <i>exposition only</i>
</span>    wide_string wide_err_string;    <span class='comment'>// <i>exposition only</i>
</span>    Codecvt* cvtptr;                <span class='comment'>// <i>exposition only</i>
</span>    state_type cvtstate;            <span class='comment'>// <i>exposition only</i>
</span>    size_t cvtcount;                <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre></div><div class='para' id='conversions.string-3'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-3'>3</a></div><p >The class template describes an object that controls conversions between wide
string objects of class <span class='texttt'>std::basic_string&lt;Elem, char_traits&lt;Elem&gt;,
Wide_alloc&gt;</span> and byte string objects of class <span class='texttt'>std::<br/>basic_string&lt;char,
char_traits&lt;char&gt;, Byte_alloc&gt;</span>. The class template defines the types
<span class='texttt'>wide_string</span> and <span class='texttt'>byte_string</span> as synonyms for these two types.
Conversion between a sequence of <span class='texttt'>Elem</span> values (stored in a
<span class='texttt'>wide_string</span> object) and multibyte sequences (stored in a
<span class='texttt'>byte_string</span> object) is performed by an object of class
<span class='texttt'>Codecvt</span>, which meets the
requirements of the standard code-conversion facet <span class='texttt'>std::codecvt&lt;Elem,
char, std::mbstate_t&gt;</span>.</p></div><div class='para' id='conversions.string-4'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-4'>4</a></div><p >An object of this class template stores:</p><ul class='itemize'><li id='conversions.string-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-4.1'>(4.1)</a></div><p ><span class='texttt'>byte_err_string</span> — a byte string to display on errors
</p></li><li id='conversions.string-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-4.2'>(4.2)</a></div><p ><span class='texttt'>wide_err_string</span> — a wide string to display on errors
</p></li><li id='conversions.string-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-4.3'>(4.3)</a></div><p ><span class='texttt'>cvtptr</span> — a pointer to the allocated conversion object
(which is freed when the <span class='texttt'>wstring_convert</span> object is destroyed)
</p></li><li id='conversions.string-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-4.4'>(4.4)</a></div><p ><span class='texttt'>cvtstate</span> — a conversion state object
</p></li><li id='conversions.string-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-4.5'>(4.5)</a></div><p ><span class='texttt'>cvtcount</span> — a conversion count
</p></li></ul><p ><span class='indexparent'><a class='index' id='byte_string,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,byte_string'></a></span><code class='itemdecl'>
using byte_string = std::basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='conversions.string-5'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-5'>5</a></div><div class='itemdescr'><p >The type shall be a synonym for <span class='texttt'>std::basic_string&lt;char,
char_traits&lt;char&gt;, Byte_alloc&gt;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='converted,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,converted'></a></span><code class='itemdecl'>
size_t converted() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-6'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cvtcount</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='from_bytes,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,from_bytes'></a></span><code class='itemdecl'>
wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string&amp; str);
wide_string from_bytes(const char* first, const char* last);
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-7'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first member function shall convert the single-element sequence <span class='texttt'>byte</span> to a
wide string. The second member function shall convert the null-terminated
sequence beginning at <span class='texttt'>ptr</span> to a wide string. The third member function
shall convert the sequence stored in <span class='texttt'>str</span> to a wide string. The fourth member
function shall convert the sequence defined by the range <span class='texttt'>[first, last)</span> to a
wide string.</p></div></div><div class='para' id='conversions.string-8'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-8'>8</a></div><div class='itemdescr'><p >In all cases:</p><ul class='itemize'><li id='conversions.string-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-8.1'>(8.1)</a></div><p >If the <span class='texttt'>cvtstate</span> object was not constructed with an explicit value, it
shall be set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.</p></li><li id='conversions.string-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-8.2'>(8.2)</a></div><p >The number of input elements successfully converted shall be stored in <span class='texttt'>cvtcount</span>.
</p></li></ul></div></div><div class='para' id='conversions.string-9'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the
member function shall return the wide-error string.
Otherwise, the member function throws an object of class <span class='texttt'>std::range_error</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='int_type,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,int_type'></a></span><code class='itemdecl'>
using int_type = typename wide_string::traits_type::int_type;
</code></p><div class='itemdescr'><p >The type shall be a synonym for <span class='texttt'>wide_string::traits_type::int_type</span>.
</p></div><p ><span class='indexparent'><a class='index' id='state,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,state'></a></span><code class='itemdecl'>
state_type state() const;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-10'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-10'>10</a></div><div class='itemdescr'><p >returns <span class='texttt'>cvtstate</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='state_type,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,state_type'></a></span><code class='itemdecl'>
using state_type = typename Codecvt::state_type;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-11'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-11'>11</a></div><div class='itemdescr'><p >The type shall be a synonym for <span class='texttt'>Codecvt::state_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_bytes,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,to_bytes'></a></span><code class='itemdecl'>
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string&amp; wstr);
byte_string to_bytes(const Elem* first, const Elem* last);
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-12'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first member function shall convert the single-element sequence <span class='texttt'>wchar</span> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <span class='texttt'>wptr</span> to
a byte string. The third member function shall convert the sequence stored in <span class='texttt'>wstr</span> to a
byte string. The fourth member function shall convert the sequence defined by the
range <span class='texttt'>[first, last)</span> to a byte string.</p></div></div><div class='para' id='conversions.string-13'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-13'>13</a></div><div class='itemdescr'><p >In all cases:</p><ul class='itemize'><li id='conversions.string-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-13.1'>(13.1)</a></div><p >If the <span class='texttt'>cvtstate</span> object was not constructed with an explicit value, it
shall be
set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.
</p></li><li id='conversions.string-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.string-13.2'>(13.2)</a></div><p >The number of input elements successfully converted shall be stored
in <span class='texttt'>cvtcount</span>.
</p></li></ul></div></div><div class='para' id='conversions.string-14'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the
member function shall return the byte-error string.
Otherwise, the member function shall throw an object of class <span class='texttt'>std::range_error</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wide_string,wstring_convert'></a></span><span class='indexparent'><a class='index' id='wstring_convert,wide_string'></a></span><code class='itemdecl'>
using wide_string = std::basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-15'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-15'>15</a></div><div class='itemdescr'><p >The type shall be a synonym for <span class='texttt'>std::basic_string&lt;Elem,
char_traits&lt;Elem&gt;, Wide_alloc&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wstring_convert,constructor'></a></span><code class='itemdecl'>
explicit wstring_convert(Codecvt* pcvt = new Codecvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string&amp; byte_err,
    const wide_string&amp; wide_err = wide_string());
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-16'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-16'>16</a></div><div class='itemdescr'><p ><i>Requires:</i>
For the first and second constructors, <span class='texttt'>pcvt != nullptr</span>.</p></div></div><div class='para' id='conversions.string-17'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first constructor shall store <span class='texttt'>pcvt</span> in <span class='texttt'>cvtptr</span> and
default values in <span class='texttt'>cvtstate</span>, <span class='texttt'>byte_err_string</span>, and
<span class='texttt'>wide_err_string</span>.
The second constructor shall store <span class='texttt'>pcvt</span> in <span class='texttt'>cvtptr</span>,
<span class='texttt'>state</span> in <span class='texttt'>cvtstate</span>, and default values in
<span class='texttt'>byte_err_string</span> and <span class='texttt'>wide_err_string</span>; moreover the
stored state shall be retained between calls to <span class='texttt'>from_bytes</span> and
<span class='texttt'>to_bytes</span>.
The third constructor shall store <span class='texttt'>new Codecvt</span> in <span class='texttt'>cvtptr</span>,
<span class='texttt'>state_type()</span> in <span class='texttt'>cvtstate</span>, <span class='texttt'>byte_err</span>
in <span class='texttt'>byte_err_string</span>, and <span class='texttt'>wide_err</span> in
<span class='texttt'>wide_err_string</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wstring_convert,destructor'></a></span><code class='itemdecl'>
~wstring_convert();
</code></p><div class='itemdescr'></div><div class='para' id='conversions.string-18'><div class='marginalizedparent'><a class='marginalized' href='#conversions.string-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> The destructor shall delete <span class='texttt'>cvtptr</span>.
</p></div></div></div><div id='conversions.buffer'><h4 ><a class='secnum' href='#conversions.buffer' style='min-width:133pt'>22.3.3.2.3</a> Buffer conversions <a class='abbr_ref' href='conversions.buffer'>[conversions.buffer]</a></h4><div class='para' id='conversions.buffer-1'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-1'>1</a></div><p >Class template <span class='texttt'>wbuffer_convert</span> looks like a wide stream buffer, but
performs all its I/O through an underlying byte stream buffer that you
specify when you construct it. Like class template <span class='texttt'>wstring_convert</span>, it
lets you specify a code conversion facet to perform the conversions,
without affecting any streams or locales.</p></div><div class='para' id='conversions.buffer-2'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-2'>2</a></div><p ><b>Class template <span class='texttt'>wbuffer_convert</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='wbuffer_convert'></a></span></p><pre class='codeblock'>
namespace std {
template&lt;class Codecvt,
    class Elem = wchar_t,
    class Tr = std::char_traits&lt;Elem&gt;&gt;
  class wbuffer_convert
    : public std::basic_streambuf&lt;Elem, Tr&gt; {
  public:
    using state_type = typename Codecvt::state_type;

    explicit wbuffer_convert(std::streambuf* bytebuf = 0,
                             Codecvt* pcvt = new Codecvt,
                             state_type state = state_type());

    ~wbuffer_convert();

    wbuffer_convert(const wbuffer_convert&amp;) = delete;
    wbuffer_convert&amp; operator=(const wbuffer_convert&amp;) = delete;

    std::streambuf* rdbuf() const;
    std::streambuf* rdbuf(std::streambuf* bytebuf);

    state_type state() const;

  private:
    std::streambuf* bufptr;         <span class='comment'>// <i>exposition only</i>
</span>    Codecvt* cvtptr;                <span class='comment'>// <i>exposition only</i>
</span>    state_type cvtstate;            <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre></div><div class='para' id='conversions.buffer-3'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-3'>3</a></div><p >The class template describes a stream buffer that controls the
transmission of elements of type <span class='texttt'>Elem</span>, whose character traits are
described by the class <span class='texttt'>Tr</span>, to and from a byte stream buffer of type
<span class='texttt'>std::streambuf</span>. Conversion between a sequence of <span class='texttt'>Elem</span> values and
multibyte sequences is performed by an object of class
<span class='texttt'>Codecvt</span>, which shall meet the requirements
of the standard code-conversion facet <span class='texttt'>std::codecvt&lt;Elem, char, std::mbstate_t&gt;</span>.</p></div><div class='para' id='conversions.buffer-4'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-4'>4</a></div><p >An object of this class template stores:</p><ul class='itemize'><li id='conversions.buffer-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.buffer-4.1'>(4.1)</a></div><p ><span class='texttt'>bufptr</span> — a pointer to its underlying byte stream buffer
</p></li><li id='conversions.buffer-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.buffer-4.2'>(4.2)</a></div><p ><span class='texttt'>cvtptr</span> — a pointer to the allocated conversion object
(which is freed when the <span class='texttt'>wbuffer_convert</span> object is destroyed)
</p></li><li id='conversions.buffer-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conversions.buffer-4.3'>(4.3)</a></div><p ><span class='texttt'>cvtstate</span> — a conversion state object
</p></li></ul><p ><span class='indexparent'><a class='index' id='state,wbuffer_convert'></a></span><span class='indexparent'><a class='index' id='wbuffer_convert,state'></a></span><code class='itemdecl'>
state_type state() const;
</code></p></div><div class='itemdescr'></div><div class='para' id='conversions.buffer-5'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cvtstate</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='rdbuf,wbuffer_convert'></a></span><span class='indexparent'><a class='index' id='wbuffer_convert,rdbuf'></a></span><code class='itemdecl'>
std::streambuf* rdbuf() const;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.buffer-6'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>bufptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='rdbuf,wbuffer_convert'></a></span><span class='indexparent'><a class='index' id='wbuffer_convert,rdbuf'></a></span><code class='itemdecl'>
std::streambuf* rdbuf(std::streambuf* bytebuf);
</code></p><div class='itemdescr'></div><div class='para' id='conversions.buffer-7'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Stores <span class='texttt'>bytebuf</span> in <span class='texttt'>bufptr</span>.</p></div></div><div class='para' id='conversions.buffer-8'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The previous value of <span class='texttt'>bufptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='state_type,wbuffer_convert'></a></span><span class='indexparent'><a class='index' id='wbuffer_convert,state_type'></a></span><code class='itemdecl'>
using state_type = typename Codecvt::state_type;
</code></p><div class='itemdescr'></div><div class='para' id='conversions.buffer-9'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-9'>9</a></div><div class='itemdescr'><p >The type shall be a synonym for <span class='texttt'>Codecvt::state_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wbuffer_convert,constructor'></a></span><code class='itemdecl'>
explicit wbuffer_convert(std::streambuf* bytebuf = 0,
    Codecvt* pcvt = new Codecvt, state_type state = state_type());
</code></p><div class='itemdescr'></div><div class='para' id='conversions.buffer-10'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pcvt != nullptr</span>.</p></div></div><div class='para' id='conversions.buffer-11'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> The constructor constructs a stream buffer object, initializes
<span class='texttt'>bufptr</span> to <span class='texttt'>bytebuf</span>, initializes <span class='texttt'>cvtptr</span>
to <span class='texttt'>pcvt</span>, and initializes <span class='texttt'>cvtstate</span> to <span class='texttt'>state</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wbuffer_convert,destructor'></a></span><code class='itemdecl'>
~wbuffer_convert();
</code></p><div class='itemdescr'></div><div class='para' id='conversions.buffer-12'><div class='marginalizedparent'><a class='marginalized' href='#conversions.buffer-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> The destructor shall delete <span class='texttt'>cvtptr</span>.
</p></div></div></div></div></div></div><div id='locale.categories'><h2 ><a class='secnum' href='#locale.categories' style='min-width:88pt'>22.4</a> Standard <span class='texttt'>locale</span> categories <a class='abbr_ref' href='locale.categories'>[locale.categories]</a></h2><div class='para' id='locale.categories-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.categories-1'>1</a></div><p >Each of the standard categories includes a family of facets.
Some of these implement formatting or parsing of a datum, for use
by standard or users' iostream operators
<span class='texttt'>&lt;&lt;</span>
and
<span class='texttt'>&gt;&gt;</span>,
as members
<span class='texttt'>put()</span>
and
<span class='texttt'>get()</span>,
respectively.
Each such member function takes an
<span class='indexparent'><a class='index' id='flags,ios_base'></a></span><span class='texttt'>ios_base&amp;</span>
argument whose members
<span class='indexparent'><a class='index' id='flags,ios_base'></a></span><span class='texttt'>flags()</span>,
<span class='indexparent'><a class='index' id='precision,ios_base'></a></span><span class='texttt'>precision()</span>,
and
<span class='indexparent'><a class='index' id='width,ios_base'></a></span><span class='texttt'>width()</span>,
specify the format of the corresponding datum (<a href='ios.base'>[ios.base]</a>).
Those functions which need to use other facets call its member
<span class='texttt'>getloc()</span>
to retrieve the locale imbued there.
Formatting facets use the character argument
<span class='texttt'>fill</span>
to fill out the specified width where necessary.</p></div><div class='para' id='locale.categories-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.categories-2'>2</a></div><p >The
<span class='texttt'>put()</span>
members make no provision for error reporting.
(Any failures of the
OutputIterator argument must be extracted from the returned iterator.)
The
<span class='texttt'>get()</span>
members take an
<span class='texttt'>ios_base::iostate&amp;</span>
argument whose value they ignore, but set to
<span class='texttt'>ios_base::failbit</span>
in case of a parse error.</p></div><div class='para' id='locale.categories-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.categories-3'>3</a></div><p >Within this clause it is unspecified whether one virtual function calls another
virtual function.</p></div><div id='category.ctype'><h3 ><a class='secnum' href='#category.ctype' style='min-width:103pt'>22.4.1</a> The <span class='texttt'>ctype</span> category <a class='abbr_ref' href='category.ctype'>[category.ctype]</a></h3><p ><span class='indexparent'><a class='index' id='ctype_base'></a></span></p><pre class='codeblock'>
namespace std {
  class ctype_base {
  public:
    using mask = <i>T</i>;

    <span class='comment'>// numeric values are for exposition only.
</span>    static const mask space = 1 &lt;&lt; 0;
    static const mask print = 1 &lt;&lt; 1;
    static const mask cntrl = 1 &lt;&lt; 2;
    static const mask upper = 1 &lt;&lt; 3;
    static const mask lower = 1 &lt;&lt; 4;
    static const mask alpha = 1 &lt;&lt; 5;
    static const mask digit = 1 &lt;&lt; 6;
    static const mask punct = 1 &lt;&lt; 7;
    static const mask xdigit = 1 &lt;&lt; 8;
    static const mask blank = 1 &lt;&lt; 9;
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;
  };
}
</pre><div class='para' id='category.ctype-1'><div class='marginalizedparent'><a class='marginalized' href='#category.ctype-1'>1</a></div><p >The type
<span class='texttt'>mask</span>
is a bitmask type (<a href='bitmask.types'>[bitmask.types]</a>).</p></div><div id='locale.ctype'><h4 ><a class='secnum' href='#locale.ctype' style='min-width:118pt'>22.4.1.1</a> Class template <span class='texttt'>ctype</span> <a class='abbr_ref' href='locale.ctype'>[locale.ctype]</a></h4><p ><span class='indexparent'><a class='index' id='ctype'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class ctype : public locale::facet, public ctype_base {
  public:
    using char_type = charT;

    explicit ctype(size_t refs = 0);

    bool         is(mask m, charT c) const;
    const charT* is(const charT* low, const charT* high, mask* vec) const;
    const charT* scan_is(mask m,
                         const charT* low, const charT* high) const;
    const charT* scan_not(mask m,
                          const charT* low, const charT* high) const;
    charT        toupper(charT c) const;
    const charT* toupper(charT* low, const charT* high) const;
    charT        tolower(charT c) const;
    const charT* tolower(charT* low, const charT* high) const;

    charT        widen(char c) const;
    const char*  widen(const char* low, const char* high, charT* to) const;
    char         narrow(charT c, char dfault) const;
    const charT* narrow(const charT* low, const charT* high, char dfault,
                        char* to) const;

    static locale::id id;

  protected:
   ~ctype();
    virtual bool         do_is(mask m, charT c) const;
    virtual const charT* do_is(const charT* low, const charT* high,
                               mask* vec) const;
    virtual const charT* do_scan_is(mask m,
                                    const charT* low, const charT* high) const;
    virtual const charT* do_scan_not(mask m,
                                     const charT* low, const charT* high) const;
    virtual charT        do_toupper(charT) const;
    virtual const charT* do_toupper(charT* low, const charT* high) const;
    virtual charT        do_tolower(charT) const;
    virtual const charT* do_tolower(charT* low, const charT* high) const;
    virtual charT        do_widen(char) const;
    virtual const char*  do_widen(const char* low, const char* high,
                                  charT* dest) const;
    virtual char         do_narrow(charT, char dfault) const;
    virtual const charT* do_narrow(const charT* low, const charT* high,
                                   char dfault, char* dest) const;
  };
}
</pre><div class='para' id='locale.ctype-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype-1'>1</a></div><p >Class
<span class='texttt'>ctype</span>
encapsulates the C library
<span class='texttt'>&lt;cctype&gt;</span>
features.
<span class='texttt'>istream</span>
members are required to use
<span class='texttt'>ctype&lt;&gt;</span>
for character classing during input parsing.</p></div><div class='para' id='locale.ctype-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype-2'>2</a></div><p >The specializations required in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>ctype&lt;char&gt;</span>
and
<span class='texttt'>ctype&lt;wchar_t&gt;</span>,
implement character classing appropriate
to the implementation's native character set.</p></div><div id='locale.ctype.members'><h4 ><a class='secnum' href='#locale.ctype.members' style='min-width:133pt'>22.4.1.1.1</a> <span class='texttt'>ctype</span> members <a class='abbr_ref' href='locale.ctype.members'>[locale.ctype.members]</a></h4><p ><span class='indexparent'><a class='index' id='ctype,is'></a></span><span class='indexparent'><a class='index' id='is,ctype'></a></span><code class='itemdecl'>
bool         is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high,
                mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_is(m, c)</span>
or
<span class='texttt'>do_is(low, high, vec)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,scan_is'></a></span><span class='indexparent'><a class='index' id='scan_is,ctype'></a></span><code class='itemdecl'>
const charT* scan_is(mask m,
                     const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_scan_is(m, low, high)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,scan_not'></a></span><span class='indexparent'><a class='index' id='scan_not,ctype'></a></span><code class='itemdecl'>
const charT* scan_not(mask m,
                      const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_scan_not(m, low, high)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,toupper'></a></span><span class='indexparent'><a class='index' id='toupper,ctype'></a></span><code class='itemdecl'>
charT        toupper(charT) const;
const charT* toupper(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_toupper(c)</span>
or
<span class='texttt'>do_toupper(low, high)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,tolower'></a></span><span class='indexparent'><a class='index' id='tolower,ctype'></a></span><code class='itemdecl'>
charT        tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_tolower(c)</span>
or
<span class='texttt'>do_tolower(low, high)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,widen'></a></span><span class='indexparent'><a class='index' id='widen,ctype'></a></span><code class='itemdecl'>
charT       widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_widen(c)</span>
or
<span class='texttt'>do_widen(low, high, to)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,narrow'></a></span><span class='indexparent'><a class='index' id='narrow,ctype'></a></span><code class='itemdecl'>
char         narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT* high, char dfault,
                    char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_narrow(c, dfault)</span>
or
<span class='texttt'>do_narrow(low, high, dfault, to)</span>.
</p></div></div></div><div id='locale.ctype.virtuals'><h4 ><a class='secnum' href='#locale.ctype.virtuals' style='min-width:133pt'>22.4.1.1.2</a> <span class='texttt'>ctype</span> virtual functions <a class='abbr_ref' href='locale.ctype.virtuals'>[locale.ctype.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='ctype,do_is'></a></span><span class='indexparent'><a class='index' id='do_is,ctype'></a></span><code class='itemdecl'>
bool         do_is(mask m, charT c) const;
const charT* do_is(const charT* low, const charT* high,
                   mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Classifies a character or sequence of characters.
For each argument character, identifies a value
<span class='texttt'>M</span>
of type
<span class='texttt'>ctype_base::mask</span>.
The second form identifies a value <span class='texttt'>M</span> of type
<span class='texttt'>ctype_base::mask</span>
for each
<span class='texttt'>*p</span>
where
<span class='texttt'>(low&lt;=p &amp;&amp; p&lt;high)</span>,
and places it into
<span class='texttt'>vec[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the result of the expression
<span class='texttt'>(M &amp; m) != 0</span>;
i.e.,
<span class='texttt'>true</span>
if the character has the characteristics specified.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype_base,do_scan_is'></a></span><span class='indexparent'><a class='index' id='do_scan_is,ctype_base'></a></span><code class='itemdecl'>
const charT* do_scan_is(mask m,
                       const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Locates a character in a buffer that conforms to a classification
<span class='texttt'>m</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest pointer <span class='texttt'>p</span> in the range
<span class='texttt'>[low, high)</span>
such that
<span class='texttt'>is(m, *p)</span>
would return
<span class='texttt'>true</span>;
otherwise, returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_scan_not'></a></span><span class='indexparent'><a class='index' id='do_scan_not,ctype'></a></span><code class='itemdecl'>
const charT* do_scan_not(mask m,
                        const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Locates a character in a buffer that fails to conform to a classification
<span class='texttt'>m</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest pointer <span class='texttt'>p</span>, if any, in the range
<span class='texttt'>[low, high)</span>
such that
<span class='texttt'>is(m, *p)</span>
would return
<span class='texttt'>false</span>;
otherwise, returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_toupper'></a></span><span class='indexparent'><a class='index' id='do_toupper,ctype'></a></span><code class='itemdecl'>
charT        do_toupper(charT c) const;
const charT* do_toupper(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Converts a character or characters to upper case.
The second form replaces each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>
for which a corresponding upper-case character exists, with
that character.</p></div></div><div class='para' id='locale.ctype.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the corresponding upper-case character if it
is known to exist, or its argument if not.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_tolower'></a></span><span class='indexparent'><a class='index' id='do_tolower,ctype'></a></span><code class='itemdecl'>
charT        do_tolower(charT c) const;
const charT* do_tolower(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Converts a character or characters to lower case.
The second form replaces each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>
and for which a corresponding lower-case character exists,
with that character.</p></div></div><div class='para' id='locale.ctype.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the corresponding lower-case character if it
is known to exist, or its argument if not.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_widen'></a></span><span class='indexparent'><a class='index' id='do_widen,ctype'></a></span><code class='itemdecl'>
charT        do_widen(char c) const;
const char*  do_widen(const char* low, const char* high,
                      charT* dest) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Applies the simplest reasonable transformation from a
<span class='texttt'>char</span>
value or sequence of
<span class='texttt'>char</span>
values to the corresponding
<span class='texttt'>charT</span>
value or values.<a class='footnotenum' href='#footnote-234'>234</a>
The only characters for which unique transformations are required
are those in the basic source character set (<a href='lex.charset'>[lex.charset]</a>).</p><p >For any named
<span class='texttt'>ctype</span>
category with a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet <span class='texttt'>ctc</span> and valid
<span class='texttt'>ctype_base::mask</span>
value <span class='texttt'>M</span>,
<span class='texttt'>(ctc.is(M, c) || !is(M, do_widen(c)) )</span>
is
<span class='texttt'>true</span>.<a class='footnotenum' href='#footnote-235'>235</a></p><p >The second form transforms each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>,
placing the result in
<span class='texttt'>dest[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the transformed value.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_narrow'></a></span><span class='indexparent'><a class='index' id='do_narrow,ctype'></a></span><code class='itemdecl'>
char         do_narrow(charT c, char dfault) const;
const charT* do_narrow(const charT* low, const charT* high,
                       char dfault, char* dest) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Applies the simplest reasonable transformation from a
<span class='texttt'>charT</span>
value or sequence of
<span class='texttt'>charT</span>
values to the corresponding
<span class='texttt'>char</span>
value or values.</p><p >For any character <span class='texttt'>c</span> in the basic source character set (<a href='lex.charset'>[lex.charset]</a>)
the transformation is such that</p><pre class='codeblock'>
do_widen(do_narrow(c,0)) == c
</pre><p >For any named
<span class='texttt'>ctype</span>
category with a
<span class='texttt'>ctype&lt;char&gt;</span>
facet <span class='texttt'>ctc</span> however, and
<span class='texttt'>ctype_base::mask</span>
value <span class='texttt'>M</span>,</p><pre class='codeblock'>
(is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )
</pre><p >is
<span class='texttt'>true</span>
(unless
<span class='texttt'>do_narrow</span>
returns
<span class='texttt'>dfault</span>).
In addition, for any digit character <span class='texttt'>c</span>,
the expression
<span class='texttt'>(do_narrow(c, dfault) - '0')</span>
evaluates to the digit value of the character.
The second form transforms each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>,
placing the result (or <span class='texttt'>dfault</span>
if no simple transformation is readily available) in
<span class='texttt'>dest[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the transformed value; or <span class='texttt'>dfault</span>
if no mapping is readily available.
The second form returns <span class='texttt'>high</span>.
</p></div></div><div class='footnote' id='footnote-234'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-234'>234)</a></div><p >The char argument of
<span class='texttt'>do_widen</span>
is intended to accept values derived from character literals for conversion
to the locale's encoding.</p></div><div class='footnote' id='footnote-235'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-235'>235)</a></div><p >In other words, the transformed character is not a member
of any character classification that <span class='texttt'>c</span> is not also a member of.</p></div></div></div><div id='locale.ctype.byname'><h4 ><a class='secnum' href='#locale.ctype.byname' style='min-width:118pt'>22.4.1.2</a> Class template <span class='texttt'>ctype_byname</span> <a class='abbr_ref' href='locale.ctype.byname'>[locale.ctype.byname]</a></h4><p ><span class='indexparent'><a class='index' id='ctype_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class ctype_byname : public ctype&lt;charT&gt; {
  public:
    using mask = typename ctype&lt;charT&gt;::mask;
    explicit ctype_byname(const char*, size_t refs = 0);
    explicit ctype_byname(const string&amp;, size_t refs = 0);
  protected:
   ~ctype_byname();
  };
}
</pre></div><div id='facet.ctype.special'><h4 ><a class='secnum' href='#facet.ctype.special' style='min-width:118pt'>22.4.1.3</a> <span class='texttt'>ctype</span> specializations <a class='abbr_ref' href='facet.ctype.special'>[facet.ctype.special]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;&gt; class ctype&lt;char&gt;
    : public locale::facet, public ctype_base {
  public:
    using char_type = char;

    explicit ctype(const mask* tab = 0, bool del = false,
                   size_t refs = 0);

    bool is(mask m, char c) const;
    const char* is(const char* low, const char* high, mask* vec) const;
    const char* scan_is (mask m,
                         const char* low, const char* high) const;
    const char* scan_not(mask m,
                         const char* low, const char* high) const;

    char        toupper(char c) const;
    const char* toupper(char* low, const char* high) const;
    char        tolower(char c) const;
    const char* tolower(char* low, const char* high) const;

    char  widen(char c) const;
    const char* widen(const char* low, const char* high, char* to) const;
    char  narrow(char c, char dfault) const;
    const char* narrow(const char* low, const char* high, char dfault,
                       char* to) const;

    static locale::id id;
    static const size_t table_size = <i>implementation-defined</i>;

    const mask* table() const noexcept;
    static const mask* classic_table() noexcept;

  protected:
   ~ctype();
    virtual char        do_toupper(char c) const;
    virtual const char* do_toupper(char* low, const char* high) const;
    virtual char        do_tolower(char c) const;
    virtual const char* do_tolower(char* low, const char* high) const;

    virtual char        do_widen(char c) const;
    virtual const char* do_widen(const char* low,
                                 const char* high,
                                 char* to) const;
    virtual char        do_narrow(char c, char dfault) const;
    virtual const char* do_narrow(const char* low,
                                  const char* high,
                                  char dfault, char* to) const;
  };
}
</pre><div class='para' id='facet.ctype.special-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.special-1'>1</a></div><p >A specialization
<span class='texttt'>ctype&lt;char&gt;</span>
is provided so that the member functions on type
<span class='texttt'>char</span>
can be implemented
<span class='texttt'>inline</span>.<a class='footnotenum' href='#footnote-236'>236</a>
The <span class='indexparent'><a class='index' id='value_of_ctype<char>::table_size'></a></span>implementation-defined value of member
<span class='texttt'>table_size</span>
is at least 256.</p></div><div class='footnote' id='footnote-236'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-236'>236)</a></div><p >Only the
<span class='texttt'>char</span>
(not
<span class='texttt'>unsigned char</span>
and
<span class='texttt'>signed char</span>)
form is provided.
The specialization is specified in the standard, and not left as an
implementation detail, because it affects the derivation interface for
<span class='texttt'>ctype&lt;char&gt;</span>.</p></div><div id='facet.ctype.char.dtor'><h4 ><a class='secnum' href='#facet.ctype.char.dtor' style='min-width:133pt'>22.4.1.3.1</a> <span class='texttt'>ctype&lt;char&gt;</span> destructor <a class='abbr_ref' href='facet.ctype.char.dtor'>[facet.ctype.char.dtor]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,destructor'></a></span><code class='itemdecl'>
~ctype();
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
If the constructor's first argument was nonzero, and its second argument
was <span class='texttt'>true</span>, does
<span class='texttt'>delete [] table()</span>.
</p></div></div></div><div id='facet.ctype.char.members'><h4 ><a class='secnum' href='#facet.ctype.char.members' style='min-width:133pt'>22.4.1.3.2</a> <span class='texttt'>ctype&lt;char&gt;</span> members <a class='abbr_ref' href='facet.ctype.char.members'>[facet.ctype.char.members]</a></h4><div class='para' id='facet.ctype.char.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ctype<char>,ctype<char>'></a></span>In the following member descriptions, for
<span class='texttt'>unsigned char</span>
values <span class='texttt'>v</span> where <span class='texttt'>v &gt;= table_size</span>,
<span class='texttt'>table()[v]</span> is assumed to have an
implementation-specific value (possibly different for each
such value <span class='texttt'>v</span>) without performing the array lookup.</p><p ><span class='indexparent'><a class='index' id='ctype<char>,constructor'></a></span><code class='itemdecl'>
explicit ctype(const mask* tbl = 0, bool del = false,
               size_t refs = 0);
</code></p></div><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>tbl</span> either 0 or an array of at least
<span class='texttt'>table_size</span>
elements.</p></div></div><div class='para' id='facet.ctype.char.members-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Passes its <span class='texttt'>refs</span> argument to its base class constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,is'></a></span><span class='indexparent'><a class='index' id='is,ctype<char>'></a></span><code class='itemdecl'>
bool        is(mask m, char c) const;
const char* is(const char* low, const char* high,
               mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
The second form, for all
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>,
assigns
into
<span class='texttt'>vec[p-low]</span>
the value
<span class='texttt'>table()[&nbsp;(unsigned char)*p]</span>.</p></div></div><div class='para' id='facet.ctype.char.members-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns
<span class='texttt'>table()[(unsigned char)c] &amp; m</span>;
the second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,scan_is'></a></span><span class='indexparent'><a class='index' id='scan_is,ctype<char>'></a></span><code class='itemdecl'>
const char* scan_is(mask m,
                    const char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest
<span class='texttt'>p</span>
in the range
<span class='texttt'>[low, high)</span>
such that
</p><pre class='codeblock'>
table()[(unsigned char) *p] &amp; m
</pre><p >is
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,scan_not'></a></span><span class='indexparent'><a class='index' id='scan_not,ctype<char>'></a></span><code class='itemdecl'>
const char* scan_not(mask m,
                     const char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-7'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest
<span class='texttt'>p</span>
in the range
<span class='texttt'>[low, high)</span>
such that
</p><pre class='codeblock'>
table()[(unsigned char) *p] &amp; m
</pre><p >is
<span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,toupper'></a></span><span class='indexparent'><a class='index' id='toupper,ctype<char>'></a></span><code class='itemdecl'>
char        toupper(char c) const;
const char* toupper(char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-8'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_toupper(c)</span>
or
<span class='texttt'>do_toupper(low, high)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,tolower'></a></span><span class='indexparent'><a class='index' id='tolower,ctype<char>'></a></span><code class='itemdecl'>
char        tolower(char c) const;
const char* tolower(char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-9'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_tolower(c)</span>
or
<span class='texttt'>do_tolower(low, high)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,widen'></a></span><span class='indexparent'><a class='index' id='widen,ctype<char>'></a></span><code class='itemdecl'>
char  widen(char c) const;
const char* widen(const char* low, const char* high,
    char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-10'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_widen(c)</span>
or
<span class='indexparent'><a class='index' id='do_widen'></a></span><span class='texttt'>do_widen(low, high, to)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,narrow'></a></span><span class='indexparent'><a class='index' id='narrow,ctype<char>'></a></span><code class='itemdecl'>
char        narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high,
                   char dfault, char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-11'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='indexparent'><a class='index' id='do_narrow'></a></span><span class='texttt'>do_narrow(c, dfault)</span>
or
<span class='indexparent'><a class='index' id='do_narrow'></a></span><span class='texttt'>do_narrow(low, high, dfault, to)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,table'></a></span><span class='indexparent'><a class='index' id='table,ctype<char>'></a></span><code class='itemdecl'>
const mask* table() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-12'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first constructor argument, if it was non-zero, otherwise
<span class='texttt'>classic_table()</span>.
</p></div></div></div><div id='facet.ctype.char.statics'><h4 ><a class='secnum' href='#facet.ctype.char.statics' style='min-width:133pt'>22.4.1.3.3</a> <span class='texttt'>ctype&lt;char&gt;</span> static members <a class='abbr_ref' href='facet.ctype.char.statics'>[facet.ctype.char.statics]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,classic_table'></a></span><span class='indexparent'><a class='index' id='classic_table,ctype<char>'></a></span><code class='itemdecl'>
static const mask* classic_table() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.statics-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.statics-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to the initial element of an array of size
<span class='texttt'>table_size</span>
which represents the classifications of characters in the <span class='texttt'>"C"</span> locale.
</p></div></div></div><div id='facet.ctype.char.virtuals'><h4 ><a class='secnum' href='#facet.ctype.char.virtuals' style='min-width:133pt'>22.4.1.3.4</a> <span class='texttt'>ctype&lt;char&gt;</span> virtual functions <a class='abbr_ref' href='facet.ctype.char.virtuals'>[facet.ctype.char.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,do_toupper'></a></span><span class='indexparent'><a class='index' id='do_toupper,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_tolower'></a></span><span class='indexparent'><a class='index' id='do_tolower,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_widen'></a></span><span class='indexparent'><a class='index' id='do_widen,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_narrow'></a></span><span class='indexparent'><a class='index' id='do_narrow,ctype<char>'></a></span></p><pre class='codeblock'>
char        do_toupper(char) const;
const char* do_toupper(char* low, const char* high) const;
char        do_tolower(char) const;
const char* do_tolower(char* low, const char* high) const;

virtual char        do_widen(char c) const;
virtual const char* do_widen(const char* low,
                             const char* high,
                             char* to) const;
virtual char        do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low,
                              const char* high,
                              char dfault, char* to) const;
</pre><p >These functions are described identically as those members of the
same name in the
<span class='texttt'>ctype</span>
class template (<a href='locale.ctype.members'>[locale.ctype.members]</a>).</p></div></div><div id='locale.codecvt'><h4 ><a class='secnum' href='#locale.codecvt' style='min-width:118pt'>22.4.1.4</a> Class template <span class='texttt'>codecvt</span> <a class='abbr_ref' href='locale.codecvt'>[locale.codecvt]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt'></a></span></p><pre class='codeblock'>
namespace std {
  class codecvt_base {
  public:
    enum result { ok, partial, error, noconv };
  };

  template &lt;class internT, class externT, class stateT&gt;
  class codecvt : public locale::facet, public codecvt_base {
  public:
    using intern_type = internT;
    using extern_type = externT;
    using state_type  = stateT;

    explicit codecvt(size_t refs = 0);

    result out(stateT&amp; state,
               const internT* from, const internT* from_end, const internT*&amp; from_next,
               externT*   to,       externT* to_end, externT*&amp; to_next) const;
    result unshift(stateT&amp; state,
                   externT*   to,        externT* to_end, externT*&amp; to_next) const;
    result in(stateT&amp; state,
              const externT* from, const externT* from_end, const externT*&amp; from_next,
              internT*   to,       internT* to_end, internT*&amp; to_next) const;
    int encoding() const noexcept;
    bool always_noconv() const noexcept;
    int length(stateT&amp;, const externT* from, const externT* end,
               size_t max) const;
    int max_length() const noexcept;

    static locale::id id;

  protected:
    ~codecvt();
    virtual result do_out(stateT&amp; state,
                          const internT* from, const internT* from_end, const internT*&amp; from_next,
                          externT* to,         externT* to_end, externT*&amp; to_next) const;
    virtual result do_in(stateT&amp; state,
                         const externT* from, const externT* from_end, const externT*&amp; from_next,
                         internT* to,         internT* to_end, internT*&amp; to_next) const;
    virtual result do_unshift(stateT&amp; state,
                              externT* to,         externT* to_end, externT*&amp; to_next) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(stateT&amp;, const externT* from,
                          const externT* end, size_t max) const;
    virtual int do_max_length() const noexcept;
  };
}
</pre><div class='para' id='locale.codecvt-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-1'>1</a></div><p >The class
<span class='texttt'>codecvt&lt;internT,externT,stateT&gt;</span>
is for use when
converting from one character encoding to another, such as from wide characters
to multibyte  characters or between wide character encodings such as
Unicode and EUC.</p></div><div class='para' id='locale.codecvt-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-2'>2</a></div><p >The
<span class='texttt'>stateT</span>
argument selects the pair of character encodings being mapped between.</p></div><div class='para' id='locale.codecvt-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-3'>3</a></div><p >The specializations required in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>)
convert the implementation-defined native character set.
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>
implements a degenerate conversion;
it does not convert at all.
The specialization <span class='texttt'>codecvt&lt;char16_t,</span> <span class='texttt'>char, mbstate_t&gt;</span>
converts between the UTF-16 and UTF-8 encoding forms, and
the specialization <span class='texttt'>codecvt</span> <span class='texttt'>&lt;char32_t, char, mbstate_t&gt;</span>
converts between the UTF-32 and UTF-8 encoding forms.
<span class='texttt'>codecvt&lt;wchar_t,char,mbstate_t&gt;</span>
converts between the native character sets for narrow and wide characters.
Specializations on
<span class='texttt'>mbstate_t</span>
perform conversion between encodings known to the library implementer.
Other encodings can be converted by specializing on a user-defined
<span class='texttt'>stateT</span>
type.
Objects of type
<span class='texttt'>stateT</span>
can contain any state that is useful to communicate to or from
the specialized
<span class='texttt'>do_in</span>
or
<span class='texttt'>do_out</span>
members.</p></div><div id='locale.codecvt.members'><h4 ><a class='secnum' href='#locale.codecvt.members' style='min-width:133pt'>22.4.1.4.1</a> <span class='texttt'>codecvt</span> members <a class='abbr_ref' href='locale.codecvt.members'>[locale.codecvt.members]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt,out'></a></span><span class='indexparent'><a class='index' id='out,codecvt'></a></span><code class='itemdecl'>
result out(stateT&amp; state,
  const internT* from, const internT* from_end, const internT*&amp; from_next,
        externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_out(state, from, from_end, from_next, to, to_end, to_next)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,unshift'></a></span><span class='indexparent'><a class='index' id='unshift,codecvt'></a></span><code class='itemdecl'>
result unshift(stateT&amp; state,
        externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_unshift(state, to, to_end, to_next)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,in'></a></span><span class='indexparent'><a class='index' id='in,codecvt'></a></span><code class='itemdecl'>
result in(stateT&amp; state,
  const externT* from, const externT* from_end, const externT*&amp; from_next,
        internT* to, internT* to_end, internT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_in(state, from, from_end, from_next, to, to_end, to_next)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,encoding'></a></span><span class='indexparent'><a class='index' id='encoding,codecvt'></a></span><code class='itemdecl'>
int encoding() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_encoding()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,always_noconv'></a></span><span class='indexparent'><a class='index' id='always_noconv,codecvt'></a></span><code class='itemdecl'>
bool always_noconv() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_always_noconv()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,length'></a></span><span class='indexparent'><a class='index' id='length,codecvt'></a></span><code class='itemdecl'>
int length(stateT&amp; state, const externT* from, const externT* from_end,
           size_t max) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_length(state, from, from_end, max)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,max_length'></a></span><span class='indexparent'><a class='index' id='max_length,codecvt'></a></span><code class='itemdecl'>
int max_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_max_length()</span>.
</p></div></div></div><div id='locale.codecvt.virtuals'><h4 ><a class='secnum' href='#locale.codecvt.virtuals' style='min-width:133pt'>22.4.1.4.2</a> <span class='texttt'>codecvt</span> virtual functions <a class='abbr_ref' href='locale.codecvt.virtuals'>[locale.codecvt.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt,do_out'></a></span><span class='indexparent'><a class='index' id='do_out,codecvt'></a></span><span class='indexparent'><a class='index' id='codecvt,do_in'></a></span><span class='indexparent'><a class='index' id='do_in,codecvt'></a></span><code class='itemdecl'>
result do_out(stateT&amp; state,
  const internT* from, const internT* from_end, const internT*&amp; from_next,
  externT* to, externT* to_end, externT*&amp; to_next) const;

result do_in(stateT&amp; state,
  const externT* from, const externT* from_end, const externT*&amp; from_next,
        internT* to, internT* to_end, internT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(from&lt;=from_end &amp;&amp; to&lt;=to_end)</span>
well-defined and
<span class='texttt'>true</span>;
<span class='texttt'>state</span> initialized, if at the beginning of a sequence, or else equal to
the result of converting the preceding characters in the sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Translates characters in the source range
<span class='texttt'>[from, from_end)</span>,
placing the results in sequential positions starting at destination <span class='texttt'>to</span>.
Converts no more than
<span class='texttt'>(from_end-from)</span>
source elements, and
stores no more than
<span class='texttt'>(to_end-to)</span>
destination elements.</p><p >Stops if it encounters a character it cannot convert.
It always leaves the <span class='texttt'>from_next</span> and <span class='texttt'>to_next</span> pointers
pointing one beyond the last element successfully converted.
If returns
<span class='texttt'>noconv</span>,
<span class='texttt'>internT</span>
and
<span class='texttt'>externT</span>
are the same type and the converted sequence is
identical to the input sequence
<span class='texttt'>[from, from_next)</span>.
<span class='texttt'>to_next</span> is set equal to <span class='texttt'>to</span>, the value of <span class='texttt'>state</span> is
unchanged, and there are no changes to the values in
<span class='texttt'>[to, to_end)</span>.</p></div></div><div class='para' id='locale.codecvt.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-3'>3</a></div><div class='itemdescr'><p >A
<span class='texttt'>codecvt</span>
facet that is used by
<span class='texttt'>basic_filebuf</span> (<a href='file.streams'>[file.streams]</a>) shall have the property that if
</p><pre class='codeblock'>
do_out(state, from, from_end, from_next, to, to_end, to_next)
</pre><p >would return
<span class='texttt'>ok</span>,
where
<span class='texttt'>from != from_end</span>,
then
</p><pre class='codeblock'>
do_out(state, from, from + 1, from_next, to, to_end, to_next)
</pre><p >shall also return
<span class='texttt'>ok</span>,
and that if
</p><pre class='codeblock'>
do_in(state, from, from_end, from_next, to, to_end, to_next)
</pre><p >would return
<span class='texttt'>ok</span>,
where
<span class='texttt'>to != to_end</span>,
then
</p><pre class='codeblock'>
do_in(state, from, from_end, from_next, to, to + 1, to_next)
</pre><p >shall also return
<span class='texttt'>ok</span>.<a class='footnotenum' href='#footnote-237'>237</a>
[&nbsp;<i>Note:</i> As a result of operations on <span class='texttt'>state</span>, it can return <span class='texttt'>ok</span> or <span class='texttt'>partial</span> and set <span class='texttt'>from_next == from</span> and <span class='texttt'>to_next != to</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.codecvt.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Its operations on <span class='texttt'>state</span> are unspecified.
[&nbsp;<i>Note:</i>
This argument can be used, for example, to maintain
shift state, to specify conversion options (such as count only), or to
identify a cache of seek offsets.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.codecvt.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value, as summarized in Table <a href='#tab:localization.convert.result.values.out.in'>[tab:localization.convert.result.values.out.in]</a>.</p><div class='numberedTable' id='tab:localization.convert.result.values.out.in'>Table <a href='#tab:localization.convert.result.values.out.in'>66</a> — <span class='texttt'>do_in/do_out</span> result values<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Value</b></td><td colspan='1' class='center'><b>Meaning</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ok</span>                  </td><td class='justify'>   completed the conversion            </td></tr><tr ><td class='left'>
<span class='texttt'>partial</span>             </td><td class='justify'>   not all source characters converted </td></tr><tr ><td class='left'>
<span class='texttt'>error</span>               </td><td class='justify'>
encountered a character in <span class='texttt'>[from, from_end)</span>
that it could not convert                                           </td></tr><tr ><td class='left'>
<span class='texttt'>noconv</span>              </td><td class='justify'>
<span class='texttt'>internT</span> and <span class='texttt'>externT</span> are the same type, and input
sequence is identical to converted sequence                         </td></tr></table></div><p >A return value of
<span class='texttt'>partial</span>,
if
<span class='texttt'>(from_next==from_end)</span>,
indicates that either the destination sequence has not absorbed all the
available destination elements, or that additional source elements are
needed before another destination element can be produced.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_unshift'></a></span><span class='indexparent'><a class='index' id='do_unshift,codecvt'></a></span><code class='itemdecl'>
result do_unshift(stateT&amp; state,
  externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(to &lt;= to_end)</span>
well defined and <span class='texttt'>true</span>; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the
sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Places characters starting at <span class='texttt'>to</span> that should be appended
to terminate a sequence when the current
<span class='texttt'>stateT</span>
is given by <span class='texttt'>state</span>.<a class='footnotenum' href='#footnote-238'>238</a>
Stores no more than
<span class='texttt'>(to_end-to)</span>
destination elements, and leaves the <span class='texttt'>to_next</span> pointer
pointing one beyond the last element successfully stored.</p></div></div><div class='para' id='locale.codecvt.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value, as summarized in Table <a href='#tab:localization.convert.result.values.unshift'>[tab:localization.convert.result.values.unshift]</a>.</p><div class='numberedTable' id='tab:localization.convert.result.values.unshift'>Table <a href='#tab:localization.convert.result.values.unshift'>67</a> — <span class='texttt'>do_unshift</span> result values<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Value</b></td><td colspan='1' class='center'><b>Meaning</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ok</span>                  </td><td class='justify'>   completed the sequence                                  </td></tr><tr ><td class='left'>
<span class='texttt'>partial</span>             </td><td class='justify'>
space for more than <span class='texttt'>to_end-to</span> destination elements was needed
to terminate a sequence given the value of <span class='texttt'>state</span></td></tr><tr ><td class='left'>
<span class='texttt'>error</span>               </td><td class='justify'>   an unspecified error has occurred </td></tr><tr ><td class='left'>
<span class='texttt'>noconv</span>              </td><td class='justify'>   no termination is needed for this <span class='texttt'>state_type</span>    </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_encoding'></a></span><span class='indexparent'><a class='index' id='do_encoding,codecvt'></a></span><code class='itemdecl'>
int do_encoding() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>-1</span> if the encoding of the <span class='texttt'>externT</span> sequence is state-dependent; else the
constant number of <span class='texttt'>externT</span> characters needed to produce an internal
character; or <span class='texttt'>0</span> if this number is not a constant.<a class='footnotenum' href='#footnote-239'>239</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_always_noconv'></a></span><span class='indexparent'><a class='index' id='do_always_noconv,codecvt'></a></span><code class='itemdecl'>
bool do_always_noconv() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if
<span class='texttt'>do_in()</span>
and
<span class='texttt'>do_out()</span>
return
<span class='texttt'>noconv</span>
for all valid argument values.
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>
returns
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_length'></a></span><span class='indexparent'><a class='index' id='do_length,codecvt'></a></span><code class='itemdecl'>
int do_length(stateT&amp; state, const externT* from, const externT* from_end,
              size_t max) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(from&lt;=from_end)</span>
well-defined and
<span class='texttt'>true</span>;
<span class='texttt'>state</span> initialized, if at the beginning of a sequence, or else equal to
the result of converting the preceding characters in the sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
The effect on the <span class='texttt'>state</span> argument is “as if” it called
<span class='texttt'>do_in(state, from, from_end, from, to, to+max, to)</span>
for <span class='texttt'>to</span> pointing to a buffer of at least <span class='texttt'>max</span> elements.</p></div></div><div class='para' id='locale.codecvt.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>(from_next-from)</span>
where
<span class='texttt'>from_next</span>
is the largest value in the range
<span class='texttt'>[from, from_end]</span>
such that the sequence of values in the range
<span class='texttt'>[from, from_next)</span>
represents
<span class='texttt'>max</span>
or fewer valid complete characters of type
<span class='texttt'>internT</span>.
The specialization
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>,
returns the lesser of
<span class='texttt'>max</span>
and
<span class='texttt'>(from_end-from)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_max_length'></a></span><span class='indexparent'><a class='index' id='do_max_length,codecvt'></a></span><code class='itemdecl'>
int do_max_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The maximum value that
<span class='texttt'>do_length(state, from, from_end, 1)</span>
can return for any valid range
<span class='texttt'>[from, from_end)</span>
and
<span class='texttt'>stateT</span>
value
<span class='texttt'>state</span>.
The specialization
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;::do_max_length()</span>
returns 1.
</p></div></div><div class='footnote' id='footnote-237'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-237'>237)</a></div><p >Informally, this means that
<span class='texttt'>basic_filebuf</span>
assumes that the mappings from internal to external characters is
1 to N: a
<span class='texttt'>codecvt</span>
facet that is used by
<span class='texttt'>basic_filebuf</span>
must be able to translate characters one internal character at a time.
</p></div><div class='footnote' id='footnote-238'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-238'>238)</a></div><p >Typically these will be characters to return the state to
<span class='texttt'>stateT()</span>.</p></div><div class='footnote' id='footnote-239'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-239'>239)</a></div><p >If <span class='texttt'>encoding()</span>
yields <span class='texttt'>-1</span>, then more than <span class='texttt'>max_length()</span> <span class='texttt'>externT</span> elements
may be consumed when producing a single <span class='texttt'>internT</span> character, and additional
<span class='texttt'>externT</span> elements may appear at the end of a sequence after those that
yield the final <span class='texttt'>internT</span> character.</p></div></div></div><div id='locale.codecvt.byname'><h4 ><a class='secnum' href='#locale.codecvt.byname' style='min-width:118pt'>22.4.1.5</a> Class template <span class='texttt'>codecvt_byname</span> <a class='abbr_ref' href='locale.codecvt.byname'>[locale.codecvt.byname]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class internT, class externT, class stateT&gt;
  class codecvt_byname : public codecvt&lt;internT, externT, stateT&gt; {
  public:
    explicit codecvt_byname(const char*, size_t refs = 0);
    explicit codecvt_byname(const string&amp;, size_t refs = 0);
  protected:
    ~codecvt_byname();
  };
}
</pre></div></div><div id='category.numeric'><h3 ><a class='secnum' href='#category.numeric' style='min-width:103pt'>22.4.2</a> The numeric category <a class='abbr_ref' href='category.numeric'>[category.numeric]</a></h3><div class='para' id='category.numeric-1'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-1'>1</a></div><p >The classes
<span class='texttt'>num_get&lt;&gt;</span>
and
<span class='texttt'>num_put&lt;&gt;</span>
handle numeric formatting and parsing.
Virtual functions are provided for several numeric types.
Implementations may (but are not required to) delegate extraction
of smaller types to extractors for larger types.<a class='footnotenum' href='#footnote-240'>240</a></p></div><div class='para' id='category.numeric-2'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-2'>2</a></div><p >All specifications of member functions for
<span class='texttt'>num_put</span>
and
<span class='texttt'>num_get</span>
in the subclauses of <a href='category.numeric'>[category.numeric]</a> only apply to the
specializations required in Tables <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>num_get&lt;char&gt;</span>,
<span class='texttt'>num_get&lt;wchar_t&gt;</span>,
<span class='texttt'>num_get&lt;C, InputIterator&gt;</span>,
<span class='texttt'>num_put&lt;char&gt;</span>,
<span class='texttt'>num_put&lt;wchar_t&gt;</span>,
and
<span class='texttt'>num_put&lt;C,OutputIterator&gt;</span>.
These specializations refer to the
<span class='texttt'>ios_base&amp;</span>
argument for formatting specifications (<a href='locale.categories'>[locale.categories]</a>),
and to its imbued locale for the
<span class='texttt'>numpunct&lt;&gt;</span>
facet to identify all numeric punctuation preferences,
and also for the
<span class='texttt'>ctype&lt;&gt;</span>
facet to perform character classification.</p></div><div class='para' id='category.numeric-3'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-3'>3</a></div><p >Extractor and inserter members of the standard iostreams use
<span class='texttt'>num_get&lt;&gt;</span>
and
<span class='texttt'>num_put&lt;&gt;</span>
member functions for formatting and parsing numeric values (<a href='istream.formatted.reqmts'>[istream.formatted.reqmts]</a>, <a href='ostream.formatted.reqmts'>[ostream.formatted.reqmts]</a>).</p></div><div class='footnote' id='footnote-240'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-240'>240)</a></div><p >Parsing
<span class='texttt'>"-1"</span> correctly into, e.g., an
<span class='texttt'>unsigned short</span>
requires that the corresponding member
<span class='texttt'>get()</span>
at least extract the sign before delegating.</p></div><div id='locale.num.get'><h4 ><a class='secnum' href='#locale.num.get' style='min-width:118pt'>22.4.2.1</a> Class template <span class='texttt'>num_get</span> <a class='abbr_ref' href='locale.num.get'>[locale.num.get]</a></h4><p ><span class='indexparent'><a class='index' id='num_get'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
  class num_get : public locale::facet {
  public:
    using char_type = charT;
    using iter_type = InputIterator;

    explicit num_get(size_t refs = 0);

    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, bool&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned short&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned int&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned long long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, float&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, double&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long double&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, void*&amp; v) const;

    static locale::id id;

  protected:
    ~num_get();
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, bool&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned short&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned int&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned long long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, float&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, double&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long double&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, void*&amp; v) const;
  };
}
</pre><div class='para' id='locale.num.get-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.num.get-1'>1</a></div><p >The facet
<span class='texttt'>num_get</span>
is used to parse numeric values from an input sequence such as an istream.</p></div><div id='facet.num.get.members'><h4 ><a class='secnum' href='#facet.num.get.members' style='min-width:133pt'>22.4.2.1.1</a> <span class='texttt'>num_get</span> members <a class='abbr_ref' href='facet.num.get.members'>[facet.num.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='num_get,get'></a></span><span class='indexparent'><a class='index' id='get,num_get'></a></span><code class='itemdecl'>
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, bool&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned short&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned int&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, float&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, double&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long double&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, void*&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(in, end, str, err, val)</span>.
</p></div></div></div><div id='facet.num.get.virtuals'><h4 ><a class='secnum' href='#facet.num.get.virtuals' style='min-width:133pt'>22.4.2.1.2</a> <span class='texttt'>num_get</span> virtual functions <a class='abbr_ref' href='facet.num.get.virtuals'>[facet.num.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='num_get,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,num_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned short&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned int&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, float&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, double&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long double&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, void*&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters from <span class='texttt'>in</span>,
interpreting them according to
<span class='texttt'>str.flags()</span>,
<span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(loc)</span>,
and
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt;&gt;(loc)</span>,
where
<span class='texttt'>loc</span>
is
<span class='texttt'>str.getloc()</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-2'>2</a></div><div class='itemdescr'><p >The details of this operation occur in three stages</p><ul class='itemize'><li id='facet.num.get.virtuals-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.get.virtuals-2.1'>(2.1)</a></div><p >Stage 1:
Determine a conversion specifier
</p></li><li id='facet.num.get.virtuals-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.get.virtuals-2.2'>(2.2)</a></div><p >Stage 2: Extract characters from <span class='texttt'>in</span> and determine a corresponding
<span class='texttt'>char</span>
value for the format expected by the conversion specification determined
in stage 1.
</p></li><li id='facet.num.get.virtuals-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.get.virtuals-2.3'>(2.3)</a></div><p >Stage 3:
Store results
</p></li></ul></div></div><div class='para' id='facet.num.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-3'>3</a></div><div class='itemdescr'><p >The details of the stages are presented below.</p><ul class='description'><li ><p >The function initializes local variables via</p><pre class='codeblock'>
fmtflags flags = str.flags();
fmtflags basefield = (flags &amp; ios_base::basefield);
fmtflags uppercase = (flags &amp; ios_base::uppercase);
fmtflags boolalpha = (flags &amp; ios_base::boolalpha);
</pre><p >For conversion to an integral type, the
function determines the integral conversion specifier as indicated in
Table <a href='#tab:localization.integer.conversions.in'>[tab:localization.integer.conversions.in]</a>.
The table is ordered.
That is, the first line whose condition is true applies.</p><div class='numberedTable' id='tab:localization.integer.conversions.in'>Table <a href='#tab:localization.integer.conversions.in'>68</a> — Integer conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent   </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>basefield == oct</span>        </td><td class='center'>   <span class='texttt'>%o</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>basefield == hex</span>        </td><td class='center'>   <span class='texttt'>%X</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>basefield == 0</span>          </td><td class='center'>   <span class='texttt'>%i</span>                 </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>signed</span> integral type    </td><td class='center'>   <span class='texttt'>%d</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned</span> integral type  </td><td class='center'>   <span class='texttt'>%u</span>                 </td></tr></table></div><p >For conversions to a  floating type the specifier is
<span class='texttt'>%g</span>.</p><p >For conversions to
<span class='texttt'>void*</span>
the specifier is
<span class='texttt'>%p</span>.</p><p >A length modifier is added to the conversion specification, if needed,
as indicated in Table <a href='#tab:localization.length.modifier.in'>[tab:localization.length.modifier.in]</a>.</p><div class='numberedTable' id='tab:localization.length.modifier.in'>Table <a href='#tab:localization.length.modifier.in'>69</a> — Length modifier<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td class='center'>   Length modifier </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>short</span>               </td><td class='center'>   <span class='texttt'>h</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned short</span>      </td><td class='center'>   <span class='texttt'>h</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long</span>                </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long</span>       </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long long</span>           </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long long</span>  </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>double</span>              </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long double</span>         </td><td class='center'>   <span class='texttt'>L</span>       </td></tr></table></div></li><li ><p >If
<span class='texttt'>in==end</span>
then stage 2 terminates.
Otherwise a
<span class='texttt'>charT</span>
is taken from <span class='texttt'>in</span> and local variables are initialized as if by</p><pre class='codeblock'>
char_type ct = *in;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct == use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).decimal_point())
c = '.';
bool discard =
  ct == use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).thousands_sep()
  &amp;&amp; use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).grouping().length() != 0;
</pre><p >where the values
<span class='texttt'>src</span>
and
<span class='texttt'>atoms</span>
are defined as if by:</p><pre class='codeblock'>
static const char src[] = "0123456789abcdefxABCDEFX+-";
char_type atoms[sizeof(src)];
use_facet&lt;ctype&lt;charT&gt;&gt;(loc).widen(src, src + sizeof(src), atoms);
</pre><p >for this value of
<span class='texttt'>loc</span>.</p><p >If <span class='texttt'>discard</span> is <span class='texttt'>true</span>, then if
<span class='texttt'>'.'</span>
has not yet been accumulated, then the position of the character is remembered,
but the character is otherwise ignored.
Otherwise, if
<span class='texttt'>'.'</span>
has already been accumulated, the character is discarded and
Stage 2 terminates.
If it is not discarded, then a check is made to determine if <span class='texttt'>c</span> is
allowed as the next character of an input field of the conversion specifier
returned by Stage 1. If so, it is accumulated.</p><p >If the character is either discarded or accumulated then <span class='texttt'>in</span>
is advanced by
<span class='texttt'>++in</span>
and processing returns to the beginning of stage 2.</p></li><li ><p >The sequence of <span class='texttt'>char</span>s accumulated in stage 2 (the field) is converted to a numeric value by the rules of one of the functions declared in the header <span class='texttt'>&lt;cstdlib&gt;</span>:</p><ul class='itemize'><li ><p >For a signed integer value, the function <span class='texttt'>strtoll</span>.</p></li><li ><p >For an unsigned integer value, the function <span class='texttt'>strtoull</span>.</p></li><li ><p >For a <span class='texttt'>float</span> value, the function <span class='texttt'>strtof</span>.</p></li><li ><p >For a <span class='texttt'>double</span> value, the function <span class='texttt'>strtod</span>.</p></li><li ><p >For a <span class='texttt'>long double</span> value, the function <span class='texttt'>strtold</span>.
</p></li></ul><p >The numeric value to be stored can be one of:</p><ul class='itemize'><li ><p >zero, if the conversion function does not convert the entire field.</p></li><li ><p >the most positive (or negative) representable value,
if the field to be converted to a signed integer type represents a value
too large positive (or negative) to be represented in <span class='texttt'>val</span>.</p></li><li ><p >the most positive representable value,
if the field to be converted to an unsigned integer type represents a value
that cannot be represented in <span class='texttt'>val</span>.</p></li><li ><p >the converted value, otherwise.
</p></li></ul><p >The resultant numeric value is stored in <span class='texttt'>val</span>.
If the conversion function does not convert the entire field, or
if the field represents a value outside the range of representable values,
<span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></li></ul></div></div><div class='para' id='facet.num.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-4'>4</a></div><div class='itemdescr'><p >Digit grouping is checked.
That is, the positions of discarded
separators is examined for consistency with
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).grouping()</span>.
If they are not consistent then
<span class='texttt'>ios_base::failbit</span>
is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-5'>5</a></div><div class='itemdescr'><p >In any case, if stage 2 processing was terminated by the test for
<span class='texttt'>in==end</span>
then
<span class='texttt'>err |=ios_base::eofbit</span>
is performed.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_get,num_get'></a></span><span class='indexparent'><a class='index' id='num_get,do_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
                 ios_base::iostate&amp; err, bool&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>(str.flags()&amp;ios_base::boolalpha) == 0</span>
then input proceeds as it would for a
<span class='texttt'>long</span>
except that if a value is being stored into <span class='texttt'>val</span>,
the value is determined according to the following:
If the value to be stored is 0 then
<span class='texttt'>false</span>
is stored.
If the value is <span class='texttt'>1</span>
then
<span class='texttt'>true</span>
is stored.
Otherwise <span class='texttt'>true</span> is stored and <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-7'>7</a></div><div class='itemdescr'><p >Otherwise target sequences are determined “as if” by calling the
members
<span class='texttt'>falsename()</span>
and
<span class='texttt'>truename()</span>
of the facet obtained by
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt;&gt;(str.getloc())</span>.
Successive characters in the range
<span class='texttt'>[in, end)</span>
(see <a href='sequence.reqmts'>[sequence.reqmts]</a>) are obtained and
matched against corresponding positions in the target sequences only
as necessary to identify a unique match. The input iterator <span class='texttt'>in</span> is
compared to <span class='texttt'>end</span> only when necessary to obtain a character. If a target sequence is uniquely matched, <span class='texttt'>val</span> is set to the
corresponding value. Otherwise <span class='texttt'>false</span> is stored and <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-8'>8</a></div><div class='itemdescr'><p >The <span class='texttt'>in</span> iterator is always left pointing one position beyond the last
character successfully matched. If <span class='texttt'>val</span> is set, then <span class='texttt'>err</span> is set to
<span class='texttt'>str.goodbit</span>;
or to
<span class='texttt'>str.eofbit</span>
if, when seeking another character to match, it is found that
<span class='texttt'>(in == end)</span>.
If <span class='texttt'>val</span> is not set, then <span class='texttt'>err</span> is set to
<span class='texttt'>str.failbit</span>;
or to
<span class='texttt'>(str.failbit|str.eofbit)</span>
if the reason for the failure was that
<span class='texttt'>(in == end)</span>.
[&nbsp;<i>Example:</i>
For targets
<span class='texttt'>true</span>:
<span class='texttt'>"a"</span>
and
<span class='texttt'>false</span>:
<span class='texttt'>"abb"</span>,
the input sequence
 <span class='texttt'>"a"</span>
yields
<span class='texttt'>val == true</span>
and
<span class='texttt'>err == str.eofbit</span>;
the input sequence
 <span class='texttt'>"abc"</span>
yields
<span class='texttt'>err = str.failbit</span>,
with <span class='texttt'>in</span> ending at the
<span class='texttt'>'c'</span>
element. For targets
<span class='texttt'>true</span>:
<span class='texttt'>"1"</span>
and
<span class='texttt'>false</span>:
<span class='texttt'>"0"</span>, the input sequence <span class='texttt'>"1"</span> yields
<span class='texttt'>val == true</span>
and
<span class='texttt'>err == str.goodbit</span>.
For empty targets <span class='texttt'>("")</span>, any input sequence yields
<span class='texttt'>err == str.failbit</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='facet.num.get.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>in</span>.
</p></div></div></div></div><div id='locale.nm.put'><h4 ><a class='secnum' href='#locale.nm.put' style='min-width:118pt'>22.4.2.2</a> Class template <span class='texttt'>num_put</span> <a class='abbr_ref' href='locale.nm.put'>[locale.nm.put]</a></h4><p ><span class='indexparent'><a class='index' id='num_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
  class num_put : public locale::facet {
  public:
    using char_type = charT;
    using iter_type = OutputIterator;

    explicit num_put(size_t refs = 0);

    iter_type put(iter_type s, ios_base&amp; f, char_type fill, bool v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill, long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill, long long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  unsigned long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  unsigned long long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  double v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  long double v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  const void* v) const;

    static locale::id id;

  protected:
    ~num_put();
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             bool v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long long v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             unsigned long) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             double v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long double v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             const void* v) const;
  };
}
</pre><div class='para' id='locale.nm.put-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.nm.put-1'>1</a></div><p >The facet
<span class='texttt'>num_put</span>
is used to format numeric values to a character sequence such as an ostream.</p></div><div id='facet.num.put.members'><h4 ><a class='secnum' href='#facet.num.put.members' style='min-width:133pt'>22.4.2.2.1</a> <span class='texttt'>num_put</span> members <a class='abbr_ref' href='facet.num.put.members'>[facet.num.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='num_put,put'></a></span><span class='indexparent'><a class='index' id='put,num_put'></a></span><code class='itemdecl'>
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  bool val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  double val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long double val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  const void* val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_put(out, str, fill, val)</span>.
</p></div></div></div><div id='facet.num.put.virtuals'><h4 ><a class='secnum' href='#facet.num.put.virtuals' style='min-width:133pt'>22.4.2.2.2</a> <span class='texttt'>num_put</span> virtual functions <a class='abbr_ref' href='facet.num.put.virtuals'>[facet.num.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='num_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,num_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  const void* val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Writes characters to the sequence <span class='texttt'>out</span>,
formatting <span class='texttt'>val</span> as desired.
In the following description,
a local variable initialized with:
</p><pre class='codeblock'>
locale loc = str.getloc();
</pre></div></div><div class='para' id='facet.num.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-2'>2</a></div><div class='itemdescr'><p >The details of this operation occur in several stages:</p><ul class='itemize'><li id='facet.num.put.virtuals-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.put.virtuals-2.1'>(2.1)</a></div><p >Stage 1:
Determine a printf conversion specifier <span class='texttt'>spec</span> and
determine the characters that would be printed by
<span class='texttt'>printf</span> (<a href='c.files'>[c.files]</a>)
given this conversion specifier for</p><pre class='codeblock'>
printf(spec, val)
</pre><p >assuming that the current locale is
the <span class='texttt'>"C"</span> locale.
</p></li><li id='facet.num.put.virtuals-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.put.virtuals-2.2'>(2.2)</a></div><p >Stage 2:
Adjust the representation by converting each
<span class='texttt'>char</span>
determined by stage 1 to a
<span class='texttt'>charT</span>
using a conversion and values returned by members of
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt;&gt;(str.getloc())</span>
</p></li><li id='facet.num.put.virtuals-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.put.virtuals-2.3'>(2.3)</a></div><p >Stage 3:
Determine where padding is required.
</p></li><li id='facet.num.put.virtuals-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#facet.num.put.virtuals-2.4'>(2.4)</a></div><p >Stage 4:
Insert the sequence into the <span class='texttt'>out</span>.
</p></li></ul></div></div><div class='para' id='facet.num.put.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-3'>3</a></div><div class='itemdescr'><p >Detailed descriptions of each stage follow.</p></div></div><div class='para' id='facet.num.put.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>out</span>.</p></div></div><div class='para' id='facet.num.put.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-5'>5</a></div><div class='itemdescr'><ul class='description'><li ><p >The first action of stage 1 is to determine a conversion specifier.
The tables that describe this determination use the following local variables</p><pre class='codeblock'>
fmtflags flags = str.flags();
fmtflags basefield =  (flags &amp; (ios_base::basefield));
fmtflags uppercase =  (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos =    (flags &amp; (ios_base::showpos));
fmtflags showbase =   (flags &amp; (ios_base::showbase));
fmtflags showpoint =  (flags &amp; (ios_base::showpoint));
</pre><p >All tables used in describing stage 1 are ordered.
That is, the first line whose condition is true applies.
A line without a condition is the default behavior when none of the earlier
lines apply.</p><p >For conversion from an integral type other than a character type, the
function determines the integral conversion specifier as indicated in
Table <a href='#tab:localization.integer.conversions.out'>[tab:localization.integer.conversions.out]</a>.</p><div class='numberedTable' id='tab:localization.integer.conversions.out'>Table <a href='#tab:localization.integer.conversions.out'>70</a> — Integer conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent       </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>basefield == ios_base::oct</span>                      </td><td class='center'>   <span class='texttt'>%o</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>(basefield == ios_base::hex) &amp;&amp; !uppercase</span>    </td><td class='center'>   <span class='texttt'>%x</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>(basefield == ios_base::hex)</span>                    </td><td class='center'>   <span class='texttt'>%X</span> </td></tr><tr class='rowsep'><td class='left'> 
for a <span class='texttt'>signed</span> integral type                     </td><td class='center'>   <span class='texttt'>%d</span> </td></tr><tr class='rowsep'><td class='left'> 
for an <span class='texttt'>unsigned</span> integral type                  </td><td class='center'>   <span class='texttt'>%u</span> </td></tr></table></div><p >For conversion from a floating-point type, the function determines
the floating-point conversion specifier as indicated in Table <a href='#tab:localization.fp.conversions.out'>[tab:localization.fp.conversions.out]</a>.</p><div class='numberedTable' id='tab:localization.fp.conversions.out'>Table <a href='#tab:localization.fp.conversions.out'>71</a> — Floating-point conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent                       </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::fixed</span>                       </td><td class='center'>   <span class='texttt'>%f</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::scientific &amp;&amp; !uppercase</span>  </td><td class='center'>   <span class='texttt'>%e</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::scientific</span>                  </td><td class='center'>   <span class='texttt'>%E</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == (ios_base::fixed | ios_base::scientific) &amp;&amp; !uppercase</span> </td><td class='center'> <span class='texttt'>%a</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == (ios_base::fixed | ios_base::scientific)</span> </td><td class='center'> <span class='texttt'>%A</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>!uppercase</span>                                          </td><td class='center'>   <span class='texttt'>%g</span> </td></tr><tr class='rowsep'><td class='left'> 
<i>otherwise</i>                                          </td><td class='center'>   <span class='texttt'>%G</span> </td></tr></table></div><p >For conversions from an integral or floating-point
type a length modifier is added to the
conversion specifier as indicated in  Table <a href='#tab:localization.length.modifier.out'>[tab:localization.length.modifier.out]</a>.</p><div class='numberedTable' id='tab:localization.length.modifier.out'>Table <a href='#tab:localization.length.modifier.out'>72</a> — Length modifier<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td class='center'>   Length modifier </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>long</span>                </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long long</span>           </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long</span>       </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long long</span>  </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long double</span>         </td><td class='center'>   <span class='texttt'>L</span>       </td></tr><tr class='rowsep'><td class='left'> 
<i>otherwise</i>          </td><td class='center'>   <i>none</i>   </td></tr></table></div><p >The conversion specifier has the following optional additional qualifiers
prepended as indicated in Table <a href='#tab:localization.numeric.conversions'>[tab:localization.numeric.conversions]</a>.</p><div class='numberedTable' id='tab:localization.numeric.conversions'>Table <a href='#tab:localization.numeric.conversions'>73</a> — Numeric conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type(s)</b></td><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent   </td></tr><tr class='capsep'><td class='left'> 
an integral type                </td><td class='left'>   <span class='texttt'>showpos</span>    </td><td class='center'>   <span class='texttt'>+</span>                   </td></tr><tr ><td class='left'>
                                </td><td class='left'>   <span class='texttt'>showbase</span>   </td><td class='center'>   <span class='texttt'>#</span>                  </td></tr><tr class='rowsep'><td class='left'> 
a floating-point type           </td><td class='left'>   <span class='texttt'>showpos</span>    </td><td class='center'>   <span class='texttt'>+</span>                   </td></tr><tr ><td class='left'>
                                </td><td class='left'>   <span class='texttt'>showpoint</span>  </td><td class='center'>   <span class='texttt'>#</span>                  </td></tr></table></div><p >For conversion from a floating-point type,
if <span class='texttt'>floatfield != (ios_base::fixed | ios_base::scientific)</span>,
<span class='texttt'>str.precision()</span>
is specified as precision in the conversion specification.
Otherwise, no precision is specified.
 
For conversion from
<span class='texttt'>void*</span>
the specifier is
<span class='texttt'>%p</span>.
 
The representations at the end of stage 1 consists of the
<span class='texttt'>char</span>'s
that would be printed by a call of
<span class='texttt'>printf(s, val)</span>
where <span class='texttt'>s</span> is the conversion specifier determined above.</p></li><li ><p >Any character <span class='texttt'>c</span> other than a decimal point(.) is converted to a
<span class='texttt'>charT</span>
via
<span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(loc).widen( c )</span></p><p >A local variable <span class='texttt'>punct</span> is initialized via
</p><pre class='codeblock'>
const numpunct&lt;charT&gt;&amp; punct = use_facet&lt;numpunct&lt;charT&gt;&gt;(str.getloc());
</pre><p >For arithmetic types,
<span class='texttt'>punct.thousands_sep()</span>
characters are inserted into the sequence as determined by the value returned
by
<span class='texttt'>punct.do_grouping()</span>
using the method described in <a href='facet.numpunct.virtuals'>[facet.numpunct.virtuals]</a>
 
Decimal point characters(.) are replaced by
<span class='texttt'>punct.decimal_point()</span></p></li><li ><p >A local variable is initialized as</p><pre class='codeblock'>
fmtflags adjustfield = (flags &amp; (ios_base::adjustfield));
</pre><p >The location of any padding<a class='footnotenum' href='#footnote-241'>241</a> is determined according to Table <a href='#tab:localization.fill.padding'>[tab:localization.fill.padding]</a>.</p><div class='numberedTable' id='tab:localization.fill.padding'>Table <a href='#tab:localization.fill.padding'>74</a> — Fill padding<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td colspan='1' class='center'><b>Location</b></td></tr><tr class='capsep'><td class='justify'> 
<span class='texttt'>adjustfield == ios_base::left</span>   </td><td class='left'>   pad after                       </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == ios_base::right</span>  </td><td class='left'>   pad before                      </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == internal</span> and a sign occurs in the representation
                                        </td><td class='left'>   pad after the sign              </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == internal</span> and representation after stage 1
began with 0x or 0X                     </td><td class='left'>   pad after x or X                </td></tr><tr class='rowsep'><td class='justify'> 
<i>otherwise</i>                      </td><td class='left'>   pad before                      </td></tr></table></div><p >If
<span class='texttt'>str.width()</span>
is nonzero and the number of
<span class='texttt'>charT</span>'s
in the sequence after stage 2 is less than
<span class='texttt'>str.width()</span>,
then enough <span class='texttt'>fill</span> characters are added to the sequence at the position
indicated for padding to bring the length of the sequence to
<span class='texttt'>str.width()</span>.
 
<span class='texttt'>str.width(0)</span>
is called.</p></li><li ><p >The sequence of
<span class='texttt'>charT</span>'s
at the end of stage 3 are output via</p><pre class='codeblock'>
*out++ = c
</pre></li></ul></div></div><p ><span class='indexparent'><a class='index' id='do_put,num_put'></a></span><span class='indexparent'><a class='index' id='num_put,do_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
                 bool val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
If
<span class='texttt'>(str.flags() &amp; ios_base::boolalpha) == 0</span>
returns
<span class='texttt'>do_put(out, str, fill,<br/>(int)val)</span>,
otherwise obtains a string
<span class='texttt'>s</span>
as if by
</p><pre class='codeblock'>
string_type s =
  val ? use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).truename()
    : use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).falsename();
</pre><p >and then inserts each character
<span class='texttt'>c</span>
of
<span class='texttt'>s</span>
into
<span class='texttt'>out</span>
via
<span class='texttt'>*out++ = c</span>
and returns
<span class='texttt'>out</span>.
</p></div></div><div class='footnote' id='footnote-241'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-241'>241)</a></div><p >The conversion specification
<span class='texttt'>#o</span>
generates a leading
<span class='texttt'>0</span>
which is
<i>not</i>
a padding character.</p></div></div></div></div><div id='facet.numpunct'><h3 ><a class='secnum' href='#facet.numpunct' style='min-width:103pt'>22.4.3</a> The numeric punctuation facet <a class='abbr_ref' href='facet.numpunct'>[facet.numpunct]</a></h3><div id='locale.numpunct'><h4 ><a class='secnum' href='#locale.numpunct' style='min-width:118pt'>22.4.3.1</a> Class template <span class='texttt'>numpunct</span> <a class='abbr_ref' href='locale.numpunct'>[locale.numpunct]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class numpunct : public locale::facet {
  public:
    using char_type   = charT;
    using string_type = basic_string&lt;charT&gt;;

    explicit numpunct(size_t refs = 0);

    char_type    decimal_point()   const;
    char_type    thousands_sep()   const;
    string       grouping()        const;
    string_type  truename()        const;
    string_type  falsename()       const;

    static locale::id id;

  protected:
   ~numpunct();                 <span class='comment'>// virtual
</span>    virtual char_type    do_decimal_point() const;
    virtual char_type    do_thousands_sep() const;
    virtual string       do_grouping()      const;
    virtual string_type  do_truename()      const;      <span class='comment'>// for <span class='texttt'>bool</span>
</span>    virtual string_type  do_falsename()     const;      <span class='comment'>// for <span class='texttt'>bool</span>
</span>  };
}
</pre><div class='para' id='locale.numpunct-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.numpunct-1'>1</a></div><p ><span class='texttt'>numpunct&lt;&gt;</span>
specifies numeric punctuation.
The specializations required in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>numpunct&lt;wchar_t&gt;</span>
and
<span class='texttt'>numpunct&lt;char&gt;</span>,
provide classic
<span class='texttt'>"C"</span>
numeric formats,
i.e., they contain information equivalent to that contained in the
<span class='texttt'>"C"</span>
locale or their wide character counterparts as if obtained by
a call to
<span class='texttt'>widen</span>.</p></div><div class='para' id='locale.numpunct-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.numpunct-2'>2</a></div><p >The syntax for number formats is as follows, where
<span class='texttt'>digit</span>
represents the radix set specified by the
<span class='texttt'>fmtflags</span>
argument value, and
<span class='texttt'>thousands-sep</span>
and
<span class='texttt'>decimal-point</span>
are the results of corresponding
<span class='texttt'>numpunct&lt;charT&gt;</span>
members.
Integer values have the format:</p><pre class='codeblock'>
integer   ::= [sign] units
sign      ::= plusminus
plusminus ::= '+' | '-'
units     ::= digits [thousands-sep units]
digits    ::= digit [digits]
</pre><p >and floating-point values have:</p><pre class='codeblock'>
floatval ::= [sign] units [decimal-point [digits]] [e [sign] digits] |
             [sign]        decimal-point  digits   [e [sign] digits]
e        ::= 'e' | 'E'
</pre><p >where the number of digits between
<span class='texttt'>thousands-sep</span>s
is as specified by
<span class='texttt'>do_grouping()</span>.
For parsing, if the
<span class='texttt'>digits</span>
portion contains no thousands-separators, no grouping constraint
is applied.</p></div><div id='facet.numpunct.members'><h4 ><a class='secnum' href='#facet.numpunct.members' style='min-width:133pt'>22.4.3.1.1</a> <span class='texttt'>numpunct</span> members <a class='abbr_ref' href='facet.numpunct.members'>[facet.numpunct.members]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct,decimal_point'></a></span><span class='indexparent'><a class='index' id='decimal_point,numpunct'></a></span><code class='itemdecl'>
char_type decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_decimal_point()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,thousands_sep'></a></span><span class='indexparent'><a class='index' id='thousands_sep,numpunct'></a></span><code class='itemdecl'>
char_type thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_thousands_sep()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,grouping'></a></span><span class='indexparent'><a class='index' id='grouping,numpunct'></a></span><code class='itemdecl'>
string grouping()  const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_grouping()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,truename'></a></span><span class='indexparent'><a class='index' id='truename,numpunct'></a></span><span class='indexparent'><a class='index' id='numpunct,falsename'></a></span><span class='indexparent'><a class='index' id='falsename,numpunct'></a></span><code class='itemdecl'>
string_type truename()  const;
string_type falsename() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_truename()</span>
or
<span class='texttt'>do_falsename()</span>,
respectively.
</p></div></div></div><div id='facet.numpunct.virtuals'><h4 ><a class='secnum' href='#facet.numpunct.virtuals' style='min-width:133pt'>22.4.3.1.2</a> <span class='texttt'>numpunct</span> virtual functions <a class='abbr_ref' href='facet.numpunct.virtuals'>[facet.numpunct.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct,do_decimal_point'></a></span><span class='indexparent'><a class='index' id='do_decimal_point,numpunct'></a></span><code class='itemdecl'>
char_type do_decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A character for use as the decimal radix separator.
The required specializations return <span class='texttt'>'.'</span> or <span class='texttt'>L'.'</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_thousands_sep'></a></span><span class='indexparent'><a class='index' id='do_thousands_sep,numpunct'></a></span><code class='itemdecl'>
char_type do_thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A character for use as the digit group separator.
The required specializations return <span class='texttt'>','</span> or <span class='texttt'>L','</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_grouping'></a></span><span class='indexparent'><a class='index' id='do_grouping,numpunct'></a></span><code class='itemdecl'>
string do_grouping() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A basic_string&lt;char&gt; <span class='texttt'>vec</span> used as a vector of integer values,
in which each element
<span class='texttt'>vec[i]</span>
represents the number of digits<a class='footnotenum' href='#footnote-242'>242</a>
in the group at position <span class='texttt'>i</span>, starting with position 0 as the
rightmost group.
If
<span class='texttt'>vec.size() &lt;= i</span>,
the number is the same as group
<span class='texttt'>(i-1)</span>;
if
<span class='texttt'>(i&lt;0 || vec[i]&lt;=0 || vec[i]==CHAR_MAX)</span>,
the size of the digit group is unlimited.</p></div></div><div class='para' id='facet.numpunct.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-4'>4</a></div><div class='itemdescr'><p >The required specializations return the empty string, indicating
no grouping.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_truename'></a></span><span class='indexparent'><a class='index' id='do_truename,numpunct'></a></span><span class='indexparent'><a class='index' id='numpunct,do_falsename'></a></span><span class='indexparent'><a class='index' id='do_falsename,numpunct'></a></span><code class='itemdecl'>
string_type do_truename()  const;
string_type do_falsename() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A string representing the name of the boolean value
<span class='texttt'>true</span>
or
<span class='texttt'>false</span>,
respectively.</p></div></div><div class='para' id='facet.numpunct.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-6'>6</a></div><div class='itemdescr'><p >In the base class implementation these names are
<span class='texttt'>"true"</span> and <span class='texttt'>"false"</span>, or <span class='texttt'>L"true"</span> and <span class='texttt'>L"false"</span>.
</p></div></div><div class='footnote' id='footnote-242'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-242'>242)</a></div><p >Thus, the string
<span class='texttt'>"\003"</span> specifies groups of 3 digits each, and
<span class='texttt'>"3"</span> probably indicates groups of 51 (!) digits each,
because 51 is the ASCII value of <span class='texttt'>"3"</span>.</p></div></div></div><div id='locale.numpunct.byname'><h4 ><a class='secnum' href='#locale.numpunct.byname' style='min-width:118pt'>22.4.3.2</a> Class template <span class='texttt'>numpunct_byname</span> <a class='abbr_ref' href='locale.numpunct.byname'>[locale.numpunct.byname]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class numpunct_byname : public numpunct&lt;charT&gt; {
  <span class='comment'>// this class is specialized for <span class='texttt'>char</span> and <span class='texttt'>wchar_t</span>.
</span>  public:
    using char_type   = charT;
    using string_type = basic_string&lt;charT&gt;;

    explicit numpunct_byname(const char*, size_t refs = 0);
    explicit numpunct_byname(const string&amp;, size_t refs = 0);
  protected:
   ~numpunct_byname();
  };
}
</pre></div></div><div id='category.collate'><h3 ><a class='secnum' href='#category.collate' style='min-width:103pt'>22.4.4</a> The collate category <a class='abbr_ref' href='category.collate'>[category.collate]</a></h3><div id='locale.collate'><h4 ><a class='secnum' href='#locale.collate' style='min-width:118pt'>22.4.4.1</a> Class template <span class='texttt'>collate</span> <a class='abbr_ref' href='locale.collate'>[locale.collate]</a></h4><p ><span class='indexparent'><a class='index' id='collate'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class collate : public locale::facet {
  public:
    using char_type   = charT;
    using string_type = basic_string&lt;charT&gt;;

    explicit collate(size_t refs = 0);

    int compare(const charT* low1, const charT* high1,
                const charT* low2, const charT* high2) const;
    string_type transform(const charT* low, const charT* high) const;
    long hash(const charT* low, const charT* high) const;

    static locale::id id;

  protected:
    ~collate();
    virtual int do_compare(const charT* low1, const charT* high1,
                           const charT* low2, const charT* high2) const;
    virtual string_type do_transform(const charT* low, const charT* high) const;
    virtual long do_hash (const charT* low, const charT* high) const;
  };
}
</pre><div class='para' id='locale.collate-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate-1'>1</a></div><p >The class
<span class='texttt'>collate&lt;charT&gt;</span>
provides features for use in the
collation (comparison) and hashing of strings.
A locale member function template,
<span class='texttt'>operator()</span>,
uses the collate facet to allow a locale to act directly as the predicate
argument for standard algorithms (Clause <a href='algorithms'>[algorithms]</a>) and containers operating on strings.
The specializations required in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>collate&lt;char&gt;</span>
and
<span class='texttt'>collate&lt;wchar_t&gt;</span>,
apply lexicographic ordering (<a href='alg.lex.comparison'>[alg.lex.comparison]</a>).</p></div><div class='para' id='locale.collate-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate-2'>2</a></div><p >Each function compares a string of characters
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[low, high)</span>.</p></div><div id='locale.collate.members'><h4 ><a class='secnum' href='#locale.collate.members' style='min-width:133pt'>22.4.4.1.1</a> <span class='texttt'>collate</span> members <a class='abbr_ref' href='locale.collate.members'>[locale.collate.members]</a></h4><p ><span class='indexparent'><a class='index' id='collate,compare'></a></span><span class='indexparent'><a class='index' id='compare,collate'></a></span><code class='itemdecl'>
int compare(const charT* low1, const charT* high1,
            const charT* low2, const charT* high2) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_compare(low1, high1, low2, high2)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,transform'></a></span><span class='indexparent'><a class='index' id='transform,collate'></a></span><code class='itemdecl'>
string_type transform(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_transform(low, high)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,hash'></a></span><span class='indexparent'><a class='index' id='hash,collate'></a></span><code class='itemdecl'>
long hash(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_hash(low, high)</span>.
</p></div></div></div><div id='locale.collate.virtuals'><h4 ><a class='secnum' href='#locale.collate.virtuals' style='min-width:133pt'>22.4.4.1.2</a> <span class='texttt'>collate</span> virtual functions <a class='abbr_ref' href='locale.collate.virtuals'>[locale.collate.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='collate,do_compare'></a></span><span class='indexparent'><a class='index' id='do_compare,collate'></a></span><code class='itemdecl'>
int do_compare(const charT* low1, const charT* high1,
               const charT* low2, const charT* high2) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>1</span>
if the first string is greater than the second,
<span class='texttt'>-1</span>
if less, zero otherwise.
The specializations required in Table <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>collate&lt;char&gt;</span>
and
<span class='texttt'>collate&lt;wchar_t&gt;</span>,
implement
a lexicographical comparison (<a href='alg.lex.comparison'>[alg.lex.comparison]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,do_transform'></a></span><span class='indexparent'><a class='index' id='do_transform,collate'></a></span><code class='itemdecl'>
string_type do_transform(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A
<span class='texttt'>basic_string&lt;charT&gt;</span>
value that, compared lexicographically with the result of calling
<span class='texttt'>transform()</span>
on another string, yields the same result as calling
<span class='texttt'>do_compare()</span>
on the same two strings.<a class='footnotenum' href='#footnote-243'>243</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,do_hash'></a></span><span class='indexparent'><a class='index' id='do_hash,collate'></a></span><code class='itemdecl'>
long do_hash(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An integer value equal to the result of calling
<span class='texttt'>hash()</span>
on any other string for which
<span class='texttt'>do_compare()</span>
returns 0 (equal) when passed the two strings.
[&nbsp;<i>Note:</i>
The probability that the result equals that for another string which does
not compare equal should be very small, approaching
<span class='texttt'>(1.0/numeric_limits&lt;unsigned long&gt;::max())</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div class='footnote' id='footnote-243'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-243'>243)</a></div><p >This function is useful when one string is
being compared to many other strings.</p></div></div></div><div id='locale.collate.byname'><h4 ><a class='secnum' href='#locale.collate.byname' style='min-width:118pt'>22.4.4.2</a> Class template <span class='texttt'>collate_byname</span> <a class='abbr_ref' href='locale.collate.byname'>[locale.collate.byname]</a></h4><p ><span class='indexparent'><a class='index' id='collate_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class collate_byname : public collate&lt;charT&gt; {
  public:
    using string_type = basic_string&lt;charT&gt;;

    explicit collate_byname(const char*, size_t refs = 0);
    explicit collate_byname(const string&amp;, size_t refs = 0);
  protected:
    ~collate_byname();
  };
}
</pre></div></div><div id='category.time'><h3 ><a class='secnum' href='#category.time' style='min-width:103pt'>22.4.5</a> The time category <a class='abbr_ref' href='category.time'>[category.time]</a></h3><div class='para' id='category.time-1'><div class='marginalizedparent'><a class='marginalized' href='#category.time-1'>1</a></div><p >Templates
<span class='texttt'>time_get&lt;charT,InputIterator&gt;</span>
and
<span class='texttt'>time_put&lt;charT,OutputIterator&gt;</span>
provide date and time formatting and parsing.
All specifications of member functions for
<span class='texttt'>time_put</span>
and
<span class='texttt'>time_get</span>
in the subclauses of <a href='category.time'>[category.time]</a> only apply to the
specializations required in Tables <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>).
Their members use their
<span class='texttt'>ios_base&amp;</span>,
<span class='texttt'>ios_base::iostate&amp;</span>,
and
<span class='texttt'>fill</span>
arguments as described in (<a href='locale.categories'>[locale.categories]</a>), and the
<span class='texttt'>ctype&lt;&gt;</span>
facet, to determine formatting details.</p></div><div id='locale.time.get'><h4 ><a class='secnum' href='#locale.time.get' style='min-width:118pt'>22.4.5.1</a> Class template <span class='texttt'>time_get</span> <a class='abbr_ref' href='locale.time.get'>[locale.time.get]</a></h4><p ><span class='indexparent'><a class='index' id='time_get'></a></span></p><pre class='codeblock'>
namespace std {
  class time_base {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
  class time_get : public locale::facet, public time_base {
  public:
    using char_type = charT;
    using iter_type = InputIterator;

    explicit time_get(size_t refs = 0);

    dateorder date_order()  const { return do_date_order(); }
    iter_type get_time(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t)  const;
    iter_type get_date(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t)  const;
    iter_type get_weekday(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get_monthname(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get_year(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t, char format, char modifier = 0) const;
    iter_type get(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t, const char_type* fmt,
                       const char_type* fmtend) const;

    static locale::id id;

  protected:
    ~time_get();
    virtual dateorder do_date_order()  const;
    virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&amp;,
                                     ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp;,
                                       ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
                             ios_base::iostate&amp; err, tm* t, char format, char modifier) const;
  };
}
</pre><div class='para' id='locale.time.get-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get-1'>1</a></div><p ><span class='texttt'>time_get</span>
is used to
parse a character sequence, extracting components of a time or date
into a
<span class='texttt'>struct tm</span>
record.
Each
<span class='texttt'>get</span>
member parses a format as produced by a corresponding format specifier to
<span class='texttt'>time_put&lt;&gt;::put</span>.
If the sequence being parsed matches the correct format, the corresponding
members of the
<span class='texttt'>struct tm</span>
argument are set to the values used to produce the sequence; otherwise
either an error is reported or unspecified values are assigned.<a class='footnotenum' href='#footnote-244'>244</a></p></div><div class='para' id='locale.time.get-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get-2'>2</a></div><p >If the end iterator is reached during parsing by any of the
<span class='texttt'>get()</span>
member functions, the member sets
<span class='texttt'>ios_base::eofbit</span>
in <span class='texttt'>err</span>.</p></div><div class='footnote' id='footnote-244'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-244'>244)</a></div><p >In
other words, user confirmation is required for reliable parsing of
user-entered dates and times, but machine-generated formats can be
parsed reliably.
This allows parsers to be aggressive about
interpreting user variations on standard formats.</p></div><div id='locale.time.get.members'><h4 ><a class='secnum' href='#locale.time.get.members' style='min-width:133pt'>22.4.5.1.1</a> <span class='texttt'>time_get</span> members <a class='abbr_ref' href='locale.time.get.members'>[locale.time.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='time_get,date_order'></a></span><span class='indexparent'><a class='index' id='date_order,time_get'></a></span><code class='itemdecl'>
dateorder date_order() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_date_order()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_time'></a></span><span class='indexparent'><a class='index' id='get_time,time_get'></a></span><code class='itemdecl'>
iter_type get_time(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_time(s, end, str, err, t)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_date'></a></span><span class='indexparent'><a class='index' id='get_date,time_get'></a></span><code class='itemdecl'>
iter_type get_date(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_date(s, end, str, err, t)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_weekday'></a></span><span class='indexparent'><a class='index' id='get_weekday,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get_monthname'></a></span><span class='indexparent'><a class='index' id='get_monthname,time_get'></a></span><code class='itemdecl'>
iter_type get_weekday(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base&amp; str,
                        ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_weekday(s, end, str, err, t)</span>
or
<span class='texttt'>do_get_monthname(s, end, str, err, t)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_year'></a></span><span class='indexparent'><a class='index' id='get_year,time_get'></a></span><code class='itemdecl'>
iter_type get_year(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_year(s, end, str, err, t)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm* t, char format, char modifier = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>do_get(s, end, f, err, t, format, modifier)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm* t, const char_type* fmt, const char_type* fmtend) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>[fmt, fmtend)</span> shall be a valid range.</p></div></div><div class='para' id='locale.time.get.members-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> The function starts by evaluating
<span class='texttt'>err = ios_base::goodbit</span>. It then enters a loop, reading zero or more
characters from <span class='texttt'>s</span> at each iteration. Unless otherwise specified below,
the loop terminates when the first of the following conditions holds:</p><ul class='itemize'><li id='locale.time.get.members-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.1'>(8.1)</a></div><p >The expression <span class='texttt'>fmt == fmtend</span> evaluates to <span class='texttt'>true</span>.</p></li><li id='locale.time.get.members-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.2'>(8.2)</a></div><p >The expression <span class='texttt'>err == ios_base::goodbit</span> evaluates to <span class='texttt'>false</span>.</p></li><li id='locale.time.get.members-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.3'>(8.3)</a></div><p >The expression <span class='texttt'>s == end</span> evaluates to <span class='texttt'>true</span>,
in which case the function
evaluates <span class='texttt'>err = ios_base::eofbit | ios_base::failbit</span>.</p></li><li id='locale.time.get.members-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.4'>(8.4)</a></div><p >The next element of <span class='texttt'>fmt</span> is equal to
<span class='texttt'>'%'</span>, optionally followed by a
modifier character, followed by a conversion specifier character,
<span class='texttt'>format</span>, together forming a conversion specification valid for the
ISO/IEC 9945 function <span class='texttt'>strptime</span>. If the number of elements in the range
<span class='texttt'>[fmt, fmtend)</span> is not sufficient to unambiguously determine whether the
conversion specification is complete and valid, the function evaluates
<span class='texttt'>err = ios_base::failbit</span>. Otherwise, the function evaluates
<span class='texttt'>s = do_get(s, end, f, err, t, format, modifier)</span>, where the value
of <span class='texttt'>modifier</span> is <span class='texttt'>'\0'</span>
when the optional modifier is absent from the conversion specification.
If <span class='texttt'>err == ios_base::goodbit</span> holds after the evaluation of the
expression, the function increments <span class='texttt'>fmt</span> to point just past the end of
the conversion specification and continues looping.</p></li><li id='locale.time.get.members-8.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.5'>(8.5)</a></div><p >The expression <span class='texttt'>isspace(*fmt, f.getloc())</span> evaluates to <span class='texttt'>true</span>,
in which case
the function first increments <span class='texttt'>fmt</span> until
<span class='texttt'>fmt == fmtend || !isspace(*fmt, f.getloc())</span> evaluates to <span class='texttt'>true</span>,
then advances <span class='texttt'>s</span> until
<span class='texttt'>s == end || !isspace(*s, f.getloc())</span> is <span class='texttt'>true</span>, and finally resumes looping.</p></li><li id='locale.time.get.members-8.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.time.get.members-8.6'>(8.6)</a></div><p >The next character read from <span class='texttt'>s</span> matches the element
pointed to by <span class='texttt'>fmt</span> in
a case-insensitive comparison, in which case the function evaluates
<span class='texttt'>++fmt, ++s</span> and continues looping. Otherwise, the function evaluates
<span class='texttt'>err = ios_base::failbit</span>.
</p></li></ul></div></div><div class='para' id='locale.time.get.members-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The function uses the <span class='texttt'>ctype&lt;charT&gt;</span>
facet installed in <span class='texttt'>f</span>'s locale
to determine valid whitespace characters. It is unspecified by what
means the function performs case-insensitive comparison or whether
multi-character sequences are considered while doing so. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.time.get.members-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>s</span>.
</p></div></div></div><div id='locale.time.get.virtuals'><h4 ><a class='secnum' href='#locale.time.get.virtuals' style='min-width:133pt'>22.4.5.1.2</a> <span class='texttt'>time_get</span> virtual functions <a class='abbr_ref' href='locale.time.get.virtuals'>[locale.time.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='time_get,do_date_order'></a></span><span class='indexparent'><a class='index' id='do_date_order,time_get'></a></span><code class='itemdecl'>
dateorder do_date_order() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value indicating the preferred order of components for
those date formats that are composed of day, month, and year.<a class='footnotenum' href='#footnote-245'>245</a>
Returns
<span class='texttt'>no_order</span>
if the date format specified by
<span class='texttt'>'x'</span>
contains other variable components (e.g., Julian day, week number, week day).
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_time'></a></span><span class='indexparent'><a class='index' id='do_get_time,time_get'></a></span><code class='itemdecl'>
iter_type do_get_time(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted those
<span class='texttt'>struct tm</span>
members, and remaining format characters, used by
<span class='texttt'>time_put&lt;&gt;::put</span>
to produce the format specified by
<span class='texttt'>"%H:%M:%S"</span>,
or until it encounters an error or end of sequence.</p></div></div><div class='para' id='locale.time.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as possibly part of a valid time.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_date'></a></span><span class='indexparent'><a class='index' id='do_get_date,time_get'></a></span><code class='itemdecl'>
iter_type do_get_date(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted those
<span class='texttt'>struct tm</span>
members and remaining format characters used by
<span class='texttt'>time_put&lt;&gt;::put</span>
to produce one of the following formats,
or until it encounters an error. The format depends on the value returned
by <span class='texttt'>date_order()</span> as shown in
Table <a href='#tab:lib.locale.time.get.virtuals.dogetdate'>[tab:lib.locale.time.get.virtuals.dogetdate]</a>.</p><div class='numberedTable' id='tab:lib.locale.time.get.virtuals.dogetdate'>Table <a href='#tab:lib.locale.time.get.virtuals.dogetdate'>75</a> — <span class='texttt'>do_get_date</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><span class='texttt'>date_order()</span></b></td><td colspan='1' class='center'><b>Format</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>no_order</span>  </td><td class='left'> <span class='texttt'>"%m%d%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>dmy</span>       </td><td class='left'> <span class='texttt'>"%d%m%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>mdy</span>       </td><td class='left'> <span class='texttt'>"%m%d%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ymd</span>       </td><td class='left'> <span class='texttt'>"%y%m%d"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ydm</span>       </td><td class='left'> <span class='texttt'>"%y%d%m"</span> </td></tr></table></div></div></div><div class='para' id='locale.time.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-5'>5</a></div><div class='itemdescr'><p >An implementation may also accept additional <span class='indexparent'><a class='index' id='additional_formats_for_time_get::do_get_date'></a></span>implementation-defined formats.</p></div></div><div class='para' id='locale.time.get.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as possibly part of a valid date.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_weekday'></a></span><span class='indexparent'><a class='index' id='do_get_weekday,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,do_get_monthname'></a></span><span class='indexparent'><a class='index' id='do_get_monthname,time_get'></a></span><code class='itemdecl'>
iter_type do_get_weekday(iter_type s, iter_type end, ios_base&amp; str,
                         ios_base::iostate&amp; err, tm* t) const;
iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp; str,
                           ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted the (perhaps abbreviated) name of a weekday or month.
If it finds an abbreviation that is followed by characters that could
match a full name, it continues reading until it matches the full name or
fails.
It sets the appropriate
<span class='texttt'>struct tm</span>
member accordingly.</p></div></div><div class='para' id='locale.time.get.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid name.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_year'></a></span><span class='indexparent'><a class='index' id='do_get_year,time_get'></a></span><code class='itemdecl'>
iter_type do_get_year(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted an unambiguous year identifier.
It is
<span class='indexparent'><a class='index' id='whether_time_get::do_get_year_accepts_two-digit_year_numbers'></a></span>implementation-defined whether
two-digit year numbers are accepted,
and (if so) what century they are assumed to lie in.
Sets the
<span class='texttt'>t-&gt;tm_year</span>
member accordingly.</p></div></div><div class='para' id='locale.time.get.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid year identifier.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,do_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm* t, char format, char modifier) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>t</span> shall point to an object.</p></div></div><div class='para' id='locale.time.get.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> The function starts by evaluating
<span class='texttt'>err = ios_base::goodbit</span>. It
then reads characters starting at <span class='texttt'>s</span> until it encounters an error, or
until it has extracted and assigned those <span class='texttt'>struct tm</span> members, and any
remaining format characters, corresponding to a conversion directive
appropriate for the ISO/IEC 9945 function <span class='texttt'>strptime</span>, formed by
concatenating <span class='texttt'>'%'</span>, the <span class='texttt'>modifier</span> character,
when non-NUL, and the <span class='texttt'>format</span>
character. When the concatenation fails to yield a complete valid
directive the function leaves the object pointed to by <span class='texttt'>t</span> unchanged and
evaluates <span class='texttt'>err |= ios_base::failbit</span>. When <span class='texttt'>s == end</span>
evaluates to <span class='texttt'>true</span> after reading a character the function evaluates
<span class='texttt'>err |= ios_base::eofbit</span>.</p></div></div><div class='para' id='locale.time.get.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-13'>13</a></div><div class='itemdescr'><p >For complex conversion directives such as <span class='texttt'>%c</span>,
<span class='texttt'>%x</span>, or <span class='texttt'>%X</span>, or directives
that involve the optional modifiers <span class='texttt'>E</span> or <span class='texttt'>O</span>,
when the function is unable
to unambiguously determine some or all <span class='texttt'>struct tm</span> members from the input
sequence <span class='texttt'>[s, end)</span>, it evaluates <span class='texttt'>err |= ios_base::eofbit</span>.
In such cases the values of those <span class='texttt'>struct tm</span> members are unspecified
and may be outside their valid range.</p></div></div><div class='para' id='locale.time.get.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> It is unspecified whether multiple calls to
<span class='texttt'>do_get()</span> with the
address of the same <span class='texttt'>struct tm</span> object will update the current contents of
the object or simply overwrite its members. Portable programs must zero
out the object before invoking the function.</p></div></div><div class='para' id='locale.time.get.virtuals-15'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator pointing immediately beyond the last character
recognized as possibly part of a valid input sequence for the given
<span class='texttt'>format</span> and <span class='texttt'>modifier</span>.
</p></div></div><div class='footnote' id='footnote-245'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-245'>245)</a></div><p >This
function is intended as a convenience only, for common
formats, and may return
<span class='texttt'>no_order</span>
in valid locales.</p></div></div></div><div id='locale.time.get.byname'><h4 ><a class='secnum' href='#locale.time.get.byname' style='min-width:118pt'>22.4.5.2</a> Class template <span class='texttt'>time_get_byname</span> <a class='abbr_ref' href='locale.time.get.byname'>[locale.time.get.byname]</a></h4><p ><span class='indexparent'><a class='index' id='time_get_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
  class time_get_byname : public time_get&lt;charT, InputIterator&gt; {
  public:
    using dateorder = time_base::dateorder;
    using iter_type = InputIterator;

    explicit time_get_byname(const char*, size_t refs = 0);
    explicit time_get_byname(const string&amp;, size_t refs = 0);
  protected:
    ~time_get_byname();
  };
}
</pre></div><div id='locale.time.put'><h4 ><a class='secnum' href='#locale.time.put' style='min-width:118pt'>22.4.5.3</a> Class template <span class='texttt'>time_put</span> <a class='abbr_ref' href='locale.time.put'>[locale.time.put]</a></h4><p ><span class='indexparent'><a class='index' id='time_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
  class time_put : public locale::facet {
  public:
    using char_type = charT;
    using iter_type = OutputIterator;

    explicit time_put(size_t refs = 0);

    <span class='comment'>// the following is implemented in terms of other member functions.
</span>    iter_type put(iter_type s, ios_base&amp; f, char_type fill, const tm* tmb,
                  const charT* pattern, const charT* pat_end) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  const tm* tmb, char format, char modifier = 0) const;

    static locale::id id;

  protected:
    ~time_put();
    virtual iter_type do_put(iter_type s, ios_base&amp;, char_type, const tm* t,
                             char format, char modifier) const;
  };
}
</pre><div id='locale.time.put.members'><h4 ><a class='secnum' href='#locale.time.put.members' style='min-width:133pt'>22.4.5.3.1</a> <span class='texttt'>time_put</span> members <a class='abbr_ref' href='locale.time.put.members'>[locale.time.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='time_put,put'></a></span><span class='indexparent'><a class='index' id='put,time_put'></a></span><code class='itemdecl'>
iter_type put(iter_type s, ios_base&amp; str, char_type fill, const tm* t,
              const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base&amp; str, char_type fill, const tm* t,
              char format, char modifier = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first form steps through the sequence from
<span class='texttt'>pattern</span>
to
<span class='texttt'>pat_end</span>,
identifying characters that are part of a format sequence.
Each character that is not part of a format sequence is written to
<span class='texttt'>s</span>
immediately, and each format sequence, as it is identified, results in
a call to
<span class='texttt'>do_put</span>;
thus, format elements and other characters are interleaved in the output
in the order in which they appear in the pattern.
Format sequences are identified by converting each character
<span class='texttt'>c</span>
to a
<span class='texttt'>char</span>
value as if by
<span class='texttt'>ct.narrow(c,0)</span>,
where
<span class='texttt'>ct</span>
is a reference to
<span class='texttt'>ctype&lt;charT&gt;</span>
obtained from
<span class='texttt'>str.getloc()</span>.
The first character of each sequence is equal to
<span class='texttt'>'%'</span>,
followed by an optional modifier character
<span class='texttt'>mod</span><a class='footnotenum' href='#footnote-246'>246</a> and a format specifier character
<span class='texttt'>spec</span>
as defined for the function
<span class='texttt'>strftime</span>.
If no modifier character is present,
<span class='texttt'>mod</span>
is zero.
For each valid format sequence identified, calls
<span class='texttt'>do_put(s, str, fill, t, spec, mod)</span>.</p></div></div><div class='para' id='locale.time.put.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-2'>2</a></div><div class='itemdescr'><p >The second form calls
<span class='texttt'>do_put(s, str, fill, t, format, modifier)</span>.</p></div></div><div class='para' id='locale.time.put.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
The <span class='texttt'>fill</span> argument may be used in the implementation-defined
formats or by derivations. A space character is a reasonable
default for this argument.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.time.put.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
</p></div></div><div class='footnote' id='footnote-246'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-246'>246)</a></div><p >Although the C programming language defines no modifiers,
most vendors do.</p></div></div><div id='locale.time.put.virtuals'><h4 ><a class='secnum' href='#locale.time.put.virtuals' style='min-width:133pt'>22.4.5.3.2</a> <span class='texttt'>time_put</span> virtual functions <a class='abbr_ref' href='locale.time.put.virtuals'>[locale.time.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='time_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,time_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type s, ios_base&amp;, char_type fill, const tm* t,
                 char format, char modifier) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Formats the contents of the parameter <span class='texttt'>t</span>
into characters placed on the output sequence <span class='texttt'>s</span>.
Formatting is controlled by the parameters <span class='texttt'>format</span> and <span class='texttt'>modifier</span>,
interpreted identically as the format specifiers in the string
argument to the standard library function
<span class='indexparent'><a class='index' id='strftime'></a></span><span class='texttt'>strftime()</span><a class='footnotenum' href='#footnote-247'>247</a>,
except that the sequence of characters produced for those specifiers
that are described as depending on the C locale are instead <span class='indexparent'><a class='index' id='formatted_character_sequence_generated_by_time_put::do_put_in_C_locale'></a></span>implementation-defined.<a class='footnotenum' href='#footnote-248'>248</a></p></div></div><div class='para' id='locale.time.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
[&nbsp;<i>Note:</i>
The <span class='texttt'>fill</span> argument may be used in the implementation-defined
formats or by derivations. A space character is a reasonable
default for this argument.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div class='footnote' id='footnote-247'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-247'>247)</a></div><p >Interpretation of the <span class='texttt'>modifier</span>
argument is implementation-defined, but should follow POSIX
conventions.</p></div><div class='footnote' id='footnote-248'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-248'>248)</a></div><p >Implementations are encouraged to refer to other standards
such as POSIX
for these definitions.</p></div></div></div><div id='locale.time.put.byname'><h4 ><a class='secnum' href='#locale.time.put.byname' style='min-width:118pt'>22.4.5.4</a> Class template <span class='texttt'>time_put_byname</span> <a class='abbr_ref' href='locale.time.put.byname'>[locale.time.put.byname]</a></h4><p ><span class='indexparent'><a class='index' id='time_put_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
  class time_put_byname : public time_put&lt;charT, OutputIterator&gt;
  {
  public:
    using char_type = charT;
    using iter_type = OutputIterator;

    explicit time_put_byname(const char*, size_t refs = 0);
    explicit time_put_byname(const string&amp;, size_t refs = 0);
  protected:
    ~time_put_byname();
  };
}
</pre></div></div><div id='category.monetary'><h3 ><a class='secnum' href='#category.monetary' style='min-width:103pt'>22.4.6</a> The monetary category <a class='abbr_ref' href='category.monetary'>[category.monetary]</a></h3><div class='para' id='category.monetary-1'><div class='marginalizedparent'><a class='marginalized' href='#category.monetary-1'>1</a></div><p >These templates handle monetary formats.
A template parameter indicates whether
local or international monetary formats are to be used.</p></div><div class='para' id='category.monetary-2'><div class='marginalizedparent'><a class='marginalized' href='#category.monetary-2'>2</a></div><p >All specifications of member functions for
<span class='texttt'>money_put</span>
and
<span class='texttt'>money_get</span>
in the subclauses of <a href='category.monetary'>[category.monetary]</a> only apply to the
specializations required in Tables <a href='#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>).
Their members use their
<span class='texttt'>ios_base&amp;</span>,
<span class='texttt'>ios_base&nbsp;::&nbsp;iostate&amp;</span>,
and
<span class='texttt'>fill</span>
arguments as described in (<a href='locale.categories'>[locale.categories]</a>), and the
<span class='texttt'>moneypunct&lt;&gt;</span>
and
<span class='texttt'>ctype&lt;&gt;</span>
facets, to determine formatting details.</p></div><div id='locale.money.get'><h4 ><a class='secnum' href='#locale.money.get' style='min-width:118pt'>22.4.6.1</a> Class template <span class='texttt'>money_get</span> <a class='abbr_ref' href='locale.money.get'>[locale.money.get]</a></h4><p ><span class='indexparent'><a class='index' id='money_get'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT,
    class InputIterator = istreambuf_iterator&lt;charT&gt;&gt;
  class money_get : public locale::facet {
  public:
    using char_type   = charT;
    using iter_type   = InputIterator;
    using string_type = basic_string&lt;charT&gt;;

    explicit money_get(size_t refs = 0);

    iter_type get(iter_type s, iter_type end, bool intl,
                  ios_base&amp; f, ios_base::iostate&amp; err,
                  long double&amp; units) const;
    iter_type get(iter_type s, iter_type end, bool intl,
                  ios_base&amp; f, ios_base::iostate&amp; err,
                  string_type&amp; digits) const;

    static locale::id id;

  protected:
    ~money_get();
    virtual iter_type do_get(iter_type, iter_type, bool, ios_base&amp;,
                             ios_base::iostate&amp; err, long double&amp; units) const;
    virtual iter_type do_get(iter_type, iter_type, bool, ios_base&amp;,
                             ios_base::iostate&amp; err, string_type&amp; digits) const;
  };
}
</pre><div id='locale.money.get.members'><h4 ><a class='secnum' href='#locale.money.get.members' style='min-width:133pt'>22.4.6.1.1</a> <span class='texttt'>money_get</span> members <a class='abbr_ref' href='locale.money.get.members'>[locale.money.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='money_get,get'></a></span><span class='indexparent'><a class='index' id='get,money_get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, bool intl,
              ios_base&amp; f, ios_base::iostate&amp; err,
              long double&amp; quant) const;
iter_type get(s, iter_type end, bool intl, ios_base&amp;f,
              ios_base::iostate&amp; err, string_type&amp; quant) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(s, end, intl, f, err, quant)</span>.
</p></div></div></div><div id='locale.money.get.virtuals'><h4 ><a class='secnum' href='#locale.money.get.virtuals' style='min-width:133pt'>22.4.6.1.2</a> <span class='texttt'>money_get</span> virtual functions <a class='abbr_ref' href='locale.money.get.virtuals'>[locale.money.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='money_get,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,money_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base&amp; str, ios_base::iostate&amp; err,
                 long double&amp; units) const;
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base&amp; str, ios_base::iostate&amp; err,
                 string_type&amp; digits) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters from
<span class='texttt'>s</span>
to parse and construct a monetary value according to the
format specified by a
<span class='texttt'>moneypunct&lt;charT,Intl&gt;</span>
facet reference
<span class='texttt'>mp</span>
and the character mapping specified by a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet reference
<span class='texttt'>ct</span>
obtained from the locale returned by
<span class='texttt'>str.getloc()</span>,
and
<span class='texttt'>str.flags()</span>.
If a valid sequence is recognized,
does not change <span class='texttt'>err</span>;
otherwise, sets <span class='texttt'>err</span> to
<span class='texttt'>(err|str.failbit)</span>,
or
<span class='texttt'>(err|str.failbit|str.eofbit)</span>
if no more characters are available,
and does not change <span class='texttt'>units</span> or <span class='texttt'>digits</span>.
Uses the pattern returned by
<span class='texttt'>mp.neg_format()</span>
to parse all values.
The result is returned as an integral value stored in
<span class='texttt'>units</span>
or as a sequence of digits possibly preceded by a minus sign
(as produced by
<span class='texttt'>ct.widen(c)</span>
where
<span class='texttt'>c</span>
is
<span class='texttt'>'-'</span>
or in the range from
<span class='texttt'>'0'</span>
through
<span class='texttt'>'9'</span>,
inclusive)
stored in
<span class='texttt'>digits</span>.
[&nbsp;<i>Example:</i>
The sequence
<span class='texttt'>&#36;1,056.23</span>
in a common United States locale would yield, for
<span class='texttt'>units</span>,
<span class='texttt'>105623</span>,
or, for
<span class='texttt'>digits</span>,
<span class='texttt'>"105623"</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
If
<span class='texttt'>mp.grouping()</span>
indicates that no thousands separators are permitted,
any such characters are not read, and parsing is terminated at the point
where they first appear.
Otherwise, thousands separators are optional;
if present, they are checked for correct placement only after
all format components have been read.</p></div></div><div class='para' id='locale.money.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-2'>2</a></div><div class='itemdescr'><p >Where
<span class='texttt'>money_base::space</span>
or
<span class='texttt'>money_base::none</span>
appears as the last element in the format pattern,
no white space is consumed. Otherwise, where <span class='texttt'>money_base::space</span> appears in any of the
initial elements of the format pattern, at least one white space character is required. Where
<span class='texttt'>money_base::none</span> appears in any of the initial elements of the format pattern, white
space is allowed but not required.
If
<span class='texttt'>(str.flags() &amp; str.showbase)</span>
is false, the currency symbol is optional and is consumed only if
other characters are needed to complete the format;
otherwise, the currency symbol is required.</p></div></div><div class='para' id='locale.money.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-3'>3</a></div><div class='itemdescr'><p >If the first character (if any) in the string
<span class='texttt'>pos</span>
returned by
<span class='texttt'>mp.positive_sign()</span>
or the string
<span class='texttt'>neg</span>
returned by
<span class='texttt'>mp.negative_sign()</span>
is recognized in the position indicated by
<span class='texttt'>sign</span>
in the format pattern, it is consumed and any remaining characters
in the string are required after all the other format components.
[&nbsp;<i>Example:</i>
If
<span class='texttt'>showbase</span>
is off, then for a
<span class='texttt'>neg</span>
value of <span class='texttt'>"()"</span> and a currency symbol of <span class='texttt'>"L"</span>,
in <span class='texttt'>"(100 L)"</span> the <span class='texttt'>"L"</span> is consumed;
but if
<span class='texttt'>neg</span>
is <span class='texttt'>"-"</span>, the <span class='texttt'>"L"</span> in <span class='texttt'>"-100 L"</span> is not consumed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
If
<span class='texttt'>pos</span>
or
<span class='texttt'>neg</span>
is empty, the sign component is optional, and if no sign is
detected, the result is given the sign that corresponds to the source
of the empty string.
Otherwise, the character in the indicated position must
match the first character of
<span class='texttt'>pos</span>
or
<span class='texttt'>neg</span>,
and the result is given the corresponding sign.
If the first character of
<span class='texttt'>pos</span>
is equal to the first character of
<span class='texttt'>neg</span>,
or if both strings are empty, the result is given a positive sign.</p></div></div><div class='para' id='locale.money.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-4'>4</a></div><div class='itemdescr'><p >Digits in the numeric monetary component are extracted and placed in
<span class='texttt'>digits</span>,
or into a character buffer
<span class='texttt'>buf1</span>
for conversion to produce a value for
<span class='texttt'>units</span>,
in the order in which they appear,
preceded by a minus sign if and only if the result is negative.
The value
<span class='texttt'>units</span>
is produced as if by<a class='footnotenum' href='#footnote-249'>249</a></p><pre class='codeblock'>
for (int i = 0; i &lt; n; ++i)
  buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &amp;units);
</pre><p >where
<span class='texttt'>n</span>
is the number of characters placed in
<span class='texttt'>buf1</span>,
<span class='texttt'>buf2</span>
is a character buffer, and the values
<span class='texttt'>src</span>
and
<span class='texttt'>atoms</span>
are defined as if by</p><pre class='codeblock'>
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
</pre></div></div><div class='para' id='locale.money.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid monetary quantity.
</p></div></div><div class='footnote' id='footnote-249'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-249'>249)</a></div><p >The semantics here are different from
<span class='texttt'>ct.narrow</span>.</p></div></div></div><div id='locale.money.put'><h4 ><a class='secnum' href='#locale.money.put' style='min-width:118pt'>22.4.6.2</a> Class template <span class='texttt'>money_put</span> <a class='abbr_ref' href='locale.money.put'>[locale.money.put]</a></h4><p ><span class='indexparent'><a class='index' id='money_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT,
    class OutputIterator = ostreambuf_iterator&lt;charT&gt;&gt;
  class money_put : public locale::facet {
  public:
    using char_type   = charT;
    using iter_type   = OutputIterator;
    using string_type = basic_string&lt;charT&gt;;

    explicit money_put(size_t refs = 0);

    iter_type put(iter_type s, bool intl, ios_base&amp; f,
                  char_type fill, long double units) const;
    iter_type put(iter_type s, bool intl, ios_base&amp; f,
                  char_type fill, const string_type&amp; digits) const;

    static locale::id id;

  protected:
    ~money_put();
    virtual iter_type do_put(iter_type, bool, ios_base&amp;, char_type fill,
                             long double units) const;
    virtual iter_type do_put(iter_type, bool, ios_base&amp;, char_type fill,
                             const string_type&amp; digits) const;
  };
}
</pre><div id='locale.money.put.members'><h4 ><a class='secnum' href='#locale.money.put.members' style='min-width:133pt'>22.4.6.2.1</a> <span class='texttt'>money_put</span> members <a class='abbr_ref' href='locale.money.put.members'>[locale.money.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='money_put,put'></a></span><span class='indexparent'><a class='index' id='put,money_put'></a></span><code class='itemdecl'>
iter_type put(iter_type s, bool intl, ios_base&amp; f, char_type fill,
              long double quant) const;
iter_type put(iter_type s, bool intl, ios_base&amp; f, char_type fill,
              const string_type&amp; quant) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_put(s, intl, f, loc, quant)</span>.
</p></div></div></div><div id='locale.money.put.virtuals'><h4 ><a class='secnum' href='#locale.money.put.virtuals' style='min-width:133pt'>22.4.6.2.2</a> <span class='texttt'>money_put</span> virtual functions <a class='abbr_ref' href='locale.money.put.virtuals'>[locale.money.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='money_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,money_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, const string_type&amp; digits) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Writes characters to
<span class='texttt'>s</span>
according to the format specified by a
<span class='texttt'>moneypunct&lt;charT,Intl&gt;</span>
facet reference
<span class='texttt'>mp</span>
and the character mapping specified by a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet reference
<span class='texttt'>ct</span>
obtained from the locale returned by
<span class='texttt'>str.getloc()</span>,
and
<span class='texttt'>str.flags()</span>.
The argument
<span class='texttt'>units</span>
is transformed into a sequence of wide characters as if by</p><pre class='codeblock'>
ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)
</pre><p >for character buffers
<span class='texttt'>buf1</span>
and
<span class='texttt'>buf2</span>.
If the first character in
<span class='texttt'>digits</span>
or
<span class='texttt'>buf2</span>
is equal to
<span class='texttt'>ct.widen('-')</span>,
then the pattern used for formatting is the result of
<span class='texttt'>mp.neg_format()</span>;
otherwise the pattern is the result of
<span class='texttt'>mp.pos_format()</span>.
Digit characters are written, interspersed with any thousands separators
and decimal point specified by the format, in the order they appear
(after the optional leading minus sign)
in
<span class='texttt'>digits</span>
or
<span class='texttt'>buf2</span>.
In
<span class='texttt'>digits</span>,
only the optional leading minus sign and the immediately subsequent
digit characters (as classified according to
<span class='texttt'>ct</span>)
are used; any trailing characters (including digits appearing
after a non-digit character) are ignored.
Calls
<span class='texttt'>str.width(0)</span>.</p></div></div><div class='para' id='locale.money.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The currency symbol is generated if and only if
<span class='texttt'>(str.flags() &amp; str.showbase)</span>
is nonzero.
If the number of characters generated for the specified format is less than the value
returned by
<span class='texttt'>str.width()</span>
on entry to the function, then copies of
<span class='texttt'>fill</span>
are inserted as necessary to pad to the specified width.
For the value
<span class='texttt'>af</span>
equal to
<span class='texttt'>(str.flags() &amp; str.adjustfield)</span>,
if
<span class='texttt'>(af == str.internal)</span>
is <span class='texttt'>true</span>, the fill characters are placed where
<span class='texttt'>none</span>
or
<span class='texttt'>space</span>
appears in the formatting pattern; otherwise if
<span class='texttt'>(af == str.left)</span>
is <span class='texttt'>true</span>, they are placed after the other characters;
otherwise, they are placed before the other characters.
[&nbsp;<i>Note:</i>
It is possible, with some combinations of format patterns and flag values,
to produce output that cannot be parsed using
<span class='texttt'>num_get&lt;&gt;::get</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.money.put.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
</p></div></div></div></div><div id='locale.moneypunct'><h4 ><a class='secnum' href='#locale.moneypunct' style='min-width:118pt'>22.4.6.3</a> Class template <span class='texttt'>moneypunct</span> <a class='abbr_ref' href='locale.moneypunct'>[locale.moneypunct]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct'></a></span></p><pre class='codeblock'>
namespace std {
  class money_base {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
  };

  template &lt;class charT, bool International = false&gt;
  class moneypunct : public locale::facet, public money_base {
  public:
    using char_type   = charT;
    using string_type = basic_string&lt;charT&gt;;

    explicit moneypunct(size_t refs = 0);

    charT        decimal_point() const;
    charT        thousands_sep() const;
    string       grouping()      const;
    string_type  curr_symbol()   const;
    string_type  positive_sign() const;
    string_type  negative_sign() const;
    int          frac_digits()   const;
    pattern      pos_format()    const;
    pattern      neg_format()    const;

    static locale::id id;
    static const bool intl = International;

  protected:
    ~moneypunct();
    virtual charT        do_decimal_point() const;
    virtual charT        do_thousands_sep() const;
    virtual string       do_grouping()      const;
    virtual string_type  do_curr_symbol()   const;
    virtual string_type  do_positive_sign() const;
    virtual string_type  do_negative_sign() const;
    virtual int          do_frac_digits()   const;
    virtual pattern      do_pos_format()    const;
    virtual pattern      do_neg_format()    const;
  };
}
</pre><div class='para' id='locale.moneypunct-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-1'>1</a></div><p >The
<span class='texttt'>moneypunct&lt;&gt;</span>
facet defines monetary formatting parameters used by
<span class='texttt'>money_get&lt;&gt;</span>
and
<span class='texttt'>money_put&lt;&gt;</span>.
A monetary format is a sequence of four components,
specified by a
<span class='texttt'>pattern</span>
value
<span class='texttt'>p</span>,
such that the
<span class='texttt'>part</span>
value
<span class='texttt'>static_cast&lt;part&gt;(p.field[i])</span>
determines the
<span class='texttt'>i</span>th
component of the format<a class='footnotenum' href='#footnote-250'>250</a>
In the
<span class='texttt'>field</span>
member of a
<span class='texttt'>pattern</span>
object, each value
<span class='texttt'>symbol</span>,
<span class='texttt'>sign</span>,
<span class='texttt'>value</span>,
and either
<span class='texttt'>space</span>
or
<span class='texttt'>none</span>
appears exactly once.
The value
<span class='texttt'>none</span>,
if present, is not first;
the value
<span class='texttt'>space</span>,
if present, is neither first nor last.</p></div><div class='para' id='locale.moneypunct-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-2'>2</a></div><p >Where
<span class='texttt'>none</span>
or
<span class='texttt'>space</span>
appears, white space is permitted in the format,
except where
<span class='texttt'>none</span>
appears at the end, in which case no white space is permitted.
The value
<span class='texttt'>space</span>
indicates that at least one space is required at that position.
Where
<span class='texttt'>symbol</span>
appears, the sequence of characters returned by
<span class='texttt'>curr_symbol()</span>
is permitted, and can be required.
Where
<span class='texttt'>sign</span>
appears, the first (if any) of the sequence of characters returned by
<span class='texttt'>positive_sign()</span>
or
<span class='texttt'>negative_sign()</span>
(respectively as the monetary value is non-negative or negative) is required.
Any remaining characters of the sign sequence are required after all
other format components.
Where
<span class='texttt'>value</span>
appears, the absolute numeric monetary value is required.</p></div><div class='para' id='locale.moneypunct-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-3'>3</a></div><p >The format of the numeric monetary value is a decimal number:</p><pre class='codeblock'>
value ::= units [ decimal-point [ digits ]] |
  decimal-point digits
</pre><p >if
<span class='texttt'>frac_digits()</span>
returns a positive value, or</p><pre class='codeblock'>
value ::= units
</pre><p >otherwise.
The symbol
<span class='texttt'>decimal-point</span>
indicates the character returned by
<span class='texttt'>decimal_point()</span>.
The other symbols are defined as follows:</p><pre class='codeblock'>
units ::= digits [ thousands-sep units ]
digits ::= adigit [ digits ]
</pre><p >In the syntax specification, the symbol
<span class='texttt'>adigit</span>
is any of the values
<span class='texttt'>ct.widen(c)</span>
for
<span class='texttt'>c</span>
in the range
<span class='texttt'>'0'</span>
through
<span class='texttt'>'9'</span>,
inclusive, and
<span class='texttt'>ct</span>
is a reference of type
<span class='texttt'>const ctype&lt;charT&gt;&amp;</span>
obtained as described in the definitions of
<span class='texttt'>money_get&lt;&gt;</span>
and
<span class='texttt'>money_put&lt;&gt;</span>.
The symbol
<span class='texttt'>thousands-sep</span>
is the character returned by
<span class='texttt'>thousands_sep()</span>.
The space character used is the value
<span class='texttt'>ct.widen(' ')</span>.
White space characters are those characters
<span class='texttt'>c</span>
for which
<span class='texttt'>ci.is(space,c)</span>
returns
<span class='texttt'>true</span>.
The number of digits required after the decimal point (if any)
is exactly the value returned by
<span class='texttt'>frac_digits()</span>.</p></div><div class='para' id='locale.moneypunct-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-4'>4</a></div><p >The placement of thousands-separator characters (if any)
is determined by the value returned by
<span class='texttt'>grouping()</span>,
defined identically as the member
<span class='texttt'>numpunct&lt;&gt;::do_grouping()</span>.</p></div><div class='footnote' id='footnote-250'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-250'>250)</a></div><p >An array of
<span class='texttt'>char</span>,
rather than an array of
<span class='texttt'>part</span>,
is specified for
<span class='texttt'>pattern::field</span>
purely for efficiency.</p></div><div id='locale.moneypunct.members'><h4 ><a class='secnum' href='#locale.moneypunct.members' style='min-width:133pt'>22.4.6.3.1</a> <span class='texttt'>moneypunct</span> members <a class='abbr_ref' href='locale.moneypunct.members'>[locale.moneypunct.members]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct,decimal_point'></a></span><span class='indexparent'><a class='index' id='decimal_point,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,thousands_sep'></a></span><span class='indexparent'><a class='index' id='thousands_sep,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,grouping'></a></span><span class='indexparent'><a class='index' id='grouping,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,curr_symbol'></a></span><span class='indexparent'><a class='index' id='curr_symbol,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,positive_sign'></a></span><span class='indexparent'><a class='index' id='positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,negative_sign'></a></span><span class='indexparent'><a class='index' id='negative_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,frac_digits'></a></span><span class='indexparent'><a class='index' id='frac_digits,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,positive_sign'></a></span><span class='indexparent'><a class='index' id='positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,negative_sign'></a></span><span class='indexparent'><a class='index' id='negative_sign,moneypunct'></a></span></p><pre class='codeblock'>
charT        decimal_point() const;
charT        thousands_sep() const;
string       grouping()      const;
string_type  curr_symbol()   const;
string_type  positive_sign() const;
string_type  negative_sign() const;
int          frac_digits()   const;
pattern      pos_format()    const;
pattern      neg_format()    const;
</pre><div class='para' id='locale.moneypunct.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.members-1'>1</a></div><p >Each of these functions <span class='texttt'><i>F</i></span>
returns the result of calling the corresponding
virtual member function
<span class='texttt'>do_<i>F</i>()</span>.</p></div></div><div id='locale.moneypunct.virtuals'><h4 ><a class='secnum' href='#locale.moneypunct.virtuals' style='min-width:133pt'>22.4.6.3.2</a> <span class='texttt'>moneypunct</span> virtual functions <a class='abbr_ref' href='locale.moneypunct.virtuals'>[locale.moneypunct.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct,do_decimal_point'></a></span><span class='indexparent'><a class='index' id='do_decimal_point,moneypunct'></a></span><code class='itemdecl'>
charT do_decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The radix separator to use in case
<span class='texttt'>do_frac_digits()</span>
is greater than zero.<a class='footnotenum' href='#footnote-251'>251</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_thousands_sep'></a></span><span class='indexparent'><a class='index' id='do_thousands_sep,moneypunct'></a></span><code class='itemdecl'>
charT do_thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The digit group separator to use in case
<span class='texttt'>do_grouping()</span>
specifies a digit grouping pattern.<a class='footnotenum' href='#footnote-252'>252</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_grouping'></a></span><span class='indexparent'><a class='index' id='do_grouping,moneypunct'></a></span><code class='itemdecl'>
string do_grouping() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pattern defined identically as, but not necessarily equal to, the result of
<span class='texttt'>numpunct&lt;charT&gt;::do_grouping()</span>.<a class='footnotenum' href='#footnote-253'>253</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_curr_symbol'></a></span><span class='indexparent'><a class='index' id='do_curr_symbol,moneypunct'></a></span><code class='itemdecl'>
string_type do_curr_symbol() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
A string to use as the currency identifier symbol.<a class='footnotenum' href='#footnote-254'>254</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_positive_sign'></a></span><span class='indexparent'><a class='index' id='do_positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,do_negative_sign'></a></span><span class='indexparent'><a class='index' id='do_negative_sign,moneypunct'></a></span><code class='itemdecl'>
string_type do_positive_sign() const;
string_type do_negative_sign() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_positive_sign()</span>
returns the string to use to indicate a
positive monetary value;<a class='footnotenum' href='#footnote-255'>255</a>
<span class='texttt'>do_negative_sign()</span>
returns the string to use to indicate a negative value.
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_frac_digits'></a></span><span class='indexparent'><a class='index' id='do_frac_digits,moneypunct'></a></span><code class='itemdecl'>
int do_frac_digits() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The number of digits after the decimal radix separator, if any.<a class='footnotenum' href='#footnote-256'>256</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_pos_format'></a></span><span class='indexparent'><a class='index' id='do_pos_format,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,do_neg_format'></a></span><span class='indexparent'><a class='index' id='do_neg_format,moneypunct'></a></span><code class='itemdecl'>
pattern do_pos_format() const;
pattern do_neg_format() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The specializations required in Table <a href='#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>moneypunct&lt;char&gt;</span>,
<span class='texttt'>moneypunct&lt;wchar_t&gt;</span>,
<span class='texttt'>moneypunct&lt;char,true&gt;</span>,
and
<span class='texttt'>moneypunct&lt;wchar_t,true&gt;</span>,
return an object of type
<span class='texttt'>pattern</span>
initialized to
<span class='texttt'>{ symbol, sign, none, value }</span>.<a class='footnotenum' href='#footnote-257'>257</a>
</p></div></div><div class='footnote' id='footnote-251'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-251'>251)</a></div><p >In common U.S. locales this is
<span class='texttt'>'.'</span>.</p></div><div class='footnote' id='footnote-252'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-252'>252)</a></div><p >In common U.S. locales this is
<span class='texttt'>','</span>.</p></div><div class='footnote' id='footnote-253'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-253'>253)</a></div><p >To specify grouping by 3s,
the value is <span class='texttt'>"\003"</span>
<i>not</i>
<span class='texttt'>"3"</span>.</p></div><div class='footnote' id='footnote-254'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-254'>254)</a></div><p >For international
specializations (second template parameter
<span class='texttt'>true</span>)
this is typically four characters long, usually three letters and a space.</p></div><div class='footnote' id='footnote-255'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-255'>255)</a></div><p >This is usually the empty string.</p></div><div class='footnote' id='footnote-256'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-256'>256)</a></div><p >In
common U.S. locales, this is 2.</p></div><div class='footnote' id='footnote-257'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-257'>257)</a></div><p >Note that the international
symbol returned by
<span class='texttt'>do_curr_sym()</span>
usually contains a space, itself;
for example, <span class='texttt'>"USD "</span>.</p></div></div></div><div id='locale.moneypunct.byname'><h4 ><a class='secnum' href='#locale.moneypunct.byname' style='min-width:118pt'>22.4.6.4</a> Class template <span class='texttt'>moneypunct_byname</span> <a class='abbr_ref' href='locale.moneypunct.byname'>[locale.moneypunct.byname]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, bool Intl = false&gt;
  class moneypunct_byname : public moneypunct&lt;charT, Intl&gt; {
  public:
    using pattern     = money_base::pattern;
    using string_type = basic_string&lt;charT&gt;;

    explicit moneypunct_byname(const char*, size_t refs = 0);
    explicit moneypunct_byname(const string&amp;, size_t refs = 0);
  protected:
    ~moneypunct_byname();
  };
}
</pre></div></div><div id='category.messages'><h3 ><a class='secnum' href='#category.messages' style='min-width:103pt'>22.4.7</a> The message retrieval category <a class='abbr_ref' href='category.messages'>[category.messages]</a></h3><div class='para' id='category.messages-1'><div class='marginalizedparent'><a class='marginalized' href='#category.messages-1'>1</a></div><p >Class
<span class='texttt'>messages&lt;charT&gt;</span>
implements retrieval of strings from message catalogs.</p></div><div id='locale.messages'><h4 ><a class='secnum' href='#locale.messages' style='min-width:118pt'>22.4.7.1</a> Class template <span class='texttt'>messages</span> <a class='abbr_ref' href='locale.messages'>[locale.messages]</a></h4><p ><span class='indexparent'><a class='index' id='messages'></a></span></p><pre class='codeblock'>
namespace std {
  class messages_base {
  public:
    using catalog = <i>unspecified signed integer type</i>;
  };

  template &lt;class charT&gt;
  class messages : public locale::facet, public messages_base {
  public:
    using char_type   = charT;
    using string_type = basic_string&lt;charT&gt;;

    explicit messages(size_t refs = 0);

    catalog open(const basic_string&lt;char&gt;&amp; fn, const locale&amp;) const;
    string_type get(catalog c, int set, int msgid,
                     const string_type&amp; dfault) const;
    void close(catalog c) const;

    static locale::id id;

  protected:
    ~messages();
    virtual catalog do_open(const basic_string&lt;char&gt;&amp;, const locale&amp;) const;
    virtual string_type do_get(catalog, int set, int msgid,
                               const string_type&amp; dfault) const;
    virtual void do_close(catalog) const;
  };
}
</pre><div class='para' id='locale.messages-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages-1'>1</a></div><p >Values of type
<span class='texttt'>messages_base::catalog</span>
usable as arguments to members
<span class='texttt'>get</span>
and
<span class='texttt'>close</span>
can be obtained only by calling member
<span class='texttt'>open</span>.</p></div><div id='locale.messages.members'><h4 ><a class='secnum' href='#locale.messages.members' style='min-width:133pt'>22.4.7.1.1</a> <span class='texttt'>messages</span> members <a class='abbr_ref' href='locale.messages.members'>[locale.messages.members]</a></h4><p ><span class='indexparent'><a class='index' id='messages,open'></a></span><span class='indexparent'><a class='index' id='open,messages'></a></span><code class='itemdecl'>
catalog open(const basic_string&lt;char&gt;&amp; name, const locale&amp; loc) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_open(name, loc)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,get'></a></span><span class='indexparent'><a class='index' id='get,messages'></a></span><code class='itemdecl'>
string_type get(catalog cat, int set, int msgid,
                const string_type&amp; dfault) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(cat, set, msgid, dfault)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,close'></a></span><span class='indexparent'><a class='index' id='close,messages'></a></span><code class='itemdecl'>
void  close(catalog cat) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>do_close(cat)</span>.
</p></div></div></div><div id='locale.messages.virtuals'><h4 ><a class='secnum' href='#locale.messages.virtuals' style='min-width:133pt'>22.4.7.1.2</a> <span class='texttt'>messages</span> virtual functions <a class='abbr_ref' href='locale.messages.virtuals'>[locale.messages.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='messages,do_open'></a></span><span class='indexparent'><a class='index' id='do_open,messages'></a></span><code class='itemdecl'>
catalog do_open(const basic_string&lt;char&gt;&amp; name,
                const locale&amp; loc) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A value that may be passed to
<span class='texttt'>get()</span>
to retrieve a message from the message catalog identified by the string
<span class='texttt'>name</span> according to an <span class='indexparent'><a class='index' id='mapping_from_name_to_catalog_when_calling_messages::do_open'></a></span>implementation-defined mapping.
The result can be used until it is passed to
<span class='texttt'>close()</span>.</p></div></div><div class='para' id='locale.messages.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-2'>2</a></div><div class='itemdescr'><p >Returns a value less than 0 if no such catalog can be opened.</p></div></div><div class='para' id='locale.messages.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The locale argument <span class='texttt'>loc</span>
is used for character set code conversion when retrieving
messages, if needed.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,messages'></a></span><code class='itemdecl'>
string_type do_get(catalog cat, int set, int msgid,
              const string_type&amp; dfault) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>cat</span> shall be a catalog obtained from
<span class='texttt'>open()</span>
and not yet closed.</p></div></div><div class='para' id='locale.messages.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A message identified by arguments <span class='texttt'>set</span>, <span class='texttt'>msgid</span>, and <span class='texttt'>dfault</span>, according
to an <span class='indexparent'><a class='index' id='mapping_to_message_when_calling_messages::do_get'></a></span>implementation-defined mapping. If no
such message can be found, returns <span class='texttt'>dfault</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='message,do_close'></a></span><span class='indexparent'><a class='index' id='do_close,message'></a></span><code class='itemdecl'>
void do_close(catalog cat) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>cat</span> shall be a catalog obtained from
<span class='texttt'>open()</span>
and not yet closed.</p></div></div><div class='para' id='locale.messages.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Releases unspecified resources associated with  <span class='texttt'>cat</span>.</p></div></div><div class='para' id='locale.messages.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The limit on such resources, if any, is <span class='indexparent'><a class='index' id='resource_limits_on_a_message_catalog'></a></span>implementation-defined.
</p></div></div></div></div><div id='locale.messages.byname'><h4 ><a class='secnum' href='#locale.messages.byname' style='min-width:118pt'>22.4.7.2</a> Class template <span class='texttt'>messages_byname</span> <a class='abbr_ref' href='locale.messages.byname'>[locale.messages.byname]</a></h4><p ><span class='indexparent'><a class='index' id='messages_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class messages_byname : public messages&lt;charT&gt; {
  public:
    using catalog     = messages_base::catalog;
    using string_type = basic_string&lt;charT&gt;;

    explicit messages_byname(const char*, size_t refs = 0);
    explicit messages_byname(const string&amp;, size_t refs = 0);
  protected:
    ~messages_byname();
  };
}
</pre></div></div><div id='facets.examples'><h3 ><a class='secnum' href='#facets.examples' style='min-width:103pt'>22.4.8</a> Program-defined facets <a class='abbr_ref' href='facets.examples'>[facets.examples]</a></h3><div class='para' id='facets.examples-1'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-1'>1</a></div><p >A C++ program may define facets to be added to a locale and used identically as
the built-in facets.
To create a new facet interface, C++ programs simply derive from
<span class='texttt'>locale::facet</span>
a class containing a static member:
<span class='texttt'>static locale::id id</span>.</p></div><div class='para' id='facets.examples-2'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-2'>2</a></div><p >[&nbsp;<i>Note:</i>
The locale member function templates verify its type and storage class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='facets.examples-3'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-3'>3</a></div><p >[&nbsp;<i>Example:</i>
Traditional global localization is still easy:</p><pre class='codeblock'>
#include &lt;iostream&gt;
#include &lt;locale&gt;
int main(int argc, char** argv) {
  using namespace std;
  locale::global(locale(""));           <span class='comment'>// set the global locale
</span>                                        <span class='comment'>// imbue it on all the std streams
</span>  cin.imbue(locale());
  cout.imbue(locale());
  cerr.imbue(locale());
  wcin.imbue(locale());
  wcout.imbue(locale());
  wcerr.imbue(locale());

  return MyObject(argc, argv).doit();
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-4'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-4'>4</a></div><p >[&nbsp;<i>Example:</i>
Greater flexibility is possible:</p><pre class='codeblock'>
#include &lt;iostream&gt;
#include &lt;locale&gt;
int main() {
  using namespace std;
  cin.imbue(locale(""));        <span class='comment'>// the user's preferred locale
</span>  cout.imbue(locale::classic());
  double f;
  while (cin &gt;&gt; f) cout &lt;&lt; f &lt;&lt; endl;
  return (cin.fail() != 0);
}
</pre><p >In a European locale, with input
<span class='texttt'>3.456,78</span>,
output is
<span class='texttt'>3456.78</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-5'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-5'>5</a></div><p >This can be important even for simple programs, which may need to
write a data file in a fixed format, regardless of a user's preference.</p></div><div class='para' id='facets.examples-6'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-6'>6</a></div><p >[&nbsp;<i>Example:</i>
Here is an example of the use of locales in a library interface.</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>Date.h</span>
</span>#include &lt;iosfwd&gt;
#include &lt;string&gt;
#include &lt;locale&gt;

class Date {
public:
  Date(unsigned day, unsigned month, unsigned year);
  std::string asString(const std::locale&amp; = std::locale());
};

std::istream&amp; operator&gt;&gt;(std::istream&amp; s, Date&amp; d);
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Date d);
</pre></div><div class='para' id='facets.examples-7'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-7'>7</a></div><p >This example illustrates two architectural uses of class
<span class='texttt'>locale</span>.</p></div><div class='para' id='facets.examples-8'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-8'>8</a></div><p >The first is as a default argument in
<span class='texttt'>Date::asString()</span>,
where the
default is the global (presumably user-preferred) locale.</p></div><div class='para' id='facets.examples-9'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-9'>9</a></div><p >The second is in the operators
<span class='texttt'>&lt;&lt;</span>
and
<span class='texttt'>&gt;&gt;</span>,
where a locale “hitchhikes”
on another object, in this case a stream, to the point where it
is needed.</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>Date.C</span>
</span>#include "Date"                 <span class='comment'>// includes <span class='texttt'>&lt;ctime&gt;</span>
</span>#include &lt;sstream&gt;
std::string Date::asString(const std::locale&amp; l) {
  using namespace std;
  ostringstream s; s.imbue(l);
  s &lt;&lt; *this; return s.str();
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; s, Date&amp; d) {
  using namespace std;
  istream::sentry cerberos(s);
  if (cerberos) {
    ios_base::iostate err = goodbit;
    struct tm t;
    use_facet&lt;time_get&lt;char&gt;&gt;(s.getloc()).get_date(s, 0, s, err, &amp;t);
    if (!err) d = Date(t.tm_day, t.tm_mon + 1, t.tm_year + 1900);
    s.setstate(err);
  }
  return s;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-10'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-10'>10</a></div><p >A locale object may be extended with a new facet simply by constructing
it with an instance of a class derived from
<span class='texttt'>locale::facet</span>.
The only member a C++ program must define is the static member
<span class='texttt'>id</span>,
which identifies your class interface as a new facet.</p></div><div class='para' id='facets.examples-11'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-11'>11</a></div><p >[&nbsp;<i>Example:</i>
Classifying Japanese characters:</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>&lt;jctype&gt;</span>
</span>#include &lt;locale&gt;
namespace My {
  using namespace std;
  class JCtype : public locale::facet {
  public:
    static locale::id id;       <span class='comment'>// required for use as a new locale facet
</span>    bool is_kanji (wchar_t c) const;
    JCtype() { }
  protected:
    ~JCtype() { }
  };
}

<span class='comment'>// file: <span class='texttt'>filt.C</span>
</span>#include &lt;iostream&gt;
#include &lt;locale&gt;
#include "jctype"               <span class='comment'>// above
</span>std::locale::id My::JCtype::id; <span class='comment'>// the static <span class='texttt'>JCtype</span> member declared above.
</span>
int main() {
  using namespace std;
  using wctype = ctype&lt;wchar_t&gt;;
  locale loc(locale(""),        <span class='comment'>// the user's preferred locale ...
</span>         new My::JCtype);       <span class='comment'>// and a new feature ...
</span>  wchar_t c = use_facet&lt;wctype&gt;(loc).widen('!');
  if (!use_facet&lt;My::JCtype&gt;(loc).is_kanji(c))
    cout &lt;&lt; "no it isn't!" &lt;&lt; endl;
  return 0;
}
</pre></div><div class='para' id='facets.examples-12'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-12'>12</a></div><p >The new facet is used exactly like the built-in facets.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-13'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-13'>13</a></div><p >[&nbsp;<i>Example:</i>
Replacing an existing facet is even easier.
The code does not define a member
<span class='texttt'>id</span>
because it is reusing the
<span class='texttt'>numpunct&lt;charT&gt;</span>
facet interface:</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>my_bool.C</span>
</span>#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
namespace My {
  using namespace std;
  using cnumpunct = numpunct_byname&lt;char&gt;;
  class BoolNames : public cnumpunct {
  protected:
    string do_truename()  const { return "Oui Oui!"; }
    string do_falsename() const { return "Mais Non!"; }
    ~BoolNames() { }
  public:
    BoolNames(const char* name) : cnumpunct(name) { }
  };
}

int main(int argc, char** argv) {
  using namespace std;
  <span class='comment'>// make the user's preferred locale, except for...
</span>  locale loc(locale(""), new My::BoolNames(""));
  cout.imbue(loc);
  cout &lt;&lt; boolalpha &lt;&lt; "Any arguments today? " &lt;&lt; (argc &gt; 1) &lt;&lt; endl;
  return 0;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='locale.stdcvt'><h2 ><a class='secnum' href='#locale.stdcvt' style='min-width:88pt'>22.5</a> Standard code conversion facets <a class='abbr_ref' href='locale.stdcvt'>[locale.stdcvt]</a></h2><div class='para' id='locale.stdcvt-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-1'>1</a></div><p >The header <span class='texttt'>&lt;codecvt&gt;</span> provides code conversion facets for various character encodings.</p></div><div class='para' id='locale.stdcvt-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-2'>2</a></div><p ><b>Header <span class='texttt'>&lt;codecvt&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='codecvt'></a></span></p><pre class='codeblock'>
namespace std {
  enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
  };

  template&lt;class Elem, unsigned long Maxcode = 0x10ffff,
    codecvt_mode Mode = (codecvt_mode)0&gt;
  class codecvt_utf8
    : public codecvt&lt;Elem, char, mbstate_t&gt; {
  public:
    explicit codecvt_utf8(size_t refs = 0);
    ~codecvt_utf8();
  };

  template&lt;class Elem, unsigned long Maxcode = 0x10ffff,
    codecvt_mode Mode = (codecvt_mode)0&gt;
  class codecvt_utf16
    : public codecvt&lt;Elem, char, mbstate_t&gt; {
  public:
    explicit codecvt_utf16(size_t refs = 0);
    ~codecvt_utf16();
  };

  template&lt;class Elem, unsigned long Maxcode = 0x10ffff,
    codecvt_mode Mode = (codecvt_mode)0&gt;
  class codecvt_utf8_utf16
    : public codecvt&lt;Elem, char, mbstate_t&gt; {
  public:
    explicit codecvt_utf8_utf16(size_t refs = 0);
    ~codecvt_utf8_utf16();
  };
}
</pre></div><div class='para' id='locale.stdcvt-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-3'>3</a></div><p >For each of the three code conversion facets <span class='texttt'>codecvt_utf8</span>, <span class='texttt'>codecvt_utf16</span>, and <span class='texttt'>codecvt_utf8_utf16</span>:</p><ul class='itemize'><li id='locale.stdcvt-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-3.1'>(3.1)</a></div><p ><span class='texttt'>Elem</span> is the wide-character type, such as <span class='texttt'>wchar_t</span>, <span class='texttt'>char16_t</span>, or <span class='texttt'>char32_t</span>.
</p></li><li id='locale.stdcvt-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-3.2'>(3.2)</a></div><p ><span class='texttt'>Maxcode</span> is the largest wide-character code that the facet will read or write without reporting a conversion error.
</p></li><li id='locale.stdcvt-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-3.3'>(3.3)</a></div><p >If <span class='texttt'>(Mode &amp; consume_header)</span>, the facet shall consume an initial header sequence, if present, when reading a multibyte sequence to determine the endianness of the subsequent multibyte sequence to be read.
</p></li><li id='locale.stdcvt-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-3.4'>(3.4)</a></div><p >If <span class='texttt'>(Mode &amp; generate_header)</span>, the facet shall generate an initial header sequence when writing a multibyte sequence to advertise the endianness of the subsequent multibyte sequence to be written.
</p></li><li id='locale.stdcvt-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-3.5'>(3.5)</a></div><p >If <span class='texttt'>(Mode &amp; little_endian)</span>, the facet shall generate a multibyte sequence in little-endian order, as opposed to the default big-endian order.
</p></li></ul></div><div class='para' id='locale.stdcvt-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-4'>4</a></div><p >For the facet <span class='texttt'>codecvt_utf8</span>:</p><ul class='itemize'><li id='locale.stdcvt-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-4.1'>(4.1)</a></div><p >The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 (depending on the size of <span class='texttt'>Elem</span>) within the program.
</p></li><li id='locale.stdcvt-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-4.2'>(4.2)</a></div><p >Endianness shall not affect how multibyte sequences are read or written.
</p></li><li id='locale.stdcvt-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-4.3'>(4.3)</a></div><p >The multibyte sequences may be written as either a text or a binary file.
</p></li></ul></div><div class='para' id='locale.stdcvt-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-5'>5</a></div><p >For the facet <span class='texttt'>codecvt_utf16</span>:</p><ul class='itemize'><li id='locale.stdcvt-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-5.1'>(5.1)</a></div><p >The facet shall convert between UTF-16 multibyte sequences and UCS2 or UCS4 (depending on the size of <span class='texttt'>Elem</span>) within the program.
</p></li><li id='locale.stdcvt-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-5.2'>(5.2)</a></div><p >Multibyte sequences shall be read or written according to the <span class='texttt'>Mode</span> flag, as set out above.
</p></li><li id='locale.stdcvt-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-5.3'>(5.3)</a></div><p >The multibyte sequences may be written only as a binary file. Attempting to write to a text file produces undefined behavior.
</p></li></ul></div><div class='para' id='locale.stdcvt-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.stdcvt-6'>6</a></div><p >For the facet <span class='texttt'>codecvt_utf8_utf16</span>:</p><ul class='itemize'><li id='locale.stdcvt-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-6.1'>(6.1)</a></div><p >The facet shall convert between UTF-8 multibyte sequences and UTF-16 (one or two 16-bit codes) within the program.
</p></li><li id='locale.stdcvt-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-6.2'>(6.2)</a></div><p >Endianness shall not affect how multibyte sequences are read or written.
</p></li><li id='locale.stdcvt-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#locale.stdcvt-6.3'>(6.3)</a></div><p >The multibyte sequences may be written as either a text or a binary file.
</p></li></ul><p ><span class='textsc'>See also:</span> ISO/IEC 10646-1:1993.</p></div></div><div id='c.locales'><h2 ><a class='secnum' href='#c.locales' style='min-width:88pt'>22.6</a> C library locales <a class='abbr_ref' href='c.locales'>[c.locales]</a></h2><p ><b>Header <span class='texttt'>&lt;clocale&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='cassert'></a></span><span class='indexparent'><a class='index' id='lconv'></a></span><span class='indexparent'><a class='index' id='setlocale'></a></span><span class='indexparent'><a class='index' id='localeconv'></a></span><span class='indexparent'><a class='index' id='NULL'></a></span><span class='indexparent'><a class='index' id='LC_ALL'></a></span><span class='indexparent'><a class='index' id='LC_COLLATE'></a></span><span class='indexparent'><a class='index' id='LC_CTYPE'></a></span><span class='indexparent'><a class='index' id='LC_MONETARY'></a></span><span class='indexparent'><a class='index' id='LC_NUMERIC'></a></span><span class='indexparent'><a class='index' id='LC_TIME'></a></span></p><pre class='codeblock'>
namespace std {
  struct lconv;

  char* setlocale(int category, const char* locale);
  lconv* localeconv();
}

#define NULL <i>see <a href='support.types.nullptr'>[support.types.nullptr]</a></i>
#define LC_ALL <i><span class='texttt'>see below</span></i>
#define LC_COLLATE <i><span class='texttt'>see below</span></i>
#define LC_CTYPE <i><span class='texttt'>see below</span></i>
#define LC_MONETARY <i><span class='texttt'>see below</span></i>
#define LC_NUMERIC <i><span class='texttt'>see below</span></i>
#define LC_TIME <i><span class='texttt'>see below</span></i>
</pre><div class='para' id='c.locales-1'><div class='marginalizedparent'><a class='marginalized' href='#c.locales-1'>1</a></div><p ><span class='indexparent'><a class='index' id='locale.h'></a></span>The contents and meaning of the header <span class='texttt'>&lt;clocale&gt;</span>
are the same as the C standard library header <span class='texttt'>&lt;locale.h&gt;</span>.</p></div><div class='para' id='c.locales-2'><div class='marginalizedparent'><a class='marginalized' href='#c.locales-2'>2</a></div><p >Calls to the function <span class='texttt'>setlocale</span> may introduce a data
race (<a href='res.on.data.races'>[res.on.data.races]</a>) with other calls to <span class='texttt'>setlocale</span> or with calls to
the functions listed in Table <a href='#tab:setlocale.data.races'>[tab:setlocale.data.races]</a>.</p><p ><span class='textsc'>See also:</span> ISO C 7.11.</p><div class='numberedTable' id='tab:setlocale.data.races'>Table <a href='#tab:setlocale.data.races'>76</a> — Potential <span class='texttt'>setlocale</span> data races<br><table ><tr class='rowsep'><td class='left'>


<span class='texttt'>fprintf</span>     </td><td class='left'>
<span class='texttt'>isprint</span>     </td><td class='left'>
<span class='texttt'>iswdigit</span>    </td><td class='left'>
<span class='texttt'>localeconv</span>  </td><td class='left'>
<span class='texttt'>tolower</span>     </td></tr><tr ><td class='left'><span class='texttt'>fscanf</span>      </td><td class='left'>
<span class='texttt'>ispunct</span>     </td><td class='left'>
<span class='texttt'>iswgraph</span>    </td><td class='left'>
<span class='texttt'>mblen</span>       </td><td class='left'>
<span class='texttt'>toupper</span>     </td></tr><tr ><td class='left'><span class='texttt'>isalnum</span>     </td><td class='left'>
<span class='texttt'>isspace</span>     </td><td class='left'>
<span class='texttt'>iswlower</span>    </td><td class='left'>
<span class='texttt'>mbstowcs</span>    </td><td class='left'>
<span class='texttt'>towlower</span>    </td></tr><tr ><td class='left'><span class='texttt'>isalpha</span>     </td><td class='left'>
<span class='texttt'>isupper</span>     </td><td class='left'>
<span class='texttt'>iswprint</span>    </td><td class='left'>
<span class='texttt'>mbtowc</span>      </td><td class='left'>
<span class='texttt'>towupper</span>    </td></tr><tr ><td class='left'><span class='texttt'>isblank</span>     </td><td class='left'>
<span class='texttt'>iswalnum</span>    </td><td class='left'>
<span class='texttt'>iswpunct</span>    </td><td class='left'>
<span class='texttt'>setlocale</span>   </td><td class='left'>
<span class='texttt'>wcscoll</span>     </td></tr><tr ><td class='left'><span class='texttt'>iscntrl</span>     </td><td class='left'>
<span class='texttt'>iswalpha</span>    </td><td class='left'>
<span class='texttt'>iswspace</span>    </td><td class='left'>
<span class='texttt'>strcoll</span>     </td><td class='left'>
<span class='texttt'>wcstod</span>      </td></tr><tr ><td class='left'><span class='texttt'>isdigit</span>     </td><td class='left'>
<span class='texttt'>iswblank</span>    </td><td class='left'>
<span class='texttt'>iswupper</span>    </td><td class='left'>
<span class='texttt'>strerror</span>    </td><td class='left'>
<span class='texttt'>wcstombs</span>    </td></tr><tr ><td class='left'><span class='texttt'>isgraph</span>     </td><td class='left'>
<span class='texttt'>iswcntrl</span>    </td><td class='left'>
<span class='texttt'>iswxdigit</span>   </td><td class='left'>
<span class='texttt'>strtod</span>      </td><td class='left'>
<span class='texttt'>wcsxfrm</span>     </td></tr><tr ><td class='left'><span class='texttt'>islower</span>     </td><td class='left'>
<span class='texttt'>iswctype</span>    </td><td class='left'>
<span class='texttt'>isxdigit</span>    </td><td class='left'>
<span class='texttt'>strxfrm</span>     </td><td class='left'>
<span class='texttt'>wctomb</span>      </td></tr></table></div></div></div></div></div></body></html>