<!DOCTYPE html><html lang='en'><head><title>[except]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='except'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Exception handling <a class='abbr_ref' href='./#except'>[except]</a></h1><p ><span class='indexparent'><a class='index' id='exception_handling'></a></span></p><p ><span class='indexparent'><a class='index' id='exception_object'></a></span><span class='indexparent'><a class='index' id='object,_exception'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Exception handling provides a way of transferring control and information
from a point in the execution of a thread to an exception handler
associated with a point previously passed by the execution.
A handler will be invoked only by throwing an exception
in code executed in the handler's try block
or in functions called from the handler's try block.</p><p ><span class='indexparent'><a class='index' id='try'></a></span></p><pre class='bnf'><a id='nt:try-block'>try-block:</a>
    <span class='terminal'>try</span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> <i ><a href='except#nt:handler-seq'>handler-seq</a></i></pre><p ><span class='indexparent'><a class='index' id='try'></a></span></p><pre class='bnf'><a id='nt:function-try-block'>function-try-block:</a>
    <span class='terminal'>try</span> <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> <i ><a href='except#nt:handler-seq'>handler-seq</a></i></pre><pre class='bnf'><a id='nt:handler-seq'>handler-seq:</a>
    <i ><a href='except#nt:handler'>handler</a></i> <i ><a href='except#nt:handler-seq'>handler-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p ><span class='indexparent'><a class='index' id='catch'></a></span></p><pre class='bnf'><a id='nt:handler'>handler:</a>
    <span class='terminal'>catch (</span> <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> <span class='terminal'>)</span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i></pre><pre class='bnf'><a id='nt:exception-declaration'>exception-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> <i ><a href='dcl.name#nt:abstract-declarator'>abstract-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <span class='terminal'>...</span></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in an <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
appertains to the parameter of the catch clause (<a href='except.handle'>[except.handle]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,try_block'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler'></a></span><span class='indexparent'><a class='index' id='try_block'></a></span><span class='indexparent'><a class='index' id='handler'></a></span>A <i ><a href='except#nt:try-block'>try-block</a></i> is a <i ><a href='stmt.stmt#nt:statement'>statement</a></i> (Clause <a href='stmt.stmt'>[stmt.stmt]</a>).
[&nbsp;<i>Note:</i> Within this Clause
“try block” is taken to mean both <i ><a href='except#nt:try-block'>try-block</a></i> and
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,goto'></a></span><span class='indexparent'><a class='index' id='exception_handling,switch'></a></span><span class='indexparent'><a class='index' id='goto,and_try_block'></a></span><span class='indexparent'><a class='index' id='switch,and_try_block'></a></span><span class='indexparent'><a class='index' id='goto,and_handler'></a></span><span class='indexparent'><a class='index' id='switch,and_handler'></a></span>A <span class='texttt'>goto</span> or <span class='texttt'>switch</span> statement shall not be used to transfer control
into a try block or into a handler.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
void f() {
  goto l1;          <span class='comment'>// Ill-formed
</span>  goto l2;          <span class='comment'>// Ill-formed
</span>  try {
    goto l1;        <span class='comment'>// OK
</span>    goto l2;        <span class='comment'>// Ill-formed
</span>    l1: ;
  } catch (...) {
    l2: ;
    goto l1;        <span class='comment'>// Ill-formed
</span>    goto l2;        <span class='comment'>// OK
</span>  }
}

</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='goto,and_try_block'></a></span><span class='indexparent'><a class='index' id='switch,and_try_block'></a></span><span class='indexparent'><a class='index' id='return,and_try_block'></a></span><span class='indexparent'><a class='index' id='continue,and_try_block'></a></span><span class='indexparent'><a class='index' id='goto,and_handler'></a></span><span class='indexparent'><a class='index' id='switch,and_handler'></a></span><span class='indexparent'><a class='index' id='return,and_handler'></a></span><span class='indexparent'><a class='index' id='continue,and_handler'></a></span>A
<span class='texttt'>goto</span>,
<span class='texttt'>break</span>,
<span class='texttt'>return</span>,
or
<span class='texttt'>continue</span>
statement can be used to transfer control out of
a try block or handler.
When this happens, each variable declared in the try block
will be destroyed in the context that
directly contains its declaration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
lab:  try {
  T1 t1;
  try {
    T2 t2;
    if (<i>condition</i>)
      goto lab;
    } catch(...) { <span class='comment'>/* <i>handler 2</i> */</span> }
  } catch(...) { <span class='comment'>/* <i>handler 1</i> */</span> }
</pre><p >Here, executing
<span class='texttt'>goto lab;</span>
will destroy first
<span class='texttt'>t2</span>,
then
<span class='texttt'>t1</span>,
assuming the
<i ><a href='stmt.stmt#nt:condition'>condition</a></i>
does not declare a variable.
Any exception thrown while destroying
<span class='texttt'>t2</span>
will result in executing
<i>handler 2</i>;
any exception thrown while destroying
<span class='texttt'>t1</span>
will result in executing
<i>handler 1</i>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='function_try_block'></a></span><span class='indexparent'><a class='index' id='exception_handling,function_try_block'></a></span>A
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
associates a
<i ><a href='except#nt:handler-seq'>handler-seq</a></i>
with the
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>,
if present, and the
<i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>.
An exception
thrown during the execution of the
<i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
or, for constructors and destructors, during the initialization or
destruction, respectively, of the class's subobjects,
transfers control to a handler in a
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
in the same way as an exception thrown during the execution of a
<i ><a href='except#nt:try-block'>try-block</a></i>
transfers control to other handlers.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int f(int);
class C {
  int i;
  double d;
public:
  C(int, double);
};

C::C(int ii, double id)
try : i(f(ii)), d(id) {
    <span class='comment'>// constructor statements
</span>}
catch (...) {
    <span class='comment'>// handles exceptions thrown from the ctor-initializer
</span>    <span class='comment'>// and from the constructor statements
</span>}

</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >In this section, “before” and “after” refer to the
“sequenced before” relation (<a href='intro.execution'>[intro.execution]</a>).</p></div><div id='throw'><h2 ><a class='secnum' href='#throw' style='min-width:88pt'>15.1</a> Throwing an exception <a class='abbr_ref' href='except.throw'>[except.throw]</a></h2><p ><span class='indexparent'><a class='index' id='exception_handling,throwing'></a></span><span class='indexparent'><a class='index' id='throwing'></a></span></p><div class='para' id='throw-1'><div class='marginalizedparent'><a class='marginalized' href='#throw-1'>1</a></div><p >Throwing an exception transfers control to a handler.
[&nbsp;<i>Note:</i>
An exception can be thrown from one of the following contexts:
<i ><a href='expr.throw#nt:throw-expression'>throw-expressions</a></i> (<a href='expr.throw'>[expr.throw]</a>),
allocation functions (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>),
<span class='texttt'>dynamic_cast</span> (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>),
<span class='texttt'>typeid</span> (<a href='expr.typeid'>[expr.typeid]</a>),
<i ><a href='expr.new#nt:new-expression'>new-expressions</a></i> (<a href='expr.new'>[expr.new]</a>), and standard library
functions (<a href='structure.specifications'>[structure.specifications]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An object is passed and the type of that object determines which handlers
can catch it.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
throw "Help!";
</pre><p >can be caught by a
<a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a>
of
<span class='texttt'>const</span>
<span class='texttt'>char*</span>
type:
</p><pre class='codeblock'>
try {
    <span class='comment'>// ...
</span>}
catch(const char* p) {
    <span class='comment'>// handle character string exceptions here
</span>}
</pre><p >and
</p><pre class='codeblock'>
class Overflow {
public:
    Overflow(char,double,double);
};

void f(double x) {
    throw Overflow('+',x,3.45e107);
}
</pre><p >can be caught by a handler for exceptions of type
<span class='texttt'>Overflow</span>
</p><pre class='codeblock'>
try {
    f(1.2);
} catch(Overflow&amp; oo) {
    <span class='comment'>// handle exceptions of type <span class='texttt'>Overflow</span> here
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='throw-2'><div class='marginalizedparent'><a class='marginalized' href='#throw-2'>2</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,throwing'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler'></a></span><span class='indexparent'><a class='index' id='exception_handling,nearest_handler'></a></span>When an exception is thrown, control is transferred to the nearest handler with
a matching type (<a href='except.handle'>[except.handle]</a>); “nearest” means the handler
for which the
<i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> or
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
following the
<span class='texttt'>try</span>
keyword was most recently entered by the thread of control and not yet exited.</p></div><div class='para' id='throw-3'><div class='marginalizedparent'><a class='marginalized' href='#throw-3'>3</a></div><p >Throwing an exception
copy-initializes (<a href='dcl.init'>[dcl.init]</a>, <a href='class.copy'>[class.copy]</a>) a temporary object,
called the
<span class='indexparent'><a class='index' id='exception_handling,exception_object'></a></span><a class='hidden_link' href='#def:exception_object' id='def:exception_object'><i>exception object</i></a>.
An lvalue denoting the temporary is used to initialize the
variable declared in the matching
<a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a> (<a href='except.handle'>[except.handle]</a>).
If the type of the exception object would
be an incomplete type or a pointer to an incomplete
type other than (possibly cv-qualified)
<span class='texttt'>void</span> the program is ill-formed.</p></div><div class='para' id='throw-4'><div class='marginalizedparent'><a class='marginalized' href='#throw-4'>4</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,memory'></a></span><span class='indexparent'><a class='index' id='exception_handling,rethrowing'></a></span><span class='indexparent'><a class='index' id='exception_handling,exception_object'></a></span>The memory for the exception object is
allocated in an unspecified way, except as noted in <a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>.
If a handler exits by rethrowing, control is passed to another handler for
the same exception object.
The points of potential destruction for the exception object are:</p><ul class='itemize'><li id='throw-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#throw-4.1'>(4.1)</a></div><p >when an active handler for the exception exits by
any means other than
rethrowing,
immediately after the destruction of the object (if any)
declared in the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> in the handler;</p></li><li id='throw-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#throw-4.2'>(4.2)</a></div><p >when an object of type <span class='texttt'>std::exception_ptr</span> (<a href='propagation'>[propagation]</a>)
that refers to the exception object is destroyed,
before the destructor of <span class='texttt'>std::exception_ptr</span> returns.
</p></li></ul><p >Among all points of potential destruction for the exception object,
there is an unspecified last one
where the exception object is destroyed.
All other points happen before that last one (<a href='intro.races'>[intro.races]</a>).
[&nbsp;<i>Note:</i>
No other thread synchronization is implied in exception handling.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The implementation may then
deallocate the memory for the exception object; any such deallocation
is done in an unspecified way.
[&nbsp;<i>Note:</i> A thrown exception does not
propagate to other threads unless caught, stored, and rethrown using
appropriate library functions; see <a href='propagation'>[propagation]</a> and <a href='futures'>[futures]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='throw-5'><div class='marginalizedparent'><a class='marginalized' href='#throw-5'>5</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,exception_object,constructor'></a></span><span class='indexparent'><a class='index' id='exception_handling,exception_object,destructor'></a></span>When the thrown object is a class object, the constructor selected for
the copy-initialization as well as the constructor selected for
a copy-initialization considering the thrown object as an lvalue
shall be non-deleted and accessible, even if the copy/move operation is
elided (<a href='class.copy'>[class.copy]</a>).
The destructor is potentially invoked (<a href='class.dtor'>[class.dtor]</a>).</p></div><div class='para' id='throw-6'><div class='marginalizedparent'><a class='marginalized' href='#throw-6'>6</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,rethrow'></a></span><span class='indexparent'><a class='index' id='rethrow'></a></span>An exception is considered caught when a handler for that exception
becomes active (<a href='except.handle'>[except.handle]</a>).
[&nbsp;<i>Note:</i>
An exception can have active handlers and still be considered uncaught if
it is rethrown.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='throw-7'><div class='marginalizedparent'><a class='marginalized' href='#throw-7'>7</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,terminate_called'></a></span><span class='indexparent'><a class='index' id='terminate,called'></a></span>If the exception handling mechanism
handling an uncaught exception (<a href='except.uncaught'>[except.uncaught]</a>)
directly invokes a function that exits via an
exception, <span class='texttt'>std::terminate</span> is called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct C {
  C() { }
  C(const C&amp;) {
    if (std::uncaught_exceptions()) {
      throw 0;      <span class='comment'>// throw during copy to handler's <span class='grammarterm'>exception-declaration</span> object (<a href='except.handle'>[except.handle]</a>)
</span>    }
  }
};

int main() {
  try {
    throw C();      <span class='comment'>// calls <span class='texttt'>std::terminate()</span> if construction of the handler's
</span>                    <span class='comment'>// <span class='grammarterm'>exception-declaration</span> object is not elided (<a href='class.copy'>[class.copy]</a>)
</span>  } catch(C) { }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Consequently, destructors should generally catch exceptions and not let them propagate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='ctor'><h2 ><a class='secnum' href='#ctor' style='min-width:88pt'>15.2</a> Constructors and destructors <a class='abbr_ref' href='except.ctor'>[except.ctor]</a></h2><p ><span class='indexparent'><a class='index' id='exception_handling,constructors_and_destructors'></a></span><span class='indexparent'><a class='index' id='constructor,exception_handling'></a></span><span class='indexparent'><a class='index' id='destructor,exception_handling'></a></span></p><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><p ><span class='indexparent'><a class='index' id='unwinding,stack'></a></span>As control passes from the point where an exception is thrown
to a handler,
destructors are invoked by a process, specified in this section, called
<a class='hidden_link' href='#def:stack_unwinding' id='def:stack_unwinding'><i>stack unwinding</i></a>.</p></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><p >The destructor is invoked for each automatic object of class type constructed,
but not yet destroyed,
since the try block was entered.
If an exception is thrown during the destruction of temporaries or
local variables for a <span class='texttt'>return</span> statement (<a href='stmt.return'>[stmt.return]</a>),
the destructor for the returned object (if any) is also invoked.
The objects are destroyed in the reverse order of the completion
of their construction.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A { };

struct Y { ~Y() noexcept(false) { throw 0; } };

A f() {
  try {
    A a;
    Y y;
    A b;
    return {};   <span class='comment'>// #1
</span>  } catch (...) {
  }
  return {};     <span class='comment'>// #2
</span>}
</pre><p >At #1, the returned object of type <span class='texttt'>A</span> is constructed.
Then, the local variable <span class='texttt'>b</span> is destroyed (<a href='stmt.jump'>[stmt.jump]</a>).
Next, the local variable <span class='texttt'>y</span> is destroyed,
causing stack unwinding,
resulting in the destruction of the returned object,
followed by the destruction of the local variable <span class='texttt'>a</span>.
Finally, the returned object is constructed again at #2.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><p >If the initialization or destruction of an object
other than by delegating constructor
is terminated by an exception,
the destructor is invoked for
each of the object's direct subobjects
and, for a complete object, virtual base class subobjects, 
whose initialization has completed (<a href='dcl.init'>[dcl.init]</a>)
and whose destructor has not yet begun execution,
except that in the case of destruction, the variant members of a
union-like class are not destroyed.
The subobjects are destroyed in the reverse order of the completion of
their construction. Such destruction is sequenced before entering a
handler of the <i ><a href='except#nt:function-try-block'>function-try-block</a></i> of the constructor or destructor,
if any.</p></div><div class='para' id='ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#ctor-4'>4</a></div><p >If the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
of the <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i>
of a delegating constructor
for an object exits via
an exception, the object's destructor is invoked.
Such destruction is sequenced before entering a handler of the
<i ><a href='except#nt:function-try-block'>function-try-block</a></i> of a delegating constructor for that object, if any.</p></div><div class='para' id='ctor-5'><div class='marginalizedparent'><a class='marginalized' href='#ctor-5'>5</a></div><p >[&nbsp;<i>Note:</i>
If the object was allocated by a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>),
the matching deallocation function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>),
if any, is called to free the storage occupied by the object.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='handle'><h2 ><a class='secnum' href='#handle' style='min-width:88pt'>15.3</a> Handling an exception <a class='abbr_ref' href='except.handle'>[except.handle]</a></h2><p ><span class='indexparent'><a class='index' id='exception_handling,handler'></a></span>
</p><div class='para' id='handle-1'><div class='marginalizedparent'><a class='marginalized' href='#handle-1'>1</a></div><p >The
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
in a
<a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a>
describes the type(s) of exceptions that can cause
that
<a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a>
to be entered.
<span class='indexparent'><a class='index' id='exception_handling,handler,incomplete_type_in'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler,rvalue_reference_in'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler,array_in'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler,pointer_to_function_in'></a></span>The
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
shall not denote an incomplete type, an abstract class type, or an rvalue reference type.
The
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
shall not denote a pointer or reference to an
incomplete type, other than
<span class='texttt'>void*</span>,
<span class='texttt'>const</span>
<span class='texttt'>void*</span>,
<span class='texttt'>volatile</span>
<span class='texttt'>void*</span>,
or
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>void*</span>.</p></div><div class='para' id='handle-2'><div class='marginalizedparent'><a class='marginalized' href='#handle-2'>2</a></div><p >A handler of type
<span class='indexparent'><a class='index' id='array,handler_of_type'></a></span>“array of <span class='texttt'>T</span>” or
<span class='indexparent'><a class='index' id='function,handler_of_type'></a></span>function type <span class='texttt'>T</span>
is adjusted to be of type
“pointer to <span class='texttt'>T</span>”.</p></div><div class='para' id='handle-3'><div class='marginalizedparent'><a class='marginalized' href='#handle-3'>3</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,handler,match'></a></span>A
<a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a>
is a match for
an exception object
of type
<span class='texttt'>E</span>
if
</p><ul class='itemize'><li id='handle-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-3.1'>(3.1)</a></div><p >The <a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a> is of type <i>cv</i> <span class='texttt'>T</span> or
<i>cv</i> <span class='texttt'>T&amp;</span> and
<span class='texttt'>E</span> and <span class='texttt'>T</span>
are the same type (ignoring the top-level <span class='grammarterm'>cv-qualifiers</span>), or
</p></li><li id='handle-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-3.2'>(3.2)</a></div><p >the <a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a> is of type <i>cv</i> <span class='texttt'>T</span> or
<i>cv</i> <span class='texttt'>T&amp;</span> and
<span class='texttt'>T</span> is an unambiguous public base class of <span class='texttt'>E</span>, or
</p></li><li id='handle-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-3.3'>(3.3)</a></div><p >the <a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a> is of type <i>cv</i> <span class='texttt'>T</span> or <span class='texttt'>const T&amp;</span>
where <span class='texttt'>T</span> is a pointer or pointer to member type and
<span class='texttt'>E</span> is a pointer or pointer to member type
that can be converted to <span class='texttt'>T</span> by one or more of
</p><ul class='itemize'><li id='handle-3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#handle-3.3.1'>(3.3.1)</a></div><p >a standard pointer conversion (<a href='conv.ptr'>[conv.ptr]</a>) not involving conversions
to pointers to private or protected or ambiguous classes
</p></li><li id='handle-3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#handle-3.3.2'>(3.3.2)</a></div><p >a function pointer conversion (<a href='conv.fctptr'>[conv.fctptr]</a>)
</p></li><li id='handle-3.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#handle-3.3.3'>(3.3.3)</a></div><p >a qualification conversion (<a href='conv.qual'>[conv.qual]</a>), or</p></li></ul></li><li id='handle-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-3.4'>(3.4)</a></div><p >the <a class='hidden_link' href='#def:handler' id='def:handler'><i>handler</i></a> is of type <i>cv</i> <span class='texttt'>T</span> or <span class='texttt'>const T&amp;</span> where <span class='texttt'>T</span> is a pointer or pointer to member type and <span class='texttt'>E</span> is <span class='texttt'>std::nullptr_t</span>.</p></li></ul><p >[&nbsp;<i>Note:</i>
A
<i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i>
whose operand is an integer literal with value zero does not match a handler of
pointer or pointer to member type.
A handler of reference to array or function type
is never a match for any exception object (<a href='expr.throw'>[expr.throw]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class Matherr { <span class='texttt'>/* ... */</span> virtual void vf(); };
class Overflow: public Matherr { <span class='texttt'>/* ... */</span> };
class Underflow: public Matherr { <span class='texttt'>/* ... */</span> };
class Zerodivide: public Matherr { <span class='texttt'>/* ... */</span> };

void f() {
  try {
    g();
  } catch (Overflow oo) {
        <span class='comment'>// ...
</span>  } catch (Matherr mm) {
        <span class='comment'>// ...
</span>  }
}
</pre><p >Here, the
<span class='texttt'>Overflow</span>
handler will catch exceptions of type
<span class='texttt'>Overflow</span>
and the
<span class='texttt'>Matherr</span>
handler will catch exceptions of type
<span class='texttt'>Matherr</span>
and of all types publicly derived from
<span class='texttt'>Matherr</span>
including exceptions of type
<span class='texttt'>Underflow</span>
and
<span class='texttt'>Zerodivide</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='handle-4'><div class='marginalizedparent'><a class='marginalized' href='#handle-4'>4</a></div><p >The handlers for a try block are tried in order of appearance.
[&nbsp;<i>Note:</i>
This makes it possible to write handlers that can never be
executed, for example by placing a handler for a final derived class after
a handler for a corresponding unambiguous public base class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='handle-5'><div class='marginalizedparent'><a class='marginalized' href='#handle-5'>5</a></div><p >A
<span class='texttt'>...</span>
in a handler's
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
functions similarly to
<span class='texttt'>...</span>
in a function parameter declaration;
it specifies a match for any exception.
If present, a
<span class='texttt'>...</span>
handler shall be the last handler for its try block.</p></div><div class='para' id='handle-6'><div class='marginalizedparent'><a class='marginalized' href='#handle-6'>6</a></div><p >If no match is found among the handlers for a try block,
the search for a matching
handler continues in a dynamically surrounding try block
of the same thread.</p></div><div class='para' id='handle-7'><div class='marginalizedparent'><a class='marginalized' href='#handle-7'>7</a></div><p >A handler is considered active when initialization is complete for
the parameter (if any) of the catch clause.
[&nbsp;<i>Note:</i>
The stack will have been unwound at that point.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Also, an implicit handler is considered active when
<span class='texttt'>std::terminate()</span>
is entered due to a throw. A handler is no longer considered active when the
catch clause exits.</p></div><div class='para' id='handle-8'><div class='marginalizedparent'><a class='marginalized' href='#handle-8'>8</a></div><p >The exception with the most recently activated handler that is
still active is called the
<a class='hidden_link' href='#def:currently_handled_exception' id='def:currently_handled_exception'><i>currently handled exception</i></a>.</p></div><div class='para' id='handle-9'><div class='marginalizedparent'><a class='marginalized' href='#handle-9'>9</a></div><p >If no matching handler is found,
the function
<span class='texttt'>std::terminate()</span>
is called;
whether or not the stack is unwound before this call to
<span class='texttt'>std::terminate()</span>
is <span class='indexparent'><a class='index' id='stack_unwinding_before_call_to_std::terminate()'></a></span>implementation-defined (<a href='except.terminate'>[except.terminate]</a>).</p></div><div class='para' id='handle-10'><div class='marginalizedparent'><a class='marginalized' href='#handle-10'>10</a></div><p >Referring to any non-static member or base class of an object
in the handler for a
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
of a constructor or destructor for that object results in undefined behavior.</p></div><div class='para' id='handle-11'><div class='marginalizedparent'><a class='marginalized' href='#handle-11'>11</a></div><p >The scope and lifetime of the parameters of a function or constructor
extend into the handlers of a
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>.</p></div><div class='para' id='handle-12'><div class='marginalizedparent'><a class='marginalized' href='#handle-12'>12</a></div><p >Exceptions thrown in destructors of objects with static storage duration or in
constructors of namespace-scope objects with static storage duration are not caught by a
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
on
<span class='texttt'>main()</span>. Exceptions thrown in destructors of objects with thread storage duration or in constructors of namespace-scope objects with thread storage duration are not caught by a
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
on the initial function of the thread.</p></div><div class='para' id='handle-13'><div class='marginalizedparent'><a class='marginalized' href='#handle-13'>13</a></div><p >If a return statement appears in a handler of the
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
of a
constructor, the program is ill-formed.</p></div><div class='para' id='handle-14'><div class='marginalizedparent'><a class='marginalized' href='#handle-14'>14</a></div><p >The currently handled exception
is rethrown if control reaches the end of a handler of the
<i ><a href='except#nt:function-try-block'>function-try-block</a></i>
of a constructor or destructor.
Otherwise, flowing off the end of
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
of a <i ><a href='except#nt:handler'>handler</a></i>
of a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>
is equivalent to flowing off the end of
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
of that function (see <a href='stmt.return'>[stmt.return]</a>).</p></div><div class='para' id='handle-15'><div class='marginalizedparent'><a class='marginalized' href='#handle-15'>15</a></div><p >The variable declared by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>, of type
<i>cv</i> <span class='texttt'>T</span> or <i>cv</i> <span class='texttt'>T&amp;</span>, is initialized from the exception object,
of type <span class='texttt'>E</span>, as follows:</p><ul class='itemize'><li id='handle-15.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-15.1'>(15.1)</a></div><p >if <span class='texttt'>T</span> is a base class of <span class='texttt'>E</span>, the variable is
copy-initialized (<a href='dcl.init'>[dcl.init]</a>) from the corresponding base class subobject
of the exception object;
</p></li><li id='handle-15.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#handle-15.2'>(15.2)</a></div><p >otherwise, the variable is copy-initialized (<a href='dcl.init'>[dcl.init]</a>)
from the exception object.
</p></li></ul><p >The lifetime of the variable ends
when the handler exits, after the
destruction of any automatic objects initialized
within the handler.</p></div><div class='para' id='handle-16'><div class='marginalizedparent'><a class='marginalized' href='#handle-16'>16</a></div><p >When the handler declares an object,
any changes to that object will not affect the exception object.
When the handler declares a reference to an object,
any changes to the referenced object are changes to the
exception object and will have effect should that object be rethrown.<span class='indexparent'><a class='index' id='exception_handling,handler,match'></a></span><span class='indexparent'><a class='index' id='exception_handling,handler'></a></span></p></div></div><div id='spec'><h2 ><a class='secnum' href='#spec' style='min-width:88pt'>15.4</a> Exception specifications <a class='abbr_ref' href='except.spec'>[except.spec]</a></h2><p ><span class='indexparent'><a class='index' id='exception_specification'></a></span></p><div class='para' id='spec-1'><div class='marginalizedparent'><a class='marginalized' href='#spec-1'>1</a></div><p >The predicate indicating whether a function cannot exit via an exception
is called the <a class='hidden_link' href='#def:exception_specification' id='def:exception_specification'><i>exception specification</i></a> of the function.
If the predicate is false,
the function has a
<span class='indexparent'><a class='index' id='exception_specification,potentially-throwing'></a></span><span class='defnx'>potentially-throwing exception specification</span>otherwise it has a
<span class='indexparent'><a class='index' id='exception_specification,non-throwing'></a></span><a class='hidden_link' href='#def:non-throwing_exception_specification' id='def:non-throwing_exception_specification'><i>non-throwing exception specification</i></a>.
The exception specification is either defined implicitly,
or defined explicitly
by using a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
as a suffix of a function declarator (<a href='dcl.fct'>[dcl.fct]</a>).</p><pre class='bnf'><a id='nt:noexcept-specifier'>noexcept-specifier:</a>
    <span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>)</span>
    <span class='terminal'>noexcept</span>
    <span class='terminal'>throw</span> <span class='terminal'>(</span> <span class='terminal'>)</span></pre></div><div class='para' id='spec-2'><div class='marginalizedparent'><a class='marginalized' href='#spec-2'>2</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,noexcept,constant_expression_and'></a></span>In a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>, the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i>,
if supplied, shall be a contextually converted constant expression
of type <span class='texttt'>bool</span> (<a href='expr.const'>[expr.const]</a>);
that constant expression is the exception specification of
the function type in which the <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> appears. 
A <span class='texttt'>(</span> token that follows <span class='texttt'>noexcept</span> is part of the
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> and does not commence an
initializer (<a href='dcl.init'>[dcl.init]</a>).
The <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> <span class='texttt'>noexcept</span>
without a <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i>
is
equivalent to the <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
<span class='texttt'>noexcept(true)</span>.
The <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> <span class='texttt'>throw()</span>
is deprecated (<a href='depr.except.spec'>[depr.except.spec]</a>), and
equivalent to the <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
<span class='texttt'>noexcept(true)</span>.</p></div><div class='para' id='spec-3'><div class='marginalizedparent'><a class='marginalized' href='#spec-3'>3</a></div><p >If a declaration of a function
does not have a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>,
the declaration has a potentially throwing exception specification
unless it is a destructor or a deallocation function
or is defaulted on its first declaration,
in which cases the exception specfication
is as specified below
and no other declaration for that function
shall have a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>.
In an explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>)
a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> may be specified,
but is not required.
If a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> is specified
in an explicit instantiation directive,
the exception specification shall be the same as
the exception specification of all other declarations of that function.
A diagnostic is required only if the
exception specifications are not the same
within a single translation unit.</p></div><div class='para' id='spec-4'><div class='marginalizedparent'><a class='marginalized' href='#spec-4'>4</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,virtual_function_and'></a></span>If a virtual function has a
non-throwing exception specification,
all declarations, including the definition, of any function
that overrides that virtual function in any derived class
shall have a non-throwing
exception specification,
unless the overriding function is defined as deleted.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B {
  virtual void f() noexcept;
  virtual void g();
  virtual void h() noexcept = delete;
};

struct D: B {
  void f();                     <span class='comment'>// ill-formed
</span>  void g() noexcept;            <span class='comment'>// OK
</span>  void h() = delete;            <span class='comment'>// OK
</span>};
</pre><p >The declaration of
<span class='texttt'>D::f</span>
is ill-formed because it
has a potentially-throwing exception specification,
whereas
<span class='texttt'>B::f</span>
has a non-throwing exception specification.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='spec-5'><div class='marginalizedparent'><a class='marginalized' href='#spec-5'>5</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,terminate_called'></a></span><span class='indexparent'><a class='index' id='terminate,called'></a></span>Whenever an exception is thrown
and the search for a handler (<a href='except.handle'>[except.handle]</a>)
encounters the outermost block of a function with a
non-throwing exception specification,
the function <span class='texttt'>std::terminate()</span> is called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i>
An implementation shall not reject an expression merely because, when
executed, it throws or might
throw an exception from a function with a non-throwing exception specification.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
extern void f();       <span class='comment'>// potentially-throwing
</span>
void g() noexcept {
  f();                 <span class='comment'>// valid, even if <span class='texttt'>f</span> throws
</span>  throw 42;            <span class='comment'>// valid, effectively a call to <span class='texttt'>std::terminate</span>
</span>}
</pre><p >The call to
<span class='texttt'>f</span>
is well-formed even though, when called,
<span class='texttt'>f</span>
might throw exception.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='spec-6'><div class='marginalizedparent'><a class='marginalized' href='#spec-6'>6</a></div><p >An expression <span class='texttt'>e</span> is
<a class='hidden_link' href='#def:potentially-throwing,expression' id='def:potentially-throwing,expression'><i>potentially-throwing</i></a> if</p><ul class='itemize'><li id='spec-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.1'>(6.1)</a></div><p ><span class='texttt'>e</span> is a function call (<a href='expr.call'>[expr.call]</a>)
whose <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
has a function type,
or a pointer-to-function type,
with a potentially-throwing exception specification,
or
</p></li><li id='spec-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.2'>(6.2)</a></div><p ><span class='texttt'>e</span> implicitly invokes a function
(such as an overloaded operator,
an allocation function in a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
a constructor for a function argument,
or a destructor if <span class='texttt'>e</span> is a full-expression (<a href='intro.execution'>[intro.execution]</a>))
that is potentially-throwing,
or
</p></li><li id='spec-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.3'>(6.3)</a></div><p ><span class='texttt'>e</span> is a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>),
or
</p></li><li id='spec-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.4'>(6.4)</a></div><p ><span class='texttt'>e</span> is a <span class='texttt'>dynamic_cast</span> expression that casts to a reference type and
requires a runtime check (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>),
or
</p></li><li id='spec-6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.5'>(6.5)</a></div><p ><span class='texttt'>e</span> is a <span class='texttt'>typeid</span> expression applied to a
(possibly parenthesized) built-in unary <span class='texttt'>*</span> operator
applied to a pointer to a
polymorphic class type (<a href='expr.typeid'>[expr.typeid]</a>),
or
</p></li><li id='spec-6.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-6.6'>(6.6)</a></div><p >any of the immediate subexpressions (<a href='intro.execution'>[intro.execution]</a>)
of <span class='texttt'>e</span> is potentially-throwing.
</p></li></ul></div><div class='para' id='spec-7'><div class='marginalizedparent'><a class='marginalized' href='#spec-7'>7</a></div><p >An implicitly-declared constructor for a class <span class='texttt'>X</span>,
or a constructor without a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
that is defaulted on its first declaration,
has a potentially-throwing exception specification
if and only if
any of the following constructs is potentially-throwing:</p><ul class='itemize'><li id='spec-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-7.1'>(7.1)</a></div><p >a constructor selected by overload resolution
in the implicit definition of the constructor
for class <span class='texttt'>X</span>
to initialize a potentially constructed subobject, or
</p></li><li id='spec-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-7.2'>(7.2)</a></div><p >a subexpression of such an initialization,
such as a default argument expression, or,
</p></li><li id='spec-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-7.3'>(7.3)</a></div><p >for a default constructor, a default member initializer.
</p></li></ul><p >[&nbsp;<i>Note:</i>
Even though destructors for fully-constructed subobjects
are invoked when an exception is thrown
during the execution of a constructor (<a href='except.ctor'>[except.ctor]</a>),
their exception specifications do not contribute
to the exception specification of the constructor,
because an exception thrown from such a destructor
would call <span class='texttt'>std::terminate</span>
rather than escape the constructor (<a href='except.throw'>[except.throw]</a>, <a href='except.terminate'>[except.terminate]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='spec-8'><div class='marginalizedparent'><a class='marginalized' href='#spec-8'>8</a></div><p >The exception specification for an implicitly-declared destructor,
or a destructor without a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>,
is potentially-throwing if and only if
any of the destructors
for any of its potentially constructed subojects
is potentially throwing.</p></div><div class='para' id='spec-9'><div class='marginalizedparent'><a class='marginalized' href='#spec-9'>9</a></div><p >The exception specification for an implicitly-declared assignment operator,
or an assignment-operator without a <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
that is defaulted on its first declaration,
is potentially-throwing if and only if
the invocation of any assignment operator
in the implicit definition is potentially-throwing.</p></div><div class='para' id='spec-10'><div class='marginalizedparent'><a class='marginalized' href='#spec-10'>10</a></div><p >A deallocation function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
with no explicit <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>
has a non-throwing exception specification.</p></div><div class='para' id='spec-11'><div class='marginalizedparent'><a class='marginalized' href='#spec-11'>11</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  A(int = (A(5), 0)) noexcept;
  A(const A&amp;) noexcept;
  A(A&amp;&amp;) noexcept;
  ~A();
};
struct B {
  B() throw();
  B(const B&amp;) = default;  <span class='comment'>// implicit exception specification is <span class='texttt'>noexcept(true)</span>
</span>  B(B&amp;&amp;, int = (throw Y(), 0)) noexcept;
  ~B() noexcept(false);
};
int n = 7;
struct D : public A, public B {
    int * p = new int[n];
    <span class='comment'>// <span class='texttt'>D::D()</span> potentially-throwing, as the <span class='texttt'>new</span> operator may throw <span class='texttt'>bad_alloc</span> or <span class='texttt'>bad_array_new_length</span>
</span>    <span class='comment'>// <span class='texttt'>D::D(const D&amp;)</span> non-throwing
</span>    <span class='comment'>// <span class='texttt'>D::D(D&amp;&amp;)</span> potentially-throwing, as the default argument for <span class='texttt'>B</span>'s constructor may throw
</span>    <span class='comment'>// <span class='texttt'>D:: D()</span> potentially-throwing
</span>};
</pre><p >Furthermore, if
<span class='texttt'>A::~A()</span>
were virtual,
the program would be ill-formed since a function that overrides a virtual
function from a base class
shall not have a potentially-throwing exception specification
if the base class function has a non-throwing exception specification.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='spec-12'><div class='marginalizedparent'><a class='marginalized' href='#spec-12'>12</a></div><p >An exception specification is considered to be <a class='hidden_link' href='#def:needed,exception_specification' id='def:needed,exception_specification'><i>needed</i></a> when:</p><ul class='itemize'><li id='spec-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-12.1'>(12.1)</a></div><p >in an expression, the function is the unique lookup result or the selected
member of a set of overloaded functions (<a href='basic.lookup'>[basic.lookup]</a>, <a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>);</p></li><li id='spec-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-12.2'>(12.2)</a></div><p >the function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) or, if it appears in an
unevaluated operand, would be odr-used if the expression were
potentially-evaluated;</p></li><li id='spec-12.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-12.3'>(12.3)</a></div><p >the exception specification is compared to that of another
declaration (e.g., an explicit specialization or an overriding virtual
function);</p></li><li id='spec-12.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-12.4'>(12.4)</a></div><p >the function is defined; or</p></li><li id='spec-12.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#spec-12.5'>(12.5)</a></div><p >the exception specification is needed for a defaulted
special member function that calls the function.
[&nbsp;<i>Note:</i> A defaulted declaration does not require the
exception specification of a base member function to be evaluated
until the implicit exception specification of the derived
function is needed, but an explicit <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> needs
the implicit exception specification to compare against.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >The exception specification of a defaulted special member
function is evaluated as described above only when needed; similarly, the
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> of a specialization of a function
template or member function of a class template is instantiated only when
needed.</p></div></div><div id='special'><h2 ><a class='secnum' href='#special' style='min-width:88pt'>15.5</a> Special functions <a class='abbr_ref' href='except.special'>[except.special]</a></h2><div class='para' id='special-1'><div class='marginalizedparent'><a class='marginalized' href='#special-1'>1</a></div><p >The function <span class='texttt'>std::terminate()</span> (<a href='except.terminate'>[except.terminate]</a>)
is used by the exception
handling mechanism for coping with errors related to the exception handling
mechanism itself. The function
<span class='texttt'>std::current_exception()</span> (<a href='propagation'>[propagation]</a>) and the class
<span class='texttt'>std::nested_exception</span> (<a href='except.nested'>[except.nested]</a>) can be used by a program to
capture the currently handled exception.</p></div><div id='terminate'><h3 ><a class='secnum' href='#terminate' style='min-width:103pt'>15.5.1</a> The <span class='texttt'>std::terminate()</span> function <a class='abbr_ref' href='except.terminate'>[except.terminate]</a></h3><div class='para' id='terminate-1'><div class='marginalizedparent'><a class='marginalized' href='#terminate-1'>1</a></div><p ><span class='indexparent'><a class='index' id='terminate'></a></span>In some situations exception handling must be abandoned
for less subtle error handling techniques. [&nbsp;<i>Note:</i> These situations are:</p><p ><span class='indexparent'><a class='index' id='terminate,called'></a></span></p><ul class='itemize'><li id='terminate-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.1'>(1.1)</a></div><p >when the exception handling mechanism, after completing
the initialization of the exception object
but before
activation of a handler for the exception (<a href='except.throw'>[except.throw]</a>),
calls a function that exits
via an exception, or</p></li><li id='terminate-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.2'>(1.2)</a></div><p >when the exception handling mechanism cannot find a handler for a thrown exception (<a href='except.handle'>[except.handle]</a>), or</p></li><li id='terminate-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.3'>(1.3)</a></div><p >when the search for a handler (<a href='except.handle'>[except.handle]</a>) encounters the
outermost block of a function
with a non-throwing exception specification (<a href='except.spec'>[except.spec]</a>), or</p></li><li id='terminate-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.4'>(1.4)</a></div><p >when the destruction of an object during stack unwinding (<a href='except.ctor'>[except.ctor]</a>)
terminates by throwing an exception, or</p></li><li id='terminate-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.5'>(1.5)</a></div><p >when initialization of a non-local
variable with static or thread storage duration (<a href='basic.start.dynamic'>[basic.start.dynamic]</a>)
exits via an exception, or</p></li><li id='terminate-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.6'>(1.6)</a></div><p >when destruction of an object with static or thread storage duration exits
via an exception (<a href='basic.start.term'>[basic.start.term]</a>), or</p></li><li id='terminate-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.7'>(1.7)</a></div><p >when execution of a function registered with
<span class='texttt'>std::atexit</span> or <span class='texttt'>std::at_quick_exit</span>
exits via an exception (<a href='support.start.term'>[support.start.term]</a>), or</p></li><li id='terminate-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.8'>(1.8)</a></div><p >when a
<i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>)
with no operand attempts to rethrow an exception and no exception is being
handled (<a href='except.throw'>[except.throw]</a>), or</p></li><li id='terminate-1.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.9'>(1.9)</a></div><p >when the function <span class='texttt'>std::nested_exception::rethrow_nested</span> is called for an object
that has captured no exception (<a href='except.nested'>[except.nested]</a>), or</p></li><li id='terminate-1.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.10'>(1.10)</a></div><p >when execution of the initial function of a thread exits via
an exception (<a href='thread.thread.constr'>[thread.thread.constr]</a>), or</p></li><li id='terminate-1.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.11'>(1.11)</a></div><p >for a parallel algorithm whose <span class='texttt'>ExecutionPolicy</span> specifies such
behavior (<a href='execpol.seq'>[execpol.seq]</a>, <a href='execpol.par'>[execpol.par]</a>, <a href='execpol.parunseq'>[execpol.parunseq]</a>),
when execution of an element access function (<a href='algorithms.parallel.defns'>[algorithms.parallel.defns]</a>)
of the parallel algorithm exits via an exception (<a href='algorithms.parallel.exceptions'>[algorithms.parallel.exceptions]</a>), or</p></li><li id='terminate-1.12'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.12'>(1.12)</a></div><p >when the destructor or the copy assignment operator is invoked on an object
of type <span class='texttt'>std::thread</span> that refers to a joinable thread
(<a href='thread.thread.destr'>[thread.thread.destr]</a>, <a href='thread.thread.assign'>[thread.thread.assign]</a>), or</p></li><li id='terminate-1.13'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#terminate-1.13'>(1.13)</a></div><p >when a call to a <span class='texttt'>wait()</span>, <span class='texttt'>wait_until()</span>, or <span class='texttt'>wait_for()</span>
function on a condition variable (<a href='thread.condition.condvar'>[thread.condition.condvar]</a>, <a href='thread.condition.condvarany'>[thread.condition.condvarany]</a>)
fails to meet a postcondition.</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='terminate-2'><div class='marginalizedparent'><a class='marginalized' href='#terminate-2'>2</a></div><p ><span class='indexparent'><a class='index' id='terminate'></a></span>In such cases,
<span class='texttt'>std::terminate()</span>
is called (<a href='exception.terminate'>[exception.terminate]</a>).
In the situation where no matching handler is found, it is
<span class='indexparent'><a class='index' id='stack_unwinding_before_call_to_std::terminate()'></a></span>implementation-defined whether or not the
stack is unwound
before
<span class='texttt'>std::terminate()</span>
is called.
In the situation where the search for a handler (<a href='except.handle'>[except.handle]</a>) encounters the
outermost block of a function
with a non-throwing exception specification (<a href='except.spec'>[except.spec]</a>), it is
<span class='indexparent'><a class='index' id='whether_stack_is_unwound_before_calling_std::terminate()_when_a_noexcept_specification_is_violated'></a></span>implementation-defined
whether the stack is unwound, unwound partially, or not unwound at all
before <span class='texttt'>std::terminate()</span> is called.
In all other situations, the stack shall not be unwound before
<span class='texttt'>std::terminate()</span>
is called.
An implementation is not permitted to finish stack unwinding
prematurely based on a determination that the unwind process
will eventually cause a call to
<span class='texttt'>std::terminate()</span>.</p></div></div><div id='uncaught'><h3 ><a class='secnum' href='#uncaught' style='min-width:103pt'>15.5.2</a> The <span class='texttt'>std::uncaught_exceptions()</span> function <a class='abbr_ref' href='except.uncaught'>[except.uncaught]</a></h3><p ><span class='indexparent'><a class='index' id='uncaught_exceptions'></a></span></p><div class='para' id='uncaught-1'><div class='marginalizedparent'><a class='marginalized' href='#uncaught-1'>1</a></div><p >An exception is considered uncaught
after completing the initialization of the exception object (<a href='except.throw'>[except.throw]</a>)
until completing the activation of a handler for the exception (<a href='except.handle'>[except.handle]</a>).
This includes stack unwinding.
If an exception is rethrown (<a href='expr.throw'>[expr.throw]</a>, <a href='propagation'>[propagation]</a>),
it is considered uncaught from the point of rethrow
until the rethrown exception is caught.
The function <span class='texttt'>std::uncaught_exceptions()</span> (<a href='uncaught.exceptions'>[uncaught.exceptions]</a>)
returns the number of uncaught exceptions in the current thread.<span class='indexparent'><a class='index' id='exception_handling'></a></span>
</p></div></div></div></div></div></body></html>