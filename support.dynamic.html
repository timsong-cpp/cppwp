<!DOCTYPE html><html lang='en'><head><title>[support.dynamic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>18</a> Language support library <a class='abbr_ref' href='./#language.support'>[language.support]</a></h1><div id='support.dynamic'><h2 ><a class='secnum' style='min-width:88pt'>18.6</a> Dynamic memory management <a class='abbr_ref'>[support.dynamic]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The header
<span class='texttt'>&lt;new&gt;</span>
defines several
functions that manage the allocation of dynamic storage in a program.
It also defines components for reporting storage management errors.</p></div><div id='new.syn'><h3 ><a class='secnum' href='#new.syn' style='min-width:103pt'>18.6.1</a> Header <span class='texttt'>&lt;new&gt;</span> synopsis <a class='abbr_ref' href='new.syn'>[new.syn]</a></h3><p ><span class='indexparent'><a class='index' id='new'></a></span><span class='indexparent'><a class='index' id='new'></a></span><span class='indexparent'><a class='index' id='align_val_t'></a></span><span class='indexparent'><a class='index' id='nothrow_t'></a></span><span class='indexparent'><a class='index' id='nothrow'></a></span></p><pre class='codeblock'>
namespace std {
  class bad_alloc;
  class bad_array_new_length;
  enum class align_val_t : size_t {};
  struct nothrow_t { explicit nothrow_t() = default; };
  extern const nothrow_t nothrow;
  using new_handler = void (*)();
  new_handler get_new_handler() noexcept;
  new_handler set_new_handler(new_handler new_p) noexcept;

  <span class='comment'>// <a href='ptr.launder'>[ptr.launder]</a>, pointer optimization barrier
</span>  template &lt;class T&gt; constexpr T* launder(T* p) noexcept;

  <span class='comment'>// <a href='hardware.interference'>[hardware.interference]</a>, hardware interference size
</span>  static constexpr size_t hardware_destructive_interference_size = <i>implementation-defined</i>;
  static constexpr size_t hardware_constructive_interference_size = <i>implementation-defined</i>;
}

void* operator new(std::size_t size);
void* operator new(std::size_t size, std::align_val_t alignment);
void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new(std::size_t size, std::align_val_t alignment,
                   const std::nothrow_t&amp;) noexcept;
void  operator delete(void* ptr) noexcept;
void  operator delete(void* ptr, std::size_t size) noexcept;
void  operator delete(void* ptr, std::align_val_t alignment) noexcept;
void  operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
void  operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;
void  operator delete(void* ptr, std::align_val_t alignment,
                      const std::nothrow_t&amp;) noexcept;
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, std::align_val_t alignment);
void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new[](std::size_t size, std::align_val_t alignment,
                     const std::nothrow_t&amp;) noexcept;
void  operator delete[](void* ptr) noexcept;
void  operator delete[](void* ptr, std::size_t size) noexcept;
void  operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void  operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
void  operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;
void  operator delete[](void* ptr, std::align_val_t alignment,
                        const std::nothrow_t&amp;) noexcept;

void* operator new  (std::size_t size, void* ptr) noexcept;
void* operator new[](std::size_t size, void* ptr) noexcept;
void  operator delete  (void* ptr, void*) noexcept;
void  operator delete[](void* ptr, void*) noexcept;
</pre><p ><span class='textsc'>See also:</span> <a href='intro.memory'>[intro.memory]</a>, <a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>,
<a href='expr.new'>[expr.new]</a>, <a href='expr.delete'>[expr.delete]</a>, <a href='class.free'>[class.free]</a>,
<a href='memory'>[memory]</a>.</p></div><div id='new.delete'><h3 ><a class='secnum' href='#new.delete' style='min-width:103pt'>18.6.2</a> Storage allocation and deallocation <a class='abbr_ref' href='new.delete'>[new.delete]</a></h3><div class='para' id='new.delete-1'><div class='marginalizedparent'><a class='marginalized' href='#new.delete-1'>1</a></div><p >Except where otherwise specified, the provisions of (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>)
apply to the library versions of <span class='texttt'>operator new</span> and <span class='texttt'>operator
delete</span>.
If the value of an alignment argument
passed to any of these functions
is not a valid alignment value,
the behavior is undefined.</p></div><div id='new.delete.single'><h4 ><a class='secnum' href='#new.delete.single' style='min-width:118pt'>18.6.2.1</a> Single-object forms <a class='abbr_ref' href='new.delete.single'>[new.delete.single]</a></h4><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size);
void* operator new(std::size_t size, std::align_val_t alignment);
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.single-1'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
allocation functions (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>)
called by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>)
to allocate
<span class='texttt'>size</span> bytes of storage.
The second form is called for a type with new-extended alignment,
and allocates storage
with the specified alignment.
The first form is called otherwise,
and allocates storage
suitably aligned to represent any object of that size
provided the object's type does not have new-extended alignment.</p></div></div><div class='para' id='new.delete.single-2'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-2'>2</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.single-3'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-3'>3</a></div><div class='itemdescr'><p ><i>Required behavior:</i> 
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else throw a
<span class='texttt'>bad_alloc</span>
<span class='indexparent'><a class='index' id='bad_alloc'></a></span>exception.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='new.delete.single-4'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-4'>4</a></div><div class='itemdescr'><p ><i>Default behavior:</i></p><ul class='itemize'><li id='new.delete.single-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.delete.single-4.1'>(4.1)</a></div><p >Executes a loop:
Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the C standard library functions
<span class='texttt'>malloc</span> or <span class='texttt'>aligned_alloc</span>
is unspecified.
<span class='indexparent'><a class='index' id='unspecified'></a></span></p></li><li id='new.delete.single-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.delete.single-4.2'>(4.2)</a></div><p >Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the
current <span class='texttt'>new_handler</span> (<a href='get.new.handler'>[get.new.handler]</a>) is
a null pointer value, throws
<span class='texttt'>bad_alloc</span>.
</p></li><li id='new.delete.single-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.delete.single-4.3'>(4.3)</a></div><p >Otherwise, the function calls the current
<span class='texttt'>new_handler</span> function (<a href='new.handler'>[new.handler]</a>).
If the called function returns, the loop repeats.
</p></li><li id='new.delete.single-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.delete.single-4.4'>(4.4)</a></div><p >The loop terminates when an attempt to allocate the requested storage is
successful or when a called
<span class='texttt'>new_handler</span>
function does not return.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.single-5'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Same as above, except that these are called by a placement version of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
when a C++ program prefers a null pointer result as an error indication,
instead of a
<span class='texttt'>bad_alloc</span>
exception.</p></div></div><div class='para' id='new.delete.single-6'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-6'>6</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.single-7'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-7'>7</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else return a null pointer.
Each of these nothrow versions of
<span class='texttt'>operator new</span>
returns a pointer obtained as if
acquired from the (possibly replaced)
corresponding non-placement function.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='new.delete.single-8'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-8'>8</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator new(size)</span>,
or <span class='texttt'>operator new(size, alignment)</span>,
respectively.
If the call returns normally,
returns the result of that call.
Otherwise, returns a null pointer.</p></div></div><div class='para' id='new.delete.single-9'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
T* p1 = new T;                  <span class='comment'>// throws <span class='texttt'>bad_alloc</span> if it fails
</span>T* p2 = new(nothrow) T;         <span class='comment'>// returns <span class='texttt'>nullptr</span> if it fails
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete(void* ptr, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.single-10'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
to render the value of <span class='texttt'>ptr</span> invalid.</p></div></div><div class='para' id='new.delete.single-11'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-11'>11</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with any of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.
If a function without a <span class='texttt'>size</span> parameter is defined,
the program should also define
the corresponding function with a <span class='texttt'>size</span> parameter.
If a function with a <span class='texttt'>size</span> parameter is defined,
the program shall also define
the corresponding version without the <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i>
The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='new.delete.single-12'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new(std::size_t)</span>
or
<span class='texttt'>operator new(std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete</span>.</p></div></div><div class='para' id='new.delete.single-13'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.single-14'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.
If present, the <span class='texttt'>size</span> argument
shall equal the <span class='texttt'>size</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.single-15'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-15'>15</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
A call to an <span class='texttt'>operator delete</span>
with a <span class='texttt'>size</span> parameter
may be changed to
a call to the corresponding <span class='texttt'>operator delete</span>
without a <span class='texttt'>size</span> parameter,
without affecting memory allocation.
[&nbsp;<i>Note:</i> A conforming implementation is for
<span class='texttt'>operator delete(void* ptr, std::size_t size)</span> to simply call
<span class='texttt'>operator delete(ptr)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='new.delete.single-16'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-16'>16</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
The functions that have a <span class='texttt'>size</span> parameter
forward their other parameters
to the corresponding function without a <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i> See the note in the above <i>Replaceable:</i> paragraph. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='new.delete.single-17'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-17'>17</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
If <span class='texttt'>ptr</span> is null, does nothing. Otherwise, reclaims the
storage allocated by the earlier call to <span class='texttt'>operator new</span>.</p></div></div><div class='para' id='new.delete.single-18'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-18'>18</a></div><div class='itemdescr'><p ><i>Remarks:</i>
It is unspecified under what conditions part or all of such
<span class='indexparent'><a class='index' id='unspecified'></a></span>reclaimed storage will be allocated by subsequent
calls to
<span class='texttt'>operator new</span>
or any of
<span class='texttt'>aligned_alloc</span>,
<span class='texttt'>calloc</span>,
<span class='texttt'>malloc</span>,
or
<span class='texttt'>realloc</span>,
declared in
<span class='texttt'>&lt;cstdlib&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;
void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.single-19'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the implementation
to render the value of <span class='texttt'>ptr</span> invalid
when the constructor invoked from a nothrow
placement version of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> throws an exception.</p></div></div><div class='para' id='new.delete.single-20'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-20'>20</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.single-21'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-21'>21</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new(std::size_t)</span>
or
<span class='texttt'>operator new(std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete</span>.</p></div></div><div class='para' id='new.delete.single-22'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-22'>22</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.single-23'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.single-24'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.single-24'>24</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator delete(ptr)</span>,
or <span class='texttt'>operator delete(ptr, alignment)</span>,
respectively.
</p></div></div></div><div id='new.delete.array'><h4 ><a class='secnum' href='#new.delete.array' style='min-width:118pt'>18.6.2.2</a> Array forms <a class='abbr_ref' href='new.delete.array'>[new.delete.array]</a></h4><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, std::align_val_t alignment);
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.array-1'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
allocation functions (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>)
called by the array form of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>)
to allocate
<span class='texttt'>size</span> bytes of storage.
The second form is called for a type with new-extended alignment,
and allocates storage
with the specified alignment.
The first form is called otherwise,
and allocates storage
suitably aligned to represent any array object of that size or smaller,
provided the object's type does not have new-extended alignment.<a class='footnotenum' href='#footnote-219'>219</a></p></div></div><div class='para' id='new.delete.array-2'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-2'>2</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.array-3'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-3'>3</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Same as for
the corresponding single-object forms.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='new.delete.array-4'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-4'>4</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Returns
<span class='texttt'>operator new(size)</span>,
or
<span class='texttt'>operator new(size, alignment)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new[](std::size_t size, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.array-5'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Same as above, except that these are called by a placement version of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
when a C++ program prefers a null pointer result as an error indication,
instead of a
<span class='texttt'>bad_alloc</span>
exception.</p></div></div><div class='para' id='new.delete.array-6'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-6'>6</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.array-7'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-7'>7</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else return a null pointer.
Each of these nothrow versions of
<span class='texttt'>operator new[]</span>
returns a pointer obtained as if
acquired from the (possibly replaced)
corresponding non-placement function.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='new.delete.array-8'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-8'>8</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator new[](size)</span>,
or <span class='texttt'>operator new[](size, alignment)</span>,
respectively.
If the call returns normally,
returns the result of that call.
Otherwise, returns a null pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.array-9'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the array form of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
to render the value of <span class='texttt'>ptr</span> invalid.</p></div></div><div class='para' id='new.delete.array-10'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-10'>10</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with any of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.
If a function without a <span class='texttt'>size</span> parameter is defined,
the program should also define
the corresponding function with a <span class='texttt'>size</span> parameter.
If a function with a <span class='texttt'>size</span> parameter is defined,
the program shall also define
the corresponding version without the <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i>
The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='new.delete.array-11'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new[](std::size_t)</span>
or
<span class='texttt'>operator new[](std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete[]</span>.</p></div></div><div class='para' id='new.delete.array-12'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.array-13'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.
If present, the <span class='texttt'>size</span> argument
shall equal the <span class='texttt'>size</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.array-14'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-14'>14</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
A call to an <span class='texttt'>operator delete[]</span>
with a <span class='texttt'>size</span> parameter
may be changed to
a call to the corresponding <span class='texttt'>operator delete[]</span>
without a <span class='texttt'>size</span> parameter,
without affecting memory allocation.
[&nbsp;<i>Note:</i> A conforming implementation is for
<span class='texttt'>operator delete[](void* ptr, std::size_t size)</span> to simply call
<span class='texttt'>operator delete[](ptr)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='new.delete.array-15'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-15'>15</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
The functions that have a <span class='texttt'>size</span> parameter
forward their other parameters
to the corresponding function without a <span class='texttt'>size</span> parameter.
The functions that do not have a <span class='texttt'>size</span> parameter
forward their parameters
to the corresponding <span class='texttt'>operator delete</span> (single-object) function.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.array-16'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the implementation
to render the value of <span class='texttt'>ptr</span> invalid
when the constructor invoked from a nothrow
placement version of the array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> throws an exception.</p></div></div><div class='para' id='new.delete.array-17'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-17'>17</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='new.delete.array-18'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new[](std::size_t)</span>
or
<span class='texttt'>operator new[](std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete[]</span>.</p></div></div><div class='para' id='new.delete.array-19'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.array-20'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-20'>20</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.array-21'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.array-21'>21</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator delete[](ptr)</span>,
or <span class='texttt'>operator delete[](ptr, alignment)</span>,
respectively.
</p></div></div><div class='footnote' id='footnote-219'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-219'>219)</a></div><p >It is not the direct responsibility of
<span class='texttt'>operator new[]</span>
or
<span class='texttt'>operator delete[]</span>
to note the repetition count or element size of the array.
Those operations are performed elsewhere in the array
<span class='texttt'>new</span>
and
<span class='texttt'>delete</span>
expressions.
The array
<span class='texttt'>new</span>
expression, may, however, increase the <span class='texttt'>size</span> argument to
<span class='texttt'>operator new[]</span>
to obtain space to store supplemental information.</p></div></div><div id='new.delete.placement'><h4 ><a class='secnum' href='#new.delete.placement' style='min-width:118pt'>18.6.2.3</a> Non-allocating forms <a class='abbr_ref' href='new.delete.placement'>[new.delete.placement]</a></h4><div class='para' id='new.delete.placement-1'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-1'>1</a></div><p >These functions are reserved, a C++ program may not define functions that displace
the versions in the C++ standard library (<a href='constraints'>[constraints]</a>).
The provisions of (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>) do not apply to these reserved
placement forms of <span class='texttt'>operator new</span> and <span class='texttt'>operator delete</span>.</p><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size, void* ptr) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='new.delete.placement-2'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.placement-3'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Intentionally performs no other action.</p></div></div><div class='para' id='new.delete.placement-4'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
This can be useful for constructing an object at a known address:</p><pre class='codeblock'>
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size, void* ptr) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.placement-5'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>ptr</span>.</p></div></div><div class='para' id='new.delete.placement-6'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Intentionally performs no other action.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr, void*) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.placement-7'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Intentionally performs no action.</p></div></div><div class='para' id='new.delete.placement-8'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.placement-9'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Default function called when any part of the initialization in a
placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that invokes the library's
non-array placement operator new
terminates by throwing an exception (<a href='expr.new'>[expr.new]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr, void*) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='new.delete.placement-10'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Intentionally performs no action.</p></div></div><div class='para' id='new.delete.placement-11'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='new.delete.placement-12'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.placement-12'>12</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Default function called when any part of the initialization in a
placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that invokes the library's
array placement operator new
terminates by throwing an exception (<a href='expr.new'>[expr.new]</a>).
</p></div></div></div><div id='new.delete.dataraces'><h4 ><a class='secnum' href='#new.delete.dataraces' style='min-width:118pt'>18.6.2.4</a> Data races <a class='abbr_ref' href='new.delete.dataraces'>[new.delete.dataraces]</a></h4><div class='para' id='new.delete.dataraces-1'><div class='marginalizedparent'><a class='marginalized' href='#new.delete.dataraces-1'>1</a></div><p >For purposes of determining the existence of data races, the library versions
of <span class='texttt'>operator new</span>, user replacement versions of global <span class='texttt'>operator new</span>,
the C standard library functions
<span class='texttt'>aligned_alloc</span>, <span class='texttt'>calloc</span>, and <span class='texttt'>malloc</span>,
the library
versions of <span class='texttt'>operator delete</span>, user replacement
versions of <span class='texttt'>operator delete</span>, the C standard library function
<span class='texttt'>free</span>, and the C standard library function <span class='texttt'>realloc</span> shall not
introduce a data race (<a href='res.on.data.races'>[res.on.data.races]</a>).
Calls to these functions that allocate or deallocate a particular unit
of storage shall occur in a single total order, and each such deallocation call
shall happen before (<a href='intro.multithread'>[intro.multithread]</a>) the next allocation (if any) in
this order.</p></div></div></div><div id='alloc.errors'><h3 ><a class='secnum' href='#alloc.errors' style='min-width:103pt'>18.6.3</a> Storage allocation errors <a class='abbr_ref' href='alloc.errors'>[alloc.errors]</a></h3><p ><span class='indexparent'><a class='index' id='bad_alloc'></a></span></p><div id='bad.alloc'><h4 ><a class='secnum' href='#bad.alloc' style='min-width:118pt'>18.6.3.1</a> Class <span class='texttt'>bad_alloc</span> <a class='abbr_ref' href='bad.alloc'>[bad.alloc]</a></h4><pre class='codeblock'>
namespace std {
  class bad_alloc : public exception {
  public:
    bad_alloc() noexcept;
    bad_alloc(const bad_alloc&amp;) noexcept;
    bad_alloc&amp; operator=(const bad_alloc&amp;) noexcept;
    const char* what() const noexcept override;
  };
}
</pre><div class='para' id='bad.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#bad.alloc-1'>1</a></div><p >The class
<span class='texttt'>bad_alloc</span>
defines the type of objects thrown as
exceptions by the implementation to report a failure to allocate storage.</p><p ><span class='indexparent'><a class='index' id='bad_alloc,constructor'></a></span><code class='itemdecl'>
bad_alloc() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='bad.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#bad.alloc-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>bad_alloc</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bad_alloc,constructor'></a></span><span class='indexparent'><a class='index' id='operator=,bad_alloc'></a></span><span class='indexparent'><a class='index' id='bad_alloc,operator='></a></span><code class='itemdecl'>
bad_alloc(const bad_alloc&amp;) noexcept;
bad_alloc&amp; operator=(const bad_alloc&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bad.alloc-3'><div class='marginalizedparent'><a class='marginalized' href='#bad.alloc-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies an object of class
<span class='texttt'>bad_alloc</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='what,bad_alloc'></a></span><span class='indexparent'><a class='index' id='bad_alloc,what'></a></span><code class='itemdecl'>
const char* what() const noexcept override;
</code></p><div class='itemdescr'></div><div class='para' id='bad.alloc-4'><div class='marginalizedparent'><a class='marginalized' href='#bad.alloc-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
An <span class='indexparent'><a class='index' id='return_value_of_bad_alloc::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.</p></div></div><div class='para' id='bad.alloc-5'><div class='marginalizedparent'><a class='marginalized' href='#bad.alloc-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The message may be a null-terminated multibyte string (<a href='multibyte.strings'>[multibyte.strings]</a>),
suitable for conversion and display as a
<span class='texttt'>wstring</span> (<a href='string.classes'>[string.classes]</a>, <a href='locale.codecvt'>[locale.codecvt]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='bad_array_new_length'></a></span></p></div><div id='new.badlength'><h4 ><a class='secnum' href='#new.badlength' style='min-width:118pt'>18.6.3.2</a> Class <span class='texttt'>bad_array_new_length</span> <a class='abbr_ref' href='new.badlength'>[new.badlength]</a></h4><pre class='codeblock'>
namespace std {
  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() noexcept;
    const char* what() const noexcept override;
  };
}
</pre><div class='para' id='new.badlength-1'><div class='marginalizedparent'><a class='marginalized' href='#new.badlength-1'>1</a></div><p >The class <span class='texttt'>bad_array_new_length</span> defines the type of objects thrown as
exceptions by the implementation to report an attempt to allocate an array of size
less than zero or
greater than an <span class='indexparent'><a class='index' id='maximum_size_of_an_allocated_object'></a></span>implementation-defined limit (<a href='expr.new'>[expr.new]</a>).</p><p ><span class='indexparent'><a class='index' id='bad_array_new_length,constructor'></a></span><code class='itemdecl'>
bad_array_new_length() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='new.badlength-2'><div class='marginalizedparent'><a class='marginalized' href='#new.badlength-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs an object of class <span class='texttt'>bad_array_new_length</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='what,bad_array_new_length'></a></span><span class='indexparent'><a class='index' id='bad_array_new_length,what'></a></span><code class='itemdecl'>
const char* what() const noexcept override;
</code></p><div class='itemdescr'></div><div class='para' id='new.badlength-3'><div class='marginalizedparent'><a class='marginalized' href='#new.badlength-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An <span class='indexparent'><a class='index' id='return_value_of_bad_array_new_length::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.</p></div></div><div class='para' id='new.badlength-4'><div class='marginalizedparent'><a class='marginalized' href='#new.badlength-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The message may be a null-terminated multibyte string (<a href='multibyte.strings'>[multibyte.strings]</a>),
suitable for conversion and display as a
<span class='texttt'>wstring</span> (<a href='string.classes'>[string.classes]</a>, <a href='locale.codecvt'>[locale.codecvt]</a>).
</p></div></div></div><div id='new.handler'><h4 ><a class='secnum' href='#new.handler' style='min-width:118pt'>18.6.3.3</a> Type <span class='texttt'>new_handler</span> <a class='abbr_ref' href='new.handler'>[new.handler]</a></h4><p ><span class='indexparent'><a class='index' id='new_handler'></a></span><code class='itemdecl'>
using new_handler = void (*)();
</code></p><div class='itemdescr'></div><div class='para' id='new.handler-1'><div class='marginalizedparent'><a class='marginalized' href='#new.handler-1'>1</a></div><div class='itemdescr'><p >The type of a
<a class='hidden_link' href='#def:handler_function' id='def:handler_function'><i>handler function</i></a>
to be called by
<span class='texttt'>operator new()</span>
or
<span class='texttt'>operator new[]()</span> (<a href='new.delete'>[new.delete]</a>) when they cannot satisfy a request for additional storage.</p></div></div><div class='para' id='new.handler-2'><div class='marginalizedparent'><a class='marginalized' href='#new.handler-2'>2</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
A <span class='texttt'>new_handler</span> shall perform one of the following:</p><ul class='itemize'><li id='new.handler-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.handler-2.1'>(2.1)</a></div><p >make more storage available for allocation and then return;
</p></li><li id='new.handler-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.handler-2.2'>(2.2)</a></div><p >throw an exception of type
<span class='texttt'>bad_alloc</span>
or a class derived from
<span class='indexparent'><a class='index' id='bad_alloc'></a></span><span class='texttt'>bad_alloc</span>;
</p></li><li id='new.handler-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#new.handler-2.3'>(2.3)</a></div><p >terminate execution of the program without returning to the caller;
<span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='exit'></a></span></p></li></ul></div></div></div><div id='set.new.handler'><h4 ><a class='secnum' href='#set.new.handler' style='min-width:118pt'>18.6.3.4</a> <span class='texttt'>set_new_handler</span> <a class='abbr_ref' href='set.new.handler'>[set.new.handler]</a></h4><p ><span class='indexparent'><a class='index' id='set_new_handler'></a></span><code class='itemdecl'>
new_handler set_new_handler(new_handler new_p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='set.new.handler-1'><div class='marginalizedparent'><a class='marginalized' href='#set.new.handler-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Establishes the function designated by <span class='texttt'>new_p</span> as the current
<span class='texttt'>new_handler</span>.</p></div></div><div class='para' id='set.new.handler-2'><div class='marginalizedparent'><a class='marginalized' href='#set.new.handler-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The previous <span class='texttt'>new_handler</span>.</p></div></div><div class='para' id='set.new.handler-3'><div class='marginalizedparent'><a class='marginalized' href='#set.new.handler-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The initial <span class='texttt'>new_handler</span> is a null pointer.
</p></div></div></div><div id='get.new.handler'><h4 ><a class='secnum' href='#get.new.handler' style='min-width:118pt'>18.6.3.5</a> <span class='texttt'>get_new_handler</span> <a class='abbr_ref' href='get.new.handler'>[get.new.handler]</a></h4><p ><span class='indexparent'><a class='index' id='get_new_handler'></a></span><code class='itemdecl'>
new_handler get_new_handler() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='get.new.handler-1'><div class='marginalizedparent'><a class='marginalized' href='#get.new.handler-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The current <span class='texttt'>new_handler</span>.
[&nbsp;<i>Note:</i> This may be a null pointer value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div><div id='ptr.launder'><h3 ><a class='secnum' href='#ptr.launder' style='min-width:103pt'>18.6.4</a> Pointer optimization barrier <a class='abbr_ref' href='ptr.launder'>[ptr.launder]</a></h3><p ><span class='indexparent'><a class='index' id='launder'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ptr.launder-1'><div class='marginalizedparent'><a class='marginalized' href='#ptr.launder-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>p</span> represents the address <i>A</i> of a byte in memory.
An object <i>X</i> that is within its lifetime (<a href='basic.life'>[basic.life]</a>)
and whose type is similar (<a href='conv.qual'>[conv.qual]</a>) to <span class='texttt'>T</span>
is located at the address <i>A</i>.
All bytes of storage that would be reachable through the result
are reachable through <span class='texttt'>p</span> (see below).</p></div></div><div class='para' id='ptr.launder-2'><div class='marginalizedparent'><a class='marginalized' href='#ptr.launder-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A value of type <span class='texttt'>T *</span> that points to <span class='texttt'>X</span>.</p></div></div><div class='para' id='ptr.launder-3'><div class='marginalizedparent'><a class='marginalized' href='#ptr.launder-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
An invocation of this function
may be used in a core constant expression
whenever the value of its argument
may be used in a core constant expression.
A byte of storage is
reachable through a pointer value
that points to an object <i>Y</i>
if it is within the storage occupied by
<i>Y</i>,
an object that is pointer-interconvertible with <i>Y</i>, or
the immediately-enclosing array object if <i>Y</i> is an array element.
The program is ill-formed if <span class='texttt'>T</span> is a function type
or (possibly cv-qualified) <span class='texttt'>void</span>.</p></div></div><div class='para' id='ptr.launder-4'><div class='marginalizedparent'><a class='marginalized' href='#ptr.launder-4'>4</a></div><div class='itemdescr'><p ><i>Notes:</i>
If a new object is created
in storage occupied by an existing object of the same type,
a pointer to the original object
can be used to refer to the new object
unless the type contains <span class='texttt'>const</span> or reference members;
in the latter cases,
this function can be used to obtain a usable pointer to the new object.
See <a href='basic.life'>[basic.life]</a>.</p></div></div><div class='para' id='ptr.launder-5'><div class='marginalizedparent'><a class='marginalized' href='#ptr.launder-5'>5</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct X { const int n; };
X *p = new X{3};
const int a = p-&gt;n;
new (p) X{5};                     <span class='comment'>// <span class='texttt'>p</span> does not point to new object (<a href='basic.life'>[basic.life]</a>)
</span>                                  <span class='comment'>// because <span class='texttt'>X::n</span> is <span class='texttt'>const</span>
</span>const int b = p-&gt;n;               <span class='comment'>// undefined behavior
</span>const int c = std::launder(p)-&gt;n; <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='hardware.interference'><h3 ><a class='secnum' href='#hardware.interference' style='min-width:103pt'>18.6.5</a> Hardware interference size <a class='abbr_ref' href='hardware.interference'>[hardware.interference]</a></h3><p ><span class='indexparent'><a class='index' id='hardware_destructive_interference_size'></a></span><code class='itemdecl'>
constexpr size_t hardware_destructive_interference_size = <i>implementation-defined</i>;
</code></p><div class='para' id='hardware.interference-1'><div class='marginalizedparent'><a class='marginalized' href='#hardware.interference-1'>1</a></div><p >This number is the minimum recommended offset
between two concurrently-accessed objects
to avoid additional performance degradation due to contention
introduced by the implementation.
It shall be at least <span class='texttt'>alignof(max_align_t)</span>.</p><p ><span class='indexparent'><a class='index' id='cats,interfering_with_canines'></a></span>[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct keep_apart {
  alignas(hardware_destructive_interference_size) atomic&lt;int&gt; cat;
  alignas(hardware_destructive_interference_size) atomic&lt;int&gt; dog;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='hardware_constructive_interference_size'></a></span><code class='itemdecl'>
constexpr size_t hardware_constructive_interference_size = <i>implementation-defined</i>;
</code></p></div><div class='para' id='hardware.interference-2'><div class='marginalizedparent'><a class='marginalized' href='#hardware.interference-2'>2</a></div><p >This number is the maximum recommended size of contiguous memory
occupied by two objects accessed with temporal locality by concurrent threads.
It shall be at least <span class='texttt'>alignof(max_align_t)</span>.</p><p ><span class='indexparent'><a class='index' id='dogs,obliviousness_to_interference'></a></span>[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct together {
  atomic&lt;int&gt; dog;
  int puppy;
};
struct kennel {
  <span class='comment'>// Other data members...
</span>  alignas(sizeof(together)) together pack;
  <span class='comment'>// Other data members...
</span>};
static_assert(sizeof(together) &lt;= hardware_constructive_interference_size);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></body></html>