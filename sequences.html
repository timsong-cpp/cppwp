<!DOCTYPE html><html lang='en'><head><title>[sequences]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><div id='sequences'><h2 ><a class='secnum' style='min-width:88pt'>23.3</a> Sequence containers <a class='abbr_ref'>[sequences]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>23.3.1</a> In general <a class='abbr_ref' href='sequences.general'>[sequences.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >The headers <span class='texttt'>&lt;array&gt;</span>, <span class='texttt'>&lt;deque&gt;</span>, <span class='texttt'>&lt;forward_list&gt;</span>,
<span class='texttt'>&lt;list&gt;</span>, and <span class='texttt'>&lt;vector&gt;</span> define class templates that meet the
requirements for sequence containers.</p></div></div><div id='array.syn'><h3 ><a class='secnum' href='#array.syn' style='min-width:103pt'>23.3.2</a> Header <span class='texttt'>&lt;array&gt;</span> synopsis <a class='abbr_ref' href='array.syn'>[array.syn]</a></h3><p ><span class='indexparent'><a class='index' id='array'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='array'>[array]</a>, class template array:
</span>  template &lt;class T, size_t N&gt; struct array;
  template &lt;class T, size_t N&gt;
    bool operator==(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    bool operator!=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    bool operator&lt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    bool operator&gt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    bool operator&lt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    bool operator&gt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template &lt;class T, size_t N&gt;
    void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));

  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;
  template &lt;class T, size_t N&gt;
    struct tuple_size&lt;array&lt;T, N&gt;&gt;;
  template &lt;size_t I, class T, size_t N&gt;
    struct tuple_element&lt;I, array&lt;T, N&gt;&gt;;
  template &lt;size_t I, class T, size_t N&gt;
    constexpr T&amp; get(array&lt;T, N&gt;&amp;) noexcept;
  template &lt;size_t I, class T, size_t N&gt;
    constexpr T&amp;&amp; get(array&lt;T, N&gt;&amp;&amp;) noexcept;
  template &lt;size_t I, class T, size_t N&gt;
    constexpr const T&amp; get(const array&lt;T, N&gt;&amp;) noexcept;
  template &lt;size_t I, class T, size_t N&gt;
    constexpr const T&amp;&amp; get(const array&lt;T, N&gt;&amp;&amp;) noexcept;
}
</pre></div><div id='deque.syn'><h3 ><a class='secnum' href='#deque.syn' style='min-width:103pt'>23.3.3</a> Header <span class='texttt'>&lt;deque&gt;</span> synopsis <a class='abbr_ref' href='deque.syn'>[deque.syn]</a></h3><p ><span class='indexparent'><a class='index' id='deque'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='deque'>[deque]</a>, class template deque:
</span>  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class deque;
  template &lt;class T, class Allocator&gt;
    bool operator==(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    void swap(deque&lt;T, Allocator&gt;&amp; x, deque&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template &lt;class T&gt;
      using deque = std::deque&lt;T, polymorphic_allocator&lt;T&gt;&gt;;
  }
}
</pre></div><div id='forward_list.syn'><h3 ><a class='secnum' href='#forward_list.syn' style='min-width:103pt'>23.3.4</a> Header <span class='texttt'>&lt;forward_list&gt;</span> synopsis <a class='abbr_ref' href='forward_list.syn'>[forward_list.syn]</a></h3><p ><span class='indexparent'><a class='index' id='forward_list'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='forwardlist'>[forwardlist]</a>, class template forward_list:
</span>  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class forward_list;
  template &lt;class T, class Allocator&gt;
    bool operator==(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    void swap(forward_list&lt;T, Allocator&gt;&amp; x, forward_list&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template &lt;class T&gt;
      using forward_list = std::forward_list&lt;T, polymorphic_allocator&lt;T&gt;&gt;;
  }
}
</pre></div><div id='list.syn'><h3 ><a class='secnum' href='#list.syn' style='min-width:103pt'>23.3.5</a> Header <span class='texttt'>&lt;list&gt;</span> synopsis <a class='abbr_ref' href='list.syn'>[list.syn]</a></h3><p ><span class='indexparent'><a class='index' id='list'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='list'>[list]</a>, class template list:
</span>  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class list;
  template &lt;class T, class Allocator&gt;
    bool operator==(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    void swap(list&lt;T, Allocator&gt;&amp; x, list&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template &lt;class T&gt;
      using list = std::list&lt;T, polymorphic_allocator&lt;T&gt;&gt;;
  }
}
</pre></div><div id='vector.syn'><h3 ><a class='secnum' href='#vector.syn' style='min-width:103pt'>23.3.6</a> Header <span class='texttt'>&lt;vector&gt;</span> synopsis <a class='abbr_ref' href='vector.syn'>[vector.syn]</a></h3><p ><span class='indexparent'><a class='index' id='vector'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='vector'>[vector]</a>, class template vector:
</span>  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class vector;
  template &lt;class T, class Allocator&gt;
    bool operator==(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    void swap(vector&lt;T, Allocator&gt;&amp; x, vector&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  <span class='comment'>// <a href='vector.bool'>[vector.bool]</a>, class vector&lt;bool&gt;
</span>  template &lt;class Allocator&gt; class vector&lt;bool, Allocator&gt;;

  <span class='comment'>// hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;

  namespace pmr {
    template &lt;class T&gt;
      using vector = std::vector&lt;T, polymorphic_allocator&lt;T&gt;&gt;;
  }
}
</pre></div><div id='array'><h3 ><a class='secnum' href='#array' style='min-width:103pt'>23.3.7</a> Class template <span class='texttt'>array</span> <a class='abbr_ref' href='array'>[array]</a></h3><p ><span class='indexparent'><a class='index' id='array'></a></span>
</p><div id='array.overview'><h4 ><a class='secnum' href='#array.overview' style='min-width:118pt'>23.3.7.1</a> Class template <span class='texttt'>array</span> overview <a class='abbr_ref' href='array.overview'>[array.overview]</a></h4><div class='para' id='array.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#array.overview-1'>1</a></div><p ><span class='indexparent'><a class='index' id='array,contiguous_storage'></a></span>The header <span class='texttt'>&lt;array&gt;</span> defines a class template for storing fixed-size
sequences of objects.
An <span class='texttt'>array</span> is a contiguous container (<a href='container.requirements.general'>[container.requirements.general]</a>).
An instance of <span class='texttt'>array&lt;T, N&gt;</span> stores <span class='texttt'>N</span> elements of type <span class='texttt'>T</span>,
so that <span class='texttt'>size() == N</span> is an invariant.</p></div><div class='para' id='array.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#array.overview-2'>2</a></div><p ><span class='indexparent'><a class='index' id='array,initialization'></a></span><span class='indexparent'><a class='index' id='array,as_aggregate'></a></span>An <span class='texttt'>array</span> is an aggregate (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>) that can be
list-initialized with up
to <span class='texttt'>N</span> elements whose types are convertible to <span class='texttt'>T</span>.</p></div><div class='para' id='array.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#array.overview-3'>3</a></div><p ><span class='indexparent'><a class='index' id='requirements,container'></a></span>An <span class='texttt'>array</span> satisfies all of the requirements of a container and
of a reversible container (<a href='container.requirements'>[container.requirements]</a>), except that a default
constructed <span class='texttt'>array</span> object is not empty and that <span class='texttt'>swap</span> does not have constant
complexity. An <span class='texttt'>array</span> satisfies some of the requirements of a sequence
container (<a href='sequence.reqmts'>[sequence.reqmts]</a>).
Descriptions are provided here
only for operations on <span class='texttt'>array</span> that are not described in
one of these tables and
for operations where there is additional semantic information.</p><p ><span class='indexparent'><a class='index' id='array'></a></span><span class='indexparent'><a class='index' id='array,begin'></a></span><span class='indexparent'><a class='index' id='begin,array'></a></span><span class='indexparent'><a class='index' id='array,end'></a></span><span class='indexparent'><a class='index' id='end,array'></a></span><span class='indexparent'><a class='index' id='array,size'></a></span><span class='indexparent'><a class='index' id='size,array'></a></span><span class='indexparent'><a class='index' id='array,max_size'></a></span><span class='indexparent'><a class='index' id='max_size,array'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T, size_t N&gt;
  struct array {
    <span class='comment'>//  types:
</span>    using value_type             = T;
    using pointer                = T*;
    using const_pointer          = const T*;
    using reference              = T&amp;;
    using const_reference        = const T&amp;;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using iterator               = <span class='indexparent'><a class='index' id='type_of_array::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id='type_of_array::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// no explicit construct/copy/destroy for aggregate type
</span>
    void fill(const T&amp; u);
    void swap(array&amp;) noexcept(is_nothrow_swappable_v&lt;T&gt;);

    <span class='comment'>// iterators:
</span>    constexpr iterator               begin() noexcept;
    constexpr const_iterator         begin() const noexcept;
    constexpr iterator               end() noexcept;
    constexpr const_iterator         end() const noexcept;

    constexpr reverse_iterator       rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator       rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;

    constexpr const_iterator         cbegin() const noexcept;
    constexpr const_iterator         cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

    <span class='comment'>// capacity:
</span>    constexpr bool      empty() const noexcept;
    constexpr size_type size() const noexcept;
    constexpr size_type max_size() const noexcept;

    <span class='comment'>// element access:
</span>    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);
    constexpr const_reference at(size_type n) const;
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;

    constexpr T *       data() noexcept;
    constexpr const T * data() const noexcept;
  };
}
</pre></div></div><div id='array.cons'><h4 ><a class='secnum' href='#array.cons' style='min-width:118pt'>23.3.7.2</a> <span class='texttt'>array</span> constructors, copy, and assignment <a class='abbr_ref' href='array.cons'>[array.cons]</a></h4><div class='para' id='array.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#array.cons-1'>1</a></div><p ><span class='indexparent'><a class='index' id='array,initialization'></a></span><span class='indexparent'><a class='index' id='requirements,container'></a></span>The conditions for an aggregate (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>) shall be
met. Class <span class='texttt'>array</span> relies on the implicitly-declared special
member functions (<a href='class.ctor'>[class.ctor]</a>, <a href='class.dtor'>[class.dtor]</a>, and <a href='class.copy'>[class.copy]</a>) to
conform to the container requirements table in <a href='container.requirements'>[container.requirements]</a>.
In addition to the requirements specified in the container requirements table,
the implicit move constructor and move assignment operator for <span class='texttt'>array</span>
require that <span class='texttt'>T</span> be <span class='texttt'>MoveConstructible</span> or <span class='texttt'>MoveAssignable</span>,
respectively.</p></div></div><div id='array.special'><h4 ><a class='secnum' href='#array.special' style='min-width:118pt'>23.3.7.3</a> <span class='texttt'>array</span> specialized algorithms <a class='abbr_ref' href='array.special'>[array.special]</a></h4><p ><span class='indexparent'><a class='index' id='array,swap'></a></span><span class='indexparent'><a class='index' id='swap,array'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt;
  void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='array.special-1'><div class='marginalizedparent'><a class='marginalized' href='#array.special-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution
unless <span class='texttt'>N == 0</span> or <span class='texttt'>is_swappable_v&lt;T&gt;</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='array.special-2'><div class='marginalizedparent'><a class='marginalized' href='#array.special-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by <span class='texttt'>x.swap(y)</span>.</p></div></div><div class='para' id='array.special-3'><div class='marginalizedparent'><a class='marginalized' href='#array.special-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>N</span>.
</p></div></div></div><div id='array.size'><h4 ><a class='secnum' href='#array.size' style='min-width:118pt'>23.3.7.4</a> <span class='texttt'>array::size</span> <a class='abbr_ref' href='array.size'>[array.size]</a></h4><p ><span class='indexparent'><a class='index' id='array,size'></a></span><span class='indexparent'><a class='index' id='size,array'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt; constexpr size_type array&lt;T, N&gt;::size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array.size-1'><div class='marginalizedparent'><a class='marginalized' href='#array.size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>N</span>
</p></div></div></div><div id='array.data'><h4 ><a class='secnum' href='#array.data' style='min-width:118pt'>23.3.7.5</a> <span class='texttt'>array::data</span> <a class='abbr_ref' href='array.data'>[array.data]</a></h4><p ><span class='indexparent'><a class='index' id='array,data'></a></span><span class='indexparent'><a class='index' id='data,array'></a></span><code class='itemdecl'>
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array.data-1'><div class='marginalizedparent'><a class='marginalized' href='#array.data-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer such that <span class='texttt'>[data(), <span class='discretionary'></span>data() + size())</span> is a valid range, and
<span class='texttt'>data() == addressof(front())</span>.
</p></div></div></div><div id='array.fill'><h4 ><a class='secnum' href='#array.fill' style='min-width:118pt'>23.3.7.6</a> <span class='texttt'>array::fill</span> <a class='abbr_ref' href='array.fill'>[array.fill]</a></h4><p ><span class='indexparent'><a class='index' id='array,fill'></a></span><span class='indexparent'><a class='index' id='fill,array'></a></span><code class='itemdecl'>
void fill(const T&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='array.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#array.fill-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>fill_n(begin(), N, u)</span>.
</p></div></div></div><div id='array.swap'><h4 ><a class='secnum' href='#array.swap' style='min-width:118pt'>23.3.7.7</a> <span class='texttt'>array::swap</span> <a class='abbr_ref' href='array.swap'>[array.swap]</a></h4><p ><span class='indexparent'><a class='index' id='array,swap'></a></span><span class='indexparent'><a class='index' id='swap,array'></a></span><code class='itemdecl'>
void swap(array&amp; y) noexcept(is_nothrow_swappable_v&lt;T&gt;);
</code></p><div class='itemdescr'></div><div class='para' id='array.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#array.swap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>swap_ranges(begin(), end(), y.begin())</span>.</p></div></div><div class='para' id='array.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#array.swap-2'>2</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless one of the element-wise swap calls throws an exception.</p></div></div><div class='para' id='array.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#array.swap-3'>3</a></div><div class='itemdescr'><p ><i>Note:</i> Unlike the <span class='texttt'>swap</span> function for other containers, <span class='texttt'>array::swap</span>
takes linear time, may exit via an exception, and does not cause iterators to
become associated with the other container.
</p></div></div></div><div id='array.zero'><h4 ><a class='secnum' href='#array.zero' style='min-width:118pt'>23.3.7.8</a> Zero sized arrays <a class='abbr_ref' href='array.zero'>[array.zero]</a></h4><p ><span class='indexparent'><a class='index' id='array,zero_sized'></a></span></p><div class='para' id='array.zero-1'><div class='marginalizedparent'><a class='marginalized' href='#array.zero-1'>1</a></div><p ><span class='texttt'>array</span> shall provide support for the special case <span class='texttt'>N == 0</span>.</p></div><div class='para' id='array.zero-2'><div class='marginalizedparent'><a class='marginalized' href='#array.zero-2'>2</a></div><p >In the case that <span class='texttt'>N == 0</span>, <span class='texttt'>begin() == end() ==</span> unique value.
The return value of <span class='texttt'>data()</span> is unspecified.</p></div><div class='para' id='array.zero-3'><div class='marginalizedparent'><a class='marginalized' href='#array.zero-3'>3</a></div><p >The effect of calling <span class='texttt'>front()</span> or <span class='texttt'>back()</span> for a zero-sized array is
undefined.</p></div><div class='para' id='array.zero-4'><div class='marginalizedparent'><a class='marginalized' href='#array.zero-4'>4</a></div><p >Member function <span class='texttt'>swap()</span> shall have a <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i>
which is equivalent to <span class='texttt'>noexcept(true)</span>.</p></div></div><div id='array.tuple'><h4 ><a class='secnum' href='#array.tuple' style='min-width:118pt'>23.3.7.9</a> Tuple interface to class template <span class='texttt'>array</span> <a class='abbr_ref' href='array.tuple'>[array.tuple]</a></h4><p ><span class='indexparent'><a class='index' id='array'></a></span><span class='indexparent'><a class='index' id='tuple'></a></span><span class='indexparent'><a class='index' id='array,tuple_interface_to'></a></span><span class='indexparent'><a class='index' id='tuple_size'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt;
  struct tuple_size&lt;array&lt;T, N&gt;&gt; : integral_constant&lt;size_t, N&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='tuple_element'></a></span><code class='itemdecl'>
tuple_element&lt;I, array&lt;T, N&gt;&gt;::type
</code></p><div class='itemdescr'></div><div class='para' id='array.tuple-1'><div class='marginalizedparent'><a class='marginalized' href='#array.tuple-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; N</span>. The program is ill-formed if <span class='texttt'>I</span> is out of bounds.</p></div></div><div class='para' id='array.tuple-2'><div class='marginalizedparent'><a class='marginalized' href='#array.tuple-2'>2</a></div><div class='itemdescr'><p ><i>Value:</i>  The type T.
</p></div></div><p ><span class='indexparent'><a class='index' id='array,get'></a></span><span class='indexparent'><a class='index' id='get,array'></a></span><code class='itemdecl'>
template &lt;size_t I, class T, size_t N&gt;
  constexpr T&amp; get(array&lt;T, N&gt;&amp; a) noexcept;
template &lt;size_t I, class T, size_t N&gt;
  constexpr T&amp;&amp; get(array&lt;T, N&gt;&amp;&amp; a) noexcept;
template &lt;size_t I, class T, size_t N&gt;
  constexpr const T&amp; get(const array&lt;T, N&gt;&amp; a) noexcept;
template &lt;size_t I, class T, size_t N&gt;
  constexpr const T&amp;&amp; get(const array&lt;T, N&gt;&amp;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array.tuple-3'><div class='marginalizedparent'><a class='marginalized' href='#array.tuple-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; N</span>. The program is ill-formed if <span class='texttt'>I</span> is out of bounds.</p></div></div><div class='para' id='array.tuple-4'><div class='marginalizedparent'><a class='marginalized' href='#array.tuple-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>I</span>th element of <span class='texttt'>a</span>,
where indexing is zero-based.
</p></div></div></div></div><div id='deque'><h3 ><a class='secnum' href='#deque' style='min-width:103pt'>23.3.8</a> Class template <span class='texttt'>deque</span> <a class='abbr_ref' href='deque'>[deque]</a></h3><div id='deque.overview'><h4 ><a class='secnum' href='#deque.overview' style='min-width:118pt'>23.3.8.1</a> Class template <span class='texttt'>deque</span> overview <a class='abbr_ref' href='deque.overview'>[deque.overview]</a></h4><div class='para' id='deque.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#deque.overview-1'>1</a></div><p >A
<span class='indexparent'><a class='index' id='deque'></a></span><span class='texttt'>deque</span>
is a sequence container that supports random access iterators (<a href='random.access.iterators'>[random.access.iterators]</a>).
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
Storage management is handled automatically.</p></div><div class='para' id='deque.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#deque.overview-2'>2</a></div><p >A
<span class='texttt'>deque</span>
satisfies all of the requirements of a container, of a reversible container
(given in tables in <a href='container.requirements'>[container.requirements]</a>), of a sequence container,
including the optional sequence container requirements (<a href='sequence.reqmts'>[sequence.reqmts]</a>), and of an allocator-aware container (Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>).
Descriptions are provided here only for operations on
<span class='texttt'>deque</span>
that are not described in one of these tables
or for operations where there is additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class deque {
  public:
    <span class='comment'>// types:
</span>    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer          = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference              = value_type&amp;;
    using const_reference        = const value_type&amp;;
    using size_type              = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type        = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator               = <span class='indexparent'><a class='index' id='type_of_deque::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id='type_of_deque::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// <a href='deque.cons'>[deque.cons]</a>, construct/copy/destroy:
</span>    deque() : deque(Allocator()) { }
    explicit deque(const Allocator&amp;);
    explicit deque(size_type n, const Allocator&amp; = Allocator());
    deque(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      deque(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
    deque(const deque&amp; x);
    deque(deque&amp;&amp;);
    deque(const deque&amp;, const Allocator&amp;);
    deque(deque&amp;&amp;, const Allocator&amp;);
    deque(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());

    ~deque();
    deque&amp; operator=(const deque&amp; x);
    deque&amp; operator=(deque&amp;&amp; x)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    deque&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; t);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='deque.capacity'>[deque.capacity]</a>, capacity:
</span>    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);
    void      shrink_to_fit();

    <span class='comment'>// element access:
</span>    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='deque.modifiers'>[deque.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
    template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);

    void push_front(const T&amp; x);
    void push_front(T&amp;&amp; x);
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);

    iterator insert(const_iterator position, const T&amp; x);
    iterator insert(const_iterator position, T&amp;&amp; x);
    iterator insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;T&gt;);

    void pop_front();
    void pop_back();

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(deque&amp;)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    void     clear() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);

  <span class='comment'>// <a href='deque.special'>[deque.special]</a>, specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(deque&lt;T, Allocator&gt;&amp; x, deque&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));
}
</pre></div></div><div id='deque.cons'><h4 ><a class='secnum' href='#deque.cons' style='min-width:118pt'>23.3.8.2</a> <span class='texttt'>deque</span> constructors, copy, and assignment <a class='abbr_ref' href='deque.cons'>[deque.cons]</a></h4><p ><span class='indexparent'><a class='index' id='deque,constructor'></a></span><code class='itemdecl'>
explicit deque(const Allocator&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='deque.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an empty
<span class='texttt'>deque</span>,
using the specified allocator.</p></div></div><div class='para' id='deque.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,constructor'></a></span><code class='itemdecl'>
explicit deque(size_type n, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='deque.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>deque</span> with
<span class='texttt'>n</span> default-inserted elements using the specified allocator.</p></div></div><div class='para' id='deque.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='deque.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,constructor'></a></span><code class='itemdecl'>
deque(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='deque.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>deque</span>
with <span class='texttt'>n</span> copies of <span class='texttt'>value</span>,
using the specified allocator.</p></div></div><div class='para' id='deque.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='deque.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,constructor'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  deque(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='deque.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>deque</span>
equal to the range
<span class='texttt'>[first, <span class='discretionary'></span>last)</span>,
using the specified allocator.</p></div></div><div class='para' id='deque.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#deque.cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>distance(first, last)</span>.
</p></div></div></div><div id='deque.capacity'><h4 ><a class='secnum' href='#deque.capacity' style='min-width:118pt'>23.3.8.3</a> <span class='texttt'>deque</span> capacity <a class='abbr_ref' href='deque.capacity'>[deque.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='resize,deque'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='deque.capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; size()</span>, erases the last <span class='texttt'>size() - sz</span> elements
from the sequence. Otherwise,
appends <span class='texttt'>sz - size()</span> default-inserted elements to the sequence.</p></div></div><div class='para' id='deque.capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>MoveInsertable</span> and <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,deque'></a></span><code class='itemdecl'>
void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='deque.capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; size()</span>, erases the last <span class='texttt'>size() - sz</span> elements
from the sequence. Otherwise,
appends <span class='texttt'>sz - size()</span> copies of <span class='texttt'>c</span> to the sequence.</p></div></div><div class='para' id='deque.capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shrink_to_fit,deque'></a></span><span class='indexparent'><a class='index' id='deque,shrink_to_fit'></a></span><code class='itemdecl'>
void shrink_to_fit();
</code></p><div class='itemdescr'></div><div class='para' id='deque.capacity-5'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>MoveInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='deque.capacity-6'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-6'>6</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in the size of the sequence.</p></div></div><div class='para' id='deque.capacity-7'><div class='marginalizedparent'><a class='marginalized' href='#deque.capacity-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>shrink_to_fit</span> is a non-binding request to reduce memory use
but does not change the size of the sequence. [&nbsp;<i>Note:</i><span class='space'></span> The request is non-binding to allow latitude for implementation-specific optimizations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='deque.modifiers'><h4 ><a class='secnum' href='#deque.modifiers' style='min-width:118pt'>23.3.8.4</a> <span class='texttt'>deque</span> modifiers <a class='abbr_ref' href='deque.modifiers'>[deque.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='insert,deque'></a></span><span class='indexparent'><a class='index' id='push_front,deque'></a></span><span class='indexparent'><a class='index' id='push_back,deque'></a></span><span class='indexparent'><a class='index' id='emplace,deque'></a></span><code class='itemdecl'>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position,
                  InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='deque.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.</p></div></div><div class='para' id='deque.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If an exception is thrown other than by the
copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>
there are no effects.
If an exception is thrown while inserting a single element at either end,
there are no effects.
Otherwise, if an exception is thrown by the move constructor of a
non-<span class='texttt'>CopyInsertable</span>
<span class='texttt'>T</span>, the effects are unspecified.</p></div></div><div class='para' id='deque.modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
<span class='texttt'>T</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase,deque'></a></span><code class='itemdecl'>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_front();
void pop_back();
</code></p><div class='itemdescr'></div><div class='para' id='deque.modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
An erase operation that erases the last element of a deque invalidates only the past-the-end iterator
and all iterators and references to the erased elements. An erase operation that erases the first
element of a deque but not the last element invalidates only iterators
and references to the erased elements. An erase operation
that erases neither the first element nor the last element of a deque invalidates the past-the-end
iterator and all iterators and references to all the elements of the deque.
[&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>pop_front</span> and <span class='texttt'>pop_back</span> are erase operations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='deque.modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The number of calls to the destructor of <span class='texttt'>T</span> is the same as the
number of elements erased, but the number of calls to the assignment operator of <span class='texttt'>T</span> is
no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</p></div></div><div class='para' id='deque.modifiers-6'><div class='marginalizedparent'><a class='marginalized' href='#deque.modifiers-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by the copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>.
</p></div></div></div><div id='deque.special'><h4 ><a class='secnum' href='#deque.special' style='min-width:118pt'>23.3.8.5</a> <span class='texttt'>deque</span> specialized algorithms <a class='abbr_ref' href='deque.special'>[deque.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,deque'></a></span><span class='indexparent'><a class='index' id='deque,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(deque&lt;T, Allocator&gt;&amp; x, deque&lt;T, Allocator&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='deque.special-1'><div class='marginalizedparent'><a class='marginalized' href='#deque.special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='forwardlist'><h3 ><a class='secnum' href='#forwardlist' style='min-width:103pt'>23.3.9</a> Class template <span class='texttt'>forward_list</span> <a class='abbr_ref' href='forwardlist'>[forwardlist]</a></h3><div id='forwardlist.overview'><h4 ><a class='secnum' href='#forwardlist.overview' style='min-width:118pt'>23.3.9.1</a> Class template <span class='texttt'>forward_list</span> overview <a class='abbr_ref' href='forwardlist.overview'>[forwardlist.overview]</a></h4><div class='para' id='forwardlist.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.overview-1'>1</a></div><p >A <span class='texttt'>forward_list</span> is a container that supports forward iterators and allows
constant time insert and erase operations anywhere within the sequence, with storage
management handled automatically. Fast random access to list elements is not supported.
[&nbsp;<i>Note:</i><span class='space'></span> It is intended that <span class='texttt'>forward_list</span> have zero space or time overhead
relative to a hand-written C-style singly linked list. Features that would conflict with
that goal have been omitted.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='forwardlist.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.overview-2'>2</a></div><p >A <span class='texttt'>forward_list</span> satisfies all of the requirements of a container
(Table <a href='container.requirements.general#tab:containers.container.requirements'>[tab:containers.container.requirements]</a>), except that the <span class='texttt'>size()</span>
member function is not provided and <span class='texttt'>operator==</span> has linear complexity.
A <span class='texttt'>forward_list</span> also satisfies all of the requirements for an allocator-aware
container (Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>). In addition, a <span class='texttt'>forward_list</span>
provides the <span class='texttt'>assign</span> member functions
(Table <a href='sequence.reqmts#tab:containers.sequence.requirements'>[tab:containers.sequence.requirements]</a>) and several of the optional
container requirements (Table <a href='sequence.reqmts#tab:containers.sequence.optional'>[tab:containers.sequence.optional]</a>).
Descriptions are provided here only for operations on
<span class='texttt'>forward_list</span> that are not described in that table or for operations where there
is additional semantic information.</p></div><div class='para' id='forwardlist.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.overview-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Modifying any list requires access to the element preceding the first element
of interest, but in a <span class='texttt'>forward_list</span> there is no constant-time way to access a
preceding element. For this reason, ranges that are modified, such as those supplied to
<span class='texttt'>erase</span> and <span class='texttt'>splice</span>, must be open at the beginning. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class forward_list {
  public:
    <span class='comment'>// types:
</span>    using value_type      = T;
    using allocator_type  = Allocator;
    using pointer         = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer   = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference       = value_type&amp;;
    using const_reference = const value_type&amp;;
    using size_type       = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator        = <span class='indexparent'><a class='index' id='type_of_forward_list::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator  = <span class='indexparent'><a class='index' id='type_of_forward_list::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>
    <span class='comment'>// <a href='forwardlist.cons'>[forwardlist.cons]</a>, construct/copy/destroy:
</span>    forward_list() : forward_list(Allocator()) { }
    explicit forward_list(const Allocator&amp;);
    explicit forward_list(size_type n, const Allocator&amp; = Allocator());
    forward_list(size_type n, const T&amp; value,
                 const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      forward_list(InputIterator first, InputIterator last,
                   const Allocator&amp; = Allocator());
    forward_list(const forward_list&amp; x);
    forward_list(forward_list&amp;&amp; x);
    forward_list(const forward_list&amp; x, const Allocator&amp;);
    forward_list(forward_list&amp;&amp; x, const Allocator&amp;);
    forward_list(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());
    ~forward_list();
    forward_list&amp; operator=(const forward_list&amp; x);
    forward_list&amp; operator=(forward_list&amp;&amp; x)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    forward_list&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; t);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// <a href='forwardlist.iter'>[forwardlist.iter]</a>, iterators:
</span>    iterator before_begin() noexcept;
    const_iterator before_begin() const noexcept;
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cbefore_begin() const noexcept;
    const_iterator cend() const noexcept;

    <span class='comment'>// capacity:
</span>    bool      empty() const noexcept;
    size_type max_size() const noexcept;

    <span class='comment'>// <a href='forwardlist.access'>[forwardlist.access]</a>, element access:
</span>    reference front();
    const_reference front() const;

    <span class='comment'>// <a href='forwardlist.modifiers'>[forwardlist.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
    void push_front(const T&amp; x);
    void push_front(T&amp;&amp; x);
    void pop_front();

    template &lt;class... Args&gt; iterator emplace_after(const_iterator position, Args&amp;&amp;... args);
    iterator insert_after(const_iterator position, const T&amp; x);
    iterator insert_after(const_iterator position, T&amp;&amp; x);

    iterator insert_after(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
    iterator insert_after(const_iterator position, initializer_list&lt;T&gt; il);

    iterator erase_after(const_iterator position);
    iterator erase_after(const_iterator position, const_iterator last);
    void swap(forward_list&amp;)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);

    void resize(size_type sz);
    void resize(size_type sz, const value_type&amp; c);
    void clear() noexcept;

    <span class='comment'>// <a href='forwardlist.ops'>[forwardlist.ops]</a>, forward_list operations:
</span>    void splice_after(const_iterator position, forward_list&amp; x);
    void splice_after(const_iterator position, forward_list&amp;&amp; x);
    void splice_after(const_iterator position, forward_list&amp; x,
                      const_iterator i);
    void splice_after(const_iterator position, forward_list&amp;&amp; x,
                      const_iterator i);
    void splice_after(const_iterator position, forward_list&amp; x,
                      const_iterator first, const_iterator last);
    void splice_after(const_iterator position, forward_list&amp;&amp; x,
                      const_iterator first, const_iterator last);

    void remove(const T&amp; value);
    template &lt;class Predicate&gt; void remove_if(Predicate pred);

    void unique();
    template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);

    void merge(forward_list&amp; x);
    void merge(forward_list&amp;&amp; x);
    template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);
    template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);

    void sort();
    template &lt;class Compare&gt; void sort(Compare comp);

    void reverse() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);

  <span class='comment'>// <a href='forwardlist.spec'>[forwardlist.spec]</a>, specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(forward_list&lt;T, Allocator&gt;&amp; x, forward_list&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));
}
</pre></div><div class='para' id='forwardlist.overview-4'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.overview-4'>4</a></div><p >An incomplete type <span class='texttt'>T</span> may be used when instantiating <span class='texttt'>forward_list</span>
if the allocator satisfies the
allocator completeness requirements <a href='allocator.requirements.completeness'>[allocator.requirements.completeness]</a>.
<span class='texttt'>T</span> shall be complete before any member of the resulting specialization
of <span class='texttt'>forward_list</span> is referenced.</p></div></div><div id='forwardlist.cons'><h4 ><a class='secnum' href='#forwardlist.cons' style='min-width:118pt'>23.3.9.2</a> <span class='texttt'>forward_list</span> constructors, copy, assignment <a class='abbr_ref' href='forwardlist.cons'>[forwardlist.cons]</a></h4><p ><span class='indexparent'><a class='index' id='forward_list,constructor'></a></span><code class='itemdecl'>
explicit forward_list(const Allocator&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an empty <span class='texttt'>forward_list</span> object using the specified allocator.</p></div></div><div class='para' id='forwardlist.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='forward_list,constructor'></a></span><code class='itemdecl'>
explicit forward_list(size_type n, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>forward_list</span> object with <span class='texttt'>n</span>
default-inserted elements using the specified allocator.</p></div></div><div class='para' id='forwardlist.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='forwardlist.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='forward_list,constructor'></a></span><code class='itemdecl'>
forward_list(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>forward_list</span> object with <span class='texttt'>n</span> copies of <span class='texttt'>value</span> using the specified allocator.</p></div></div><div class='para' id='forwardlist.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='forwardlist.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='forward_list,constructor'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  forward_list(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>forward_list</span> object equal to the range <span class='texttt'>[first, <span class='discretionary'></span>last)</span>.</p></div></div><div class='para' id='forwardlist.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>distance(first, last)</span>.
</p></div></div></div><div id='forwardlist.iter'><h4 ><a class='secnum' href='#forwardlist.iter' style='min-width:118pt'>23.3.9.3</a> <span class='texttt'>forward_list</span> iterators <a class='abbr_ref' href='forwardlist.iter'>[forwardlist.iter]</a></h4><p ><span class='indexparent'><a class='index' id='before_begin,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,before_begin'></a></span><span class='indexparent'><a class='index' id='cbefore_begin,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,cbefore_begin'></a></span><code class='itemdecl'>
iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
const_iterator cbefore_begin() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.iter-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.iter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A non-dereferenceable iterator that, when incremented, is equal to the iterator
returned by <span class='texttt'>begin()</span>.</p></div></div><div class='para' id='forwardlist.iter-2'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.iter-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>cbefore_begin()</span> is equivalent to
<span class='texttt'>const_cast&lt;forward_list const&amp;&gt;(*this).before_begin()</span>.</p></div></div><div class='para' id='forwardlist.iter-3'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.iter-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>before_begin() == end()</span> shall equal <span class='texttt'>false</span>.
</p></div></div></div><div id='forwardlist.access'><h4 ><a class='secnum' href='#forwardlist.access' style='min-width:118pt'>23.3.9.4</a> <span class='texttt'>forward_list</span> element access <a class='abbr_ref' href='forwardlist.access'>[forwardlist.access]</a></h4><p ><span class='indexparent'><a class='index' id='front,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,front'></a></span><code class='itemdecl'>
reference front();
const_reference front() const;
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.access-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*begin()</span>
</p></div></div></div><div id='forwardlist.modifiers'><h4 ><a class='secnum' href='#forwardlist.modifiers' style='min-width:118pt'>23.3.9.5</a> <span class='texttt'>forward_list</span> modifiers <a class='abbr_ref' href='forwardlist.modifiers'>[forwardlist.modifiers]</a></h4><div class='para' id='forwardlist.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-1'>1</a></div><p >None of the overloads of <span class='texttt'>insert_after</span> shall affect the validity of iterators and
references, and <span class='texttt'>erase_after</span> shall invalidate only iterators and references to
the erased elements. If an exception is thrown during <span class='texttt'>insert_after</span> there shall
be no effect. Inserting <span class='texttt'>n</span> elements into a <span class='texttt'>forward_list</span> is linear in
<span class='texttt'>n</span>, and the number of calls to the copy or move constructor of <span class='texttt'>T</span> is
exactly equal to <span class='texttt'>n</span>. Erasing <span class='texttt'>n</span> elements from a <span class='texttt'>forward_list</span> is
linear in <span class='texttt'>n</span> and the number of calls to the destructor of type <span class='texttt'>T</span> is
exactly equal to <span class='texttt'>n</span>.</p><p ><span class='indexparent'><a class='index' id='emplace_front,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,emplace_front'></a></span><code class='itemdecl'>
template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
</code></p></div><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts an object of type <span class='texttt'>value_type</span> constructed with
<span class='texttt'>value_type(std::forward&lt;Args&gt;(<span class='discretionary'></span>args)...)</span> at the beginning of the list.
</p></div></div><p ><span class='indexparent'><a class='index' id='push_front,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,push_front'></a></span><code class='itemdecl'>
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts a copy of <span class='texttt'>x</span> at the beginning of the list.
</p></div></div><p ><span class='indexparent'><a class='index' id='pop,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,pop'></a></span><code class='itemdecl'>
void pop_front();
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>erase_after(before_begin())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='insert_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,insert_after'></a></span><code class='itemdecl'>
iterator insert_after(const_iterator position, const T&amp; x);
iterator insert_after(const_iterator position, T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.</p></div></div><div class='para' id='forwardlist.modifiers-6'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts a copy of <span class='texttt'>x</span> after <span class='texttt'>position</span>.</p></div></div><div class='para' id='forwardlist.modifiers-7'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator pointing to the copy of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='insert_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,insert_after'></a></span><code class='itemdecl'>
iterator insert_after(const_iterator position, size_type n, const T&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-8'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.</p></div></div><div class='para' id='forwardlist.modifiers-9'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts <span class='texttt'>n</span> copies of <span class='texttt'>x</span> after <span class='texttt'>position</span>.</p></div></div><div class='para' id='forwardlist.modifiers-10'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing to the last inserted copy of <span class='texttt'>x</span> or <span class='texttt'>position</span> if <span class='texttt'>n == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='insert_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,insert_after'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-11'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.
<span class='texttt'>first</span> and <span class='texttt'>last</span> are not iterators in <span class='texttt'>*this</span>.</p></div></div><div class='para' id='forwardlist.modifiers-12'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts copies of elements in <span class='texttt'>[first, <span class='discretionary'></span>last)</span> after <span class='texttt'>position</span>.</p></div></div><div class='para' id='forwardlist.modifiers-13'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing to the last inserted element or <span class='texttt'>position</span> if <span class='texttt'>first == last</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='insert_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,insert_after'></a></span><code class='itemdecl'>
iterator insert_after(const_iterator position, initializer_list&lt;T&gt; il);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-14'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>insert_after(p, il.begin(), il.end())</span>.</p></div></div><div class='para' id='forwardlist.modifiers-15'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing to the last inserted element or <span class='texttt'>position</span> if <span class='texttt'>il</span> is empty.
</p></div></div><p ><span class='indexparent'><a class='index' id='emplace_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,emplace_after'></a></span><code class='itemdecl'>
template &lt;class... Args&gt;
  iterator emplace_after(const_iterator position, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-16'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-16'>16</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.</p></div></div><div class='para' id='forwardlist.modifiers-17'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts an object of type <span class='texttt'>value_type</span> constructed with
<span class='texttt'>value_type(std::forward&lt;Args&gt;(<span class='discretionary'></span>args)...)</span> after <span class='texttt'>position</span>.</p></div></div><div class='para' id='forwardlist.modifiers-18'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator pointing to the new object.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,erase_after'></a></span><code class='itemdecl'>
iterator erase_after(const_iterator position);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-19'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i> The iterator following <span class='texttt'>position</span> is dereferenceable.</p></div></div><div class='para' id='forwardlist.modifiers-20'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases the element pointed to by the iterator following <span class='texttt'>position</span>.</p></div></div><div class='para' id='forwardlist.modifiers-21'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator pointing to the element following the one that was
erased, or <span class='texttt'>end()</span> if no such element exists.</p></div></div><div class='para' id='forwardlist.modifiers-22'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-22'>22</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='erased,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,erased'></a></span><code class='itemdecl'>
iterator erase_after(const_iterator position, const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-23'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i> All iterators in the range <span class='texttt'>(position, <span class='discretionary'></span>last)</span> are dereferenceable.</p></div></div><div class='para' id='forwardlist.modifiers-24'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases the elements in the range <span class='texttt'>(position, <span class='discretionary'></span>last)</span>.</p></div></div><div class='para' id='forwardlist.modifiers-25'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='forwardlist.modifiers-26'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,resize'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-27'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-27'>27</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; distance(begin(), end())</span>, erases the last <span class='texttt'>distance(begin(),
end()) - sz</span> elements from the list. Otherwise, inserts <span class='texttt'>sz - distance(begin(), end())</span> default-inserted
elements at the end of the list.</p></div></div><div class='para' id='forwardlist.modifiers-28'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-28'>28</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
void resize(size_type sz, const value_type&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-29'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; distance(begin(), end())</span>, erases the last <span class='texttt'>distance(begin(),
end()) - sz</span> elements from the list. Otherwise, inserts <span class='texttt'>sz - distance(begin(), end())</span>  
copies of <span class='texttt'>c</span> at the end of the list.</p></div></div><div class='para' id='forwardlist.modifiers-30'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-30'>30</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='clear,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,clear'></a></span><code class='itemdecl'>
void clear() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.modifiers-31'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-31'>31</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases all elements in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.</p></div></div><div class='para' id='forwardlist.modifiers-32'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.modifiers-32'>32</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not invalidate past-the-end iterators.
</p></div></div></div><div id='forwardlist.ops'><h4 ><a class='secnum' href='#forwardlist.ops' style='min-width:118pt'>23.3.9.6</a> <span class='texttt'>forward_list</span> operations <a class='abbr_ref' href='forwardlist.ops'>[forwardlist.ops]</a></h4><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x);
void splice_after(const_iterator position, forward_list&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.
<span class='texttt'>get_allocator() == x.get_allocator()</span>.
<span class='texttt'>&amp;x != this</span>.</p></div></div><div class='para' id='forwardlist.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts the contents of <span class='texttt'>x</span> after
<span class='texttt'>position</span>, and <span class='texttt'>x</span> becomes empty. Pointers and references to the moved
elements of <span class='texttt'>x</span> now refer to those same elements but as members of <span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their elements, but
they now behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='forwardlist.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='forwardlist.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'><span class='texttt'>distance(x.begin(), x.end())</span></span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&amp;&amp; x, const_iterator i);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>.
The iterator following <span class='texttt'>i</span> is a dereferenceable iterator in <span class='texttt'>x</span>.
<span class='texttt'>get_allocator() == x.get_allocator()</span>.</p></div></div><div class='para' id='forwardlist.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts the element following <span class='texttt'>i</span> into <span class='texttt'>*this</span>, following
<span class='texttt'>position</span>, and removes it from <span class='texttt'>x</span>.
The result is unchanged if <span class='texttt'>position == i</span> or <span class='texttt'>position == ++i</span>. Pointers
and references to <span class='texttt'>*++i</span> continue to refer to the same element but as a member of
<span class='texttt'>*this</span>. Iterators to <span class='texttt'>*++i</span> continue to refer to
the same element, but now behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='forwardlist.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='forwardlist.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'>1</span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x,
                  const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&amp;&amp; x,
                  const_iterator first, const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a
dereferenceable iterator in the range <span class='texttt'>[begin(), <span class='discretionary'></span>end())</span>. <span class='texttt'>(first, <span class='discretionary'></span>last)</span> is a
valid range in <span class='texttt'>x</span>, and all iterators in the range <span class='texttt'>(first, <span class='discretionary'></span>last)</span> are
dereferenceable. <span class='texttt'>position</span> is not an iterator in the range <span class='texttt'>(first, <span class='discretionary'></span>last)</span>.
<span class='texttt'>get_allocator() == x.get_allocator()</span>.</p></div></div><div class='para' id='forwardlist.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts elements in the range <span class='texttt'>(first, <span class='discretionary'></span>last)</span> after <span class='texttt'>position</span> and
removes the elements from <span class='texttt'>x</span>. Pointers and references to the moved elements of
<span class='texttt'>x</span> now refer to those same elements but as members of <span class='texttt'>*this</span>. Iterators
referring to the moved elements will continue to refer to their elements, but they now
behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='forwardlist.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-11'>11</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'><span class='texttt'>distance(first, last)</span></span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='remove,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,remove'></a></span><span class='indexparent'><a class='index' id='remove_if,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,remove_if'></a></span><code class='itemdecl'>
void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases all the elements in the list referred by a list iterator <span class='texttt'>i</span> for
which the following conditions hold: <span class='texttt'>*i == value</span> (for <span class='texttt'>remove()</span>),
<span class='texttt'>pred(*i)</span> is true (for <span class='texttt'>remove_if()</span>).
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='forwardlist.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless an exception is thrown by the equality comparison or the
predicate.</p></div></div><div class='para' id='forwardlist.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>).</p></div></div><div class='para' id='forwardlist.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-15'>15</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>distance(begin(), end())</span> applications of the corresponding
predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,unique'></a></span><code class='itemdecl'>
void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases all but the first element from every consecutive
group of equal elements referred to by the iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first +
1, <span class='discretionary'></span>last)</span> for which <span class='texttt'>*i == *(i-1)</span> (for the version with no arguments) or <span class='texttt'>pred(*i,
*(i - 1))</span> (for the version with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='forwardlist.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-17'>17</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless an exception is thrown by the equality comparison or the predicate.</p></div></div><div class='para' id='forwardlist.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-18'>18</a></div><div class='itemdescr'><p ><i>Complexity:</i> If the range <span class='texttt'>[first, <span class='discretionary'></span>last)</span> is not empty, exactly <span class='texttt'>(last - first) - 1</span> applications of the corresponding predicate, otherwise no applications of the predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='merge,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,merge'></a></span><code class='itemdecl'>
void merge(forward_list&amp; x);
void merge(forward_list&amp;&amp; x);
template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>comp</span> defines a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>), and <span class='texttt'>*this</span>
and <span class='texttt'>x</span> are both sorted according to this ordering.
<span class='texttt'>get_allocator() == x.get_allocator()</span>.</p></div></div><div class='para' id='forwardlist.ops-20'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Merges the two sorted ranges <span class='texttt'>[begin(), end())</span> and
<span class='texttt'>[x.begin(), x.end())</span>. <span class='texttt'>x</span> is empty after the merge. If an
exception is thrown other than by a comparison there are no effects.
Pointers and references to the moved elements of <span class='texttt'>x</span> now refer to those same elements
but as members of <span class='texttt'>*this</span>. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into <span class='texttt'>*this</span>, not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='forwardlist.ops-21'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-21'>21</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>). The behavior is undefined if
<span class='texttt'>get_allocator() != x.get_allocator()</span>.</p></div></div><div class='para' id='forwardlist.ops-22'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-22'>22</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most <span class='texttt'>distance(begin(),
end()) + distance(x.begin(), x.end()) - 1</span> comparisons.
</p></div></div><p ><span class='indexparent'><a class='index' id='sort,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,sort'></a></span><code class='itemdecl'>
void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-23'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>operator&lt;</span> (for the version with no arguments) or <span class='texttt'>comp</span> (for the
version with a comparison argument) defines a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>).</p></div></div><div class='para' id='forwardlist.ops-24'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> Sorts the list according to the <span class='texttt'>operator&lt;</span> or the <span class='texttt'>comp</span> function object.
If an exception is thrown the order of the elements in <span class='texttt'>*this</span> is unspecified.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='forwardlist.ops-25'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-25'>25</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>).</p></div></div><div class='para' id='forwardlist.ops-26'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-26'>26</a></div><div class='itemdescr'><p ><i>Complexity:</i> Approximately <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span> <span class='mathalpha'>N</span></span> comparisons, where <span class='math'><span class='mathalpha'>N</span></span> is <span class='texttt'>distance(begin(), end())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,reverse'></a></span><code class='itemdecl'>
void reverse() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.ops-27'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-27'>27</a></div><div class='itemdescr'><p ><i>Effects:</i> Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='forwardlist.ops-28'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.ops-28'>28</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear time.
</p></div></div></div><div id='forwardlist.spec'><h4 ><a class='secnum' href='#forwardlist.spec' style='min-width:118pt'>23.3.9.7</a> <span class='texttt'>forward_list</span> specialized algorithms <a class='abbr_ref' href='forwardlist.spec'>[forwardlist.spec]</a></h4><p ><span class='indexparent'><a class='index' id='swap,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(forward_list&lt;T, Allocator&gt;&amp; x, forward_list&lt;T, Allocator&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='forwardlist.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#forwardlist.spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='list'><h3 ><a class='secnum' href='#list' style='min-width:103pt'>23.3.10</a> Class template <span class='texttt'>list</span> <a class='abbr_ref' href='list'>[list]</a></h3><div id='list.overview'><h4 ><a class='secnum' href='#list.overview' style='min-width:118pt'>23.3.10.1</a> Class template <span class='texttt'>list</span> overview <a class='abbr_ref' href='list.overview'>[list.overview]</a></h4><div class='para' id='list.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#list.overview-1'>1</a></div><p ><span class='indexparent'><a class='index' id='list'></a></span>A
<span class='texttt'>list</span>
is a sequence container that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike vectors (<a href='vector'>[vector]</a>) and deques (<a href='deque'>[deque]</a>),
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.</p></div><div class='para' id='list.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#list.overview-2'>2</a></div><p >A <span class='texttt'>list</span> satisfies all of the requirements of a container, of
a reversible container (given in two tables in
<a href='container.requirements'>[container.requirements]</a>), of a sequence container,
including most of the optional sequence container
requirements (<a href='sequence.reqmts'>[sequence.reqmts]</a>), and of an allocator-aware container
(Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>).
The exceptions are the
<span class='texttt'>operator[]</span>
and
<span class='texttt'>at</span>
member functions, which are not provided.<a class='footnotenum' href='#footnote-259'>259</a>
Descriptions are provided here only for operations on
<span class='texttt'>list</span>
that are not described in one of these tables
or for operations where there is additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class list {
  public:
    <span class='comment'>// types:
</span>    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer          = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference              = value_type&amp;;
    using const_reference        = const value_type&amp;;
    using size_type              = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type        = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator               = <span class='indexparent'><a class='index' id='type_of_list::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id='type_of_list::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// <a href='list.cons'>[list.cons]</a>, construct/copy/destroy:
</span>    list() : list(Allocator()) { }
    explicit list(const Allocator&amp;);
    explicit list(size_type n, const Allocator&amp; = Allocator());
    list(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      list(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
    list(const list&amp; x);
    list(list&amp;&amp; x);
    list(const list&amp;, const Allocator&amp;);
    list(list&amp;&amp;, const Allocator&amp;);
    list(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());
    ~list();
    list&amp; operator=(const list&amp; x);
    list&amp; operator=(list&amp;&amp; x)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    list&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; t);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='list.capacity'>[list.capacity]</a>, capacity:
</span>    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);

    <span class='comment'>// element access:
</span>    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='list.modifiers'>[list.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
    template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
    void push_front(const T&amp; x);
    void push_front(T&amp;&amp; x);
    void pop_front();
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);
    void pop_back();

    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
    iterator insert(const_iterator position, const T&amp; x);
    iterator insert(const_iterator position, T&amp;&amp; x);
    iterator insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert(const_iterator position, InputIterator first,
                      InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;T&gt; il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator position, const_iterator last);
    void     swap(list&amp;)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    void     clear() noexcept;

    <span class='comment'>// <a href='list.ops'>[list.ops]</a>, list operations:
</span>    void splice(const_iterator position, list&amp; x);
    void splice(const_iterator position, list&amp;&amp; x);
    void splice(const_iterator position, list&amp; x, const_iterator i);
    void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
    void splice(const_iterator position, list&amp; x,
                const_iterator first, const_iterator last);
    void splice(const_iterator position, list&amp;&amp; x,
                const_iterator first, const_iterator last);

    void remove(const T&amp; value);
    template &lt;class Predicate&gt; void remove_if(Predicate pred);

    void unique();
    template &lt;class BinaryPredicate&gt;
      void unique(BinaryPredicate binary_pred);

    void merge(list&amp; x);
    void merge(list&amp;&amp; x);
    template &lt;class Compare&gt; void merge(list&amp; x, Compare comp);
    template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);

    void sort();
    template &lt;class Compare&gt; void sort(Compare comp);

    void reverse() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);

  <span class='comment'>// <a href='list.special'>[list.special]</a>, specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(list&lt;T, Allocator&gt;&amp; x, list&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));
}
</pre></div><div class='para' id='list.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#list.overview-3'>3</a></div><p >An incomplete type <span class='texttt'>T</span> may be used when instantiating <span class='texttt'>list</span>
if the allocator satisfies the
allocator completeness requirements <a href='allocator.requirements.completeness'>[allocator.requirements.completeness]</a>.
<span class='texttt'>T</span> shall be complete before any member of the resulting specialization
of <span class='texttt'>list</span> is referenced.</p></div><div class='footnote' id='footnote-259'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-259'>259)</a></div><p >These member functions
are only provided by containers whose iterators
are random access iterators.
</p></div></div><div id='list.cons'><h4 ><a class='secnum' href='#list.cons' style='min-width:118pt'>23.3.10.2</a> <span class='texttt'>list</span> constructors, copy, and assignment <a class='abbr_ref' href='list.cons'>[list.cons]</a></h4><p ><span class='indexparent'><a class='index' id='list,constructor'></a></span><code class='itemdecl'>
explicit list(const Allocator&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='list.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an empty list, using the specified allocator.</p></div></div><div class='para' id='list.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='list,constructor'></a></span><code class='itemdecl'>
explicit list(size_type n, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='list.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>list</span> with
<span class='texttt'>n</span> default-inserted elements using the specified allocator.</p></div></div><div class='para' id='list.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='list.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear in
<span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='list,constructor'></a></span><code class='itemdecl'>
list(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='list.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>list</span>
with
<span class='texttt'>n</span>
copies of
<span class='texttt'>value</span>,
using the specified allocator.</p></div></div><div class='para' id='list.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='list.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear in
<span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='list,constructor'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  list(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='list.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>list</span>
equal to the range
<span class='texttt'>[first, <span class='discretionary'></span>last)</span>.</p></div></div><div class='para' id='list.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#list.cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear in
<span class='texttt'>distance(first, last)</span>.
</p></div></div></div><div id='list.capacity'><h4 ><a class='secnum' href='#list.capacity' style='min-width:118pt'>23.3.10.3</a> <span class='texttt'>list</span> capacity <a class='abbr_ref' href='list.capacity'>[list.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='resize,list'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='list.capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#list.capacity-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>size() &lt; sz</span>,
appends <span class='texttt'>sz - size()</span> default-inserted elements to the
sequence.
If <span class='texttt'>sz &lt;= size()</span>, equivalent to:</p><pre class='codeblock'>
list&lt;T&gt;::iterator it = begin();
advance(it, sz);
erase(it, end());
</pre></div></div><div class='para' id='list.capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#list.capacity-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,list'></a></span><code class='itemdecl'>
void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='list.capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#list.capacity-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 <span class='comment'>// do nothing
</span></pre></div></div><div class='para' id='list.capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#list.capacity-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div></div><div id='list.modifiers'><h4 ><a class='secnum' href='#list.modifiers' style='min-width:118pt'>23.3.10.4</a> <span class='texttt'>list</span> modifiers <a class='abbr_ref' href='list.modifiers'>[list.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='insert,list'></a></span><code class='itemdecl'>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position, InputIterator first,
                  InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='list.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#list.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.</p></div></div><div class='para' id='list.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#list.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Insertion of a single element into a list takes constant time and
exactly one call to a constructor of
<span class='texttt'>T</span>. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor or move constructor of <span class='texttt'>T</span> is exactly equal
to the number of elements inserted.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase,list'></a></span><code class='itemdecl'>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='list.modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#list.modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='list.modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#list.modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='list.modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#list.modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Erasing a single element is a constant time operation with a single call to the destructor of
<span class='texttt'>T</span>.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
<span class='texttt'>T</span>
is exactly equal to the size of the range.
</p></div></div></div><div id='list.ops'><h4 ><a class='secnum' href='#list.ops' style='min-width:118pt'>23.3.10.5</a> <span class='texttt'>list</span> operations <a class='abbr_ref' href='list.ops'>[list.ops]</a></h4><div class='para' id='list.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-1'>1</a></div><p >Since lists allow fast insertion and erasing from the middle of a list, certain
operations are provided specifically for them.<a class='footnotenum' href='#footnote-260'>260</a></p></div><div class='para' id='list.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-2'>2</a></div><p ><span class='texttt'>list</span> provides three splice operations that destructively move elements from one list to
another. The behavior of splice operations is undefined if <span class='texttt'>get_allocator() !=
x.get_allocator()</span>.</p><p ><span class='indexparent'><a class='index' id='splice,list'></a></span><code class='itemdecl'>
void splice(const_iterator position, list&amp; x);
void splice(const_iterator position, list&amp;&amp; x);
</code></p></div><div class='itemdescr'></div><div class='para' id='list.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>&amp;x != this</span>.</p></div></div><div class='para' id='list.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Inserts the contents of
<span class='texttt'>x</span>
before
<span class='texttt'>position</span>
and
<span class='texttt'>x</span>
becomes empty.
Pointers and references to the moved elements of
<span class='texttt'>x</span>
now refer to those same elements but as members of
<span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='list.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-6'>6</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='splice,list'></a></span><span class='indexparent'><a class='index' id='list,splice'></a></span><code class='itemdecl'>
void splice(const_iterator position, list&amp; x, const_iterator i);
void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Inserts an element pointed to by
<span class='texttt'>i</span>
from list
<span class='texttt'>x</span>
before <span class='texttt'>position</span> and removes the element from
<span class='texttt'>x</span>.
The result is unchanged if
<span class='texttt'>position == i</span>
or
<span class='texttt'>position == ++i</span>.
Pointers and references to
<span class='texttt'>*i</span>
continue to refer to this same element but as a member of
<span class='texttt'>*this</span>.
Iterators
to
<span class='texttt'>*i</span>
(including
<span class='texttt'>i</span>
itself) continue to refer to the same element, but now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>i</span>
is a valid dereferenceable iterator of
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='list.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='splice,list'></a></span><span class='indexparent'><a class='index' id='list,splice'></a></span><code class='itemdecl'>
void splice(const_iterator position, list&amp; x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&amp;&amp; x, const_iterator first,
            const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Inserts elements in the range
<span class='texttt'>[first, <span class='discretionary'></span>last)</span>
before
<span class='texttt'>position</span>
and removes the elements from
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>[first, last)</span>
is a valid range in
<span class='texttt'>x</span>.
The result is undefined if
<span class='texttt'>position</span>
is an iterator in the range
<span class='texttt'>[first, <span class='discretionary'></span>last)</span>.
Pointers and references to the moved elements of
<span class='texttt'>x</span>
now refer to those same elements but as members of
<span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='list.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-14'>14</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time if
<span class='texttt'>&amp;x == this</span>;
otherwise, linear time.
</p></div></div><p ><span class='indexparent'><a class='index' id='remove,list'></a></span><code class='itemdecl'>
void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>
Erases all the elements in the list referred by a list iterator <span class='texttt'>i</span> for which the
following conditions hold: <span class='texttt'>*i == value, pred(*i) != false</span>.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='list.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by
<span class='texttt'>*i == value</span>
or
<span class='texttt'>pred(*i) != false</span>.</p></div></div><div class='para' id='list.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-17'>17</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>).</p></div></div><div class='para' id='list.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-18'>18</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>size()</span>
applications of the corresponding predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique,list'></a></span><code class='itemdecl'>
void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
Erases all but the first element from every
consecutive group of equal elements referred to by the iterator <span class='texttt'>i</span> in the range
<span class='texttt'>[first + 1, <span class='discretionary'></span>last)</span> for which <span class='texttt'>*i == *(i-1)</span> (for the version of
<span class='texttt'>unique</span> with no arguments) or <span class='texttt'>pred(*i, *(i - 1))</span> (for the version of
<span class='texttt'>unique</span> with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='list.ops-20'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by
<span class='texttt'>*i == *(i-1)</span>
or
<span class='texttt'>pred(*i, *(i - 1))</span></p></div></div><div class='para' id='list.ops-21'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-21'>21</a></div><div class='itemdescr'><p ><i>Complexity:</i>
If the range
<span class='texttt'>[first, last)</span>
is not empty, exactly
<span class='texttt'>(last - first) - 1</span>
applications of the corresponding predicate,
otherwise no applications of the predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='merge,list'></a></span><code class='itemdecl'>
void merge(list&amp; x);
void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-22'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-22'>22</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>comp</span> shall define a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>), and both the list and the argument list shall be
sorted according to this ordering.</p></div></div><div class='para' id='list.ops-23'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>(&amp;x == this)</span> does nothing; otherwise, merges the two sorted ranges <span class='texttt'>[begin(),
end())</span> and <span class='texttt'>[x.<span class='discretionary'></span>begin(), x.end())</span>. The result is a range in which the elements
will be sorted in non-decreasing order according to the ordering defined by <span class='texttt'>comp</span>; that
is, for every iterator <span class='texttt'>i</span>, in the range other than the first, the condition
<span class='texttt'>comp(*i, *(i - 1))</span> will be false.
Pointers and references to the moved elements of <span class='texttt'>x</span> now refer to those same elements
but as members of <span class='texttt'>*this</span>. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into <span class='texttt'>*this</span>, not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='list.ops-24'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-24'>24</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>). If <span class='texttt'>(&amp;x != this)</span> the range <span class='texttt'>[x.begin(), x.end())</span>
is empty after the merge.
No elements are copied by this operation. The behavior is undefined if
<span class='texttt'>get_allocator() != x.get_allocator()</span>.</p></div></div><div class='para' id='list.ops-25'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-25'>25</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>size() + x.size() - 1</span>
applications of <span class='texttt'>comp</span> if
<span class='texttt'>(&amp;x != this)</span>;
otherwise, no applications of <span class='texttt'>comp</span> are performed.
If an exception is thrown other than by a comparison there are no effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse,list'></a></span><code class='itemdecl'>
void reverse() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-26'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='list.ops-27'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-27'>27</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear time.
</p></div></div><p ><span class='indexparent'><a class='index' id='sort,list'></a></span><code class='itemdecl'>
void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='list.ops-28'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-28'>28</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>operator&lt;</span>
(for the first
version)
or
<span class='texttt'>comp</span>
(for the second version)
shall define a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>).</p></div></div><div class='para' id='list.ops-29'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sorts the list according to the <span class='texttt'>operator&lt;</span> or a <span class='texttt'>Compare</span> function object.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='list.ops-30'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-30'>30</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (<a href='algorithm.stable'>[algorithm.stable]</a>).</p></div></div><div class='para' id='list.ops-31'><div class='marginalizedparent'><a class='marginalized' href='#list.ops-31'>31</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Approximately
<span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>
comparisons, where
<span class='texttt'>N == size()</span>.
</p></div></div><div class='footnote' id='footnote-260'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-260'>260)</a></div><p >As specified
in <a href='allocator.requirements'>[allocator.requirements]</a>, the requirements in this Clause apply only to
lists whose allocators compare equal.</p></div></div><div id='list.special'><h4 ><a class='secnum' href='#list.special' style='min-width:118pt'>23.3.10.6</a> <span class='texttt'>list</span> specialized algorithms <a class='abbr_ref' href='list.special'>[list.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,list'></a></span><span class='indexparent'><a class='index' id='list,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(list&lt;T, Allocator&gt;&amp; x, list&lt;T, Allocator&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='list.special-1'><div class='marginalizedparent'><a class='marginalized' href='#list.special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='vector'><h3 ><a class='secnum' href='#vector' style='min-width:103pt'>23.3.11</a> Class template <span class='texttt'>vector</span> <a class='abbr_ref' href='vector'>[vector]</a></h3><div id='vector.overview'><h4 ><a class='secnum' href='#vector.overview' style='min-width:118pt'>23.3.11.1</a> Class template <span class='texttt'>vector</span> overview <a class='abbr_ref' href='vector.overview'>[vector.overview]</a></h4><div class='para' id='vector.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.overview-1'>1</a></div><p ><span class='indexparent'><a class='index' id='vector'></a></span>A
<span class='texttt'>vector</span>
is a sequence container that supports
(amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.</p></div><div class='para' id='vector.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.overview-2'>2</a></div><p >A <span class='texttt'>vector</span> satisfies all of the requirements of a container and of a
reversible container (given in two tables in <a href='container.requirements'>[container.requirements]</a>), of a
sequence container, including most of the optional sequence container
requirements (<a href='sequence.reqmts'>[sequence.reqmts]</a>), of an allocator-aware container
(Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>),
and, for an element type other than <span class='texttt'>bool</span>,
of a contiguous container (<a href='container.requirements.general'>[container.requirements.general]</a>).
The exceptions are the
<span class='texttt'>push_front</span>, <span class='texttt'>pop_front</span>, and <span class='texttt'>emplace_front</span> member functions, which are not
provided. Descriptions are provided here only for operations on <span class='texttt'>vector</span>
that are not described in one of these tables or for operations where there is
additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class vector {
  public:
    <span class='comment'>// types:
</span>    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer          = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference              = value_type&amp;;
    using const_reference        = const value_type&amp;;
    using size_type              = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type        = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator               = <span class='indexparent'><a class='index' id='type_of_vector::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id='type_of_vector::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// <a href='vector.cons'>[vector.cons]</a>, construct/copy/destroy:
</span>    vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
    explicit vector(const Allocator&amp;) noexcept;
    explicit vector(size_type n, const Allocator&amp; = Allocator());
    vector(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
    vector(const vector&amp; x);
    vector(vector&amp;&amp;) noexcept;
    vector(const vector&amp;, const Allocator&amp;);
    vector(vector&amp;&amp;, const Allocator&amp;);
    vector(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());
    ~vector();
    vector&amp; operator=(const vector&amp; x);
    vector&amp; operator=(vector&amp;&amp; x)
      noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
               allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    vector&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; u);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='vector.capacity'>[vector.capacity]</a>, capacity:
</span>    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);
    void      reserve(size_type n);
    void      shrink_to_fit();

    <span class='comment'>// element access:
</span>    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='vector.data'>[vector.data]</a>, data access
</span>    T*       data() noexcept;
    const T* data() const noexcept;

    <span class='comment'>// <a href='vector.modifiers'>[vector.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);
    void pop_back();

    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
    iterator insert(const_iterator position, const T&amp; x);
    iterator insert(const_iterator position, T&amp;&amp; x);
    iterator insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;T&gt; il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(vector&amp;)
      noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
               allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    void     clear() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);

  <span class='comment'>// <a href='vector.special'>[vector.special]</a>, specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(vector&lt;T, Allocator&gt;&amp; x, vector&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));
}
</pre><p ><span class='indexparent'><a class='index' id='vector,operator=='></a></span><span class='indexparent'><a class='index' id='vector,operator<'></a></span></p></div><div class='para' id='vector.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#vector.overview-3'>3</a></div><p >An incomplete type <span class='texttt'>T</span> may be used when instantiating <span class='texttt'>vector</span>
if the allocator satisfies the
allocator completeness requirements <a href='allocator.requirements.completeness'>[allocator.requirements.completeness]</a>.
<span class='texttt'>T</span> shall be complete before any member of the resulting specialization
of <span class='texttt'>vector</span> is referenced.</p></div></div><div id='vector.cons'><h4 ><a class='secnum' href='#vector.cons' style='min-width:118pt'>23.3.11.2</a> <span class='texttt'>vector</span> constructors, copy, and assignment <a class='abbr_ref' href='vector.cons'>[vector.cons]</a></h4><p ><span class='indexparent'><a class='index' id='vector,constructor'></a></span>
<code class='itemdecl'>
explicit vector(const Allocator&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='vector.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an empty <span class='texttt'>vector</span>, using the
specified allocator.</p></div></div><div class='para' id='vector.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,constructor'></a></span>
<code class='itemdecl'>
explicit vector(size_type n, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='vector.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> with <span class='texttt'>n</span>
default-inserted elements using the specified allocator.</p></div></div><div class='para' id='vector.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,constructor'></a></span>
<code class='itemdecl'>
vector(size_type n, const T&amp; value,
       const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='vector.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> with <span class='texttt'>n</span>
copies of <span class='texttt'>value</span>, using the specified allocator.</p></div></div><div class='para' id='vector.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,constructor'></a></span>
<code class='itemdecl'>
template &lt;class InputIterator&gt;
  vector(InputIterator first, InputIterator last,
         const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='vector.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> equal to the
range <span class='texttt'>[first, <span class='discretionary'></span>last)</span>, using the specified allocator.</p></div></div><div class='para' id='vector.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#vector.cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Makes only <span class='math'><span class='mathalpha'>N</span></span>
calls to the copy constructor of
<span class='texttt'>T</span>
(where <span class='math'><span class='mathalpha'>N</span></span>
is the distance between
<span class='texttt'>first</span>
and
<span class='texttt'>last</span>)
and no reallocations if iterators first and last are of forward, bidirectional, or random access categories.
It makes order
<span class='texttt'>N</span>
calls to the copy constructor of
<span class='texttt'>T</span>
and order
<span class='math'><span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>
reallocations if they are just input iterators.
</p></div></div></div><div id='vector.capacity'><h4 ><a class='secnum' href='#vector.capacity' style='min-width:118pt'>23.3.11.3</a> <span class='texttt'>vector</span> capacity <a class='abbr_ref' href='vector.capacity'>[vector.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='capacity,vector'></a></span><code class='itemdecl'>
size_type capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The total number of elements that the vector can hold
without requiring reallocation.
</p></div></div><p ><span class='indexparent'><a class='index' id='reserve,vector'></a></span><code class='itemdecl'>
void reserve(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>MoveInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
A directive that informs a
<span class='texttt'>vector</span>
of a planned change in size, so that it can manage the storage allocation accordingly.
After
<span class='texttt'>reserve()</span>,
<span class='texttt'>capacity()</span>
is greater or equal to the argument of
<span class='texttt'>reserve</span>
if reallocation happens; and equal to the previous value of
<span class='texttt'>capacity()</span>
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
<span class='texttt'>reserve()</span>. If an exception is thrown
other than by the move constructor of a non-<span class='texttt'>CopyInsertable</span> type,
there are no effects.</p></div></div><div class='para' id='vector.capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.</p></div></div><div class='para' id='vector.capacity-5'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>length_error</span> if <span class='texttt'>n &gt;
max_size()</span>.<a class='footnotenum' href='#footnote-261'>261</a></p></div></div><div class='para' id='vector.capacity-6'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
No reallocation shall take place during insertions that happen
after a call to
<span class='texttt'>reserve()</span>
until the time when an insertion would make the size of the vector
greater than the value of
<span class='texttt'>capacity()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shrink_to_fit,vector'></a></span><code class='itemdecl'>
void shrink_to_fit();
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-7'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>MoveInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.capacity-8'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in the size of the sequence.</p></div></div><div class='para' id='vector.capacity-9'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>shrink_to_fit</span> is a non-binding request to reduce <span class='texttt'>capacity()</span> to <span class='texttt'>size()</span>. [&nbsp;<i>Note:</i><span class='space'></span> The request is non-binding to allow latitude for implementation-specific optimizations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an exception is thrown other than by the move constructor of a non-<span class='texttt'>CopyInsertable</span> <span class='texttt'>T</span> there are no effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,vector'></a></span><code class='itemdecl'>
void swap(vector&amp; x)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-10'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges the contents and
<span class='texttt'>capacity()</span>
of
<span class='texttt'>*this</span>
with that of <span class='texttt'>x</span>.</p></div></div><div class='para' id='vector.capacity-11'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-11'>11</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,vector'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-12'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; size()</span>, erases the last <span class='texttt'>size() - sz</span> elements
from the sequence. Otherwise,
appends <span class='texttt'>sz - size()</span> default-inserted elements to the sequence.</p></div></div><div class='para' id='vector.capacity-13'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>MoveInsertable</span> and <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.capacity-14'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> If an exception is thrown other than by the move constructor of a non-<span class='texttt'>CopyInsertable</span>
<span class='texttt'>T</span> there are no effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,vector'></a></span><code class='itemdecl'>
void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='vector.capacity-15'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt; size()</span>, erases the last <span class='texttt'>size() - sz</span> elements
from the sequence. Otherwise,
appends <span class='texttt'>sz - size()</span> copies of <span class='texttt'>c</span> to the sequence.</p></div></div><div class='para' id='vector.capacity-16'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-16'>16</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='vector.capacity-17'><div class='marginalizedparent'><a class='marginalized' href='#vector.capacity-17'>17</a></div><div class='itemdescr'><p ><i>Remarks:</i> If an exception is thrown there are no effects.
</p></div></div><div class='footnote' id='footnote-261'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-261'>261)</a></div><p ><span class='texttt'>reserve()</span> uses <span class='texttt'>Allocator::allocate()</span> which
may throw an appropriate exception.</p></div></div><div id='vector.data'><h4 ><a class='secnum' href='#vector.data' style='min-width:118pt'>23.3.11.4</a> <span class='texttt'>vector</span> data <a class='abbr_ref' href='vector.data'>[vector.data]</a></h4><p ><span class='indexparent'><a class='index' id='data,vector'></a></span><code class='itemdecl'>
T*         data() noexcept;
const T*   data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='vector.data-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.data-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer such that <span class='texttt'>[data(), <span class='discretionary'></span>data() + size())</span> is a valid range. For a
non-empty vector, <span class='texttt'>data()</span> <span class='texttt'>==</span> <span class='texttt'>addressof(front())</span>.</p></div></div><div class='para' id='vector.data-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.data-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div></div><div id='vector.modifiers'><h4 ><a class='secnum' href='#vector.modifiers' style='min-width:118pt'>23.3.11.5</a> <span class='texttt'>vector</span> modifiers <a class='abbr_ref' href='vector.modifiers'>[vector.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='insert,vector'></a></span><code class='itemdecl'>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='vector.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span> or by any <span class='texttt'>InputIterator</span> operation
there are no effects.
If an exception is thrown while inserting a single element at the end and
<span class='texttt'>T</span> is <span class='texttt'>CopyInsertable</span> or <span class='texttt'>is_nothrow_move_constructible_v&lt;T&gt;</span>
is <span class='texttt'>true</span>, there are no effects.
Otherwise, if an exception is thrown by the move constructor of a non-<span class='texttt'>CopyInsertable</span>
<span class='texttt'>T</span>, the effects are unspecified.</p></div></div><div class='para' id='vector.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The complexity is linear in the number of elements inserted plus the distance
to the end of the vector.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase,vector'></a></span><code class='itemdecl'>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_back();
</code></p><div class='itemdescr'></div><div class='para' id='vector.modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#vector.modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Invalidates iterators and references at or after the point of the erase.</p></div></div><div class='para' id='vector.modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#vector.modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The destructor of <span class='texttt'>T</span> is called the number of times equal to the
number of the elements erased, but the assignment operator
of <span class='texttt'>T</span> is called the number of times equal to the number of
elements in the vector after the erased elements.</p></div></div><div class='para' id='vector.modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#vector.modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by the
copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>.
</p></div></div></div><div id='vector.special'><h4 ><a class='secnum' href='#vector.special' style='min-width:118pt'>23.3.11.6</a> <span class='texttt'>vector</span> specialized algorithms <a class='abbr_ref' href='vector.special'>[vector.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,vector'></a></span><span class='indexparent'><a class='index' id='vector,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(vector&lt;T, Allocator&gt;&amp; x, vector&lt;T, Allocator&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='vector.special-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='vector.bool'><h3 ><a class='secnum' href='#vector.bool' style='min-width:103pt'>23.3.12</a> Class <span class='texttt'>vector&lt;bool&gt;</span> <a class='abbr_ref' href='vector.bool'>[vector.bool]</a></h3><div class='para' id='vector.bool-1'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-1'>1</a></div><p ><span class='indexparent'><a class='index' id='vector<bool>'></a></span>To optimize space allocation, a specialization of vector for
<span class='texttt'>bool</span>
elements is provided:</p><pre class='codeblock'>
namespace std {
  template &lt;class Allocator&gt;
  class vector&lt;bool, Allocator&gt; {
  public:
    <span class='comment'>// types:
</span>    using value_type             = bool;
    using allocator_type         = Allocator;
    using pointer                = <i>implementation-defined</i>;
    using const_pointer          = <i>implementation-defined</i>;
    using const_reference        = bool;
    using size_type              = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type        = <i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator               = <span class='indexparent'><a class='index' id='type_of_vector<bool>::iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id='type_of_vector<bool>::const_iterator'></a></span><i>implementation-defined</i>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// bit reference:
</span>    class reference {
      friend class vector;
      reference() noexcept;
    public:
      ~reference();
      operator bool() const noexcept;
      reference&amp; operator=(const bool x) noexcept;
      reference&amp; operator=(const reference&amp; x) noexcept;
      void flip() noexcept;     <span class='comment'>// flips the bit
</span>    };

    <span class='comment'>// construct/copy/destroy:
</span>    vector() : vector(Allocator()) { }
    explicit vector(const Allocator&amp;);
    explicit vector(size_type n, const Allocator&amp; = Allocator());
    vector(size_type n, const bool&amp; value,
           const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      vector(InputIterator first, InputIterator last,
             const Allocator&amp; = Allocator());
    vector(const vector&lt;bool, Allocator&gt;&amp; x);
    vector(vector&lt;bool, Allocator&gt;&amp;&amp; x);
    vector(const vector&amp;, const Allocator&amp;);
    vector(vector&amp;&amp;, const Allocator&amp;);
    vector(initializer_list&lt;bool&gt;, const Allocator&amp; = Allocator()));
   ~vector();
    vector&lt;bool, Allocator&gt;&amp; operator=(const vector&lt;bool, Allocator&gt;&amp; x);
    vector&lt;bool, Allocator&gt;&amp; operator=(vector&lt;bool, Allocator&gt;&amp;&amp; x);
    vector&amp; operator=(initializer_list&lt;bool&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const bool&amp; t);
    void assign(initializer_list&lt;bool&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// capacity:
</span>    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz, bool c = false);
    void      reserve(size_type n);
    void      shrink_to_fit();

    <span class='comment'>// element access:
</span>    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// modifiers:
</span>    template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
    void push_back(const bool&amp; x);
    void pop_back();
    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
    iterator insert(const_iterator position, const bool&amp; x);
    iterator insert(const_iterator position, size_type n, const bool&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert(const_iterator position,
                      InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;bool&gt; il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector&lt;bool, Allocator&gt;&amp;);
    static void swap(reference x, reference y) noexcept;
    void flip() noexcept;       <span class='comment'>// flips all bits
</span>    void clear() noexcept;
  };
}
</pre></div><div class='para' id='vector.bool-2'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-2'>2</a></div><p >Unless described below, all operations have the same requirements and
semantics as the primary <span class='texttt'>vector</span> template, except that operations
dealing with the <span class='texttt'>bool</span> value type map to bit values in the
container storage and
<span class='texttt'>allocator_traits::construct</span> (<a href='allocator.traits.members'>[allocator.traits.members]</a>)
is not used to construct these values.</p></div><div class='para' id='vector.bool-3'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-3'>3</a></div><p >There is no requirement that the data be stored as a contiguous allocation
of <span class='texttt'>bool</span> values. A space-optimized representation of bits is
recommended instead.</p></div><div class='para' id='vector.bool-4'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-4'>4</a></div><p ><span class='texttt'>reference</span>
is a class that simulates the behavior of references of a single bit in
<span class='texttt'>vector&lt;bool&gt;</span>. The conversion operator returns <span class='texttt'>true</span>
when the bit is set, and <span class='texttt'>false</span> otherwise. The assignment operator
sets the bit when the argument is (convertible to) <span class='texttt'>true</span> and
clears it otherwise. <span class='texttt'>flip</span> reverses the state of the bit.</p><p ><span class='indexparent'><a class='index' id='flip,vector<bool>'></a></span><span class='indexparent'><a class='index' id='vector<bool>,flip'></a></span><code class='itemdecl'>
void flip() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='vector.bool-5'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Replaces each element in the container with its complement.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,vector<bool>'></a></span><span class='indexparent'><a class='index' id='vector<bool>,swap'></a></span><code class='itemdecl'>
static void swap(reference x, reference y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='vector.bool-6'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the contents of <span class='texttt'>x</span> and <span class='texttt'>y</span> as if by:</p><pre class='codeblock'>
bool b = x;
x = y;
y = b;
</pre></div></div><p ><code class='itemdecl'>
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='vector.bool-7'><div class='marginalizedparent'><a class='marginalized' href='#vector.bool-7'>7</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div></div></div></body></html>