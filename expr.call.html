<!DOCTYPE html><html lang='en'><head><title>[expr.call]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.call'>[expr.post]</a></h2><div id='expr.call'><h3 ><a class='secnum' style='min-width:103pt'>5.2.2</a> Function call <a class='abbr_ref'>[expr.call]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,function_call'></a></span><span class='indexparent'><a class='index' id='operator,function_call'></a></span><span class='indexparent'><a class='index' id='()'></a></span>A function call is a postfix expression followed by parentheses
containing a possibly empty, comma-separated list of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> which
constitute the arguments to the function. The postfix expression shall
have function type or function pointer type.
For a call to a non-member function or to a static member function,
the postfix expression shall be either an lvalue that refers to a
function (in which case the function-to-pointer standard
conversion (<a href='conv.func'>[conv.func]</a>) is suppressed on the postfix expression),
or it shall have function pointer type. Calling a function through an
expression whose function type is different
from the function type of the called function's
definition results in undefined behavior (<a href='dcl.link'>[dcl.link]</a>). For a call to a non-static
member function,
the postfix expression shall be an
implicit (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>, <a href='class.static'>[class.static]</a>) or explicit
class member access (<a href='expr.ref'>[expr.ref]</a>) whose <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is a
function member name, or a pointer-to-member
expression (<a href='expr.mptr.oper'>[expr.mptr.oper]</a>) selecting a function member; the call is as a member of
the class object referred to by the
object expression. In the case of an implicit class
member access, the implied object is the one pointed to by <span class='texttt'>this</span>.
[&nbsp;<i>Note:</i><span class='space'></span>
A member function call of the form <span class='texttt'>f()</span> is interpreted as
<span class='texttt'>(*this).f()</span> (see <a href='class.mfct.non-static'>[class.mfct.non-static]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If a function or member function name is used, the name can be
overloaded (Clause <a href='over'>[over]</a>), in which case the appropriate function
shall be selected according to the rules in <a href='over.match'>[over.match]</a>. If the selected
function is non-virtual, or if the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in the class
member access expression is a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, that function is
called. Otherwise, its final overrider (<a href='class.virtual'>[class.virtual]</a>) in the dynamic type
of the object expression is called; such a call is referred to as a
<a class='hidden_link' href='#def:function,virtual_function_call' id='def:function,virtual_function_call'><i>virtual function call</i></a>.
[&nbsp;<i>Note:</i><span class='space'></span>
The dynamic type is the type of the object referred to by the
current value of the object expression. <a href='class.cdtor'>[class.cdtor]</a> describes the
behavior of virtual function calls when the object expression
refers to
an object under construction or destruction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
If a function or member function name is used, and name
lookup (<a href='basic.lookup'>[basic.lookup]</a>) does not find a declaration of that name,
the program is ill-formed. No function is implicitly declared by such a
call.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> designates a destructor (<a href='class.dtor'>[class.dtor]</a>),
the type of the function call expression is <span class='texttt'>void</span>; otherwise, the
type of the function call expression is the return type of the
statically chosen function (i.e., ignoring the <span class='texttt'>virtual</span> keyword),
even if the type of the function actually called is different.
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>This return type shall be an object type, a reference type or <i>cv</i>
<span class='texttt'>void</span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='function_argument'></a></span><span class='indexparent'><a class='index' id='function_parameter'></a></span><span class='indexparent'><a class='index' id='initialization,parameter'></a></span>When a function is called, each parameter (<a href='dcl.fct'>[dcl.fct]</a>) shall be
initialized (<a href='dcl.init'>[dcl.init]</a>, <a href='class.copy'>[class.copy]</a>, <a href='class.ctor'>[class.ctor]</a>) with
its corresponding argument.
If the function is a non-static member
function, the <span class='texttt'>this</span> parameter of the function (<a href='class.this'>[class.this]</a>)
shall be initialized with a pointer to the object of the call, converted
as if by an explicit type conversion (<a href='expr.cast'>[expr.cast]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
There is no access or ambiguity checking on this conversion; the access
checking and disambiguation are done as part of the (possibly implicit)
class member access operator.
See <a href='class.member.lookup'>[class.member.lookup]</a>, <a href='class.access.base'>[class.access.base]</a>,
and <a href='expr.ref'>[expr.ref]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
When a function is called, the parameters that have object type shall
have completely-defined object type.
[&nbsp;<i>Note:</i><span class='space'></span>
this still allows a parameter to be a pointer or reference to an
incomplete class type. However, it prevents a passed-by-value parameter
to have an incomplete class type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
It is <span class='indexparent'><a class='index' id='whether_the_lifetime_of_a_parameter_ends_when_the_callee_returns_or_at_the_end_of_the_enclosing_full-expression'></a></span>implementation-defined whether the
lifetime of a parameter ends when the function in which it is defined
returns or at the end of the enclosing full-expression.
The initialization and destruction of each parameter occurs
within the context of the calling function.
[&nbsp;<i>Example:</i><span class='space'></span>
the access of the constructor, conversion functions or destructor is
checked at the point of call in the calling function. If a constructor
or destructor for a function parameter throws an exception, the search
for a handler starts in the scope of the calling function; in
particular, if the function called has a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>
(Clause <a href='except'>[except]</a>) with a handler that could handle the exception,
this handler is not considered.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='evaluation,order_of_argument'></a></span><span class='indexparent'><a class='index' id='evaluation,unspecified_order_of_function_call'></a></span><span class='indexparent'><a class='index' id='evaluation,unspecified_order_of_argument'></a></span>The <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> is sequenced before
each <i ><a href='expr.comma#nt:expression'>expression</a></i> in the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
and any default argument.
The initialization of a parameter,
including every associated value computation and side effect,
is indeterminately sequenced with respect to that of any other parameter.
[&nbsp;<i>Note:</i><span class='space'></span>
All side effects of
argument evaluations are sequenced before the function is
entered (see <a href='intro.execution'>[intro.execution]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
void f() {
  std::string s = "but I have heard it works even if you don't believe in it";
  s.replace(0, 4, "").replace(s.find("even"), 4, "only").replace(s.find(" don't"), 6, "");
  assert(s == "I have heard it works only if you believe in it"); <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The result of a function call is the
result of the operand of the evaluated <span class='texttt'>return</span> statement (<a href='stmt.return'>[stmt.return]</a>)
in the called function (if any),
except in a virtual function call if the return type of the
final overrider is different from the return type of the statically
chosen function, the value returned from the final overrider is
converted to the return type of the statically chosen function.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='type_checking,argument'></a></span><span class='indexparent'><a class='index' id='function_call'></a></span><span class='indexparent'><a class='index' id='argument_passing'></a></span><span class='indexparent'><a class='index' id='value,call_by'></a></span><span class='indexparent'><a class='index' id='reference,call_by'></a></span><span class='indexparent'><a class='index' id='argument,reference'></a></span>a function can change the values of its non-const parameters, but these
changes cannot affect the values of the arguments except where a
parameter is of a reference type (<a href='dcl.ref'>[dcl.ref]</a>); if the reference is to
a const-qualified type, <span class='texttt'>const_cast</span> is required to be used to
cast away the constness in order to modify the argument's value. Where a
parameter is of <span class='texttt'>const</span> reference type a temporary object is
introduced if
needed (<a href='dcl.type'>[dcl.type]</a>, <a href='lex.literal'>[lex.literal]</a>, <a href='lex.string'>[lex.string]</a>, <a href='dcl.array'>[dcl.array]</a>, <a href='class.temporary'>[class.temporary]</a>).
In addition, it is possible to modify the values of nonconstant objects through
pointer parameters.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='declaration,ellipsis_in_function'></a></span><span class='indexparent'><a class='index' id='parameter_list,variable'></a></span>A function can be declared to accept fewer arguments (by declaring default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>)) or more arguments (by using the ellipsis,
<span class='texttt'>...</span>, or a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>)) than the number of
parameters in the function definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
this implies that, except where the ellipsis (<span class='texttt'>...</span>) or a function
parameter pack is used, a parameter is available for each argument.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='ellipsis,conversion_sequence'></a></span>When there is no parameter for a given argument, the argument is passed
in such a way that the receiving function can obtain the value of the
argument by invoking <span class='texttt'>va_arg</span> (<a href='support.runtime'>[support.runtime]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This paragraph does not apply to arguments passed to a function parameter pack.
Function parameter packs are expanded during template instantiation (<a href='temp.variadic'>[temp.variadic]</a>),
thus each such argument has a corresponding parameter when a function template
specialization is actually called. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard conversions are
performed on the argument expression.
An argument that has (possibly cv-qualified) type <span class='texttt'>std::nullptr_t</span> is converted
to type <span class='texttt'>void*</span> (<a href='conv.ptr'>[conv.ptr]</a>).
After these conversions, if the
argument does not have arithmetic, enumeration, pointer, pointer to
member, or class type, the program is ill-formed. Passing a potentially-evaluated
argument of class type (Clause <a href='class'>[class]</a>) having a non-trivial
copy constructor, a non-trivial move constructor,
or a
non-trivial destructor, with no corresponding parameter, is conditionally-supported with
<span class='indexparent'><a class='index' id='passing_argument_of_class_type_through_ellipsis'></a></span>implementation-defined semantics. If the argument has
integral or enumeration type that is subject to the integral
promotions (<a href='conv.prom'>[conv.prom]</a>), or a floating point type that is subject to the floating
point promotion (<a href='conv.fpprom'>[conv.fpprom]</a>), the value of the argument is converted to the
promoted type before the call. These promotions are referred to as
the <a class='hidden_link' href='#def:promotion,default_argument_promotion' id='def:promotion,default_argument_promotion'><i>default argument promotions</i></a>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='function_call,recursive'></a></span>Recursive calls are permitted, except to the <span class='texttt'>main</span>
function (<a href='basic.start.main'>[basic.start.main]</a>).</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >A function call is an lvalue
if the result type is an lvalue reference type or an rvalue reference to function type,
an xvalue if the result type is an rvalue reference to object type, and a prvalue
otherwise.</p></div></div></div></body></html>