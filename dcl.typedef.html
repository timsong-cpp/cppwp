<!DOCTYPE html><html lang='en'><head><title>[dcl.typedef]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.typedef'>[dcl.spec]</a></h2><div id='dcl.typedef'><h3 ><a class='secnum' style='min-width:103pt'>7.1.3</a> The <span class='texttt'>typedef</span> specifier <a class='abbr_ref'>[dcl.typedef]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,typedef'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Declarations containing the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <span class='texttt'>typedef</span>
declare identifiers that can be used later for naming
fundamental (<a href='basic.fundamental'>[basic.fundamental]</a>) or compound (<a href='basic.compound'>[basic.compound]</a>)
types. The <span class='texttt'>typedef</span> specifier shall not be
combined in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> with any other kind of
specifier except a <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>, and it shall not be used in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> (<a href='dcl.fct'>[dcl.fct]</a>) nor in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
If a <span class='texttt'>typedef</span> specifier appears in a declaration without a <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>,
the program is ill-formed.</p><pre class='bnf'><a id='nt:typedef-name'>typedef-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><p >A name declared with the <span class='texttt'>typedef</span> specifier becomes a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>. Within the scope of its declaration, a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is syntactically equivalent to a keyword and
names the type associated with the identifier in the way described in
Clause <a href='dcl.decl'>[dcl.decl]</a>.
<span class='indexparent'><a class='index' id='declaration,typedef'></a></span><span class='indexparent'><a class='index' id='equivalence,type'></a></span><span class='indexparent'><a class='index' id='synonym,type_name_as'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is thus a synonym for another type. A
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> does not introduce a new type the way a class
declaration (<a href='class.name'>[class.name]</a>) or enum declaration does.
[&nbsp;<i>Example:</i>
<span class='indexparent'><a class='index' id='example,typedef'></a></span>after</p><pre class='codeblock'>
typedef int MILES, *KLICKSP;
</pre><p >the constructions</p><pre class='codeblock'>
MILES distance;
extern KLICKSP metricp;
</pre><p >are all correct declarations; the type of <span class='texttt'>distance</span> is
<span class='texttt'>int</span> and that of <span class='texttt'>metricp</span> is “pointer to <span class='texttt'>int</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> can also be introduced by an
<i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>. The <i ><a href='lex.name#nt:identifier'>identifier</a></i> following the
<span class='texttt'>using</span> keyword becomes a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
and the optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> following the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> appertains to that <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>.
Such a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> has the same
semantics as if it were introduced by the <span class='texttt'>typedef</span> specifier. In
particular, it does not define a new type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int);         <span class='comment'>// redeclare <span class='texttt'>ignore</span>
</span>using cell = pair&lt;void*, cell*&gt;;    <span class='comment'>// ill-formed
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>
of the <i ><a href='dcl.name#nt:defining-type-id'>defining-type-id</a></i> shall not define
a class or enumeration if the <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
is the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> of a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='redefinition,typedef'></a></span>In a given non-class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine the name of any type declared in that scope to refer to the
type to which it already refers.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef struct s { <span class='texttt'>/* ... */</span> } s;
typedef int I;
typedef int I;
typedef I I;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >In a given class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine any <i ><a href='class#nt:class-name'>class-name</a></i> declared in that scope that is not
also a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> to refer to the type to which it already
refers.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S {
  typedef struct A { } A;       <span class='comment'>// OK
</span>  typedef struct B B;           <span class='comment'>// OK
</span>  typedef A A;                  <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If a <span class='texttt'>typedef</span> specifier is used to redefine in a given scope an
entity that can be referenced using an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>,
the entity can continue to be referenced by an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> or as an enumeration or class name
in an enumeration or class definition respectively. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S;
typedef struct S S;
int main() {
  struct S* p;                  <span class='comment'>// OK
</span>}
struct S { };                   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >In a given scope, a <span class='texttt'>typedef</span> specifier shall not be used to
redefine the name of any type declared in that scope to refer to a
different type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class complex { <span class='texttt'>/* ... */</span> };
typedef int complex;            <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Similarly, in a given scope, a class or enumeration shall not be
declared with the same name as a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that is
declared in that scope and refers to a type other than the class or
enumeration itself.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
typedef int complex;
class complex { <span class='texttt'>/* ... */</span> };    <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a class type, or a cv-qualified
version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>). If
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is used to identify the subject of an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>), a class
definition (Clause <a href='class'>[class]</a>), a constructor
declaration (<a href='class.ctor'>[class.ctor]</a>), or a destructor
declaration (<a href='class.dtor'>[class.dtor]</a>), the program is ill-formed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S {
  S();
  ~S();
};

typedef struct S T;

S a = T();                      <span class='comment'>// OK
</span>struct T * p;                   <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='class_name,typedef'></a></span><span class='indexparent'><a class='index' id='enum_name,typedef'></a></span><span class='indexparent'><a class='index' id='class,unnamed'></a></span>If the typedef declaration defines an unnamed class (or enum), the first
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> declared by the declaration to be that class
type (or enum type) is used to denote the class type (or enum type) for
linkage purposes only (<a href='basic.link'>[basic.link]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef struct { } *ps, S;      <span class='comment'>// <span class='texttt'>S</span> is the class name for linkage purposes
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>