<!DOCTYPE html><html lang='en'><head><title>[tuple.creation]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.5</a> Tuples <a class='abbr_ref' href='tuple#creation'>[tuple]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.5.2</a> Class template <span class='texttt'>tuple</span> <a class='abbr_ref' href='tuple.tuple#tuple.creation'>[tuple.tuple]</a></h3><div id='tuple.creation'><h4 ><a class='secnum' style='min-width:118pt'>20.5.2.4</a> Tuple creation functions <a class='abbr_ref'>[tuple.creation]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >In the function descriptions that follow, let <span class='math'><span class='mathalpha'>i</span></span> be in the range <span class='texttt'>[0, <span class='discretionary'></span>sizeof...(TTypes))</span>
in order and let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in a template parameter pack named <span class='texttt'>TTypes</span>;
let <span class='math'><span class='mathalpha'>j</span></span> be in the range <span class='texttt'>[0, <span class='discretionary'></span>sizeof...(UTypes))</span> in order and <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>j</span></sub></span> be the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> type
in a template parameter pack named <span class='texttt'>UTypes</span>, where indexing is zero-based.</p><p ><span class='indexparent'><a class='index' id='make_tuple'></a></span><span class='indexparent'><a class='index' id='tuple!make_tuple'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;... t);
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'><span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span></span> be <span class='texttt'>decay_t&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> for each
<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>Types</span>. Then each <span class='math'><span class='mathalpha'>V</span><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>VTypes</span> is
<span class='texttt'>X&amp;</span> if <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> equals <span class='texttt'>reference_wrapper&lt;X&gt;</span>, otherwise
<span class='math'><span class='mathalpha'>V</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tuple&lt;VTypes...&gt;(std::forward&lt;Types&gt;(t)...)</span>.</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int i; float j;
make_tuple(1, ref(i), cref(j))
</pre><p >creates a tuple of type</p><pre class='codeblock'>
tuple&lt;int, int&amp;, const float&amp;&gt;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='forward_as_tuple'></a></span><span class='indexparent'><a class='index' id='tuple!forward_as_tuple'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;... t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a tuple of references to the arguments in <span class='texttt'>t</span> suitable
for forwarding as arguments to a function. Because the result may contain references
to temporary variables, a program shall ensure that the return value of this
function does not outlive any of its arguments. (e.g., the program should typically
not store the result in a named variable).</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tuple&lt;Types&amp;&amp;...&gt;(std::forward&lt;Types&gt;(t)...)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tie'></a></span><span class='indexparent'><a class='index' id='ignore'></a></span><span class='indexparent'><a class='index' id='tuple!tie'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;Types&amp;...&gt; tie(Types&amp;... t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>tuple&lt;Types&amp;...&gt;(t...)</span>.  When an
argument in <span class='texttt'>t</span> is <span class='texttt'>ignore</span>, assigning
any value to the corresponding tuple element has no effect.</p></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span>
<span class='texttt'>tie</span> functions allow one to create tuples that unpack
tuples into variables. <span class='texttt'>ignore</span> can be used for elements that
are not needed:
</p><pre class='codeblock'>
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
<span class='comment'>// <span class='texttt'>i == 42</span>, <span class='texttt'>s == "C++"</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple_cat'></a></span>
<code class='itemdecl'>
template &lt;class... Tuples&gt;
  constexpr tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;... tpls);
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p >In the following paragraphs, let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Tuples</span>,
<span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> be <span class='texttt'>remove_reference_t&lt;Ti&gt;</span>, and <span class='math'><span class='mathalpha'>tp</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
parameter in the function parameter pack <span class='texttt'>tpls</span>, where all indexing is
zero-based.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> shall be the type
<span class='math'><i>cv</i><sub ><span class='mathalpha'>i</span></sub></span> <span class='texttt'>tuple&lt;<span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub>...</span>&gt;</span>, where <span class='math'><i>cv</i><sub ><span class='mathalpha'>i</span></sub></span> is the (possibly empty) <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
cv-qualifier-seq and <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span> is the parameter pack representing the element
types in <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>. Let <span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span> be the <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span>. For all
<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span> the following requirements shall be satisfied: If <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> is
deduced as an lvalue reference type, then
<span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>, <span class='math'><span class='mathalpha'>cv</span><sub ><span class='mathalpha'>i</span></sub></span> <span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>&amp;&gt; == true</span>, otherwise
<span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>, <span class='math'><span class='mathalpha'>cv</span><sub ><span class='mathalpha'>i</span></sub> <span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>&amp;&amp;&gt; == true</span>.</p></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> The types in <span class='texttt'><i>Ctypes</i></span> shall be equal to the ordered
sequence of the extended types
<span class='texttt'><span class='math'><span class='mathalpha'>Args</span><sub >0</sub></span>..., <span class='math'><span class='mathalpha'>Args</span><sub >1</sub></span>...,</span> ... <span class='texttt'><span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>n</span>-1</sub></span>...</span>, where <span class='math'><span class='mathalpha'>n</span></span> is
equal to <span class='texttt'>sizeof...(Tuples)</span>. Let <span class='texttt'><span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span>...</span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
ordered sequence of tuple elements of the resulting <span class='texttt'>tuple</span> object
corresponding to the type sequence <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span>.</p></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>tuple</span> object constructed by initializing the <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub><sup ><span class='mathalpha'>th</span></sup></span>
type element <span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>ik</span></sub></span> in <span class='texttt'><span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span>...</span> with<br/>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(std::forward&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(<span class='math'><span class='mathalpha'>tp</span><sub ><span class='mathalpha'>i</span></sub></span>))</span> for each valid <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub></span> and
each group <span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span> in order.</p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Note:</i> An implementation may support additional types in the parameter
pack <span class='texttt'>Tuples</span> that support the <span class='texttt'>tuple</span>-like protocol, such as
<span class='texttt'>pair</span> and <span class='texttt'>array</span>.
</p></div></div></div></div></body></html>