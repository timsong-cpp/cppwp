<!DOCTYPE html><html lang='en'><head><title>[container.node.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>21.2</a> Container requirements <a class='abbr_ref' href='container.requirements#container.node.overview'>[container.requirements]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>21.2.4</a> Node handles <a class='abbr_ref' href='container.node#overview'>[container.node]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>21.2.4.1</a> Overview <a class='abbr_ref'>[container.node.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/containers.tex#L1204'>#</a></div><div id='1.sentence-1' class='sentence'>A <a class='hidden_link' href='#def:node_handle' id='def:node_handle'><i >node handle</i></a> is an object that accepts ownership of a single element
from an associative container (<a href='associative.reqmts'>[associative.reqmts]</a>) or an unordered
associative container (<a href='unord.req'>[unord.req]</a>)<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>It may be used to transfer that
ownership to another container with compatible nodes<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>Containers with
compatible nodes have the same node handle type<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>Elements may be transferred in
either direction between container types in the same row of
Table <a href='#tab:containers.node.compat'>70</a><a class='hidden_link' href='#1.sentence-4'>.</a></div><div class='numberedTable' id='tab:containers.node.compat'>Table <a href='#tab:containers.node.compat'>70</a> â€” Container types with compatible nodes<br><table ><tr class='rowsep'><td class='left'><div id='1.sentence-5' class='sentence'><span class='texttt'>map&lt;K, T, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-6' class='sentence'><span class='texttt'>map&lt;K, T, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-7' class='sentence'><span class='texttt'>map&lt;K, T, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-8' class='sentence'><span class='texttt'>multimap&lt;K, T, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-9' class='sentence'><span class='texttt'>set&lt;K, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-10' class='sentence'><span class='texttt'>set&lt;K, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-11' class='sentence'><span class='texttt'>set&lt;K, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-12' class='sentence'><span class='texttt'>multiset&lt;K, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-13' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-14' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-15' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-16' class='sentence'><span class='texttt'>unordered_&shy;multimap&lt;K, T, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-17' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-18' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-19' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-20' class='sentence'><span class='texttt'>unordered_&shy;multiset&lt;K, H2, E2, A&gt;</span></div></td></tr></table></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/containers.tex#L1233'>#</a></div><div id='2.sentence-1' class='sentence'>If a node handle is not empty, then it contains an allocator that is equal to
the allocator of the container when the element was extracted<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>If a node handle
is empty, it contains no allocator<a class='hidden_link' href='#2.sentence-2'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/containers.tex#L1238'>#</a></div><div id='3.sentence-1' class='sentence'>Class <span class='texttt'><span class='textit'>node-handle</span></span> is for exposition only<a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/containers.tex#L1241'>#</a></div><div id='4.sentence-1' class='sentence'>If a user-defined specialization of <span class='texttt'>pair</span> exists for
<span class='texttt'>pair&lt;const Key, T&gt;</span> or <span class='texttt'>pair&lt;Key, T&gt;</span>, where <span class='texttt'>Key</span> is the
container's <span class='texttt'>key_&shy;type</span> and <span class='texttt'>T</span> is the container's
<span class='texttt'>mapped_&shy;type</span>, the behavior of operations involving node handles is
undefined<a class='hidden_link' href='#4.sentence-1'>.</a></div><pre class='codeblock'>
template&lt;<span class='textit'><span class='texttt'>unspecified</span></span>&gt;
class <span class='textit'>node-handle</span> {
public:
  <span class='comment'>// These type declarations are described in Tables <a href='associative.reqmts#tab:containers.associative.requirements'>71</a> and <a href='unord.req#tab:HashRequirements'>72</a>.
</span>  using value_type     = <span class='textit'><span class='texttt'>see below</span></span>;     <span class='comment'>// not present for map containers
</span>  using key_type       = <span class='textit'><span class='texttt'>see below</span></span>;     <span class='comment'>// not present for set containers
</span>  using mapped_type    = <span class='textit'><span class='texttt'>see below</span></span>;     <span class='comment'>// not present for set containers
</span>  using allocator_type = <span class='textit'><span class='texttt'>see below</span></span>;

private:
  using container_node_type = <span class='textit'><span class='texttt'>unspecified</span></span>;
  using ator_traits = allocator_traits&lt;allocator_type&gt;;

  typename ator_traits::rebind_traits&lt;container_node_type&gt;::pointer ptr_;
  optional&lt;allocator_type&gt; alloc_;

public:
  <span class='comment'>// <a href='container.node.cons'>[container.node.cons]</a>, constructors, copy, and assignment
</span>  constexpr <span class='textit'>node-handle</span>() noexcept : ptr_(), alloc_() {}
  <span class='textit'>node-handle</span>(<span class='textit'>node-handle</span>&amp;&amp;) noexcept;
  <span class='textit'>node-handle</span>&amp; operator=(<span class='textit'>node-handle</span>&amp;&amp;);

  <span class='comment'>// <a href='container.node.dtor'>[container.node.dtor]</a>, destructor
</span>  ~<span class='textit'>node-handle</span>();

  <span class='comment'>// <a href='container.node.observers'>[container.node.observers]</a>, observers
</span>  value_type&amp; value() const;            <span class='comment'>// not present for map containers
</span>  key_type&amp; key() const;                <span class='comment'>// not present for set containers
</span>  mapped_type&amp; mapped() const;          <span class='comment'>// not present for set containers
</span>
  allocator_type get_allocator() const;
  explicit operator bool() const noexcept;
  [[nodiscard]] bool empty() const noexcept;

  <span class='comment'>// <a href='container.node.modifiers'>[container.node.modifiers]</a>, modifiers
</span>  void swap(<span class='textit'>node-handle</span>&amp;)
    noexcept(ator_traits::propagate_on_container_swap::value ||
             ator_traits::is_always_equal::value);

  friend void swap(<span class='textit'>node-handle</span>&amp; x, <span class='textit'>node-handle</span>&amp; y) noexcept(noexcept(x.swap(y))) {
    x.swap(y);
  }
};</pre></div></div></body></html>