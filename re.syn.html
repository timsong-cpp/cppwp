<!DOCTYPE html><html lang='en'><head><title>[re.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>28</a> Regular expressions library <a class='abbr_ref' href='./#re'>[re]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>28.4</a> Header <span class='texttt'>&lt;regex&gt;</span> synopsis <a class='abbr_ref'>[re.syn]</a></h2><span class='indexparent'><a class='index' id=':<regex>'></a></span><span class='indexparent'><a class='index' id=':<regex>'></a></span><span class='indexparent'><a class='index' id='lib:basic_regex'></a></span><span class='indexparent'><a class='index' id='lib:regex'></a></span><span class='indexparent'><a class='index' id='lib:wregex'></a></span><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='re.const'>[re.const]</a>, regex constants
</span>  namespace regex_constants {
    using syntax_option_type = <span class='textit'>T1</span>;
    using match_flag_type = <span class='textit'>T2</span>;
    using error_type = <span class='textit'>T3</span>;
  }

  <span class='comment'>// <a href='re.badexp'>[re.badexp]</a>, class <span class='tcode_in_codeblock'>regex_&shy;error</span>
</span>  class regex_error;

  <span class='comment'>// <a href='re.traits'>[re.traits]</a>, class template <span class='tcode_in_codeblock'>regex_&shy;traits</span>
</span>  template&lt;class charT&gt; struct regex_traits;

  <span class='comment'>// <a href='re.regex'>[re.regex]</a>, class template <span class='tcode_in_codeblock'>basic_&shy;regex</span>
</span>  template&lt;class charT, class traits = regex_traits&lt;charT&gt;&gt; class basic_regex;

  using regex  = basic_regex&lt;char&gt;;
  using wregex = basic_regex&lt;wchar_t&gt;;

  <span class='comment'>// <a href='re.regex.swap'>[re.regex.swap]</a>, <span class='tcode_in_codeblock'>basic_&shy;regex</span> swap
</span>  template&lt;class charT, class traits&gt;
    void swap(basic_regex&lt;charT, traits&gt;&amp; e1, basic_regex&lt;charT, traits&gt;&amp; e2);

  <span class='comment'>// <a href='re.submatch'>[re.submatch]</a>, class template <span class='tcode_in_codeblock'>sub_&shy;match</span>
</span>  template&lt;class BidirectionalIterator&gt;
    class sub_match;

  using csub_match  = sub_match&lt;const char*&gt;;
  using wcsub_match = sub_match&lt;const wchar_t*&gt;;
  using ssub_match  = sub_match&lt;string::const_iterator&gt;;
  using wssub_match = sub_match&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.submatch.op'>[re.submatch.op]</a>, <span class='tcode_in_codeblock'>sub_&shy;match</span> non-member operators
</span>  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);

  template&lt;class BiIter, class ST, class SA&gt;
    bool operator==(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator!=(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;=(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;=(
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);

  template&lt;class BiIter, class ST, class SA&gt;
    bool operator==(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator!=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);

  template&lt;class BiIter&gt;
    bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);

  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);

  template&lt;class BiIter&gt;
    bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);

  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);

  template&lt;class charT, class ST, class BiIter&gt;
    basic_ostream&lt;charT, ST&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);

  <span class='comment'>// <a href='re.results'>[re.results]</a>, class template <span class='tcode_in_codeblock'>match_&shy;results</span>
</span>  template&lt;class BidirectionalIterator,
           class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;
    class match_results;

  using cmatch  = match_results&lt;const char*&gt;;
  using wcmatch = match_results&lt;const wchar_t*&gt;;
  using smatch  = match_results&lt;string::const_iterator&gt;;
  using wsmatch = match_results&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <span class='tcode_in_codeblock'>match_&shy;results</span> comparisons
</span>  template&lt;class BidirectionalIterator, class Allocator&gt;
    bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
  template&lt;class BidirectionalIterator, class Allocator&gt;
    bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.results.swap'>[re.results.swap]</a>, <span class='tcode_in_codeblock'>match_&shy;results</span> swap
</span>  template&lt;class BidirectionalIterator, class Allocator&gt;
    void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
              match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.alg.match'>[re.alg.match]</a>, function template <span class='tcode_in_codeblock'>regex_&shy;match</span>
</span>  template&lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class BidirectionalIterator, class charT, class traits&gt;
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class charT, class Allocator, class traits&gt;
    bool regex_match(const charT* str, match_results&lt;const charT*, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     match_results&lt;typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                                   Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;,
                     match_results&lt;typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                                   Allocator&gt;&amp;,
                     const basic_regex&lt;charT, traits&gt;&amp;,
                     regex_constants::match_flag_type = regex_constants::match_default) = delete;
  template&lt;class charT, class traits&gt;
    bool regex_match(const charT* str,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);

  <span class='comment'>// <a href='re.alg.search'>[re.alg.search]</a>, function template <span class='tcode_in_codeblock'>regex_&shy;search</span>
</span>  template&lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class BidirectionalIterator, class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class charT, class Allocator, class traits&gt;
    bool regex_search(const charT* str,
                      match_results&lt;const charT*, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class charT, class traits&gt;
    bool regex_search(const charT* str,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      match_results&lt;typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                                    Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;,
                      match_results&lt;typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                                    Allocator&gt;&amp;,
                      const basic_regex&lt;charT, traits&gt;&amp;,
                      regex_constants::match_flag_type
                        = regex_constants::match_default) = delete;

  <span class='comment'>// <a href='re.alg.replace'>[re.alg.replace]</a>, function template <span class='tcode_in_codeblock'>regex_&shy;replace</span>
</span>  template&lt;class OutputIterator, class BidirectionalIterator,
            class traits, class charT, class ST, class SA&gt;
    OutputIterator
      regex_replace(OutputIterator out,
                    BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class OutputIterator, class BidirectionalIterator, class traits, class charT&gt;
    OutputIterator
      regex_replace(OutputIterator out,
                    BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class traits, class charT, class ST, class SA, class FST, class FSA&gt;
    basic_string&lt;charT, ST, SA&gt;
      regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const basic_string&lt;charT, FST, FSA&gt;&amp; fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT, ST, SA&gt;
      regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT&gt;
      regex_replace(const charT* s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template&lt;class traits, class charT&gt;
    basic_string&lt;charT&gt;
      regex_replace(const charT* s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);

  <span class='comment'>// <a href='re.regiter'>[re.regiter]</a>, class template <span class='tcode_in_codeblock'>regex_&shy;iterator</span>
</span>  template&lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_iterator;

  using cregex_iterator  = regex_iterator&lt;const char*&gt;;
  using wcregex_iterator = regex_iterator&lt;const wchar_t*&gt;;
  using sregex_iterator  = regex_iterator&lt;string::const_iterator&gt;;
  using wsregex_iterator = regex_iterator&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.tokiter'>[re.tokiter]</a>, class template <span class='tcode_in_codeblock'>regex_&shy;token_&shy;iterator</span>
</span>  template&lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_token_iterator;

  using cregex_token_iterator  = regex_token_iterator&lt;const char*&gt;;
  using wcregex_token_iterator = regex_token_iterator&lt;const wchar_t*&gt;;
  using sregex_token_iterator  = regex_token_iterator&lt;string::const_iterator&gt;;
  using wsregex_token_iterator = regex_token_iterator&lt;wstring::const_iterator&gt;;

  namespace pmr {
    template&lt;class BidirectionalIterator&gt;
      using match_results =
        std::match_results&lt;BidirectionalIterator,
                           polymorphic_allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;;

    using cmatch  = match_results&lt;const char*&gt;;
    using wcmatch = match_results&lt;const wchar_t*&gt;;
    using smatch  = match_results&lt;string::const_iterator&gt;;
    using wsmatch = match_results&lt;wstring::const_iterator&gt;;
  }
}</pre></div></body></html>