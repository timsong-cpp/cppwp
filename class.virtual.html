<!DOCTYPE html><html lang='en'><head><title>[class.virtual]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>10</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>10.6</a> Derived classes <a class='abbr_ref' href='class.derived#class.virtual'>[class.derived]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>10.6.2</a> Virtual functions <a class='abbr_ref'>[class.virtual]</a></h3><span class='indexparent'><a class='index' id=':function,virtual'></a></span><span class='indexparent'><a class='index' id=':type,polymorphic'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3721'>#</a></div><div id='1.sentence-1' class='sentence'>A non-static member function is a <span class='indexparent'><a class='index' id=':function,virtual_'></a></span><span class='textit'>virtual function</span>
if it is first declared with the keyword <span class='texttt'>virtual</span> or
if it overrides a virtual member function declared in a base class
(see below)<a class='hidden_link' href='#1.sentence-1'>.</a><a class='footnotenum' href='#footnote-113'>113</a></div> <div id='1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-2' class='sentence'>Virtual functions support dynamic binding and object-oriented
programming<a class='hidden_link' href='#1.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='1.sentence-3' class='sentence'> A class that declares or inherits a virtual function is
called a <span class='indexparent'><a class='index' id=':class,polymorphic'></a></span><span class='textit'>polymorphic class</span><a class='hidden_link' href='#1.sentence-3'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3733'>#</a></div><div id='2.sentence-1' class='sentence'>If a virtual member function <span class='texttt'>vf</span> is declared in a class
<span class='texttt'>Base</span> and in a class <span class='texttt'>Derived</span>, derived directly or
indirectly from <span class='texttt'>Base</span>, a member function <span class='texttt'>vf</span> with the same
name, parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>), cv-qualification, and ref-qualifier
(or absence of same) as <span class='texttt'>Base&#x200b;::&#x200b;vf</span> is declared,
then <span class='texttt'>Derived&#x200b;::&#x200b;vf</span> <a class='hidden_link' href='#def:overrides' id='def:overrides'><i>overrides</i></a><a class='footnotenum' href='#footnote-114'>114</a>
<span class='texttt'>Base&#x200b;::&#x200b;vf</span><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>For convenience we say that any virtual function
overrides itself<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'><span class='indexparent'><a class='index' id=':overrider,final'></a></span>A virtual member function <span class='texttt'>C&#x200b;::&#x200b;vf</span> of a class object <span class='texttt'>S</span> is a <a class='hidden_link' href='#def:final_overrider' id='def:final_overrider'><i >final
overrider</i></a> unless the most derived class (<a href='intro.object'>[intro.object]</a>) of which <span class='texttt'>S</span> is a
base class subobject (if any) declares or inherits another member function that overrides
<span class='texttt'>vf</span><a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.sentence-4' class='sentence'>In a derived class, if a virtual member function of a base class subobject
has more than one final overrider the program is ill-formed<a class='hidden_link' href='#2.sentence-4'>.</a></div> <div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  virtual void f();
};
struct B : virtual A {
  virtual void f();
};
struct C : B , virtual A {
  using A::f;
};

void foo() {
  C c;
  c.f();              <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>, the final overrider
</span>  c.C::f();           <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span> because of the using-declaration
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> <div id='2.example-2' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { };  <span class='comment'>// OK: <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span> and <span class='tcode_in_codeblock'>C&#x200b;::&#x200b;f</span> are the final overriders
</span>                      <span class='comment'>// for the <span class='tcode_in_codeblock'>B</span> and <span class='tcode_in_codeblock'>C</span> subobjects, respectively
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3782'>#</a></div><div id='3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-1' class='sentence'>A virtual member function does not have to be visible to be overridden,
for example,
<pre class='codeblock'>
struct B {
  virtual void f();
};
struct D : B {
  void f(int);
};
struct D2 : D {
  void f();
};</pre>
the function <span class='texttt'>f(int)</span> in class <span class='texttt'>D</span> hides the virtual
function <span class='texttt'>f()</span> in its base class <span class='texttt'>B</span>; <span class='texttt'>D&#x200b;::&#x200b;f(int)</span> is
not a virtual function<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>However, <span class='texttt'>f()</span> declared in class
<span class='texttt'>D2</span> has the same name and the same parameter list as
<span class='texttt'>B&#x200b;::&#x200b;f()</span>, and therefore is a virtual function that overrides the
function <span class='texttt'>B&#x200b;::&#x200b;f()</span> even though <span class='texttt'>B&#x200b;::&#x200b;f()</span> is not visible in
class <span class='texttt'>D2</span><a class='hidden_link' href='#3.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3806'>#</a></div><div id='4.sentence-1' class='sentence'>If a virtual function <span class='texttt'>f</span> in some class <span class='texttt'>B</span> is marked with the
<i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i> <span class='texttt'>final</span> and in a class <span class='texttt'>D</span> derived from <span class='texttt'>B</span>
a function <span class='texttt'>D&#x200b;::&#x200b;f</span> overrides <span class='texttt'>B&#x200b;::&#x200b;f</span>, the program is ill-formed<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct B {
  virtual void f() const final;
};

struct D : B {
  void f() const;     <span class='comment'>// error: <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;f</span> attempts to override <span class='tcode_in_codeblock'>final</span> <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3821'>#</a></div><div id='5.sentence-1' class='sentence'>If a virtual function is marked with the <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i> <span class='texttt'>override</span> and
does not override a member function of a base class, the program is ill-formed<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct B {
  virtual void f(int);
};

struct D : B {
  virtual void f(long) override;  <span class='comment'>// error: wrong signature overriding <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>
</span>  virtual void f(int) override;   <span class='comment'>// OK
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3836'>#</a></div><div id='6.sentence-1' class='sentence'>A virtual function shall not have a trailing <i ><a href='temp#nt:requires-clause'>requires-clause</a></i> (<a href='dcl.decl'>[dcl.decl]</a>)<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  virtual void f() requires true; <span class='comment'>// error: virtual function cannot be constrained (<a href='temp.constr.decl'>[temp.constr.decl]</a>)
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3846'>#</a></div><div id='7.sentence-1' class='sentence'>Even though destructors are not inherited, a destructor in a derived
class overrides a base class destructor declared virtual;
see <a href='class.dtor'>[class.dtor]</a> and <a href='class.free'>[class.free]</a><a class='hidden_link' href='#7.sentence-1'>.</a></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3851'>#</a></div><div id='8.sentence-1' class='sentence'>The return type of an overriding function shall be either identical to
the return type of the overridden function or <a class='hidden_link' href='#def:return_type,covariant' id='def:return_type,covariant'><i >covariant</i></a> with
the classes of the functions<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.sentence-2' class='sentence'>If a function <span class='texttt'>D&#x200b;::&#x200b;f</span> overrides a
function <span class='texttt'>B&#x200b;::&#x200b;f</span>, the return types of the functions are covariant
if they satisfy the following criteria:
<ul class='itemize'><li id='8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.1'>(8.1)</a></div><div id='8.1.sentence-1' class='sentence'>both are pointers to classes, both are lvalue references to
classes, or both are rvalue references to classes<a class='footnotenum' href='#footnote-115'>115</a></div></li><li id='8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.2'>(8.2)</a></div><div id='8.2.sentence-1' class='sentence'>the class in the return type of <span class='texttt'>B&#x200b;::&#x200b;f</span> is the same class as
the class in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span>, or is an unambiguous and
accessible direct or indirect base class of the class in the return type
of <span class='texttt'>D&#x200b;::&#x200b;f</span></div></li><li id='8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.3'>(8.3)</a></div><div id='8.3.sentence-1' class='sentence'>both pointers or references have the same cv-qualification and the
class type in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> has the same
cv-qualification as or less cv-qualification than the class type in the
return type of <span class='texttt'>B&#x200b;::&#x200b;f</span><a class='hidden_link' href='#8.3.sentence-1'>.</a></div></li></ul></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3874'>#</a></div><div id='9.sentence-1' class='sentence'>If the class type in the covariant return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> differs from that of
<span class='texttt'>B&#x200b;::&#x200b;f</span>, the class type in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> shall be
complete at the point of declaration of <span class='texttt'>D&#x200b;::&#x200b;f</span> or shall be the
class type <span class='texttt'>D</span><a class='hidden_link' href='#9.sentence-1'>.</a></div> <div id='9.sentence-2' class='sentence'>When the overriding function is called as the
final overrider of the overridden function, its result is converted to
the type returned by the (statically chosen) overridden
function (<a href='expr.call'>[expr.call]</a>)<a class='hidden_link' href='#9.sentence-2'>.</a></div> <div id='9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class B { };
class D : private B { friend class Derived; };
struct Base {
  virtual void vf1();
  virtual void vf2();
  virtual void vf3();
  virtual B*   vf4();
  virtual B*   vf5();
  void f();
};

struct No_good : public Base {
  D*  vf4();        <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> (base class of <span class='tcode_in_codeblock'>D</span>) inaccessible
</span>};

class A;
struct Derived : public Base {
    void vf1();     <span class='comment'>// virtual and overrides <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf1()</span>
</span>    void vf2(int);  <span class='comment'>// not virtual, hides <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf2()</span>
</span>    char vf3();     <span class='comment'>// error: invalid difference in return type only
</span>    D*   vf4();     <span class='comment'>// OK: returns pointer to derived class
</span>    A*   vf5();     <span class='comment'>// error: returns pointer to incomplete class
</span>    void f();
};

void g() {
  Derived d;
  Base* bp = &amp;d;                <span class='comment'>// standard conversion:
</span>                                <span class='comment'>// <span class='tcode_in_codeblock'>Derived*</span> to <span class='tcode_in_codeblock'>Base*</span>
</span>  bp-&gt;vf1();                    <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;vf1()</span>
</span>  bp-&gt;vf2();                    <span class='comment'>// calls <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf2()</span>
</span>  bp-&gt;f();                      <span class='comment'>// calls <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;f()</span> (not virtual)
</span>  B*  p = bp-&gt;vf4();            <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;vf4()</span> and converts the
</span>                                <span class='comment'>// result to <span class='tcode_in_codeblock'>B*</span>
</span>  Derived*  dp = &amp;d;
  D*  q = dp-&gt;vf4();            <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;vf4()</span> and does not
</span>                                <span class='comment'>// convert the result to <span class='tcode_in_codeblock'>B*</span>
</span>  dp-&gt;vf2();                    <span class='comment'>// ill-formed: argument mismatch
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3926'>#</a></div><div id='10.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#10.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='10.sentence-1' class='sentence'>The interpretation of the call of a virtual function depends on the type
of the object for which it is called (the dynamic type), whereas the
interpretation of a call of a non-virtual member function depends only
on the type of the pointer or reference denoting that object (the static
type) (<a href='expr.call'>[expr.call]</a>)<a class='hidden_link' href='#10.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3935'>#</a></div><div id='11.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#11.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='11.sentence-1' class='sentence'>The <span class='texttt'>virtual</span> specifier implies membership, so a virtual function
cannot be a non-member (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>) function<a class='hidden_link' href='#11.sentence-1'>.</a></div> <div id='11.sentence-2' class='sentence'>Nor can a virtual
function be a static member, since a virtual function call relies on a
specific object for determining which function to invoke<a class='hidden_link' href='#11.sentence-2'>.</a></div> <div id='11.sentence-3' class='sentence'>A virtual
function declared in one class can be declared a friend (<a href='class.friend'>[class.friend]</a>) in
another class<a class='hidden_link' href='#11.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3945'>#</a></div><div id='12.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':definition,virtual_function'></a></span>A virtual function declared in a class shall be defined, or declared
pure (<a href='class.abstract'>[class.abstract]</a>) in that class, or both; no diagnostic is
required (<a href='basic.def.odr'>[basic.def.odr]</a>)<a class='hidden_link' href='#12.sentence-1'>.</a></div> <span class='indexparent'><a class='index' id=':friend,virtual_and'></a></span></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3952'>#</a></div><span class='indexparent'><a class='index' id=':multiple_inheritance,virtual_and'></a></span><div id='13.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#13.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='13.sentence-1' class='sentence'>Here are some uses of virtual functions with multiple base classes:
<pre class='codeblock'>
struct A {
  virtual void f();
};

struct B1 : A {                 <span class='comment'>// note non-virtual derivation
</span>  void f();
};

struct B2 : A {
  void f();
};

struct D : B1, B2 {             <span class='comment'>// <span class='tcode_in_codeblock'>D</span> has two separate <span class='tcode_in_codeblock'>A</span> subobjects
</span>};

void foo() {
  D   d;
<span class='comment'>//<span class='tcode_in_codeblock'>   A*  ap = &amp;d;</span>                  // would be ill-formed: ambiguous
</span>  B1*  b1p = &amp;d;
  A*   ap = b1p;
  D*   dp = &amp;d;
  ap-&gt;f();                      <span class='comment'>// calls <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;B1&#x200b;::&#x200b;f</span>
</span>  dp-&gt;f();                      <span class='comment'>// ill-formed: ambiguous
</span>}</pre>
In class <span class='texttt'>D</span> above there are two occurrences of class <span class='texttt'>A</span>
and hence two occurrences of the virtual member function <span class='texttt'>A&#x200b;::&#x200b;f</span><a class='hidden_link' href='#13.sentence-1'>.</a></div> <div id='13.sentence-2' class='sentence'>The final overrider of <span class='texttt'>B1&#x200b;::&#x200b;A&#x200b;::&#x200b;f</span> is <span class='texttt'>B1&#x200b;::&#x200b;f</span> and the final
overrider of <span class='texttt'>B2&#x200b;::&#x200b;A&#x200b;::&#x200b;f</span> is <span class='texttt'>B2&#x200b;::&#x200b;f</span><a class='hidden_link' href='#13.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L3988'>#</a></div><div id='14.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#14.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='14.sentence-1' class='sentence'>The following example shows a function that does not have a unique final
overrider:
<pre class='codeblock'>
struct A {
  virtual void f();
};

struct VB1 : virtual A {        <span class='comment'>// note virtual derivation
</span>  void f();
};

struct VB2 : virtual A {
  void f();
};

struct Error : VB1, VB2 {       <span class='comment'>// ill-formed
</span>};

struct Okay : VB1, VB2 {
  void f();
};</pre>
Both <span class='texttt'>VB1&#x200b;::&#x200b;f</span> and <span class='texttt'>VB2&#x200b;::&#x200b;f</span> override <span class='texttt'>A&#x200b;::&#x200b;f</span> but there
is no overrider of both of them in class <span class='texttt'>Error</span><a class='hidden_link' href='#14.sentence-1'>.</a></div> <div id='14.sentence-2' class='sentence'>This example is
therefore ill-formed<a class='hidden_link' href='#14.sentence-2'>.</a></div> <div id='14.sentence-3' class='sentence'>Class <span class='texttt'>Okay</span> is well-formed, however,
because <span class='texttt'>Okay&#x200b;::&#x200b;f</span> is a final overrider<a class='hidden_link' href='#14.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L4018'>#</a></div><div id='15.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#15.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='15.sentence-1' class='sentence'>The following example uses the well-formed classes from above<a class='hidden_link' href='#15.sentence-1'>.</a></div> <pre class='codeblock'>
struct VB1a : virtual A {       <span class='comment'>// does not declare <span class='tcode_in_codeblock'>f</span>
</span>};

struct Da : VB1a, VB2 {
};

void foe() {
  VB1a*  vb1ap = new Da;
  vb1ap-&gt;f();                   <span class='comment'>// calls <span class='tcode_in_codeblock'>VB2&#x200b;::&#x200b;f</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L4035'>#</a></div><div id='16.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':operator,scope_resolution'></a></span><span class='indexparent'><a class='index' id=':virtual_function_call'></a></span>Explicit qualification with the scope operator (<a href='expr.prim.id.qual'>[expr.prim.id.qual]</a>)
suppresses the virtual call mechanism<a class='hidden_link' href='#16.sentence-1'>.</a></div> <div id='16.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#16.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class B { public: virtual void f(); };
class D : public B { public: void f(); };

void D::f() { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> B::f(); }</pre><div id='16.sentence-2' class='sentence'>Here, the function call in
<span class='texttt'>D&#x200b;::&#x200b;f</span>
really does call
<span class='texttt'>B&#x200b;::&#x200b;f</span>
and not
<span class='texttt'>D&#x200b;::&#x200b;f</span><a class='hidden_link' href='#16.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L4056'>#</a></div><div id='17.sentence-1' class='sentence'>A function with a deleted definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>) shall
not override a function that does not have a deleted definition<a class='hidden_link' href='#17.sentence-1'>.</a></div> <div id='17.sentence-2' class='sentence'>Likewise,
a function that does not have a deleted definition shall not override a
function with a deleted definition<a class='hidden_link' href='#17.sentence-2'>.</a></div> </div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L4063'>#</a></div><div id='18.sentence-1' class='sentence'>If an overriding function specifies contract conditions (<a href='dcl.attr.contract'>[dcl.attr.contract]</a>),
it shall specify the same list of contract conditions as
its overridden functions;
no diagnostic is required
if corresponding conditions will always evaluate to the same value<a class='hidden_link' href='#18.sentence-1'>.</a></div> <div id='18.sentence-2' class='sentence'>Otherwise, it is considered to have
the list of contract conditions from one of its overridden functions;
the names in the contract conditions are bound,
and the semantic constraints are checked,
at the point where the contract conditions appear<a class='hidden_link' href='#18.sentence-2'>.</a></div> <div id='18.sentence-3' class='sentence'>Given a virtual function <span class='texttt'>f</span>
with a contract condition that odr-uses <span class='texttt'>*this</span> (<a href='basic.def.odr'>[basic.def.odr]</a>),
the class of which <span class='texttt'>f</span> is a direct member
shall be be an unambiguous and accessible base class of any class
in which <span class='texttt'>f</span> is overridden<a class='hidden_link' href='#18.sentence-3'>.</a></div> <div id='18.sentence-4' class='sentence'>If a function overrides more than one function,
all of the overridden functions shall have
the same list of contract conditions (<a href='dcl.attr.contract'>[dcl.attr.contract]</a>);
no diagnostic is required
if corresponding conditions will always evaluate to the same value<a class='hidden_link' href='#18.sentence-4'>.</a></div> <div id='18.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#18.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  virtual void g() [[expects: x == 0]];
  int x = 42;
};

int x = 42;
struct B {
  virtual void g() [[expects: x == 0]];
}

struct C : A, B {
  virtual void g();             <span class='comment'>// error: preconditions of overridden functions are not the same
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-113'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-113'>113)</a></div><div id='footnote-113.sentence-1' class='sentence'>The use of the <span class='texttt'>virtual</span> specifier in the
declaration of an overriding function is valid but redundant (has empty
semantics)<a class='hidden_link' href='#footnote-113.sentence-1'>.</a></div></div><div class='footnote' id='footnote-114'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-114'>114)</a></div><div id='footnote-114.sentence-1' class='sentence'>A function
with the same name but a different parameter list (<a href='over'>[over]</a>)
as a virtual function is not necessarily virtual and
does not override<a class='hidden_link' href='#footnote-114.sentence-1'>.</a></div> <div id='footnote-114.sentence-2' class='sentence'>Access control (<a href='class.access'>[class.access]</a>) is not considered in
determining overriding<a class='hidden_link' href='#footnote-114.sentence-2'>.</a></div></div><div class='footnote' id='footnote-115'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-115'>115)</a></div><div id='footnote-115.sentence-1' class='sentence'>Multi-level pointers to classes or references to multi-level pointers to
classes are not allowed<a class='hidden_link' href='#footnote-115.sentence-1'>.</a></div></div></div></body></html>