<!DOCTYPE html><html lang='en'><head><title>[thread.condition.condvarany]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>30.5</a> Condition variables <a class='abbr_ref' href='thread.condition#condvarany'>[thread.condition]</a></h2><div id='thread.condition.condvarany'><h3 ><a class='secnum' style='min-width:103pt'>30.5.2</a> Class <span class='texttt'>condition_variable_any</span> <a class='abbr_ref'>[thread.condition.condvarany]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <span class='texttt'>Lock</span> type shall meet the <span class='texttt'>BasicLockable</span>
requirements (<a href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a>). [&nbsp;<i>Note:</i><span class='space'></span> All of the standard
mutex types meet this requirement. If a <span class='texttt'>Lock</span> type other than one of the
standard mutex types or a <span class='texttt'>unique_lock</span> wrapper for a standard mutex type
is used with <span class='texttt'>condition_variable_any</span>, the user must ensure that any
necessary synchronization is in place with respect to the predicate associated
with the <span class='texttt'>condition_variable_any</span> instance. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  class condition_variable_any {
  public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    template &lt;class Lock&gt;
      void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
      void wait(Lock&amp; lock, Predicate pred);

    template &lt;class Lock, class Clock, class Duration&gt;
      cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
      bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
        Predicate pred);
    template &lt;class Lock, class Rep, class Period&gt;
      cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Lock, class Rep, class Period, class Predicate&gt;
      bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
        Predicate pred);
  };
}
</pre><p ><span class='indexparent'><a class='index' id='condition_variable_any!constructor'></a></span><code class='itemdecl'>
condition_variable_any();
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable_any</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span> or <span class='texttt'>system_error</span> when an exception is
required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if some non-memory resource
limitation prevents initialization.</p></li><li ><p ><span class='texttt'>operation_not_permitted</span> — if the thread does not have the
privilege to perform the operation.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!destructor'></a></span><code class='itemdecl'>
~condition_variable_any();
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!notify_one'></a></span><span class='indexparent'><a class='index' id='notify_one!condition_variable_any'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!notify_all'></a></span><span class='indexparent'><a class='index' id='notify_all!condition_variable_any'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait'></a></span><span class='indexparent'><a class='index' id='wait!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock&gt;
  void wait(Lock&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Note:</i> if any of the <span class='texttt'>wait</span> functions exits via an exception, it is
unspecified whether the <span class='texttt'>Lock</span> is held. One can use a <span class='texttt'>Lock</span> type
that allows to query that, such as the <span class='texttt'>unique_lock</span> wrapper.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.
</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>,
a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li></ul></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait'></a></span><span class='indexparent'><a class='index' id='wait!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Predicate&gt;
  void wait(Lock&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration&gt;
  cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li ><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function.
</p></li></ul></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, or
if the timeout has already expired. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any!wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for!condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div></div></div></body></html>