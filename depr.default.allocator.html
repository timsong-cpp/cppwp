<!DOCTYPE html><html lang='en'><head><title>[depr.default.allocator]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(normative)</a> Compatibility features <a class='abbr_ref' href='./#depr'>[depr]</a></h1><div id='depr.default.allocator'><h2 ><a class='secnum' style='min-width:88pt'>D.9</a> The default allocator <a class='abbr_ref'>[depr.default.allocator]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The following members and explicit class template specialization are defined in
addition to those specified in <a href='default.allocator'>[default.allocator]</a>:</p><p ><span class='indexparent'><a class='index' id='allocator'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// specialize for <span class='texttt'>void</span>:
</span>  template &lt;&gt; class allocator&lt;void&gt; {
  public:
    using value_type    = void;
    using pointer       = void*;
    using const_pointer = const void*;
    <span class='comment'>// reference-to-<span class='texttt'>void</span> members are impossible.
</span>
    template &lt;class U&gt; struct rebind { using other = allocator&lt;U&gt;; };
  };

  template &lt;class T&gt; class allocator {
   public:
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&amp;;
    using const_reference = const T&amp;;
    template &lt;class U&gt; struct rebind { using other = allocator&lt;U&gt;; };

    T* address(T&amp; x) const noexcept;
    const T* address(const T&amp; x) const noexcept;

    T* allocate(size_t n, const void* hint);

    template&lt;class U, class... Args&gt;
      void construct(U* p, Args&amp;&amp;... args);
    template &lt;class U&gt;
      void destroy(U* p);

    size_t max_size() const noexcept;
  };
}
</pre><p ><span class='indexparent'><a class='index' id='address!allocator'></a></span><span class='indexparent'><a class='index' id='allocator!address'></a></span><code class='itemdecl'>
T* address(T&amp; x) const noexcept;
const T* address(const T&amp; x) const noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The actual address of the object referenced by <span class='texttt'>x</span>, even in the presence of an
overloaded operator&amp;.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocate!allocator'></a></span><span class='indexparent'><a class='index' id='allocator!allocate'></a></span><code class='itemdecl'>
T* allocate(size_t n, const void* hint);
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to the initial element of an array of storage of size <span class='texttt'>n</span>
<span class='texttt'>* sizeof(T)</span>, aligned appropriately for objects of type <span class='texttt'>T</span>.
It is <span class='indexparent'><a class='index' id='support for over-aligned types'></a></span>implementation-defined whether over-aligned types are
supported (<a href='basic.align'>[basic.align]</a>).</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Remark:</i>
the storage is obtained by calling <span class='texttt'>::operator new(std::size_t)</span> (<a href='new.delete'>[new.delete]</a>),
but it is unspecified when or how often this function is called.</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_alloc</span> if the storage cannot be obtained.
</p></div></div><p ><span class='indexparent'><a class='index' id='construct!allocator'></a></span><span class='indexparent'><a class='index' id='allocator!construct'></a></span><code class='itemdecl'>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by: <span class='texttt'>::new((void *)p) U(std::forward&lt;Args&gt;(args)...);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='destroy!allocator'></a></span><span class='indexparent'><a class='index' id='allocator!destroy'></a></span><code class='itemdecl'>
template &lt;class U&gt;
  void destroy(U* p);
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by <span class='texttt'>p-&gt;~U()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size!allocator'></a></span><span class='indexparent'><a class='index' id='allocator!max_size'></a></span><code class='itemdecl'>
size_t max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
The largest value <i>N</i> for which the call <span class='texttt'>allocate(N, 0)</span>
might succeed.
</p></div></div></div></div></body></html>