<!DOCTYPE html><html lang='en'><head><title>[cpp.replace]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>19</a> Preprocessing directives <a class='abbr_ref' href='./#cpp'>[cpp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>19.3</a> Macro replacement <a class='abbr_ref'>[cpp.replace]</a></h2><p ><span class='indexparent'><a class='index' id=':macro,replacement'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L588'>#</a></div><p ><span class='indexparent'><a class='index' id=':macro,replacement_list'></a></span>Two replacement lists are identical if and only if
the preprocessing tokens in both have
the same number, ordering, spelling, and white-space separation,
where all white-space separations are considered identical.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L595'>#</a></div><p >An identifier currently defined as an
<span class='indexparent'><a class='index' id=':macro,object-like'></a></span>object-like macro (see below) may be redefined by another
<span class='texttt'>#define</span>
preprocessing directive provided that the second definition is an
object-like macro definition and the two replacement lists
are identical, otherwise the program is ill-formed.
Likewise, an identifier currently defined as a
<span class='indexparent'><a class='index' id=':macro,function-like'></a></span>function-like macro (see below) may be redefined by another
<span class='texttt'>#define</span>
preprocessing directive provided that the second definition is a
function-like macro definition that has the same number and spelling
of parameters,
and the two replacement lists are identical,
otherwise the program is ill-formed.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L615'>#</a></div><p ><span class='indexparent'><a class='index' id=':macro,replacement_list_'></a></span>There shall be white-space between the identifier and the replacement list
in the definition of an object-like macro.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L620'>#</a></div><p >If the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> in the macro definition does not end with
an ellipsis, the number of arguments (including those arguments consisting
of no preprocessing tokens)
in an invocation of a function-like macro shall
equal the number of parameters in the macro definition. Otherwise, there shall be more arguments in the invocation than there are
parameters in the macro definition (excluding the <span class='texttt'>...</span>). There
shall exist a
<span class='texttt'>)</span>
preprocessing token that terminates the invocation.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L631'>#</a></div><p ><span class='indexparent'><a class='index' id=':__VA_ARGS__'></a></span>The identifier <span class='texttt'>__VA_&shy;ARGS__</span> shall occur only in the <i ><a href='cpp#nt:replacement-list'>replacement-list</a></i>
of a function-like macro that uses the ellipsis notation in the parameters.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L636'>#</a></div><p >A parameter identifier in a function-like macro
shall be uniquely declared within its scope.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L640'>#</a></div><p >The identifier immediately following the
<span class='texttt'>define</span>
is called the
<span class='indexparent'><a class='index' id=':macro,name'></a></span><a class='hidden_link' href='#def:macro_name' id='def:macro_name'><i>macro name</i></a>.
There is one name space for macro names.
Any white-space characters preceding or following the
replacement list of preprocessing tokens are not considered
part of the replacement list for either form of macro.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L652'>#</a></div><p >If a
<span class='indexparent'><a class='index' id=':#_operator'></a></span>
<span class='texttt'>#</span>
preprocessing token,
followed by an identifier,
occurs lexically
at the point at which a preprocessing directive could begin,
the identifier is not subject to macro replacement.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L662'>#</a></div><p >A preprocessing directive of the form</p><pre class='ncsimplebnf'><span class='terminal'># define</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:replacement-list'>replacement-list</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i><span class='indexparent'><a class='index' id=':#define'></a></span>
</pre><p >defines an
<a class='hidden_link' href='#def:macro,object-like' id='def:macro,object-like'><i >object-like macro</i></a> that
causes each subsequent instance of the macro name<a class='footnotenum' href='#footnote-148'>148</a>
to be replaced by the replacement list of preprocessing tokens
that constitute the remainder of the directive.<a class='footnotenum' href='#footnote-149'>149</a>
The replacement list is then rescanned for more macro names as
specified below.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L685'>#</a></div><p >A preprocessing directive of the form
</p><pre class='ncsimplebnf'><span class='terminal'># define</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:lparen'>lparen</a></i> <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i><span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>)</span> <i ><a href='cpp#nt:replacement-list'>replacement-list</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i>
<span class='terminal'># define</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:lparen'>lparen</a></i> <span class='terminal'>...</span> <span class='terminal'>)</span> <i ><a href='cpp#nt:replacement-list'>replacement-list</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i>
<span class='terminal'># define</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:lparen'>lparen</a></i> <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> <span class='terminal'>, ...</span> <span class='terminal'>)</span> <i ><a href='cpp#nt:replacement-list'>replacement-list</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i>
</pre><p >defines a <a class='hidden_link' href='#def:macro,function-like' id='def:macro,function-like'><i >function-like macro</i></a>
with parameters, whose use is
similar syntactically to a function call.
The parameters
<span class='indexparent'><a class='index' id=':parameters,macro'></a></span>are specified by the optional list of identifiers,
whose scope extends from their declaration in the identifier list
until the new-line character that terminates the
<span class='texttt'>#define</span>
preprocessing directive.
Each subsequent instance of the function-like macro name followed by a
<span class='texttt'>(</span>
as the next preprocessing token
introduces the sequence of preprocessing tokens that is replaced
by the replacement list in the definition
(an invocation of the macro).
<span class='indexparent'><a class='index' id=':invocation,macro'></a></span>The replaced sequence of preprocessing tokens is terminated by the matching
<span class='texttt'>)</span>
preprocessing token, skipping intervening matched pairs of left and
right parenthesis preprocessing tokens.
Within the sequence of preprocessing tokens making up an invocation
of a function-like macro,
new-line is considered a normal white-space character.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L717'>#</a></div><p ><span class='indexparent'><a class='index' id=':macro,function-like,arguments'></a></span>The sequence of preprocessing tokens
bounded by the outside-most matching parentheses
forms the list of arguments for the function-like macro.
The individual arguments within the list
are separated by comma preprocessing tokens,
but comma preprocessing tokens between matching
inner parentheses do not separate arguments.
If there are sequences of preprocessing tokens within the list of
arguments that would otherwise act as preprocessing directives,<a class='footnotenum' href='#footnote-150'>150</a>
the behavior is undefined.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L730'>#</a></div><p ><span class='indexparent'><a class='index' id=':macro,function-like,arguments_'></a></span>If there is a <span class='texttt'>...</span> immediately preceding the <span class='texttt'>)</span> in the
function-like macro
definition, then the trailing arguments, including any separating comma preprocessing
tokens, are merged to form a single item: the <a class='hidden_link' href='#def:variable_arguments' id='def:variable_arguments'><i>variable arguments</i></a>. The number of
arguments so combined is such that, following merger, the number of arguments is
one more than the number of parameters in the macro definition (excluding the
<span class='texttt'>...</span>).</p></div><div class='footnote' id='footnote-148'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-148'>148)</a></div><p >Since, by macro-replacement time,
all character literals and string literals are preprocessing tokens,
not sequences possibly containing identifier-like subsequences
(see <a href='lex.phases'>[lex.phases]</a>, translation phases),
they are never scanned for macro names or parameters.</p></div><div class='footnote' id='footnote-149'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-149'>149)</a></div><p >An <a href='lex.digraph'>alternative token</a> is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not possible to define a macro
whose name is the same as that of an alternative token.</p></div><div class='footnote' id='footnote-150'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-150'>150)</a></div><p >A <i ><a href='cpp#nt:conditionally-supported-directive'>conditionally-supported-directive</a></i> is a preprocessing directive regardless of whether the implementation supports it.</p></div><div id='cpp.subst'><h3 ><a class='secnum' href='#cpp.subst' style='min-width:103pt'>19.3.1</a> Argument substitution <a class='abbr_ref' href='cpp.subst'>[cpp.subst]</a></h3><p ><span class='indexparent'><a class='index' id=':macro,argument_substitution'></a></span>
</p><div class='para' id='cpp.subst-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.subst-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L744'>#</a></div><p >After the arguments for the invocation of a function-like macro have
been identified, argument substitution takes place.
A parameter in the replacement list, unless preceded by a
<span class='texttt'>#</span>
or
<span class='texttt'>##</span>
preprocessing token or followed by a
<span class='texttt'>##</span>
preprocessing token (see below),
is replaced by the corresponding argument after all macros
contained therein have been expanded.
Before being substituted,
each argument's preprocessing tokens are completely
macro replaced as if they formed the rest of the
preprocessing file;
no other preprocessing tokens are available.</p></div><div class='para' id='cpp.subst-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.subst-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L762'>#</a></div><p >An identifier <span class='texttt'>__VA_&shy;ARGS__</span> that occurs in the replacement list
shall be treated as if it were a parameter, and the variable arguments shall form
the preprocessing tokens used to replace it.</p></div></div><div id='cpp.stringize'><h3 ><a class='secnum' href='#cpp.stringize' style='min-width:103pt'>19.3.2</a> The <span class='texttt'>#</span> operator <a class='abbr_ref' href='cpp.stringize'>[cpp.stringize]</a></h3><p ><span class='indexparent'><a class='index' id=':#_operator_'></a></span></p><div class='para' id='cpp.stringize-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.stringize-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L771'>#</a></div><p >Each
<span class='texttt'>#</span>
preprocessing token in the replacement list for a function-like
macro shall be followed by a parameter as the next preprocessing
token in the replacement list.</p></div><div class='para' id='cpp.stringize-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.stringize-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L778'>#</a></div><p >A <a class='hidden_link' href='#def:character_string_literal' id='def:character_string_literal'><i >character string literal</i></a> is a <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> with no prefix.
If, in the replacement list, a parameter is immediately
preceded by a
<span class='texttt'>#</span>
preprocessing token,
both are replaced by a single character string literal preprocessing token that
contains the spelling of the preprocessing token sequence for the
corresponding argument.
Each occurrence of white space between the argument's preprocessing
tokens becomes a single space character in the character string literal.
White space before the first preprocessing token and after the last
preprocessing token comprising the argument is deleted.
Otherwise, the original spelling of each preprocessing token in the
argument is retained in the character string literal,
except for special handling for producing the spelling of
string literals and character literals:
a
<span class='texttt'>\</span>
character is inserted before each
<span class='texttt'>"</span>
and
<span class='texttt'>\</span>
character of a character literal or string literal
(including the delimiting
<span class='texttt'>"</span>
characters).
If the replacement that results is not a valid character string literal,
the behavior is undefined. The character string literal corresponding to
an empty argument is <span class='texttt'>""</span>.
The order of evaluation of
<span class='texttt'>#</span>
and
<span class='texttt'>##</span>
operators is unspecified.</p></div></div><div id='cpp.concat'><h3 ><a class='secnum' href='#cpp.concat' style='min-width:103pt'>19.3.3</a> The <span class='texttt'>##</span> operator <a class='abbr_ref' href='cpp.concat'>[cpp.concat]</a></h3><p ><span class='indexparent'><a class='index' id=':##_operator'></a></span></p><div class='para' id='cpp.concat-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.concat-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L818'>#</a></div><p >A
<span class='texttt'>##</span>
preprocessing token shall not occur at the beginning or
at the end of a replacement list for either form
of macro definition.</p></div><div class='para' id='cpp.concat-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.concat-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L825'>#</a></div><p >If, in the replacement list of a function-like macro, a parameter is
immediately preceded or followed by a
<span class='texttt'>##</span>
preprocessing token, the parameter is replaced by the
corresponding argument's preprocessing token sequence; however, if an argument consists of no preprocessing tokens, the parameter is
replaced by a placemarker preprocessing token instead.<a class='footnotenum' href='#footnote-151'>151</a></p></div><div class='para' id='cpp.concat-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.concat-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L834'>#</a></div><p >For both object-like and function-like macro invocations, before the
replacement list is reexamined for more macro names to replace,
each instance of a
<span class='texttt'>##</span>
preprocessing token in the replacement list
(not from an argument) is deleted and the
preceding preprocessing token is concatenated
with the following preprocessing token.
Placemarker preprocessing tokens are handled specially: concatenation
of two placemarkers results in a single placemarker preprocessing token, and
concatenation of a placemarker with a non-placemarker preprocessing token results
in the non-placemarker preprocessing token.
If the result is not a valid preprocessing token,
the behavior is undefined.
The resulting token is available for further macro replacement.
The order of evaluation of
<span class='texttt'>##</span>
operators is unspecified.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>  In the following fragment:</p><pre class='codeblock'>
#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y);          <span class='comment'>// equivalent to <span class='tcode_in_codeblock'>char p[] = "x ## y";</span>
</span></pre><p >The expansion produces, at various stages:</p><pre class='codeblock'>
join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
mkstr(x ## y)
"x ## y"</pre><p >In other words, expanding <span class='texttt'>hash_&shy;hash</span> produces a new token,
consisting of two adjacent sharp signs, but this new token is not the
<span class='texttt'>##</span> operator. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='footnote' id='footnote-151'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-151'>151)</a></div><p >Placemarker preprocessing tokens do not appear in the syntax
because they are temporary entities that exist only within translation phase 4.</p></div></div><div id='cpp.rescan'><h3 ><a class='secnum' href='#cpp.rescan' style='min-width:103pt'>19.3.4</a> Rescanning and further replacement <a class='abbr_ref' href='cpp.rescan'>[cpp.rescan]</a></h3><p ><span class='indexparent'><a class='index' id=':macro,rescanning_and_replacement'></a></span></p><div class='para' id='cpp.rescan-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.rescan-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L882'>#</a></div><p >After all parameters in the replacement list have been substituted and <span class='texttt'>#</span> and <span class='texttt'>##</span> processing has taken
place, all placemarker preprocessing tokens are removed. Then
the resulting preprocessing token sequence is rescanned, along with all
subsequent preprocessing tokens of the source file, for more macro names
to replace.</p></div><div class='para' id='cpp.rescan-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.rescan-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L889'>#</a></div><p >If the name of the macro being replaced is found during this scan of
the replacement list
(not including the rest of the source file's preprocessing tokens),
it is not replaced.
Furthermore,
if any nested replacements encounter the name of the macro being replaced,
it is not replaced.
These nonreplaced macro name preprocessing tokens are no longer available
for further replacement even if they are later (re)examined in contexts
in which that macro name preprocessing token would otherwise have been
replaced.</p></div><div class='para' id='cpp.rescan-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.rescan-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L902'>#</a></div><p >The resulting completely macro-replaced preprocessing token sequence
is not processed as a preprocessing directive even if it resembles one,
but all pragma unary operator expressions within it are then processed as
specified in <a href='cpp.pragma.op'>[cpp.pragma.op]</a> below.</p></div></div><div id='cpp.scope'><h3 ><a class='secnum' href='#cpp.scope' style='min-width:103pt'>19.3.5</a> Scope of macro definitions <a class='abbr_ref' href='cpp.scope'>[cpp.scope]</a></h3><p ><span class='indexparent'><a class='index' id=':macro,scope_of_definition'></a></span></p><div class='para' id='cpp.scope-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L912'>#</a></div><p >A macro definition lasts
(independent of block structure)
until a corresponding
<span class='texttt'>#undef</span>
directive is encountered or
(if none is encountered)
until the end of the translation unit.
Macro definitions have no significance after translation phase 4.</p></div><div class='para' id='cpp.scope-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L922'>#</a></div><p >A preprocessing directive of the form</p><pre class='ncsimplebnf'><span class='terminal'># undef</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i><span class='indexparent'><a class='index' id=':#undef'></a></span>
</pre><p >causes the specified identifier no longer to be defined as a macro name.
It is ignored if the specified identifier is not currently defined as
a macro name.</p></div><div class='para' id='cpp.scope-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L934'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
The simplest use of this facility is to define a “manifest constant”,
as in
</p><pre class='codeblock'>
#define TABSIZE 100
int table[TABSIZE];</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-4'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L944'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
The following defines a function-like
macro whose value is the maximum of its arguments.
It has the advantages of working for any compatible types of the arguments
and of generating in-line code without the overhead of function calling.
It has the disadvantages of evaluating one or the other of its arguments
a second time
(including
<span class='indexparent'><a class='index' id=':side_effects'></a></span>side effects)
and generating more code than a function if invoked several times.
It also cannot have its address taken,
as it has none.</p><pre class='codeblock'>
#define max(a, b) ((a) &gt; (b) ? (a) : (b))</pre><p >The parentheses ensure that the arguments and
the resulting expression are bound properly.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-5'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L967'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
To illustrate the rules for redefinition and reexamination,
the sequence</p><pre class='codeblock'>
#define x       3
#define f(a)    f(x * (a))
#undef  x
#define x       2
#define g       f
#define z       z[0]
#define h       g(~
#define m(a)    a(w)
#define w       0,1
#define t(a)    a
#define p()     int
#define q(x)    x
#define r(x,y)  x ## y
#define str(x)  # x

f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) &amp; m
    (f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };</pre><p >results in</p><pre class='codeblock'>
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) &amp; f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-6'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L1005'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
To illustrate the rules for creating character string literals
and concatenating tokens,
the sequence</p><pre class='codeblock'>
#define str(s)      # s
#define xstr(s)     str(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \
               x ## s, x ## t)
#define INCFILE(n)  vers ## n
#define glue(a, b)  a ## b
#define xglue(a, b) glue(a, b)
#define HIGHLOW     "hello"
#define LOW         LOW ", world"

debug(1, 2);
fputs(str(strncmp("abc\0d", "abc", '\4')        <span class='comment'>// this goes away
</span>    == 0) str(: @\n), s);
#include xstr(INCFILE(2).h)
glue(HIGH, LOW);
xglue(HIGH, LOW)</pre><p >results in</p><pre class='codeblock'>
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", '\\4') == 0" ": @\n", s);
#include "vers2.h"      <span class='textrm'>(<span class='textit'>after macro replacement, before file access</span>)</span>
"hello";
"hello" ", world"</pre><p >or, after concatenation of the character string literals,</p><pre class='codeblock'>
printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", '\\4') == 0: @\n", s);
#include "vers2.h"      <span class='textrm'>(<span class='textit'>after macro replacement, before file access</span>)</span>
"hello";
"hello, world"</pre><p >Space around the
<span class='texttt'>#</span>
and
<span class='texttt'>##</span>
tokens in the macro definition is optional.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-7'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L1057'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
To illustrate the rules for placemarker preprocessing tokens, the sequence</p><pre class='codeblock'>
#define t(x,y,z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),
  t(10,,), t(,11,), t(,,12), t(,,) };</pre><p >results in</p><pre class='codeblock'>
int j[] = { 123, 45, 67, 89,
  10, 11, 12, };</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-8'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L1075'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
To demonstrate the redefinition rules,
the following sequence is valid.</p><pre class='codeblock'>
#define OBJ_LIKE      (1-1)
#define OBJ_LIKE      <span class='tcode_in_codeblock'>/* white space */ (1-1) /* other */</span>
#define FUNC_LIKE(a)   ( a )
#define FUNC_LIKE( a )(     <span class='tcode_in_codeblock'>/* note the white space */ \</span>
                a <span class='tcode_in_codeblock'>/* other stuff on this line</span>
                  <span class='tcode_in_codeblock'>*/</span> )</pre><p >But the following redefinitions are invalid:</p><pre class='codeblock'>
#define OBJ_LIKE    (0)         <span class='comment'>// different token sequence
</span>#define OBJ_LIKE    (1 - 1)     <span class='comment'>// different white space
</span>#define FUNC_LIKE(b) ( a )      <span class='comment'>// different parameter usage
</span>#define FUNC_LIKE(b) ( b )      <span class='comment'>// different parameter spelling
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='cpp.scope-9'><div class='marginalizedparent'><a class='marginalized' href='#cpp.scope-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/preprocessor.tex#L1099'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
Finally, to show the variable argument list macro facilities:</p><pre class='codeblock'>
#define debug(...) fprintf(stderr, <span class='tcode_in_codeblock'>__VA_&shy;ARGS__</span>)
#define showlist(...) puts(#<span class='tcode_in_codeblock'>__VA_&shy;ARGS__</span>)
#define report(test, ...) ((test) ? puts(#test) : printf(<span class='tcode_in_codeblock'>__VA_&shy;ARGS__</span>))
debug("Flag");
debug("X = %d\n", x);
showlist(The first, second, and third items.);
report(x&gt;y, "x is %d but y is %d", x, y);</pre><p >results in</p><pre class='codeblock'>
fprintf(stderr, "Flag");
fprintf(stderr, "X = %d\n", x);
puts("The first, second, and third items.");
((x&gt;y) ? puts("x&gt;y") : printf("x is %d but y is %d", x, y));</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div></div></body></html>