<!DOCTYPE html><html lang='en'><head><title>[mem.res.pool.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.12</a> Memory resources <a class='abbr_ref' href='mem.res#pool.overview'>[mem.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.12.5</a> Pool resource classes <a class='abbr_ref' href='mem.res.pool#overview'>[mem.res.pool]</a></h3><div id='mem.res.pool.overview'><h4 ><a class='secnum' style='min-width:118pt'>20.12.5.1</a> Classes <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> and <span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> <a class='abbr_ref'>[mem.res.pool.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/utilities.tex#L11556'>#</a></div><p >The <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> and
<span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> classes
(collectively called <a class='hidden_link' href='#def:pool_resource_classes' id='def:pool_resource_classes'><i>pool resource classes</i></a>)
are general-purpose memory resources having the following qualities:
</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >Each resource frees its allocated memory on destruction,
even if <span class='texttt'>deallocate</span> has not been called for some of the allocated blocks.
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >A pool resource consists of a collection of <a class='hidden_link' href='#def:pools' id='def:pools'><i>pools</i></a>,
serving requests for different block sizes.
Each individual pool manages a collection of <a class='hidden_link' href='#def:chunks' id='def:chunks'><i>chunks</i></a>
that are in turn divided into blocks of uniform size,
returned via calls to <span class='texttt'>do_&shy;allocate</span>.
Each call to <span class='texttt'>do_&shy;allocate(size, alignment)</span> is dispatched
to the pool serving the smallest blocks accommodating at least <span class='texttt'>size</span> bytes.
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >When a particular pool is exhausted,
allocating a block from that pool results in the allocation
of an additional chunk of memory from the <a class='hidden_link' href='#def:upstream_allocator' id='def:upstream_allocator'><i>upstream allocator</i></a>
(supplied at construction), thus replenishing the pool.
With each successive replenishment,
the chunk size obtained increases geometrically.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
By allocating memory in chunks,
the pooling strategy increases the chance that consecutive allocations
will be close together in memory.<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >Allocation requests that exceed the largest block size of any pool
are fulfilled directly from the upstream allocator.
</p></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><p >A <span class='texttt'>pool_&shy;options</span> struct may be passed to the pool resource constructors
to tune the largest block size and the maximum chunk size.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/utilities.tex#L11592'>#</a></div><p >A <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> may be accessed from multiple threads
without external synchronization
and may have thread-specific pools to reduce synchronization costs.
An <span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> class may not be accessed
from multiple threads simultaneously
and thus avoids the cost of synchronization entirely
in single-threaded applications.</p><p ><span class='indexparent'><a class='index' id='pool_options'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource'></a></span></p><p ><pre class='codeblock'>
struct pool_options {
  size_t max_blocks_per_chunk = 0;
  size_t largest_required_pool_block = 0;
};

class synchronized_pool_resource : public memory_resource {
public:
  synchronized_pool_resource(const pool_options&amp; opts,
                             memory_resource* upstream);

  synchronized_pool_resource()
      : synchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit synchronized_pool_resource(memory_resource* upstream)
      : synchronized_pool_resource(pool_options(), upstream) {}
  explicit synchronized_pool_resource(const pool_options&amp; opts)
      : synchronized_pool_resource(opts, get_default_resource()) {}

  synchronized_pool_resource(const synchronized_pool_resource&amp;) = delete;
  virtual ~synchronized_pool_resource();

  synchronized_pool_resource&amp;
    operator=(const synchronized_pool_resource&amp;) = delete;

  void release();
  memory_resource* upstream_resource() const;
  pool_options options() const;

protected:
  void *do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void *p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource&amp; other) const noexcept override;
};

class unsynchronized_pool_resource : public memory_resource {
public:
  unsynchronized_pool_resource(const pool_options&amp; opts,
                               memory_resource* upstream);

  unsynchronized_pool_resource()
      : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit unsynchronized_pool_resource(memory_resource* upstream)
      : unsynchronized_pool_resource(pool_options(), upstream) {}
  explicit unsynchronized_pool_resource(const pool_options&amp; opts)
      : unsynchronized_pool_resource(opts, get_default_resource()) {}

  unsynchronized_pool_resource(const unsynchronized_pool_resource&amp;) = delete;
  virtual ~unsynchronized_pool_resource();

  unsynchronized_pool_resource&amp;
    operator=(const unsynchronized_pool_resource&amp;) = delete;

  void release();
  memory_resource *upstream_resource() const;
  pool_options options() const;

protected:
  void* do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void* p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource&amp; other) const noexcept override;
};</pre></p></div></div></div></body></html>