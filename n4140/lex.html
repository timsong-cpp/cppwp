<!DOCTYPE html><html lang='en'><head><title>[lex]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='lex'><h1 ><a class='secnum' style='min-width:73pt'>2</a> Lexical conventions <a class='abbr_ref' href='./#lex'>[lex]</a></h1><p ><span class='indexparent'><a class='index' id='lexical_conventions'></a></span>
<span class='indexparent'><a class='index' id='translation,separate'></a></span>
<span class='indexparent'><a class='index' id='separate_translation'></a></span>
<span class='indexparent'><a class='index' id='separate_compilation'></a></span>
<span class='indexparent'><a class='index' id='phases_of_translation'></a></span>
<span class='indexparent'><a class='index' id='source_file_character'></a></span>
<span class='indexparent'><a class='index' id='alternative_token'></a></span>
<span class='indexparent'><a class='index' id='digraph'></a></span>
<span class='indexparent'><a class='index' id='integer_literal'></a></span>
<span class='indexparent'><a class='index' id='character_literal'></a></span>
<span class='indexparent'><a class='index' id='floating_literal'></a></span>
<span class='indexparent'><a class='index' id='floating-point_literal'></a></span>
<span class='indexparent'><a class='index' id='string_literal'></a></span>
<span class='indexparent'><a class='index' id='boolean_literal'></a></span>
<span class='indexparent'><a class='index' id='pointer_literal'></a></span>
<span class='indexparent'><a class='index' id='user-defined_literal'></a></span>
<span class='indexparent'><a class='index' id='file,_source'></a></span></p><div id='separate'><h2 ><a class='secnum' href='#separate' style='min-width:88pt'>2.1</a> Separate translation <a class='abbr_ref' href='lex.separate'>[lex.separate]</a></h2><div class='para' id='separate-1'><div class='marginalizedparent'><a class='marginalized' href='#separate-1'>1</a></div><p ><span class='indexparent'><a class='index' id='conventions,lexical'></a></span><span class='indexparent'><a class='index' id='compilation,separate'></a></span>The text of the program is kept in units called
<span class='indexparent'><a class='index' id='source_file'></a></span><a class='hidden_link' href='#def:source_files' id='def:source_files'><i>source files</i></a> in this International
Standard. A source file together with all the headers (<a href='headers'>[headers]</a>)
and source files included (<a href='cpp.include'>[cpp.include]</a>) via the preprocessing
directive <span class='texttt'>#include</span>, less any source lines skipped by any of the
conditional inclusion (<a href='cpp.cond'>[cpp.cond]</a>) preprocessing directives, is
called a <a class='hidden_link' href='#def:translation_unit' id='def:translation_unit'><i>translation unit</i></a>.
[&nbsp;<i>Note:</i> A C++ program need not all be translated at the same time.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='separate-2'><div class='marginalizedparent'><a class='marginalized' href='#separate-2'>2</a></div><p >[&nbsp;<i>Note:</i> Previously translated translation units and instantiation
units can be preserved individually or in libraries. The separate
translation units of a program communicate (<a href='basic.link'>[basic.link]</a>) by (for
example) calls to functions whose identifiers have external linkage,
manipulation of objects whose identifiers have external linkage, or
manipulation of data files. Translation units can be separately
translated and then later linked to produce an executable
program (<a href='basic.link'>[basic.link]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='compilation,separate'></a></span></p></div></div><div id='phases'><h2 ><a class='secnum' href='#phases' style='min-width:88pt'>2.2</a> Phases of translation <a class='abbr_ref' href='lex.phases'>[lex.phases]</a></h2><div class='para' id='phases-1'><div class='marginalizedparent'><a class='marginalized' href='#phases-1'>1</a></div><p ><span class='indexparent'><a class='index' id='translation,phases'></a></span>
The precedence among the syntax rules of translation is specified by the
following phases.<a class='footnotenum' href='#footnote-11'>11</a></p><ol class='enumerate'><li id='phases-1.1'><p ><span class='indexparent'><a class='index' id='source_file'></a></span><span class='indexparent'><a class='index' id='character,source_file'></a></span><span class='indexparent'><a class='index' id='character_set,basic_source'></a></span></p><p >Physical source file characters are mapped, in an
<span class='indexparent'><a class='index' id='mapping_physical_source_file_characters_to_basic_source_character_set'></a></span>implementation-defined manner,
to the basic source character set (introducing new-line characters for end-of-line
indicators) if necessary.
The set of physical source file characters accepted is <span class='indexparent'><a class='index' id='physical_source_file_characters'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='trigraph_sequence'></a></span>Trigraph sequences (<a href='lex.trigraph'>[lex.trigraph]</a>) are
replaced by corresponding single-character internal representations. Any
source file character not in the basic source character
set (<a href='lex.charset'>[lex.charset]</a>) is replaced by the
<span class='indexparent'><a class='index' id='universal_character_name'></a></span>universal-character-name that
designates that character. (An implementation may use any internal
encoding, so long as an actual extended character encountered in the
source file, and the same extended character expressed in the source
file as a universal-character-name (i.e., using the <span class='texttt'>\uXXXX</span> notation), are handled equivalently
except where this replacement is reverted in a raw string literal.)</p><p ><span class='indexparent'><a class='index' id='line_splicing'></a></span></p></li><li id='phases-1.2'><p >Each instance of a backslash character (\)
immediately followed by a new-line character is deleted, splicing
physical source lines to form logical source lines. Only the last
backslash on any physical source line shall be eligible for being part
of such a splice.
Except for splices reverted in a raw string literal, if a splice results in
a character sequence that matches the
syntax of a universal-character-name, the behavior is
undefined. A source file that is not empty and that does not end in a new-line
character, or that ends in a new-line character immediately preceded by a
backslash character before any such splicing takes place,
shall be processed as if an additional new-line character were appended
to the file.</p></li><li id='phases-1.3'><p >The source file is decomposed into preprocessing
tokens (<a href='lex.pptoken'>[lex.pptoken]</a>) and sequences of white-space characters
(including comments). A source file shall not end in a partial
preprocessing token or in a partial comment.<a class='footnotenum' href='#footnote-12'>12</a>
Each comment is replaced by one space character. New-line characters are
retained. Whether each nonempty sequence of white-space characters other
than new-line is retained or replaced by one space character is
unspecified. The process of dividing a source file's
characters into preprocessing tokens is context-dependent.
[&nbsp;<i>Example:</i>
see the handling of <span class='texttt'>&lt;</span> within a <span class='texttt'>#include</span> preprocessing
directive.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li id='phases-1.4'><p >Preprocessing directives are executed, macro invocations are
expanded, and <span class='texttt'>_Pragma</span> unary operator expressions are executed.
If a character sequence that matches the syntax of a
universal-character-name is produced by token
concatenation (<a href='cpp.concat'>[cpp.concat]</a>), the behavior is undefined. A
<span class='texttt'>#include</span> preprocessing directive causes the named header or
source file to be processed from phase 1 through phase 4, recursively.
All preprocessing directives are then deleted.</p></li><li id='phases-1.5'><p >Each source character set member in a character literal or a string
literal, as well as each escape sequence and universal-character-name in a
character literal or a non-raw string literal, is converted to the corresponding
member of the execution character set (<a href='lex.ccon'>[lex.ccon]</a>, <a href='lex.string'>[lex.string]</a>); if
there is no corresponding member, it is converted to an <span class='indexparent'><a class='index' id='converting_characters_from_source_character_set_to_execution_character_set'></a></span>implementation-defined member other
than the null (wide) character.<a class='footnotenum' href='#footnote-13'>13</a></p></li><li id='phases-1.6'><p >Adjacent string literal tokens are concatenated.</p></li><li id='phases-1.7'><p >White-space characters separating tokens are no longer
significant. Each preprocessing token is converted into a
token. (<a href='lex.token'>[lex.token]</a>). The resulting tokens are syntactically and
semantically analyzed and translated as a translation unit. [&nbsp;<i>Note:</i>
The process of analyzing and translating the tokens may occasionally
result in one token being replaced by a sequence of other
tokens (<a href='temp.names'>[temp.names]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i> Source files, translation
units and translated translation units need not necessarily be stored as
files, nor need there be any one-to-one correspondence between these
entities and any external representation. The description is conceptual
only, and does not specify any particular implementation. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='phases-1.8'><p >Translated translation units and instantiation units are combined
as follows: [&nbsp;<i>Note:</i> Some or all of these may be supplied from a
library. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Each translated translation unit is examined to
produce a list of required instantiations. [&nbsp;<i>Note:</i> This may include
instantiations which have been explicitly
requested (<a href='temp.explicit'>[temp.explicit]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;] The definitions of the
required templates are located. It is <span class='indexparent'><a class='index' id='whether_source_of_translation_units_must_be_available_to_locate_template_definitions'></a></span>implementation-defined whether the
source of the translation units containing these definitions is required
to be available. [&nbsp;<i>Note:</i> An implementation could encode sufficient
information into the translated translation unit so as to ensure the
source is not required here. <i>&nbsp;—&nbsp;end note</i>&nbsp;] All the required instantiations
are performed to produce
<a class='hidden_link' href='#def:instantiation_units' id='def:instantiation_units'><i>instantiation units</i></a>. [&nbsp;<i>Note:</i> These are similar
to translated translation units, but contain no references to
uninstantiated templates and no template definitions. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The
program is ill-formed if any instantiation fails.</p></li><li id='phases-1.9'><p >All external entity references are resolved. Library
components are linked to satisfy external references to
entities not defined in the current translation. All such translator
output is collected into a program image which contains information
needed for execution in its execution environment.<span class='indexparent'><a class='index' id='translation,phases'></a></span>
</p></li></ol></div><div class='footnote' id='footnote-11'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-11'>11)</a></div><p >Implementations must behave as if these separate phases
occur, although in practice different phases might be folded together.</p></div><div class='footnote' id='footnote-12'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-12'>12)</a></div><p >A partial preprocessing
token would arise from a source file
ending in the first portion of a multi-character token that requires a
terminating sequence of characters, such as a <i ><a href='lex.header#nt:header-name'>header-name</a></i>
that is missing the closing <span class='texttt'>"</span>
or <span class='texttt'>&gt;</span>. A partial comment
would arise from a source file ending with an unclosed <span class='texttt'>/*</span>
comment.</p></div><div class='footnote' id='footnote-13'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-13'>13)</a></div><p >An implementation need not convert all
non-corresponding source characters to the same execution character.</p></div></div><div id='charset'><h2 ><a class='secnum' href='#charset' style='min-width:88pt'>2.3</a> Character sets <a class='abbr_ref' href='lex.charset'>[lex.charset]</a></h2><div class='para' id='charset-1'><div class='marginalizedparent'><a class='marginalized' href='#charset-1'>1</a></div><p ><span class='indexparent'><a class='index' id='character_set'></a></span><span class='indexparent'><a class='index' id='character_set,basic_source'></a></span>The <a class='hidden_link' href='#def:basic_source_character_set' id='def:basic_source_character_set'><i>basic source character set</i></a> consists of 96 characters: the space character,
the control characters representing horizontal tab, vertical tab, form feed, and
new-line, plus the following 91 graphical characters:<a class='footnotenum' href='#footnote-14'>14</a></p><pre class='codeblock'>
a b c d e f g h i j k l m n o p q r s t u v w x y z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

0 1 2 3 4 5 6 7 8 9

_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ " '
</pre></div><div class='para' id='charset-2'><div class='marginalizedparent'><a class='marginalized' href='#charset-2'>2</a></div><p >The <i ><a href='lex.charset#nt:universal-character-name'>universal-character-name</a></i> construct provides a way to name
other characters.</p><pre class='bnf'><a id='nt:hex-quad'>hex-quad:</a>
    <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i></pre><pre class='bnf'><a id='nt:universal-character-name'>universal-character-name:</a>
    <span class='terminal'>\u</span> <i ><a href='lex.charset#nt:hex-quad'>hex-quad</a></i>
    <span class='terminal'>\U</span> <i ><a href='lex.charset#nt:hex-quad'>hex-quad</a></i> <i ><a href='lex.charset#nt:hex-quad'>hex-quad</a></i></pre><p >The character designated by the universal-character-name <span class='texttt'>\UNNNNNNNN</span> is that character whose character short name in ISO/IEC 10646 is
<span class='texttt'>NNNNNNNN</span>; the character designated by the universal-character-name
<span class='texttt'>\uNNNN</span> is that character whose character short name in
ISO/IEC 10646 is <span class='texttt'>0000NNNN</span>. If the hexadecimal value for a
universal-character-name corresponds to a surrogate code point (in the
range 0xD800–0xDFFF, inclusive), the program is ill-formed. Additionally, if
the hexadecimal value for a universal-character-name outside
the <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i>, <i ><a href='lex.string#nt:s-char-sequence'>s-char-sequence</a></i>, or
<i ><a href='lex.string#nt:r-char-sequence'>r-char-sequence</a></i> of
a character or
string literal corresponds to a control character (in either of the
ranges 0x00–0x1F or 0x7F–0x9F, both inclusive) or to a character in the basic
source character set, the program is ill-formed.<a class='footnotenum' href='#footnote-15'>15</a></p></div><div class='para' id='charset-3'><div class='marginalizedparent'><a class='marginalized' href='#charset-3'>3</a></div><p >The <a class='hidden_link' href='#def:basic_execution_character_set' id='def:basic_execution_character_set'><i>basic execution character set</i></a> and the <a class='hidden_link' href='#def:basic
execution_wide-character_set' id='def:basic
execution_wide-character_set'><i>basic
execution wide-character set</i></a> shall each contain all the members of the
basic source character set, plus control characters representing alert,
backspace, and carriage return, plus a <a class='hidden_link' href='#def:null_character' id='def:null_character'><i>null character</i></a>
(respectively, <a class='hidden_link' href='#def:null_wide_character' id='def:null_wide_character'><i>null wide character</i></a>), whose representation has
all zero bits. For each basic execution character set, the values of the
members shall be non-negative and distinct from one another. In both the
source and execution basic character sets, the value of each character
after <span class='texttt'>0</span> in the above list of decimal digits shall be one greater
than the value of the previous. The <a class='hidden_link' href='#def:execution_character_set' id='def:execution_character_set'><i>execution character set</i></a>
and the <a class='hidden_link' href='#def:execution_wide-character_set' id='def:execution_wide-character_set'><i>execution wide-character set</i></a> are
implementation-defined
<span class='indexparent'><a class='index' id='execution_character-set_and_execution_wide-character_set'></a></span>
supersets of the
basic execution character set and the basic execution wide-character
set, respectively. The values of the members of the execution character sets
and the sets of additional members
are locale-specific.<span class='indexparent'><a class='index' id='character_set'></a></span></p></div><div class='footnote' id='footnote-14'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-14'>14)</a></div><p >The glyphs for
the members of the basic source character set are intended to
identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII
character set. However, because the mapping from source file characters to the source
character set (described in translation phase 1) is specified as implementation-defined,
an implementation is required to document how the basic source characters are
represented in source files.</p></div><div class='footnote' id='footnote-15'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-15'>15)</a></div><p >A sequence of characters resembling a universal-character-name in an
<i ><a href='lex.string#nt:r-char-sequence'>r-char-sequence</a></i> (<a href='lex.string'>[lex.string]</a>) does not form a
universal-character-name.</p></div></div><div id='trigraph'><h2 ><a class='secnum' href='#trigraph' style='min-width:88pt'>2.4</a> Trigraph sequences <a class='abbr_ref' href='lex.trigraph'>[lex.trigraph]</a></h2><div class='para' id='trigraph-1'><div class='marginalizedparent'><a class='marginalized' href='#trigraph-1'>1</a></div><p ><span class='indexparent'><a class='index' id='trigraph_sequence'></a></span>Before any other processing takes place, each occurrence of one of the
following sequences of three characters (“<a class='hidden_link' href='#def:trigraph
sequences' id='def:trigraph
sequences'><i>trigraph
sequences</i></a>”) is replaced by the single character indicated in
Table <a href='#tab:trigraph.sequences'>[tab:trigraph.sequences]</a>.</p><div class='numberedTable' id='tab:trigraph.sequences'>Table <a href='#tab:trigraph.sequences'>1</a> — Trigraph sequences<br><table ><tr class='rowsep'><td class='center'>

 
 Trigraph   </td><td class='center'>   Replacement    </td><td class='border center'>
 Trigraph   </td><td class='center'>   Replacement    </td><td class='border center'>
 Trigraph   </td><td class='center'>   Replacement    </td></tr><tr class='capsep'><td class='center'> 

<span class='texttt'>??=</span>        </td><td class='center'>   <span class='texttt'>#</span>             </td><td class='border center'>
<span class='texttt'>??(</span>        </td><td class='center'>   <span class='texttt'>[</span>              </td><td class='border center'>
<span class='texttt'>??&lt;</span>        </td><td class='center'>   <span class='texttt'>{</span>             </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>??/</span>        </td><td class='center'>   <span class='texttt'>\</span> </td><td class='border center'>
<span class='texttt'>??)</span>        </td><td class='center'>   <span class='texttt'>]</span>              </td><td class='border center'>
<span class='texttt'>??&gt;</span>        </td><td class='center'>   <span class='texttt'>}</span>             </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>??'</span>        </td><td class='center'>   <span class='texttt'>^</span>           </td><td class='border center'>
<span class='texttt'>??!</span>        </td><td class='center'>   <span class='texttt'>|</span>              </td><td class='border center'>
<span class='texttt'>??-</span>        </td><td class='center'>   <span class='texttt'>~</span>             </td></tr></table></div></div><div class='para' id='trigraph-2'><div class='marginalizedparent'><a class='marginalized' href='#trigraph-2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
??=define arraycheck(a,b) a??(b??) ??!??! b??(a??)
</pre><p >becomes</p><pre class='codeblock'>
#define arraycheck(a,b) a[b] || b[a]
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='trigraph-3'><div class='marginalizedparent'><a class='marginalized' href='#trigraph-3'>3</a></div><p >No other trigraph sequence exists. Each <span class='texttt'>?</span> that does not begin
one of the trigraphs listed above is not changed.<span class='indexparent'><a class='index' id='trigraph_sequence'></a></span></p></div></div><div id='pptoken'><h2 ><a class='secnum' href='#pptoken' style='min-width:88pt'>2.5</a> Preprocessing tokens <a class='abbr_ref' href='lex.pptoken'>[lex.pptoken]</a></h2><pre class='bnf'><span class='indexparent'><a class='index' id='token,preprocessing'></a></span><a id='nt:preprocessing-token'>preprocessing-token:</a>
    <i ><a href='lex.header#nt:header-name'>header-name</a></i>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i>
    <i ><a href='lex.ccon#nt:character-literal'>character-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i>
    <i ><a href='lex.string#nt:string-literal'>string-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>
    <i ><a href='lex.operators#nt:preprocessing-op-or-punc'>preprocessing-op-or-punc</a></i>
    <span class='textnormal'>each non-white-space character that cannot be one of the above</span></pre><div class='para' id='pptoken-1'><div class='marginalizedparent'><a class='marginalized' href='#pptoken-1'>1</a></div><p >Each preprocessing token that is converted to a token (<a href='lex.token'>[lex.token]</a>)
shall have the lexical form of a keyword, an identifier, a literal, an
operator, or a punctuator.</p></div><div class='para' id='pptoken-2'><div class='marginalizedparent'><a class='marginalized' href='#pptoken-2'>2</a></div><p >A preprocessing token is the minimal lexical element of the language in translation
phases 3 through 6. The categories of preprocessing token are: header names,
identifiers, preprocessing numbers, character literals (including user-defined character
literals), string literals (including user-defined string literals), preprocessing
operators and punctuators, and single non-white-space characters that do not lexically
match the other preprocessing token categories. If a <span class='texttt'>'</span> or a <span class='texttt'>"</span> character
matches the last category, the behavior is undefined. Preprocessing tokens can be
separated by
<span class='indexparent'><a class='index' id='space,white'></a></span>white space;
<span class='indexparent'><a class='index' id='comment'></a></span>this consists of comments (<a href='lex.comment'>[lex.comment]</a>), or white-space
characters (space, horizontal tab, new-line, vertical tab, and
form-feed), or both. As described in Clause <a href='cpp'>[cpp]</a>, in certain
circumstances during translation phase 4, white space (or the absence
thereof) serves as more than preprocessing token separation. White space
can appear within a preprocessing token only as part of a header name or
between the quotation characters in a character literal or string
literal.</p></div><div class='para' id='pptoken-3'><div class='marginalizedparent'><a class='marginalized' href='#pptoken-3'>3</a></div><p >If the input stream has been parsed into preprocessing tokens up to a
given character:</p><ul class='itemize'><li id='pptoken-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#pptoken-3.1'>(3.1)</a></div><p >If the next character begins a sequence of characters that could be the prefix
and initial double quote of a raw string literal, such as <span class='texttt'>R"</span>, the next preprocessing
token shall be a raw string literal. Between the initial and final
double quote characters of the raw string, any transformations performed in phases
1 and 2 (trigraphs, universal-character-names, and line splicing) are reverted; this reversion
shall apply before any <i ><a href='lex.string#nt:d-char'>d-char</a></i>, <i ><a href='lex.string#nt:r-char'>r-char</a></i>, or delimiting
parenthesis is identified. The raw string literal is defined as the shortest sequence
of characters that matches the raw-string pattern</p><pre class='bnf'><i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>R</span> <i ><a href='lex.string#nt:raw-string'>raw-string</a></i></pre></li><li id='pptoken-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#pptoken-3.2'>(3.2)</a></div><p >Otherwise, if the next three characters are <span class='texttt'>&lt;::</span> and the subsequent character
is neither <span class='texttt'>:</span> nor <span class='texttt'>&gt;</span>, the <span class='texttt'>&lt;</span> is treated as a preprocessor token by
itself and not as the first character of the alternative token <span class='texttt'>&lt;:</span>.</p></li><li id='pptoken-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#pptoken-3.3'>(3.3)</a></div><p >Otherwise,
the next preprocessing token is the longest sequence of
characters that could constitute a preprocessing token, even if that
would cause further lexical analysis to fail.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
#define R "x"
const char* s = R"y";           <span class='comment'>// ill-formed raw string, not <span class='texttt'>"x" "y"</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='pptoken-4'><div class='marginalizedparent'><a class='marginalized' href='#pptoken-4'>4</a></div><p >[&nbsp;<i>Example:</i> The program fragment <span class='texttt'>1Ex</span> is parsed as a
preprocessing number token (one that is not a valid floating or integer
literal token), even though a parse as the pair of preprocessing tokens
<span class='texttt'>1</span> and <span class='texttt'>Ex</span> might produce a valid expression (for example,
if <span class='texttt'>Ex</span> were a macro defined as <span class='texttt'>+1</span>). Similarly, the
program fragment <span class='texttt'>1E1</span> is parsed as a preprocessing number (one
that is a valid floating literal token), whether or not <span class='texttt'>E</span> is a
macro name. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='pptoken-5'><div class='marginalizedparent'><a class='marginalized' href='#pptoken-5'>5</a></div><p >[&nbsp;<i>Example:</i> The program fragment <span class='texttt'>x+++++y</span> is parsed as <span class='texttt'>x
++ ++ + y</span>, which, if <span class='texttt'>x</span> and <span class='texttt'>y</span> have integral types,
violates a constraint on increment operators, even though the parse
<span class='texttt'>x ++ + ++ y</span> might yield a correct expression. <i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='token,preprocessing'></a></span></p></div></div><div id='digraph'><h2 ><a class='secnum' href='#digraph' style='min-width:88pt'>2.6</a> Alternative tokens <a class='abbr_ref' href='lex.digraph'>[lex.digraph]</a></h2><div class='para' id='digraph-1'><div class='marginalizedparent'><a class='marginalized' href='#digraph-1'>1</a></div><p ><span class='indexparent'><a class='index' id='token,alternative'></a></span>Alternative token representations are provided for some operators and
punctuators.<a class='footnotenum' href='#footnote-16'>16</a></p></div><div class='para' id='digraph-2'><div class='marginalizedparent'><a class='marginalized' href='#digraph-2'>2</a></div><p >In all respects of the language, each alternative token behaves the
same, respectively, as its primary token, except for its spelling.<a class='footnotenum' href='#footnote-17'>17</a>
The set of alternative tokens is defined in
Table <a href='#tab:alternative.tokens'>[tab:alternative.tokens]</a>.</p><div class='numberedTable' id='tab:alternative.tokens'>Table <a href='#tab:alternative.tokens'>2</a> — Alternative tokens<br><table ><tr class='rowsep'><td class='center'>

 
 Alternative   </td><td class='center'>   Primary    </td><td class='border center'>
 Alternative   </td><td class='center'>   Primary    </td><td class='border center'>
 Alternative   </td><td class='center'>   Primary    </td></tr><tr class='capsep'><td class='center'> 

<span class='texttt'>&lt;%</span>             </td><td class='center'>   <span class='texttt'>{</span>         </td><td class='border center'>
<span class='texttt'>and</span>             </td><td class='center'>   <span class='texttt'>&amp;&amp;</span>       </td><td class='border center'>
<span class='texttt'>and_eq</span>          </td><td class='center'>   <span class='texttt'>&amp;=</span>        </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>%&gt;</span>             </td><td class='center'>   <span class='texttt'>}</span>         </td><td class='border center'>
<span class='texttt'>bitor</span>           </td><td class='center'>   <span class='texttt'>|</span>          </td><td class='border center'>
<span class='texttt'>or_eq</span>           </td><td class='center'>   <span class='texttt'>|=</span>         </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>&lt;:</span>              </td><td class='center'>   <span class='texttt'>[</span>          </td><td class='border center'>
<span class='texttt'>or</span>              </td><td class='center'>   <span class='texttt'>||</span>         </td><td class='border center'>
<span class='texttt'>xor_eq</span>          </td><td class='center'>   <span class='texttt'>^=</span>      </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>:&gt;</span>              </td><td class='center'>   <span class='texttt'>]</span>          </td><td class='border center'>
<span class='texttt'>xor</span>             </td><td class='center'>   <span class='texttt'>^</span>       </td><td class='border center'>
<span class='texttt'>not</span>             </td><td class='center'>   <span class='texttt'>!</span>          </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>%:</span>             </td><td class='center'>   <span class='texttt'>#</span>         </td><td class='border center'>
<span class='texttt'>compl</span>           </td><td class='center'>   <span class='texttt'>~</span>         </td><td class='border center'>
<span class='texttt'>not_eq</span>          </td><td class='center'>   <span class='texttt'>!=</span>         </td></tr><tr class='rowsep'><td class='center'> 
<span class='texttt'>%:%:</span>          </td><td class='center'>   <span class='texttt'>##</span>       </td><td class='border center'>
<span class='texttt'>bitand</span>          </td><td class='center'>   <span class='texttt'>&amp;</span>         </td><td class='border center'>
                        </td><td class='center'>                      </td></tr></table></div><p ><span class='indexparent'><a class='index' id='token,alternative'></a></span></p></div><div class='footnote' id='footnote-16'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-16'>16)</a></div><p ><span class='indexparent'><a class='index' id='digraph'></a></span>These include “digraphs” and additional reserved words. The term
“digraph” (token consisting of two characters) is not perfectly
descriptive, since one of the alternative preprocessing-tokens is
<span class='texttt'>%:%:</span> and of course several primary tokens contain two
characters. Nonetheless, those alternative tokens that aren't lexical
keywords are colloquially known as “digraphs”. </p></div><div class='footnote' id='footnote-17'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-17'>17)</a></div><p >Thus the “stringized” values (<a href='cpp.stringize'>[cpp.stringize]</a>) of
<span class='texttt'>[</span> and <span class='texttt'>&lt;:</span> will be different, maintaining the source
spelling, but the tokens can otherwise be freely interchanged. </p></div></div><div id='token'><h2 ><a class='secnum' href='#token' style='min-width:88pt'>2.7</a> Tokens <a class='abbr_ref' href='lex.token'>[lex.token]</a></h2><p ><span class='indexparent'><a class='index' id='token'></a></span></p><pre class='bnf'><a id='nt:token'>token:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    keyword
    <i ><a href='lex.literal.kinds#nt:literal'>literal</a></i>
    <i ><a href='over.oper#nt:operator'>operator</a></i>
    punctuator</pre><div class='para' id='token-1'><div class='marginalizedparent'><a class='marginalized' href='#token-1'>1</a></div><p ><span class='indexparent'><a class='index' id='token'></a></span>There are five kinds of tokens: identifiers, keywords, literals,<a class='footnotenum' href='#footnote-18'>18</a>
operators, and other separators.
<span class='indexparent'><a class='index' id='white_space'></a></span>Blanks, horizontal and vertical tabs, newlines, formfeeds, and comments
(collectively, “white space”), as described below, are ignored except
as they serve to separate tokens. [&nbsp;<i>Note:</i> Some white space is
required to separate otherwise adjacent identifiers, keywords, numeric
literals, and alternative tokens containing alphabetic characters.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='token'></a></span></p></div><div class='footnote' id='footnote-18'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-18'>18)</a></div><p >Literals include strings and character and numeric literals.
</p></div></div><div id='comment'><h2 ><a class='secnum' href='#comment' style='min-width:88pt'>2.8</a> Comments <a class='abbr_ref' href='lex.comment'>[lex.comment]</a></h2><div class='para' id='comment-1'><div class='marginalizedparent'><a class='marginalized' href='#comment-1'>1</a></div><p ><span class='indexparent'><a class='index' id='comment'></a></span><span class='indexparent'><a class='index' id='comment,/*_*/'></a></span><span class='indexparent'><a class='index' id='comment,//'></a></span>The characters <span class='texttt'>/*</span> start a comment, which terminates with the
characters <span class='texttt'>*/</span>. These comments do not nest.
<span class='indexparent'><a class='index' id='comment,//'></a></span>The characters <span class='texttt'>//</span> start a comment, which terminates immediately before the
next new-line character. If there is a form-feed or a vertical-tab
character in such a comment, only white-space characters shall appear
between it and the new-line that terminates the comment; no diagnostic
is required. [&nbsp;<i>Note:</i> The comment characters <span class='texttt'>//</span>, <span class='texttt'>/*</span>,
and <span class='texttt'>*/</span> have no special meaning within a <span class='texttt'>//</span> comment and
are treated just like other characters. Similarly, the comment
characters <span class='texttt'>//</span> and <span class='texttt'>/*</span> have no special meaning within a
<span class='texttt'>/*</span> comment. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='comment'></a></span></p></div></div><div id='header'><h2 ><a class='secnum' href='#header' style='min-width:88pt'>2.9</a> Header names <a class='abbr_ref' href='lex.header'>[lex.header]</a></h2><p ><span class='indexparent'><a class='index' id='header,name'></a></span></p><pre class='bnf'><a id='nt:header-name'>header-name:</a>
    <span class='terminal'>&lt;</span> <i ><a href='lex.header#nt:h-char-sequence'>h-char-sequence</a></i> <span class='terminal'>&gt;</span>
    <span class='terminal'>"</span> <i ><a href='lex.header#nt:q-char-sequence'>q-char-sequence</a></i> <span class='terminal'>"</span></pre><pre class='bnf'><a id='nt:h-char-sequence'>h-char-sequence:</a>
    <i ><a href='lex.header#nt:h-char'>h-char</a></i>
    <i ><a href='lex.header#nt:h-char-sequence'>h-char-sequence</a></i> <i ><a href='lex.header#nt:h-char'>h-char</a></i></pre><pre class='bnf'><a id='nt:h-char'>h-char:</a>
    <span class='textnormal'>any member of the source character set except new-line and <span class='terminal'>&gt;</span></span></pre><pre class='bnf'><a id='nt:q-char-sequence'>q-char-sequence:</a>
    <i ><a href='lex.header#nt:q-char'>q-char</a></i>
    <i ><a href='lex.header#nt:q-char-sequence'>q-char-sequence</a></i> <i ><a href='lex.header#nt:q-char'>q-char</a></i></pre><pre class='bnf'><a id='nt:q-char'>q-char:</a>
    <span class='textnormal'>any member of the source character set except new-line and <span class='terminal'>"</span></span></pre><div class='para' id='header-1'><div class='marginalizedparent'><a class='marginalized' href='#header-1'>1</a></div><p >Header name preprocessing tokens shall only appear within a
<span class='texttt'>#include</span> preprocessing directive (<a href='cpp.include'>[cpp.include]</a>). The
sequences in both forms of <i ><a href='lex.header#nt:header-name'>header-names</a></i> are mapped in an
<span class='indexparent'><a class='index' id='mapping_header_name_to_header_or_external_source_file'></a></span>implementation-defined manner to headers or to
external source file names as specified in <a href='cpp.include'>[cpp.include]</a>.</p></div><div class='para' id='header-2'><div class='marginalizedparent'><a class='marginalized' href='#header-2'>2</a></div><p >The appearance of either of the characters <span class='texttt'>'</span> or <span class='texttt'>\</span> or of
either of the character sequences <span class='texttt'>/*</span> or <span class='texttt'>//</span> in a
<i ><a href='lex.header#nt:q-char-sequence'>q-char-sequence</a></i> or an <i ><a href='lex.header#nt:h-char-sequence'>h-char-sequence</a></i>
is conditionally-supported with implementation-defined semantics,
as is the appearance of the
character <span class='texttt'>"</span> in an <i ><a href='lex.header#nt:h-char-sequence'>h-char-sequence</a></i>.<a class='footnotenum' href='#footnote-19'>19</a><span class='indexparent'><a class='index' id='header,name'></a></span></p></div><div class='footnote' id='footnote-19'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-19'>19)</a></div><p >Thus, a
sequence of characters that resembles an escape sequence might result in an
error, be interpreted as the character corresponding to the escape sequence, or
have a completely different meaning, depending on the implementation.</p></div></div><div id='ppnumber'><h2 ><a class='secnum' href='#ppnumber' style='min-width:88pt'>2.10</a> Preprocessing numbers <a class='abbr_ref' href='lex.ppnumber'>[lex.ppnumber]</a></h2><p ><span class='indexparent'><a class='index' id='number,preprocessing'></a></span></p><pre class='bnf'><a id='nt:pp-number'>pp-number:</a>
    <i ><a href='lex.name#nt:digit'>digit</a></i>
    <span class='terminal'>.</span> <i ><a href='lex.name#nt:digit'>digit</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <i ><a href='lex.name#nt:digit'>digit</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <i ><a href='lex.name#nt:identifier-nondigit'>identifier-nondigit</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <span class='terminal'>'</span> <i ><a href='lex.name#nt:digit'>digit</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <span class='terminal'>'</span> <i ><a href='lex.name#nt:nondigit'>nondigit</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <span class='terminal'>e</span> <i ><a href='lex.fcon#nt:sign'>sign</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <span class='terminal'>E</span> <i ><a href='lex.fcon#nt:sign'>sign</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> <span class='terminal'>.</span></pre><div class='para' id='ppnumber-1'><div class='marginalizedparent'><a class='marginalized' href='#ppnumber-1'>1</a></div><p >Preprocessing number tokens lexically include all integer literal
tokens (<a href='lex.icon'>[lex.icon]</a>) and all floating literal
tokens (<a href='lex.fcon'>[lex.fcon]</a>).</p></div><div class='para' id='ppnumber-2'><div class='marginalizedparent'><a class='marginalized' href='#ppnumber-2'>2</a></div><p >A preprocessing number does not have a type or a value; it acquires both
after a successful conversion to an integer literal token or a floating literal
token.<span class='indexparent'><a class='index' id='number,preprocessing'></a></span></p></div></div><div id='name'><h2 ><a class='secnum' href='#name' style='min-width:88pt'>2.11</a> Identifiers <a class='abbr_ref' href='lex.name'>[lex.name]</a></h2><p ><span class='indexparent'><a class='index' id='identifier'></a></span></p><pre class='bnf'><a id='nt:identifier'>identifier:</a>
    <i ><a href='lex.name#nt:identifier-nondigit'>identifier-nondigit</a></i>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='lex.name#nt:identifier-nondigit'>identifier-nondigit</a></i>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='lex.name#nt:digit'>digit</a></i></pre><pre class='bnf'><a id='nt:identifier-nondigit'>identifier-nondigit:</a>
    <i ><a href='lex.name#nt:nondigit'>nondigit</a></i>
    <i ><a href='lex.charset#nt:universal-character-name'>universal-character-name</a></i>
    <span class='textnormal'>other implementation-defined characters</span></pre><pre class='bnf'><a id='nt:nondigit'>nondigit:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>a b c d e f g h i j k l m</span>
    <span class='terminal'>n o p q r s t u v w x y z</span>
    <span class='terminal'>A B C D E F G H I J K L M</span>
    <span class='terminal'>N O P Q R S T U V W X Y Z _</span></pre><pre class='bnf'><a id='nt:digit'>digit:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>0 1 2 3 4 5 6 7 8 9</span></pre><div class='para' id='name-1'><div class='marginalizedparent'><a class='marginalized' href='#name-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,length_of'></a></span><span class='indexparent'><a class='index' id='name'></a></span>An identifier is an arbitrarily long sequence of letters and digits.
Each universal-character-name in an identifier shall designate a
character whose encoding in ISO 10646 falls into one of the ranges
specified in <a href='charname.allowed'>[charname.allowed]</a>.
The initial element shall not be a universal-character-name
designating a character whose encoding falls into one of the ranges
specified in <a href='charname.disallowed'>[charname.disallowed]</a>.
Upper- and lower-case letters are
different. All characters are significant.<a class='footnotenum' href='#footnote-20'>20</a></p></div><div class='para' id='name-2'><div class='marginalizedparent'><a class='marginalized' href='#name-2'>2</a></div><p >The identifiers in Table <a href='#tab:identifiers.special'>[tab:identifiers.special]</a> have a special meaning when
appearing in a certain context. When referred to in the grammar, these identifiers
are used explicitly rather than using the <i ><a href='lex.name#nt:identifier'>identifier</a></i> grammar production.
Unless otherwise specified, any ambiguity as to whether a given
<i ><a href='lex.name#nt:identifier'>identifier</a></i> has a special meaning is resolved to interpret the
token as a regular <i ><a href='lex.name#nt:identifier'>identifier</a></i>.</p><div class='numberedTable' id='tab:identifiers.special'>Table <a href='#tab:identifiers.special'>3</a> — Identifiers with special meaning<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>override</span>        </td><td class='left'>
<span class='texttt'>final</span>           </td></tr></table></div></div><div class='para' id='name-3'><div class='marginalizedparent'><a class='marginalized' href='#name-3'>3</a></div><p ><span class='indexparent'><a class='index' id='_'></a></span><span class='indexparent'><a class='index' id='character,underscore,in_identifier'></a></span><span class='indexparent'><a class='index' id='reserved_identifier'></a></span>In addition, some identifiers are reserved for use by C++
implementations and standard libraries (<a href='global.names'>[global.names]</a>) and shall
not be used otherwise; no diagnostic is required.<span class='indexparent'><a class='index' id='identifier'></a></span></p></div><div class='footnote' id='footnote-20'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-20'>20)</a></div><p >On systems in which linkers cannot accept extended
characters, an encoding of the universal-character-name may be used in
forming valid external identifiers. For example, some otherwise unused
character or sequence of characters may be used to encode the
<span class='texttt'>\u</span> in a universal-character-name. Extended
characters may produce a long external identifier, but C++ does not
place a translation limit on significant characters for external
identifiers. In C++, upper- and lower-case letters are considered
different for all identifiers, including external identifiers. </p></div></div><div id='key'><h2 ><a class='secnum' href='#key' style='min-width:88pt'>2.12</a> Keywords <a class='abbr_ref' href='lex.key'>[lex.key]</a></h2><div class='para' id='key-1'><div class='marginalizedparent'><a class='marginalized' href='#key-1'>1</a></div><p ><span class='indexparent'><a class='index' id='keyword'></a></span>The identifiers shown in Table <a href='#tab:keywords'>[tab:keywords]</a> are reserved for use
as keywords (that is, they are unconditionally treated as keywords in
phase 7) except in an <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> (<a href='dcl.attr.grammar'>[dcl.attr.grammar]</a>)
[&nbsp;<i>Note:</i> The <span class='texttt'>export</span> keyword is unused but is reserved for future use.<i>&nbsp;—&nbsp;end note</i>&nbsp;]:</p><div class='numberedTable' id='tab:keywords'>Table <a href='#tab:keywords'>4</a> — Keywords<br><table ><tr class='rowsep'><td class='left'>


<span class='texttt'>alignas</span>           </td><td class='left'>
<span class='texttt'>continue</span>          </td><td class='left'>
<span class='texttt'>friend</span>            </td><td class='left'>
<span class='texttt'>register</span>          </td><td class='left'>
<span class='texttt'>true</span>              </td></tr><tr ><td class='left'><span class='texttt'>alignof</span>           </td><td class='left'>
<span class='texttt'>decltype</span>          </td><td class='left'>
<span class='texttt'>goto</span>              </td><td class='left'>
<span class='texttt'>reinterpret_cast</span>  </td><td class='left'>
<span class='texttt'>try</span>               </td></tr><tr ><td class='left'><span class='texttt'>asm</span>               </td><td class='left'>
<span class='texttt'>default</span>           </td><td class='left'>
<span class='texttt'>if</span>                </td><td class='left'>
<span class='texttt'>return</span>            </td><td class='left'>
<span class='texttt'>typedef</span>           </td></tr><tr ><td class='left'><span class='texttt'>auto</span>              </td><td class='left'>
<span class='texttt'>delete</span>            </td><td class='left'>
<span class='texttt'>inline</span>            </td><td class='left'>
<span class='texttt'>short</span>             </td><td class='left'>
<span class='texttt'>typeid</span>            </td></tr><tr ><td class='left'><span class='texttt'>bool</span>              </td><td class='left'>
<span class='texttt'>do</span>                </td><td class='left'>
<span class='texttt'>int</span>               </td><td class='left'>
<span class='texttt'>signed</span>            </td><td class='left'>
<span class='texttt'>typename</span>          </td></tr><tr ><td class='left'><span class='texttt'>break</span>             </td><td class='left'>
<span class='texttt'>double</span>            </td><td class='left'>
<span class='texttt'>long</span>              </td><td class='left'>
<span class='texttt'>sizeof</span>            </td><td class='left'>
<span class='texttt'>union</span>             </td></tr><tr ><td class='left'><span class='texttt'>case</span>              </td><td class='left'>
<span class='texttt'>dynamic_cast</span>      </td><td class='left'>
<span class='texttt'>mutable</span>           </td><td class='left'>
<span class='texttt'>static</span>            </td><td class='left'>
<span class='texttt'>unsigned</span>          </td></tr><tr ><td class='left'><span class='texttt'>catch</span>             </td><td class='left'>
<span class='texttt'>else</span>              </td><td class='left'>
<span class='texttt'>namespace</span>         </td><td class='left'>
<span class='texttt'>static_assert</span>     </td><td class='left'>
<span class='texttt'>using</span>             </td></tr><tr ><td class='left'><span class='texttt'>char</span>              </td><td class='left'>
<span class='texttt'>enum</span>              </td><td class='left'>
<span class='texttt'>new</span>               </td><td class='left'>
<span class='texttt'>static_cast</span>       </td><td class='left'>
<span class='texttt'>virtual</span>           </td></tr><tr ><td class='left'><span class='texttt'>char16_t</span>          </td><td class='left'>
<span class='texttt'>explicit</span>          </td><td class='left'>
<span class='texttt'>noexcept</span>          </td><td class='left'>
<span class='texttt'>struct</span>            </td><td class='left'>
<span class='texttt'>void</span>              </td></tr><tr ><td class='left'><span class='texttt'>char32_t</span>          </td><td class='left'>
<span class='texttt'>export</span>            </td><td class='left'>
<span class='texttt'>nullptr</span>           </td><td class='left'>
<span class='texttt'>switch</span>            </td><td class='left'>
<span class='texttt'>volatile</span>          </td></tr><tr ><td class='left'><span class='texttt'>class</span>             </td><td class='left'>
<span class='texttt'>extern</span>            </td><td class='left'>
<span class='texttt'>operator</span>          </td><td class='left'>
<span class='texttt'>template</span>          </td><td class='left'>
<span class='texttt'>wchar_t</span>           </td></tr><tr ><td class='left'><span class='texttt'>const</span>             </td><td class='left'>
<span class='texttt'>false</span>             </td><td class='left'>
<span class='texttt'>private</span>           </td><td class='left'>
<span class='texttt'>this</span>              </td><td class='left'>
<span class='texttt'>while</span>             </td></tr><tr ><td class='left'><span class='texttt'>constexpr</span>         </td><td class='left'>
<span class='texttt'>float</span>             </td><td class='left'>
<span class='texttt'>protected</span>         </td><td class='left'>
<span class='texttt'>thread_local</span>      </td><td class='left'> </td></tr><tr ><td class='left'><span class='texttt'>const_cast</span>        </td><td class='left'>
<span class='texttt'>for</span>               </td><td class='left'>
<span class='texttt'>public</span>            </td><td class='left'>
<span class='texttt'>throw</span>             </td><td class='left'> </td></tr></table></div></div><div class='para' id='key-2'><div class='marginalizedparent'><a class='marginalized' href='#key-2'>2</a></div><p >Furthermore, the alternative representations shown in
Table <a href='#tab:alternative.representations'>[tab:alternative.representations]</a> for certain operators and
punctuators (<a href='lex.digraph'>[lex.digraph]</a>) are reserved and shall not be used
otherwise:</p><div class='numberedTable' id='tab:alternative.representations'>Table <a href='#tab:alternative.representations'>5</a> — Alternative representations<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>and</span>     </td><td class='left'>   <span class='texttt'>and_eq</span>  </td><td class='left'>   <span class='texttt'>bitand</span>  </td><td class='left'>   <span class='texttt'>bitor</span>   </td><td class='left'>   <span class='texttt'>compl</span>   </td><td class='left'>   <span class='texttt'>not</span> </td></tr><tr ><td class='left'>
<span class='texttt'>not_eq</span>  </td><td class='left'>   <span class='texttt'>or</span>      </td><td class='left'>   <span class='texttt'>or_eq</span>   </td><td class='left'>   <span class='texttt'>xor</span>     </td><td class='left'>   <span class='texttt'>xor_eq</span>  </td><td class='left'>       </td></tr></table></div><p ><span class='indexparent'><a class='index' id='keyword'></a></span></p></div></div><div id='operators'><h2 ><a class='secnum' href='#operators' style='min-width:88pt'>2.13</a> Operators and punctuators <a class='abbr_ref' href='lex.operators'>[lex.operators]</a></h2><div class='para' id='operators-1'><div class='marginalizedparent'><a class='marginalized' href='#operators-1'>1</a></div><p ><span class='indexparent'><a class='index' id='operator'></a></span><span class='indexparent'><a class='index' id='punctuator'></a></span>The lexical representation of C++ programs includes a number of
preprocessing tokens which are used in the syntax of the preprocessor or
are converted into tokens for operators and punctuators:</p><pre class='bnf'><a id='nt:preprocessing-op-or-punc'>preprocessing-op-or-punc:</a> <span class='textnormal'>one of</span>
&#9;{ &#9;} &#9;[ &#9;] &#9;# &#9;## &#9;( &#9;)
&#9;&lt;: &#9;:&gt; &#9;&lt;% &#9;%&gt; &#9;%: &#9;%:%: &#9;; &#9;: &#9;...
&#9;new &#9;delete &#9;? &#9;:: &#9;. &#9;.*
&#9;+ &#9;- &#9;* &#9;/ &#9;% &#9;^ &#9;&amp; &#9;| &#9;~
&#9;! &#9;= &#9;&lt; &#9;&gt; &#9;+= &#9;-= &#9;*= &#9;/= &#9;%=
&#9;^= &#9;&amp;= &#9;|= &#9;&lt;&lt; &#9;&gt;&gt; &#9;&gt;&gt;= &#9;&lt;&lt;= &#9;== &#9;!=
&#9;&lt;= &#9;&gt;= &#9;&amp;&amp; &#9;|| &#9;++ &#9;-- &#9;, &#9;-&gt;* &#9;-&gt;
&#9;and &#9;and_eq &#9;bitand &#9;bitor &#9;compl &#9;not &#9;not_eq
&#9;or &#9;or_eq &#9;xor &#9;xor_eq</pre><p >Each <i ><a href='lex.operators#nt:preprocessing-op-or-punc'>preprocessing-op-or-punc</a></i> is converted to a single token
in translation phase 7 (<a href='lex.phases'>[lex.phases]</a>).<span class='indexparent'><a class='index' id='punctuator'></a></span><span class='indexparent'><a class='index' id='operator'></a></span></p></div></div><div id='literal'><h2 ><a class='secnum' href='#literal' style='min-width:88pt'>2.14</a> Literals <a class='abbr_ref' href='lex.literal'>[lex.literal]</a></h2><p ><span class='indexparent'><a class='index' id='literal'></a></span></p><div id='literal.kinds'><h3 ><a class='secnum' href='#literal.kinds' style='min-width:103pt'>2.14.1</a> Kinds of literals <a class='abbr_ref' href='lex.literal.kinds'>[lex.literal.kinds]</a></h3><div class='para' id='literal.kinds-1'><div class='marginalizedparent'><a class='marginalized' href='#literal.kinds-1'>1</a></div><p ><span class='indexparent'><a class='index' id='constant'></a></span><span class='indexparent'><a class='index' id='literal,constant'></a></span>There are several kinds of literals.<a class='footnotenum' href='#footnote-21'>21</a></p><pre class='bnf'><a id='nt:literal'>literal:</a>
    <i ><a href='lex.icon#nt:integer-literal'>integer-literal</a></i>
    <i ><a href='lex.ccon#nt:character-literal'>character-literal</a></i>
    <i ><a href='lex.fcon#nt:floating-literal'>floating-literal</a></i>
    <i ><a href='lex.string#nt:string-literal'>string-literal</a></i>
    <i ><a href='lex.bool#nt:boolean-literal'>boolean-literal</a></i>
    <i ><a href='lex.nullptr#nt:pointer-literal'>pointer-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i></pre></div><div class='footnote' id='footnote-21'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-21'>21)</a></div><p >The term “literal” generally designates, in this
International Standard, those tokens that are called “constants” in
ISO C. </p></div></div><div id='icon'><h3 ><a class='secnum' href='#icon' style='min-width:103pt'>2.14.2</a> Integer literals <a class='abbr_ref' href='lex.icon'>[lex.icon]</a></h3><p ><span class='indexparent'><a class='index' id='literal,integer'></a></span></p><pre class='bnf'><a id='nt:integer-literal'>integer-literal:</a>
    <i ><a href='lex.icon#nt:binary-literal'>binary-literal</a></i> <i ><a href='lex.icon#nt:integer-suffix'>integer-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.icon#nt:octal-literal'>octal-literal</a></i> <i ><a href='lex.icon#nt:integer-suffix'>integer-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.icon#nt:decimal-literal'>decimal-literal</a></i> <i ><a href='lex.icon#nt:integer-suffix'>integer-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.icon#nt:hexadecimal-literal'>hexadecimal-literal</a></i> <i ><a href='lex.icon#nt:integer-suffix'>integer-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:binary-literal'>binary-literal:</a>
    <span class='terminal'>0b</span> <i ><a href='lex.icon#nt:binary-digit'>binary-digit</a></i>
    <span class='terminal'>0B</span> <i ><a href='lex.icon#nt:binary-digit'>binary-digit</a></i>
    <i ><a href='lex.icon#nt:binary-literal'>binary-literal</a></i> <span class='terminal'>'</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.icon#nt:binary-digit'>binary-digit</a></i></pre><pre class='bnf'><a id='nt:octal-literal'>octal-literal:</a>
    <span class='terminal'>0</span>
    <i ><a href='lex.icon#nt:octal-literal'>octal-literal</a></i> <span class='terminal'>'</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i></pre><pre class='bnf'><a id='nt:decimal-literal'>decimal-literal:</a>
    <i ><a href='lex.icon#nt:nonzero-digit'>nonzero-digit</a></i>
    <i ><a href='lex.icon#nt:decimal-literal'>decimal-literal</a></i> <span class='terminal'>'</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:digit'>digit</a></i></pre><pre class='bnf'><a id='nt:hexadecimal-literal'>hexadecimal-literal:</a>
    <span class='terminal'>0x</span> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i>
    <span class='terminal'>0X</span> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i>
    <i ><a href='lex.icon#nt:hexadecimal-literal'>hexadecimal-literal</a></i> <span class='terminal'>'</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i></pre><pre class='bnf'><a id='nt:binary-digit'>binary-digit:</a>
    <span class='terminal'>0</span>
    <span class='terminal'>1</span></pre><pre class='bnf'><a id='nt:octal-digit'>octal-digit:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>0  1  2  3  4  5  6  7</span></pre><pre class='bnf'><a id='nt:nonzero-digit'>nonzero-digit:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>1  2  3  4  5  6  7  8  9</span></pre><pre class='bnf'><a id='nt:hexadecimal-digit'>hexadecimal-digit:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>0  1  2  3  4  5  6  7  8  9</span>
    <span class='terminal'>a  b  c  d  e  f</span>
    <span class='terminal'>A  B  C  D  E  F</span></pre><pre class='bnf'><a id='nt:integer-suffix'>integer-suffix:</a>
    <i ><a href='lex.icon#nt:unsigned-suffix'>unsigned-suffix</a></i> <i ><a href='lex.icon#nt:long-suffix'>long-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> 
    <i ><a href='lex.icon#nt:unsigned-suffix'>unsigned-suffix</a></i> <i ><a href='lex.icon#nt:long-long-suffix'>long-long-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> 
    <i ><a href='lex.icon#nt:long-suffix'>long-suffix</a></i> <i ><a href='lex.icon#nt:unsigned-suffix'>unsigned-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> 
    <i ><a href='lex.icon#nt:long-long-suffix'>long-long-suffix</a></i> <i ><a href='lex.icon#nt:unsigned-suffix'>unsigned-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:unsigned-suffix'>unsigned-suffix:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>u  U</span></pre><pre class='bnf'><a id='nt:long-suffix'>long-suffix:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>l  L</span></pre><pre class='bnf'><a id='nt:long-long-suffix'>long-long-suffix:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>ll  LL</span></pre><div class='para' id='icon-1'><div class='marginalizedparent'><a class='marginalized' href='#icon-1'>1</a></div><p ><span class='indexparent'><a class='index' id='literal,unsigned'></a></span><span class='indexparent'><a class='index' id='literal,long'></a></span><span class='indexparent'><a class='index' id='literal,integer'></a></span><span class='indexparent'><a class='index' id='literal,binary'></a></span><span class='indexparent'><a class='index' id='literal,octal'></a></span><span class='indexparent'><a class='index' id='literal,decimal'></a></span><span class='indexparent'><a class='index' id='literal,hexadecimal'></a></span><span class='indexparent'><a class='index' id='literal,base_of_integer'></a></span>An <a class='hidden_link' href='#def:integer_literal' id='def:integer_literal'><i>integer literal</i></a> is a sequence of digits that has no period
or exponent part, with optional separating single quotes that are ignored
when determining its value. An integer literal may have a prefix that specifies
its base and a suffix that specifies its type. The lexically first digit
of the sequence of digits is the most significant.
A <a class='hidden_link' href='#def:binary' id='def:binary'><i>binary</i></a> integer literal (base two) begins with
<span class='texttt'>0b</span> or <span class='texttt'>0B</span> and consists of a sequence of binary digits.
An <a class='hidden_link' href='#def:octal' id='def:octal'><i>octal</i></a> integer
literal (base eight) begins with the digit <span class='texttt'>0</span> and consists of a
sequence of octal digits.<a class='footnotenum' href='#footnote-22'>22</a>
A <a class='hidden_link' href='#def:decimal' id='def:decimal'><i>decimal</i></a>
integer literal (base ten) begins with a digit other than <span class='texttt'>0</span> and
consists of a sequence of decimal digits.
A <a class='hidden_link' href='#def:hexadecimal' id='def:hexadecimal'><i>hexadecimal</i></a> integer literal (base sixteen) begins with
<span class='texttt'>0x</span> or <span class='texttt'>0X</span> and consists of a sequence of hexadecimal
digits, which include the decimal digits and the letters <span class='texttt'>a</span>
through <span class='texttt'>f</span> and <span class='texttt'>A</span> through <span class='texttt'>F</span> with decimal values
ten through fifteen.
[&nbsp;<i>Example:</i> The number twelve can be written <span class='texttt'>12</span>, <span class='texttt'>014</span>,
<span class='texttt'>0XC</span>, or <span class='texttt'>0b1100</span>. The literals <span class='texttt'>1048576</span>,
<span class='texttt'>1'048'576</span>, <span class='texttt'>0X100000</span>, <span class='texttt'>0x10'0000</span>, and
<span class='texttt'>0'004'000'000</span> all have the same value.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='icon-2'><div class='marginalizedparent'><a class='marginalized' href='#icon-2'>2</a></div><p ><span class='indexparent'><a class='index' id='literal,long'></a></span><span class='indexparent'><a class='index' id='literal,unsigned'></a></span><span class='indexparent'><a class='index' id='suffix,L'></a></span><span class='indexparent'><a class='index' id='suffix,U'></a></span><span class='indexparent'><a class='index' id='suffix,l'></a></span><span class='indexparent'><a class='index' id='suffix,u'></a></span><span class='indexparent'><a class='index' id='literal,type_of_integer'></a></span>The type of an integer literal is the first of the corresponding list
in Table <a href='#tab:lex.type.integer.literal'>[tab:lex.type.integer.literal]</a> in which its value can be
represented.</p><div class='numberedTable' id='tab:lex.type.integer.literal'>Table <a href='#tab:lex.type.integer.literal'>6</a> — Types of integer literals<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Suffix</b></td><td colspan='1' class='border center'><b>Decimal literal</b></td><td colspan='1' class='border center'><b>Binary, octal, or hexadecimal literal</b></td></tr><tr class='capsep'><td class='left'>  
<span class='endhead'></span>
none    </td><td class='border left'>
  <span class='texttt'>int</span> </td><td class='border left'>
  <span class='texttt'>int</span></td></tr><tr ><td class='left'>
        </td><td class='border left'>
  <span class='texttt'>long int</span> </td><td class='border left'>
  <span class='texttt'>unsigned int</span></td></tr><tr ><td class='left'>
        </td><td class='border left'>
  <span class='texttt'>long long int</span> </td><td class='border left'>
  <span class='texttt'>long int</span></td></tr><tr ><td class='left'>
        </td><td class='border left'>
        </td><td class='border left'>
  <span class='texttt'>unsigned long int</span></td></tr><tr ><td class='left'>
        </td><td class='border left'>
        </td><td class='border left'>
  <span class='texttt'>long long int</span></td></tr><tr ><td class='left'>
        </td><td class='border left'>
        </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr class='rowsep'><td class='left'>
<span class='texttt'>u</span> or <span class='texttt'>U</span>  </td><td class='border left'>
  <span class='texttt'>unsigned int</span>  </td><td class='border left'>
  <span class='texttt'>unsigned int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
  <span class='texttt'>unsigned long int</span>   </td><td class='border left'>
  <span class='texttt'>unsigned long int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span>   </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr class='rowsep'><td class='left'>
<span class='texttt'>l</span> or <span class='texttt'>L</span>  </td><td class='border left'>
  <span class='texttt'>long int</span>  </td><td class='border left'>
  <span class='texttt'>long int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
  <span class='texttt'>long long int</span>       </td><td class='border left'>
  <span class='texttt'>unsigned long int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
                              </td><td class='border left'>
  <span class='texttt'>long long int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
                              </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr class='rowsep'><td class='left'>
Both <span class='texttt'>u</span> or <span class='texttt'>U</span>   </td><td class='border left'>
  <span class='texttt'>unsigned long int</span>  </td><td class='border left'>
  <span class='texttt'>unsigned long int</span></td></tr><tr ><td class='left'>
and <span class='texttt'>l</span> or <span class='texttt'>L</span>  </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span>  </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr class='rowsep'><td class='left'>
<span class='texttt'>ll</span> or <span class='texttt'>LL</span>  </td><td class='border left'>
  <span class='texttt'>long long int</span>       </td><td class='border left'>
  <span class='texttt'>long long int</span></td></tr><tr ><td class='left'>
                              </td><td class='border left'>
                              </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr class='rowsep'><td class='left'>
Both <span class='texttt'>u</span> or <span class='texttt'>U</span>   </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span>  </td><td class='border left'>
  <span class='texttt'>unsigned long long int</span></td></tr><tr ><td class='left'>
and <span class='texttt'>ll</span> or <span class='texttt'>LL</span>  </td><td class='border left'>
                              </td><td class='border left'>
                              </td></tr></table></div></div><div class='para' id='icon-3'><div class='marginalizedparent'><a class='marginalized' href='#icon-3'>3</a></div><p >If an integer literal cannot be represented by any type in its list and
an extended integer type (<a href='basic.fundamental'>[basic.fundamental]</a>) can represent its value, it may have that
extended integer type. If all of the types in the list for the literal
are signed, the extended integer type shall be signed. If all of the
types in the list for the literal are unsigned, the extended integer
type shall be unsigned. If the list contains both signed and unsigned
types, the extended integer type may be signed or unsigned. A program is
ill-formed if one of its translation units contains an integer literal
that cannot be represented by any of the allowed types.</p></div><div class='footnote' id='footnote-22'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-22'>22)</a></div><p >The digits <span class='texttt'>8</span> and <span class='texttt'>9</span> are not octal digits. </p></div></div><div id='ccon'><h3 ><a class='secnum' href='#ccon' style='min-width:103pt'>2.14.3</a> Character literals <a class='abbr_ref' href='lex.ccon'>[lex.ccon]</a></h3><p ><span class='indexparent'><a class='index' id='literal,character'></a></span></p><pre class='bnf'><a id='nt:character-literal'>character-literal:</a>
    <span class='terminal'>'</span> <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i> <span class='terminal'>'</span>
    u<span class='terminal'>'</span> <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i> <span class='terminal'>'</span>
    U<span class='terminal'>'</span> <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i> <span class='terminal'>'</span>
    L<span class='terminal'>'</span> <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i> <span class='terminal'>'</span></pre><pre class='bnf'><a id='nt:c-char-sequence'>c-char-sequence:</a>
    <i ><a href='lex.ccon#nt:c-char'>c-char</a></i>
    <i ><a href='lex.ccon#nt:c-char-sequence'>c-char-sequence</a></i> <i ><a href='lex.ccon#nt:c-char'>c-char</a></i></pre><pre class='bnf'><a id='nt:c-char'>c-char:</a>
&#9;<span class='textnormal'>any member of the source character set except</span>
&#9;&#9;<span class='textnormal'>the single-quote <span class='terminal'>'</span>, backslash <span class='terminal'>\</span>, or new-line character</span>
&#9;<i ><a href='lex.ccon#nt:escape-sequence'>escape-sequence</a></i>
&#9;<i ><a href='lex.charset#nt:universal-character-name'>universal-character-name</a></i></pre><pre class='bnf'><a id='nt:escape-sequence'>escape-sequence:</a>
    <i ><a href='lex.ccon#nt:simple-escape-sequence'>simple-escape-sequence</a></i>
    <i ><a href='lex.ccon#nt:octal-escape-sequence'>octal-escape-sequence</a></i>
    <i ><a href='lex.ccon#nt:hexadecimal-escape-sequence'>hexadecimal-escape-sequence</a></i></pre><pre class='bnf'><a id='nt:simple-escape-sequence'>simple-escape-sequence:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>\'</span>&emsp;&ensp;<span class='terminal'>\"</span>&emsp;&ensp;<span class='terminal'>\?</span>&emsp;&ensp;<span class='terminal'>\\</span>
    <span class='terminal'>\a</span>&emsp;&ensp;<span class='terminal'>\b</span>&emsp;&ensp;<span class='terminal'>\f</span>&emsp;&ensp;<span class='terminal'>\n</span>&emsp;&ensp;<span class='terminal'>\r</span>&emsp;&ensp;<span class='terminal'>\t</span>&emsp;&ensp;<span class='terminal'>\v</span></pre><pre class='bnf'><a id='nt:octal-escape-sequence'>octal-escape-sequence:</a>
    <span class='terminal'>\</span> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i>
    <span class='terminal'>\</span> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i>
    <span class='terminal'>\</span> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i> <i ><a href='lex.icon#nt:octal-digit'>octal-digit</a></i></pre><pre class='bnf'><a id='nt:hexadecimal-escape-sequence'>hexadecimal-escape-sequence:</a>
    <span class='terminal'>\x</span> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i>
    <i ><a href='lex.ccon#nt:hexadecimal-escape-sequence'>hexadecimal-escape-sequence</a></i> <i ><a href='lex.icon#nt:hexadecimal-digit'>hexadecimal-digit</a></i></pre><div class='para' id='ccon-1'><div class='marginalizedparent'><a class='marginalized' href='#ccon-1'>1</a></div><p ><span class='indexparent'><a class='index' id='literal,character'></a></span><span class='indexparent'><a class='index' id='literal,narrow-character'></a></span><span class='indexparent'><a class='index' id='literal,char16_t'></a></span><span class='indexparent'><a class='index' id='literal,char32_t'></a></span>A character literal is one or more characters enclosed in single quotes,
as in <span class='texttt'>'x'</span>, optionally preceded by one of the letters <span class='texttt'>u</span>,
<span class='texttt'>U</span>, or <span class='texttt'>L</span>, as in <span class='texttt'>u'y'</span>, <span class='texttt'>U'z'</span>, or
<span class='texttt'>L'x'</span>, respectively.
<span class='indexparent'><a class='index' id='literal,type_of_character'></a></span>A character literal that does not begin with <span class='texttt'>u</span>, <span class='texttt'>U</span>, or
<span class='texttt'>L</span> is an ordinary character literal, also referred to as a
narrow-character literal. An ordinary character literal that contains a
single <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> representable in the execution character
set has type <span class='texttt'>char</span>, with value equal to the
numerical value of the encoding of the <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> in the
execution character set. An ordinary character literal that contains
more than one <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> is a
<span class='indexparent'><a class='index' id='multicharacter_literal'></a></span><a class='hidden_link' href='#def:literal,multicharacter' id='def:literal,multicharacter'><i>multicharacter literal</i></a>.
A multicharacter literal, or an ordinary character literal containing
a single <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> not representable in the execution
character set, is conditionally-supported, has type <span class='texttt'>int</span>,
<span class='indexparent'><a class='index' id='literal,multicharacter,implementation-defined_value_of'></a></span>and has an <span class='indexparent'><a class='index' id='value_of_multicharacter_literal'></a></span>implementation-defined value.</p></div><div class='para' id='ccon-2'><div class='marginalizedparent'><a class='marginalized' href='#ccon-2'>2</a></div><p ><span class='indexparent'><a class='index' id='wide-character'></a></span><span class='indexparent'><a class='index' id='char16_t_character'></a></span><span class='indexparent'><a class='index' id='char32_t_character'></a></span><span class='indexparent'><a class='index' id='stddef.h'></a></span><span class='indexparent'><a class='index' id='wchar_t'></a></span><span class='indexparent'><a class='index' id='char16_t'></a></span><span class='indexparent'><a class='index' id='char32_t'></a></span>A character literal that begins with the letter <span class='texttt'>u</span>, such as
<span class='texttt'>u'y'</span>, is a character literal of type <span class='texttt'>char16_t</span>. The value
of a <span class='texttt'>char16_t</span> literal containing a single <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> is
equal to its ISO 10646 code point value, provided that the code point is
representable with a single 16-bit code unit. (That is, provided it is a
basic multi-lingual plane code point.) If the value is not representable
within 16 bits, the program is ill-formed. A <span class='texttt'>char16_t</span> literal
containing multiple <i ><a href='lex.ccon#nt:c-char'>c-chars</a></i> is ill-formed. A character
literal that begins with the letter <span class='texttt'>U</span>, such as <span class='texttt'>U'z'</span>, is
a character literal of type <span class='texttt'>char32_t</span>. The value of a
<span class='texttt'>char32_t</span> literal containing a single <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> is equal
to its ISO 10646 code point value. A <span class='texttt'>char32_t</span> literal containing
multiple <i ><a href='lex.ccon#nt:c-char'>c-chars</a></i> is ill-formed. A character literal that
begins with the letter <span class='texttt'>L</span>, such as <span class='texttt'>L'x'</span>,
<span class='indexparent'><a class='index' id='prefix,L'></a></span>is a wide-character literal. A wide-character literal has type
<span class='texttt'>wchar_t</span>.<a class='footnotenum' href='#footnote-23'>23</a>
The value of a wide-character literal containing a single
<i ><a href='lex.ccon#nt:c-char'>c-char</a></i> has value equal to the numerical value of the encoding
of the <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> in the execution wide-character set, unless the
<i ><a href='lex.ccon#nt:c-char'>c-char</a></i> has no representation in the execution wide-character set, in which
case the value is <span class='indexparent'><a class='index' id='value_of_wide-character_literal_with_single_c-char_that_is_not_in_execution_wide-character_set'></a></span>implementation-defined. [&nbsp;<i>Note:</i> The type <span class='texttt'>wchar_t</span> is able to
represent all members of the execution wide-character set (see <a href='basic.fundamental'>[basic.fundamental]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]. The value
of a wide-character literal containing multiple <i ><a href='lex.ccon#nt:c-char'>c-chars</a></i> is
<span class='indexparent'><a class='index' id='value_of_wide-character_literal_containing_multiple_characters'></a></span>implementation-defined.</p></div><div class='para' id='ccon-3'><div class='marginalizedparent'><a class='marginalized' href='#ccon-3'>3</a></div><p >Certain nongraphic characters, the single quote <span class='texttt'>'</span>, the double quote <span class='texttt'>"</span>,
the question mark <span class='texttt'>?</span>,<a class='footnotenum' href='#footnote-24'>24</a> and the backslash
<span class='indexparent'><a class='index' id='backslash_character'></a></span><span class='indexparent'><a class='index' id='\'></a></span><span class='indexparent'><a class='index' id='escape_character'></a></span><span class='texttt'>\</span>, can be represented according to
Table <a href='#tab:escape.sequences'>[tab:escape.sequences]</a>.
<span class='indexparent'><a class='index' id='escape_sequence,undefined'></a></span>The double quote <span class='texttt'>"</span>  and the question mark <span class='texttt'>?</span>, can be
represented as themselves or by the escape sequences
<span class='texttt'>\"</span> and <span class='texttt'>\?</span> respectively, but
the single quote <span class='texttt'>'</span> and the backslash <span class='texttt'>\</span>
shall be represented by the escape sequences <span class='texttt'>\'</span> and
<span class='texttt'>\\</span> respectively. Escape sequences in
which the character following the backslash is not listed in
Table <a href='#tab:escape.sequences'>[tab:escape.sequences]</a> are conditionally-supported, with <span class='indexparent'><a class='index' id='semantics_of_non-standard_escape_sequences'></a></span>implementation-defined semantics. An escape sequence specifies a single
character.</p><div class='numberedTable' id='tab:escape.sequences'>Table <a href='#tab:escape.sequences'>7</a> — Escape sequences<br><table ><tr class='rowsep'><td class='left'>



new-line        </td><td class='left'>   NL(LF)          </td><td class='left'>   <span class='texttt'>\n</span>                </td></tr><tr ><td class='left'>
horizontal tab  </td><td class='left'>   HT              </td><td class='left'>   <span class='texttt'>\t</span>                </td></tr><tr ><td class='left'>
vertical tab    </td><td class='left'>   VT              </td><td class='left'>   <span class='texttt'>\v</span>                </td></tr><tr ><td class='left'>
backspace       </td><td class='left'>   BS              </td><td class='left'>   <span class='texttt'>\b</span>                </td></tr><tr ><td class='left'>
carriage return </td><td class='left'>   CR              </td><td class='left'>   <span class='texttt'>\r</span>                </td></tr><tr ><td class='left'>
form feed       </td><td class='left'>   FF              </td><td class='left'>   <span class='texttt'>\f</span>                </td></tr><tr ><td class='left'>
alert           </td><td class='left'>   BEL             </td><td class='left'>   <span class='texttt'>\a</span>                </td></tr><tr ><td class='left'>
backslash       </td><td class='left'>   \  </td><td class='left'>   <span class='texttt'>\\</span>    </td></tr><tr ><td class='left'>
question mark   </td><td class='left'>   ?               </td><td class='left'>   <span class='texttt'>\?</span>                </td></tr><tr ><td class='left'>
single quote    </td><td class='left'>   <span class='texttt'>'</span>       </td><td class='left'>   <span class='texttt'>\<span class='texttt'>'</span></span>         </td></tr><tr ><td class='left'>
double quote    </td><td class='left'>   <span class='texttt'>"</span>       </td><td class='left'>   <span class='texttt'>\<span class='texttt'>"</span></span>         </td></tr><tr ><td class='left'>
octal number    </td><td class='left'>   <span class='textsl'>ooo</span>  </td><td class='left'>   <span class='texttt'>\<span class='textsl'>ooo</span></span>    </td></tr><tr ><td class='left'>
hex number      </td><td class='left'>   <span class='textsl'>hhh</span>  </td><td class='left'>   <span class='texttt'>\x<span class='textsl'>hhh</span></span>  </td></tr></table></div></div><div class='para' id='ccon-4'><div class='marginalizedparent'><a class='marginalized' href='#ccon-4'>4</a></div><p >The escape
<span class='indexparent'><a class='index' id='number,octal'></a></span><span class='texttt'>\<span class='textsl'>ooo</span></span> consists of the backslash followed by one,
two, or three octal digits that are taken to specify the value of the
desired character. The escape
<span class='indexparent'><a class='index' id='number,hex'></a></span><span class='texttt'>\x<span class='textsl'>hhh</span></span>
consists of the backslash followed by <span class='texttt'>x</span> followed by one or more
hexadecimal digits that are taken to specify the value of the desired
character. There is no limit to the number of digits in a hexadecimal
sequence. A sequence of octal or hexadecimal digits is terminated by the
first character that is not an octal digit or a hexadecimal digit,
respectively.
<span class='indexparent'><a class='index' id='literal,implementation-defined_value_of_char'></a></span>The value of a character literal is <span class='indexparent'><a class='index' id='value_of_character_literal_outside_range_of_corresponding_type'></a></span>implementation-defined if it falls outside of the implementation-defined range defined for
<span class='texttt'>char</span>
(for literals with no prefix), <span class='texttt'>char16_t</span> (for literals prefixed
by <span class='texttt'>'u'</span>), <span class='texttt'>char32_t</span> (for literals prefixed by
<span class='texttt'>'U'</span>), or <span class='texttt'>wchar_t</span> (for literals prefixed by <span class='texttt'>'L'</span>).</p></div><div class='para' id='ccon-5'><div class='marginalizedparent'><a class='marginalized' href='#ccon-5'>5</a></div><p >A universal-character-name is translated to the encoding, in the appropriate
execution character set, of the character named. If there is no such
encoding, the universal-character-name is translated to an
<span class='indexparent'><a class='index' id='encoding_of_universal_character_name_not_in_execution_character_set'></a></span>implementation-defined encoding.
[&nbsp;<i>Note:</i> In translation phase 1, a universal-character-name is introduced whenever an
actual extended
character is encountered in the source text. Therefore, all extended
characters are described in terms of universal-character-names. However,
the actual compiler implementation may use its own native character set,
so long as the same results are obtained. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-23'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-23'>23)</a></div><p >They are intended for character sets where a character does
not fit into a single byte. </p></div><div class='footnote' id='footnote-24'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-24'>24)</a></div><p >Using an escape sequence for a question mark can
avoid accidentally creating a trigraph.</p></div></div><div id='fcon'><h3 ><a class='secnum' href='#fcon' style='min-width:103pt'>2.14.4</a> Floating literals <a class='abbr_ref' href='lex.fcon'>[lex.fcon]</a></h3><p ><span class='indexparent'><a class='index' id='literal,floating'></a></span></p><pre class='bnf'><a id='nt:floating-literal'>floating-literal:</a>
    <i ><a href='lex.fcon#nt:fractional-constant'>fractional-constant</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.fcon#nt:floating-suffix'>floating-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i> <i ><a href='lex.fcon#nt:floating-suffix'>floating-suffix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:fractional-constant'>fractional-constant:</a>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>.</span> <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> <span class='terminal'>.</span></pre><pre class='bnf'><a id='nt:exponent-part'>exponent-part:</a>
    <span class='terminal'>e</span> <i ><a href='lex.fcon#nt:sign'>sign</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i>
    <span class='terminal'>E</span> <i ><a href='lex.fcon#nt:sign'>sign</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i></pre><pre class='bnf'><a id='nt:sign'>sign:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>+  -</span></pre><pre class='bnf'><a id='nt:digit-sequence'>digit-sequence:</a>
    <i ><a href='lex.name#nt:digit'>digit</a></i>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> <span class='terminal'>'</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:digit'>digit</a></i></pre><pre class='bnf'><a id='nt:floating-suffix'>floating-suffix:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>f  l  F  L</span></pre><div class='para' id='fcon-1'><div class='marginalizedparent'><a class='marginalized' href='#fcon-1'>1</a></div><p ><span class='indexparent'><a class='index' id='literal,floating'></a></span>A floating literal consists of an integer part, a decimal point, a
fraction part, an
<span class='indexparent'><a class='index' id='suffix,e'></a></span><span class='indexparent'><a class='index' id='suffix,E'></a></span><span class='texttt'>e</span> or <span class='texttt'>E</span>, an optionally signed integer exponent, and an
optional type suffix. The integer and fraction parts both consist of a
sequence of decimal (base ten) digits. Optional separating single quotes in a
<i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> are ignored when determining its value.
[&nbsp;<i>Example:</i> The literals <span class='texttt'>1.602'176'565e-19</span> and <span class='texttt'>1.602176565e-19</span>
have the same value. <i>&nbsp;—&nbsp;end example</i>&nbsp;]
Either the integer part or the
fraction part (not both) can be omitted; either the decimal point or the
letter <span class='texttt'>e</span> (or <span class='texttt'>E</span> ) and the exponent (not both) can be
omitted. The integer part, the optional decimal point and the optional
fraction part form the <a class='hidden_link' href='#def:significant_part' id='def:significant_part'><i>significant part</i></a> of the
floating literal. The exponent, if present, indicates the power of 10 by
which the significant part is to be scaled. If the scaled value is in
the range of representable values for its type, the result is the scaled
value if representable, else the larger or smaller representable value
nearest the scaled value, chosen in an <span class='indexparent'><a class='index' id='choice_of_larger_or_smaller_value_of_floating_literal'></a></span>implementation-defined manner.
<span class='indexparent'><a class='index' id='literal,double'></a></span>The type of a floating literal is <span class='texttt'>double</span>
<span class='indexparent'><a class='index' id='literal,type_of_floating_point'></a></span>unless explicitly specified by a suffix.
<span class='indexparent'><a class='index' id='literal,float'></a></span><span class='indexparent'><a class='index' id='suffix,F'></a></span><span class='indexparent'><a class='index' id='suffix,f'></a></span>The suffixes <span class='texttt'>f</span> and <span class='texttt'>F</span> specify <span class='texttt'>float</span>,
<span class='indexparent'><a class='index' id='suffix,L'></a></span><span class='indexparent'><a class='index' id='suffix,l'></a></span><span class='indexparent'><a class='index' id='literal,long_double'></a></span>the suffixes <span class='texttt'>l</span> and <span class='texttt'>L</span> specify <span class='texttt'>long</span>
<span class='texttt'>double</span>. If the scaled value is not in the range of representable
values for its type, the program is ill-formed.</p></div></div><div id='string'><h3 ><a class='secnum' href='#string' style='min-width:103pt'>2.14.5</a> String literals <a class='abbr_ref' href='lex.string'>[lex.string]</a></h3><p ><span class='indexparent'><a class='index' id='literal,string'></a></span></p><pre class='bnf'><a id='nt:string-literal'>string-literal:</a>
    <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>"</span> <i ><a href='lex.string#nt:s-char-sequence'>s-char-sequence</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>"</span>
    <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>R</span> <i ><a href='lex.string#nt:raw-string'>raw-string</a></i></pre><pre class='bnf'><a id='nt:encoding-prefix'>encoding-prefix:</a>
  <span class='terminal'>u8</span>
  <span class='terminal'>u</span>
  <span class='terminal'>U</span>
  <span class='terminal'>L</span></pre><pre class='bnf'><a id='nt:s-char-sequence'>s-char-sequence:</a>
    <i ><a href='lex.string#nt:s-char'>s-char</a></i>
    <i ><a href='lex.string#nt:s-char-sequence'>s-char-sequence</a></i> <i ><a href='lex.string#nt:s-char'>s-char</a></i></pre><pre class='bnf'><a id='nt:s-char'>s-char:</a>
&#9;<span class='textnormal'>any member of the source character set except</span>
&#9;&#9;<span class='textnormal'>the double-quote <span class='terminal'>"</span>, backslash <span class='terminal'>\</span>, or new-line character</span>
&#9;<i ><a href='lex.ccon#nt:escape-sequence'>escape-sequence</a></i>
&#9;<i ><a href='lex.charset#nt:universal-character-name'>universal-character-name</a></i></pre><pre class='bnf'><a id='nt:raw-string'>raw-string:</a>
    <span class='terminal'>"</span> <i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='lex.string#nt:r-char-sequence'>r-char-sequence</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span> <i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>"</span></pre><pre class='bnf'><a id='nt:r-char-sequence'>r-char-sequence:</a>
    <i ><a href='lex.string#nt:r-char'>r-char</a></i>
    <i ><a href='lex.string#nt:r-char-sequence'>r-char-sequence</a></i> <i ><a href='lex.string#nt:r-char'>r-char</a></i></pre><pre class='bnf'><a id='nt:r-char'>r-char:</a>
&#9;<span class='textnormal'>any member of the source character set, except</span>
&#9;&#9;<span class='textnormal'>a right parenthesis <span class='terminal'>)</span> followed by the initial <span class='small'></span><span class='rmfamily'></span><i> d-char-sequence</i></span>
&#9;&#9;<span class='textnormal'>(which may be empty) followed by a double quote <span class='terminal'>"</span>.</span></pre><pre class='bnf'><a id='nt:d-char-sequence'>d-char-sequence:</a>
    <i ><a href='lex.string#nt:d-char'>d-char</a></i>
    <i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i> <i ><a href='lex.string#nt:d-char'>d-char</a></i></pre><pre class='bnf'><a id='nt:d-char'>d-char:</a>
&#9;<span class='textnormal'>any member of the basic source character set except:</span>
&#9;&#9;<span class='textnormal'>space, the left parenthesis <span class='terminal'>(</span>, the right parenthesis <span class='terminal'>)</span>, the backslash <span class='terminal'>\</span>,</span>
&#9;&#9;<span class='textnormal'>and the control characters representing horizontal tab,</span>
&#9;&#9;<span class='textnormal'>vertical tab, form feed, and newline.</span></pre><div class='para' id='string-1'><div class='marginalizedparent'><a class='marginalized' href='#string-1'>1</a></div><p ><span class='indexparent'><a class='index' id='literal,string'></a></span><span class='indexparent'><a class='index' id='literal,string,narrow'></a></span><span class='indexparent'><a class='index' id='literal,string,wide'></a></span><span class='indexparent'><a class='index' id='literal,string,char16_t'></a></span><span class='indexparent'><a class='index' id='literal,string,char32_t'></a></span><span class='indexparent'><a class='index' id='character_string'></a></span>A string literal is a sequence of characters (as defined
in <a href='lex.ccon'>[lex.ccon]</a>) surrounded by double quotes, optionally prefixed by
<span class='texttt'>R</span>,
<span class='texttt'>u8</span>,
<span class='texttt'>u8R</span>,
<span class='texttt'>u</span>,
<span class='texttt'>uR</span>,
<span class='texttt'>U</span>,
<span class='texttt'>UR</span>,
<span class='texttt'>L</span>,
or <span class='texttt'>LR</span>,
as in
<span class='texttt'>"..."</span>,
<span class='texttt'>R"(...)"</span>,
<span class='texttt'>u8"..."</span>,
<span class='texttt'>u8R"**(...)**"</span>,
<span class='texttt'>u"..."</span>,
<span class='texttt'>uR"*~(...)*~"</span>,
<span class='texttt'>U"..."</span>,
<span class='texttt'>UR"zzz(...)zzz"</span>,
<span class='texttt'>L"..."</span>,
or <span class='texttt'>LR"(...)"</span>,
respectively.</p></div><div class='para' id='string-2'><div class='marginalizedparent'><a class='marginalized' href='#string-2'>2</a></div><p >A string literal that has an <span class='texttt'>R</span> in the prefix is a <a class='hidden_link' href='#def:raw_string_literal' id='def:raw_string_literal'><i>raw string literal</i></a>. The
<i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i> serves as a delimiter. The terminating
<i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i> of a <i ><a href='lex.string#nt:raw-string'>raw-string</a></i> is the same sequence of
characters as the initial <i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i>. A <i ><a href='lex.string#nt:d-char-sequence'>d-char-sequence</a></i>
shall consist of at most 16 characters.</p></div><div class='para' id='string-3'><div class='marginalizedparent'><a class='marginalized' href='#string-3'>3</a></div><p >[&nbsp;<i>Note:</i> The characters <span class='texttt'>'('</span> and <span class='texttt'>')'</span> are permitted in a
<i ><a href='lex.string#nt:raw-string'>raw-string</a></i>. Thus, <span class='texttt'>R"delimiter((a|b))delimiter"</span> is equivalent to
<span class='texttt'>"(a|b)"</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='string-4'><div class='marginalizedparent'><a class='marginalized' href='#string-4'>4</a></div><p >[&nbsp;<i>Note:</i> A source-file new-line in a raw string literal results in a new-line in the
resulting execution <a class='hidden_link' href='#def:string-literal' id='def:string-literal'><i>string-literal</i></a>. Assuming no
whitespace at the beginning of lines in the following example, the assert will succeed:</p><pre class='codeblock'>
const char* p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='string-5'><div class='marginalizedparent'><a class='marginalized' href='#string-5'>5</a></div><p >[&nbsp;<i>Example:</i> The raw string</p><pre class='codeblock'>
R"a(
)\
a"
)a"
</pre><p >is equivalent to <span class='texttt'>"\n)\\\na\"\n"</span>. The raw string</p><pre class='codeblock'>
R"(??)"
</pre><p >is equivalent to <span class='texttt'>"\?\?"</span>. The raw string</p><pre class='codeblock'>
R"#(
)??="
)#"
</pre><p >is equivalent to <span class='texttt'>"\n)\?\?=\"\n"</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-6'><div class='marginalizedparent'><a class='marginalized' href='#string-6'>6</a></div><p ><span class='indexparent'><a class='index' id='string,type_of'></a></span><span class='indexparent'><a class='index' id='literal,string,narrow'></a></span>After translation phase 6, a string literal that does not begin with an <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i> is an ordinary string literal, and is initialized with the given characters.</p></div><div class='para' id='string-7'><div class='marginalizedparent'><a class='marginalized' href='#string-7'>7</a></div><p >A string literal that begins with <span class='texttt'>u8</span>, such as <span class='texttt'>u8"asdf"</span>, is a UTF-8 string literal.</p></div><div class='para' id='string-8'><div class='marginalizedparent'><a class='marginalized' href='#string-8'>8</a></div><p >Ordinary string literals and UTF-8 string literals are
also referred to as narrow
string literals. A narrow string literal has type
<span class='indexparent'><a class='index' id='literal,string,type_of'></a></span>“array of <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> <span class='texttt'>const char</span>”, where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the size of
the string as defined below, and has static storage
duration (<a href='basic.stc'>[basic.stc]</a>).</p></div><div class='para' id='string-9'><div class='marginalizedparent'><a class='marginalized' href='#string-9'>9</a></div><p >For a UTF-8 string literal, each successive element of the object
representation (<a href='basic.types'>[basic.types]</a>) has the value of the corresponding
code unit of the UTF-8 encoding of the string.</p></div><div class='para' id='string-10'><div class='marginalizedparent'><a class='marginalized' href='#string-10'>10</a></div><p ><span class='indexparent'><a class='index' id='literal,string,char16_t'></a></span>A string literal that begins with <span class='texttt'>u</span>, such as <span class='texttt'>u"asdf"</span>, is
a <span class='texttt'>char16_t</span> string literal. A <span class='texttt'>char16_t</span> string literal has
type “array of <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> <span class='texttt'>const char16_t</span>”, where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the
size of the string as defined below; it has static storage duration and
is initialized with the given characters. A single <i ><a href='lex.ccon#nt:c-char'>c-char</a></i> may
produce more than one <span class='texttt'>char16_t</span> character in the form of
surrogate pairs.</p></div><div class='para' id='string-11'><div class='marginalizedparent'><a class='marginalized' href='#string-11'>11</a></div><p ><span class='indexparent'><a class='index' id='literal,string,char32_t'></a></span>A string literal that begins with <span class='texttt'>U</span>, such as <span class='texttt'>U"asdf"</span>, is
a <span class='texttt'>char32_t</span> string literal. A <span class='texttt'>char32_t</span> string literal has
type “array of <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> <span class='texttt'>const char32_t</span>”, where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the
size of the string as defined below; it has static storage duration and
is initialized with the given characters.</p></div><div class='para' id='string-12'><div class='marginalizedparent'><a class='marginalized' href='#string-12'>12</a></div><p ><span class='indexparent'><a class='index' id='literal,string,wide'></a></span>A string literal that begins with
<span class='texttt'>L</span>,
such as <span class='texttt'>L"asdf"</span>,
is a wide string literal.
<span class='indexparent'><a class='index' id='stddef.h'></a></span><span class='indexparent'><a class='index' id='wchar_t'></a></span><span class='indexparent'><a class='index' id='literal,string,wide'></a></span><span class='indexparent'><a class='index' id='prefix,L'></a></span>A wide string literal has type “array of <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> <span class='texttt'>const
wchar_t</span>”, where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the size of the string as defined below; it
has static storage duration and is initialized with the given
characters.</p></div><div class='para' id='string-13'><div class='marginalizedparent'><a class='marginalized' href='#string-13'>13</a></div><p ><span class='indexparent'><a class='index' id='literal,string,implementation-defined'></a></span><span class='indexparent'><a class='index' id='string,distinct'></a></span>Whether all string literals are distinct (that is, are stored in
nonoverlapping objects) is <span class='indexparent'><a class='index' id='distinctness_of_string_literals'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='literal,string,undefined_change_to'></a></span>The effect of attempting to modify a string literal is undefined.</p></div><div class='para' id='string-14'><div class='marginalizedparent'><a class='marginalized' href='#string-14'>14</a></div><p ><span class='indexparent'><a class='index' id='concatenation,string'></a></span>In translation phase 6 (<a href='lex.phases'>[lex.phases]</a>), adjacent string literals are concatenated. If
both string literals have the same <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i>, the resulting concatenated string literal has
that <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i>. If one string literal has no <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i>, it is treated as a string literal of
the same <i ><a href='lex.string#nt:encoding-prefix'>encoding-prefix</a></i> as the other operand. If a UTF-8 string literal token is adjacent to a
wide string literal token, the program is ill-formed. Any other concatenations are
conditionally-supported with <span class='indexparent'><a class='index' id='concatenation_of_some_types_of_string_literals'></a></span>implementation-defined
behavior. [&nbsp;<i>Note:</i> This
concatenation is an interpretation, not a conversion.
Because the interpretation happens in translation phase 6 (after each character from a
literal has been translated into a value from the appropriate character set), a string
literal's initial rawness has no effect on the interpretation or well-formedness of the
concatenation.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Table <a href='#tab:lex.string.concat'>[tab:lex.string.concat]</a> has some examples of valid concatenations.</p><div class='numberedTable' id='tab:lex.string.concat'>Table <a href='#tab:lex.string.concat'>8</a> — String literal concatenations<br><table ><tr class='rowsep'><td colspan='2' class='center'>Source</td><td class='left'>
Means </td><td colspan='2' class='border center'>Source</td><td class='left'>
Means </td><td colspan='2' class='border center'>Source</td><td class='left'>
Means </td></tr><tr ><td class='left'>
<span class='texttt'>u"a"</span> </td><td class='left'> <span class='texttt'>u"b"</span> </td><td class='left'> <span class='texttt'>u"ab"</span> </td><td class='border left'>
<span class='texttt'>U"a"</span> </td><td class='left'> <span class='texttt'>U"b"</span> </td><td class='left'> <span class='texttt'>U"ab"</span> </td><td class='border left'>
<span class='texttt'>L"a"</span> </td><td class='left'> <span class='texttt'>L"b"</span> </td><td class='left'> <span class='texttt'>L"ab"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>u"a"</span> </td><td class='left'> <span class='texttt'>"b"</span>  </td><td class='left'> <span class='texttt'>u"ab"</span> </td><td class='border left'>
<span class='texttt'>U"a"</span> </td><td class='left'> <span class='texttt'>"b"</span>  </td><td class='left'> <span class='texttt'>U"ab"</span> </td><td class='border left'>
<span class='texttt'>L"a"</span> </td><td class='left'> <span class='texttt'>"b"</span>  </td><td class='left'> <span class='texttt'>L"ab"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>"a"</span>  </td><td class='left'> <span class='texttt'>u"b"</span> </td><td class='left'> <span class='texttt'>u"ab"</span> </td><td class='border left'>
<span class='texttt'>"a"</span>  </td><td class='left'> <span class='texttt'>U"b"</span> </td><td class='left'> <span class='texttt'>U"ab"</span> </td><td class='border left'>
<span class='texttt'>"a"</span>  </td><td class='left'> <span class='texttt'>L"b"</span> </td><td class='left'> <span class='texttt'>L"ab"</span> </td></tr></table></div><p >Characters in concatenated strings are kept distinct.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
"\xA" "B"
</pre><p >contains the two characters <span class='texttt'>'\xA'</span> and <span class='texttt'>'B'</span>
after concatenation (and not the single hexadecimal character
<span class='texttt'>'\xAB'</span>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-15'><div class='marginalizedparent'><a class='marginalized' href='#string-15'>15</a></div><p ><span class='indexparent'><a class='index' id='0'></a></span><span class='indexparent'><a class='index' id='0,string_terminator'></a></span><span class='indexparent'><a class='index' id='0,null_character'></a></span>After any necessary concatenation, in translation phase
7 (<a href='lex.phases'>[lex.phases]</a>), <span class='texttt'>'\0'</span> is appended to every
string literal so that programs that scan a string can find its end.</p></div><div class='para' id='string-16'><div class='marginalizedparent'><a class='marginalized' href='#string-16'>16</a></div><p ><span class='indexparent'><a class='index' id='encoding,multibyte'></a></span>Escape sequences and universal-character-names in non-raw string literals
have the same meaning as in character literals (<a href='lex.ccon'>[lex.ccon]</a>), except that
the single quote <span class='texttt'>'</span> is representable either by itself or by the escape sequence
<span class='texttt'>\'</span>, and the double quote <span class='texttt'>"</span> shall be preceded by a
<span class='texttt'>\</span>.
<span class='indexparent'><a class='index' id='string,sizeof'></a></span>In a narrow string literal, a universal-character-name may map to more
than one <span class='texttt'>char</span> element due to <a class='hidden_link' href='#def:multibyte_encoding' id='def:multibyte_encoding'><i>multibyte encoding</i></a>. The
size of a <span class='texttt'>char32_t</span> or wide string literal is the total number of
escape sequences, universal-character-names, and other characters, plus
one for the terminating <span class='texttt'>U'\0'</span> or
<span class='texttt'>L'\0'</span>. The size of a <span class='texttt'>char16_t</span> string
literal is the total number of escape sequences,
universal-character-names, and other characters, plus one for each
character requiring a surrogate pair, plus one for the terminating
<span class='texttt'>u'\0'</span>. [&nbsp;<i>Note:</i> The size of a <span class='texttt'>char16_t</span>
string literal is the number of code units, not the number of
characters. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Within <span class='texttt'>char32_t</span> and <span class='texttt'>char16_t</span>
literals, any universal-character-names shall be within the range
<span class='texttt'>0x0</span> to <span class='texttt'>0x10FFFF</span>. The size of a narrow string literal is
the total number of escape sequences and other characters, plus at least
one for the multibyte encoding of each universal-character-name, plus
one for the terminating <span class='texttt'>'\0'</span>.</p></div></div><div id='bool'><h3 ><a class='secnum' href='#bool' style='min-width:103pt'>2.14.6</a> Boolean literals <a class='abbr_ref' href='lex.bool'>[lex.bool]</a></h3><p ><span class='indexparent'><a class='index' id='literal,boolean'></a></span></p><pre class='bnf'><a id='nt:boolean-literal'>boolean-literal:</a>
    <span class='terminal'>false</span>
    <span class='terminal'>true</span></pre><div class='para' id='bool-1'><div class='marginalizedparent'><a class='marginalized' href='#bool-1'>1</a></div><p ><span class='indexparent'><a class='index' id='Boolean_literal'></a></span>The Boolean literals are the keywords <span class='texttt'>false</span> and <span class='texttt'>true</span>.
Such literals are prvalues and have type <span class='texttt'>bool</span>.</p></div></div><div id='nullptr'><h3 ><a class='secnum' href='#nullptr' style='min-width:103pt'>2.14.7</a> Pointer literals <a class='abbr_ref' href='lex.nullptr'>[lex.nullptr]</a></h3><p ><span class='indexparent'><a class='index' id='literal,pointer'></a></span></p><pre class='bnf'><a id='nt:pointer-literal'>pointer-literal:</a>
    <span class='terminal'>nullptr</span></pre><div class='para' id='nullptr-1'><div class='marginalizedparent'><a class='marginalized' href='#nullptr-1'>1</a></div><p >The pointer literal is the keyword <span class='texttt'>nullptr</span>. It is a prvalue of type
<span class='texttt'>std::nullptr_t</span>.
[&nbsp;<i>Note:</i>
<span class='texttt'>std::nullptr_t</span> is a distinct type that is neither a pointer type nor a pointer
to member type; rather, a prvalue of this type is a null pointer constant and can be
converted to a null pointer value or null member pointer value. See <a href='conv.ptr'>[conv.ptr]</a>
and <a href='conv.mem'>[conv.mem]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='ext'><h3 ><a class='secnum' href='#ext' style='min-width:103pt'>2.14.8</a> User-defined literals <a class='abbr_ref' href='lex.ext'>[lex.ext]</a></h3><p ><span class='indexparent'><a class='index' id='literal,user_defined'></a></span></p><pre class='bnf'><a id='nt:user-defined-literal'>user-defined-literal:</a>
    <i ><a href='lex.ext#nt:user-defined-integer-literal'>user-defined-integer-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-floating-literal'>user-defined-floating-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i></pre><pre class='bnf'><a id='nt:user-defined-integer-literal'>user-defined-integer-literal:</a>
    <i ><a href='lex.icon#nt:decimal-literal'>decimal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:octal-literal'>octal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:hexadecimal-literal'>hexadecimal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:binary-literal'>binary-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-floating-literal'>user-defined-floating-literal:</a>
    <i ><a href='lex.fcon#nt:fractional-constant'>fractional-constant</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-string-literal'>user-defined-string-literal:</a>
    <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-character-literal'>user-defined-character-literal:</a>
    <i ><a href='lex.ccon#nt:character-literal'>character-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:ud-suffix'>ud-suffix:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='ext-1'><div class='marginalizedparent'><a class='marginalized' href='#ext-1'>1</a></div><p >If a token matches both <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> and another literal kind, it
is treated as the latter. [&nbsp;<i>Example:</i> <span class='texttt'>123_km</span>
is a <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i>, but <span class='texttt'>12LL</span> is an
<i ><a href='lex.icon#nt:integer-literal'>integer-literal</a></i>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]
The syntactic non-terminal preceding the <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> in a
<i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> is taken to be the longest sequence of
characters that could match that non-terminal.</p></div><div class='para' id='ext-2'><div class='marginalizedparent'><a class='marginalized' href='#ext-2'>2</a></div><p >A <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> is treated as a call to a literal operator or
literal operator template (<a href='over.literal'>[over.literal]</a>). To determine the form of this call for a
given <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> with <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>,
the <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> whose literal suffix identifier is <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a> is
looked up in the context of <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> using the rules for unqualified name
lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>). Let <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> be the set of declarations found by
this lookup. <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall not be empty.</p></div><div class='para' id='ext-3'><div class='marginalizedparent'><a class='marginalized' href='#ext-3'>3</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-integer-literal'>user-defined-integer-literal</a></i>, let <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> be the literal
without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator with
parameter type <span class='texttt'>unsigned long long</span>, the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of
the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a>ULL)
</pre><p >Otherwise, <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a raw literal operator or a literal operator
template (<a href='over.literal'>[over.literal]</a>) but not both. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a raw literal operator,
the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>("<span class='term'>n"</span>)
</pre><p >Otherwise (<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator template), <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>&lt;'<span class='math'><span class='mathalpha'>c</span><sub >1</sub></span>', '<span class='math'><span class='mathalpha'>c</span><sub >2</sub></span>', ... '<span class='math'><span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>'&gt;()
</pre><p >where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the source character sequence <span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>. [&nbsp;<i>Note:</i> The sequence
<span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span> can only contain characters from the basic source character set.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='ext-4'><div class='marginalizedparent'><a class='marginalized' href='#ext-4'>4</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-floating-literal'>user-defined-floating-literal</a></i>, let <a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator
with parameter type <span class='texttt'>long double</span>, the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of
the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a>L)
</pre><p >Otherwise, <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a raw literal operator or a literal operator
template (<a href='over.literal'>[over.literal]</a>) but not both. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a raw literal operator,
the <a class='hidden_link' href='#def:literal' id='def:literal'><i>literal</i></a> <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>("<span class='term'>f"</span>)
</pre><p >Otherwise (<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator template), <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>&lt;'<span class='math'><span class='mathalpha'>c</span><sub >1</sub></span>', '<span class='math'><span class='mathalpha'>c</span><sub >2</sub></span>', ... '<span class='math'><span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>'&gt;()
</pre><p >where <a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a> is the source character sequence <span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>. [&nbsp;<i>Note:</i> The sequence
<span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span> can only contain characters from the basic source character set.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='ext-5'><div class='marginalizedparent'><a class='marginalized' href='#ext-5'>5</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>, let <a class='hidden_link' href='#def:str' id='def:str'><i>str</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> and let <a class='hidden_link' href='#def:len' id='def:len'><i>len</i></a> be
the number of
code units in <a class='hidden_link' href='#def:str' id='def:str'><i>str</i></a> (i.e., its length excluding the terminating
null character).
 The literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<span class='term'>str</span>, <span class='term'>len</span>)
</pre></div><div class='para' id='ext-6'><div class='marginalizedparent'><a class='marginalized' href='#ext-6'>6</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i>, let <a class='hidden_link' href='#def:ch' id='def:ch'><i>ch</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>.
<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a literal operator (<a href='over.literal'>[over.literal]</a>) whose only parameter has
the type of <a class='hidden_link' href='#def:ch' id='def:ch'><i>ch</i></a> and the
literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<span class='term'>ch</span>)
</pre></div><div class='para' id='ext-7'><div class='marginalizedparent'><a class='marginalized' href='#ext-7'>7</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
long double operator "" _w(long double);
std::string operator "" _w(const char16_t*, std::size_t);
unsigned operator "" _w(const char*);
int main() {
  1.2_w;      <span class='comment'>// calls <span class='texttt'>operator "" _w(1.2L)</span>
</span>  u"one"_w;   <span class='comment'>// calls <span class='texttt'>operator "" _w(u"one", 3)</span>
</span>  12_w;       <span class='comment'>// calls <span class='texttt'>operator "" _w("12")</span>
</span>  "two"_w;    <span class='comment'>// error: no applicable literal operator
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ext-8'><div class='marginalizedparent'><a class='marginalized' href='#ext-8'>8</a></div><p >In translation phase 6 (<a href='lex.phases'>[lex.phases]</a>), adjacent string literals are concatenated and
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literals</a></i> are considered string literals for that
purpose. During concatenation, <i ><a href='lex.ext#nt:ud-suffix'>ud-suffixes</a></i> are removed and ignored and
the concatenation process occurs as described in <a href='lex.string'>[lex.string]</a>. At the end of phase
6, if a string literal is the result of a concatenation involving at least one
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>, all the participating
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literals</a></i> shall have the same <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
and that suffix is applied to the result of the concatenation.</p></div><div class='para' id='ext-9'><div class='marginalizedparent'><a class='marginalized' href='#ext-9'>9</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int main() {
  L"A" "B" "C"_x; <span class='comment'>// OK: same as <span class='texttt'>L"ABC"_x</span>
</span>  "P"_x "Q" "R"_y;<span class='comment'>// error: two different <span class='grammarterm'>ud-suffixes</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div><div class='para' id='ext-10'><div class='marginalizedparent'><a class='marginalized' href='#ext-10'>10</a></div><p >Some <i ><a href='lex.name#nt:identifier'>identifiers</a></i> appearing as <i ><a href='lex.ext#nt:ud-suffix'>ud-suffixes</a></i> are
reserved for future standardization (<a href='usrlit.suffix'>[usrlit.suffix]</a>). A program containing
such a <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> is ill-formed, no diagnostic required.
<span class='indexparent'><a class='index' id='literal'></a></span><span class='indexparent'><a class='index' id='conventions,lexical'></a></span>
</p></div></div></div></div></div></body></html>