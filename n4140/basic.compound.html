<!DOCTYPE html><html lang='en'><head><title>[basic.compound]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.9</a> Types <a class='abbr_ref' href='basic.types#basic.compound'>[basic.types]</a></h2><div id='basic.compound'><h3 ><a class='secnum' style='min-width:103pt'>3.9.2</a> Compound types <a class='abbr_ref'>[basic.compound]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='type,compound'></a></span>Compound types can be constructed in the following ways:</p><ul ><li ><p ><span class='indexparent'><a class='index' id='type,array'></a></span><a class='hidden_link' href='#def:arrays' id='def:arrays'><i>arrays</i></a> of objects of a given type, <a href='dcl.array'>[dcl.array]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='type,function'></a></span><a class='hidden_link' href='#def:functions' id='def:functions'><i>functions</i></a>, which have parameters of given types and return
<span class='texttt'>void</span> or references or objects of a given type, <a href='dcl.fct'>[dcl.fct]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='type,pointer'></a></span><a class='hidden_link' href='#def:pointers' id='def:pointers'><i>pointers</i></a> to <span class='texttt'>void</span> or objects or functions (including
static members of classes) of a given type, <a href='dcl.ptr'>[dcl.ptr]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='reference'></a></span><span class='indexparent'><a class='index' id='reference,lvalue'></a></span><span class='indexparent'><a class='index' id='reference,rvalue'></a></span><span class='indexparent'><a class='index' id='lvalue_reference'></a></span><span class='indexparent'><a class='index' id='rvalue_reference'></a></span><a class='hidden_link' href='#def:references' id='def:references'><i>references</i></a> to objects or functions of a given
type, <a href='dcl.ref'>[dcl.ref]</a>. There are two types of references:
</p><ul ><li ><p ><a class='hidden_link' href='#def:lvalue_reference' id='def:lvalue_reference'><i>lvalue reference</i></a>
</p></li><li ><p ><a class='hidden_link' href='#def:rvalue_reference' id='def:rvalue_reference'><i>rvalue reference</i></a>
</p></li></ul></li><li ><p ><span class='indexparent'><a class='index' id='class'></a></span><a class='hidden_link' href='#def:classes' id='def:classes'><i>classes</i></a> containing a sequence of objects of various types
(Clause <a href='class'>[class]</a>), a set of types, enumerations and functions for
manipulating these objects (<a href='class.mfct'>[class.mfct]</a>), and a set of restrictions
on the access to these entities (Clause <a href='class.access'>[class.access]</a>);</p></li><li ><p ><span class='indexparent'><a class='index' id='union'></a></span><a class='hidden_link' href='#def:unions' id='def:unions'><i>unions</i></a>, which are classes capable of containing objects of
different types at different times, <a href='class.union'>[class.union]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='enum'></a></span><a class='hidden_link' href='#def:enumerations' id='def:enumerations'><i>enumerations</i></a>, which comprise a set of named constant values.
Each distinct enumeration constitutes a different
<span class='indexparent'><a class='index' id='type,enumerated'></a></span><a class='hidden_link' href='#def:enumerated_type' id='def:enumerated_type'><i>enumerated type</i></a>, <a href='dcl.enum'>[dcl.enum]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='member_pointer_to'></a></span><span class='indexparent'><a class='index' id='pointer_to_member'></a></span><a class='hidden_link' href='#def:pointers_to_non-static' id='def:pointers_to_non-static'><i>pointers to non-static</i></a>
<a class='footnotenum' href='#footnote-52'>52</a>
<a class='hidden_link' href='#def:class_members' id='def:class_members'><i>class members</i></a>, which identify members of a given
type within objects of a given class, <a href='dcl.mptr'>[dcl.mptr]</a>.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >These methods of constructing types can be applied recursively;
restrictions are mentioned in <a href='dcl.ptr'>[dcl.ptr]</a>, <a href='dcl.array'>[dcl.array]</a>,
<a href='dcl.fct'>[dcl.fct]</a>, and <a href='dcl.ref'>[dcl.ref]</a>. Constructing a type such that the number of
bytes in its object representation exceeds the maximum value representable in
the type <span class='texttt'>std::size_t</span> (<a href='support.types'>[support.types]</a>) is ill-formed.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='terminology,pointer'></a></span>The type of a pointer to <span class='texttt'>void</span> or a pointer to an object type is
called an <a class='hidden_link' href='#def:object_pointer_type' id='def:object_pointer_type'><i>object pointer type</i></a>. [&nbsp;<i>Note:</i> A pointer to <span class='texttt'>void</span>
does not have a pointer-to-object type, however, because <span class='texttt'>void</span> is not
an object type. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The type of a pointer that can designate a function
is called a <a class='hidden_link' href='#def:function_pointer_type' id='def:function_pointer_type'><i>function pointer type</i></a>.
A pointer to objects of type <span class='texttt'>T</span> is referred to as a “pointer to
<span class='texttt'>T</span>.” [&nbsp;<i>Example:</i> a pointer to an object of type <span class='texttt'>int</span> is
referred to as “pointer to <span class='texttt'>int</span> ” and a pointer to an object of
class <span class='texttt'>X</span> is called a “pointer to <span class='texttt'>X</span>.” <i>&nbsp;—&nbsp;end example</i>&nbsp;]
Except for pointers to static members, text referring to “pointers”
does not apply to pointers to members. Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them (<a href='basic.align'>[basic.align]</a>).
<span class='indexparent'><a class='index' id='address'></a></span>A valid value of an object
pointer type represents either the address of a byte in
memory (<a href='intro.memory'>[intro.memory]</a>) or a null pointer (<a href='conv.ptr'>[conv.ptr]</a>). If an
object of type <span class='texttt'>T</span> is located at an address <span class='texttt'>A</span>, a pointer
of type <a class='hidden_link' href='#def:cv' id='def:cv'><i>cv</i></a> <span class='texttt'>T*</span> whose value is the address <span class='texttt'>A</span> is
said to <a class='hidden_link' href='#def:point_to' id='def:point_to'><i>point to</i></a> that object, regardless of how the value was
obtained. [&nbsp;<i>Note:</i> For instance, the address one past the end of an
array (<a href='expr.add'>[expr.add]</a>) would be considered to point to an unrelated
object of the array's element type that might be located at that
address. There are further restrictions on pointers to objects with dynamic storage
duration; see <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The value representation of
pointer types is <span class='indexparent'><a class='index' id='value_representation_of_pointer_types'></a></span>implementation-defined. Pointers to
cv-qualified and cv-unqualified
versions (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) of layout-compatible types shall
have the same value representation and alignment
requirements (<a href='basic.align'>[basic.align]</a>).
[&nbsp;<i>Note:</i> Pointers to over-aligned types (<a href='basic.align'>[basic.align]</a>) have no special
representation, but their range of valid values is restricted by the extended
alignment requirement. This International Standard specifies only two ways
of obtaining such a pointer: taking the address of a valid object with
an over-aligned type, and using one of the runtime pointer alignment functions.
An implementation may provide other means of obtaining a valid pointer value
for an over-aligned type.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='pointer'></a></span><span class='indexparent'><a class='index' id='void*,type'></a></span>A pointer to <i>cv</i>-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) or <i>cv</i>-unqualified
<span class='texttt'>void</span>
can be used to point to objects of
unknown type. Such a pointer shall be able to hold any object pointer.
An object of type <i>cv</i>
<span class='texttt'>void*</span> shall have the same representation and alignment
requirements as <i>cv</i> <span class='texttt'>char*</span>.</p></div><div class='footnote' id='footnote-52'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-52'>52)</a></div><p >Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions.</p></div></div></div></body></html>