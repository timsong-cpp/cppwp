<!DOCTYPE html><html lang='en'><head><title>[utilities]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='utilities'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>20.1</a> General <a class='abbr_ref' href='utilities.general'>[utilities.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes utilities that are generally useful in C++ programs; some
of these utilities are used by other elements of the C++ standard library.
These utilities are summarized in Table <a href='#tab:util.lib.summary'>[tab:util.lib.summary]</a>.</p><div class='numberedTable' id='tab:util.lib.summary'>Table <a href='#tab:util.lib.summary'>44</a> — General utilities library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='utility'>[utility]</a>               </td><td class='left'> Utility components                </td><td class='left'> <span class='texttt'>&lt;utility&gt;</span>     </td></tr><tr class='rowsep'><td class='left'> 
<a href='pairs'>[pairs]</a>                 </td><td class='left'> Pairs                             </td><td class='left'> <span class='texttt'>&lt;utility&gt;</span>     </td></tr><tr class='rowsep'><td class='left'> 
<a href='tuple'>[tuple]</a>                 </td><td class='left'> Tuples                            </td><td class='left'> <span class='texttt'>&lt;tuple&gt;</span>       </td></tr><tr class='rowsep'><td class='left'> 
<a href='intseq'>[intseq]</a>                </td><td class='left'> Compile-time integer sequences    </td><td class='left'> <span class='texttt'>&lt;utility&gt;</span>     </td></tr><tr class='rowsep'><td class='left'> 
<a href='template.bitset'>[template.bitset]</a>       </td><td class='left'> Fixed-size sequences of bits      </td><td class='left'> <span class='texttt'>&lt;bitset&gt;</span>      </td></tr><tr class='rowsep'><td class='left'> 
                            </td><td class='left'>                                   </td><td class='left'> <span class='texttt'>&lt;memory&gt;</span>      </td></tr><tr ><td class='left'>
<a href='memory'>[memory]</a>                </td><td class='left'> Memory                            </td><td class='left'> <span class='texttt'>&lt;cstdlib&gt;</span>     </td></tr><tr ><td class='left'>
                            </td><td class='left'>                                   </td><td class='left'> <span class='texttt'>&lt;cstring&gt;</span>     </td></tr><tr class='rowsep'><td class='left'> 
<a href='smartptr'>[smartptr]</a>              </td><td class='left'> Smart pointers                    </td><td class='left'> <span class='texttt'>&lt;memory&gt;</span>      </td></tr><tr class='rowsep'><td class='left'> 
<a href='function.objects'>[function.objects]</a>      </td><td class='left'> Function objects                  </td><td class='left'> <span class='texttt'>&lt;functional&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> 
<a href='meta'>[meta]</a>                  </td><td class='left'> Type traits                       </td><td class='left'> <span class='texttt'>&lt;type_traits&gt;</span> </td></tr><tr class='rowsep'><td class='left'> 
<a href='ratio'>[ratio]</a>                 </td><td class='left'> Compile-time rational arithmetic  </td><td class='left'> <span class='texttt'>&lt;ratio&gt;</span>       </td></tr><tr class='rowsep'><td class='left'> 
<a href='time'>[time]</a>                  </td><td class='left'> Time utilities                    </td><td class='left'> <span class='texttt'>&lt;chrono&gt;</span>      </td></tr><tr ><td class='left'>
                            </td><td class='left'>                                   </td><td class='left'> <span class='texttt'>&lt;ctime&gt;</span>       </td></tr><tr class='rowsep'><td class='left'> 
<a href='allocator.adaptor'>[allocator.adaptor]</a>     </td><td class='left'> Scoped allocators                 </td><td class='left'> <span class='texttt'>&lt;scoped_allocator&gt;</span> </td></tr><tr class='rowsep'><td class='left'> 
<a href='type.index'>[type.index]</a>            </td><td class='left'> Type indexes                      </td><td class='left'> <span class='texttt'>&lt;typeindex&gt;</span>   </td></tr></table></div></div></div><div id='utility'><h2 ><a class='secnum' href='#utility' style='min-width:88pt'>20.2</a> Utility components <a class='abbr_ref' href='utility'>[utility]</a></h2><div class='para' id='utility-1'><div class='marginalizedparent'><a class='marginalized' href='#utility-1'>1</a></div><p >This subclause contains some basic function and class templates that are used
throughout the rest of the library.</p><p ><span class='indexparent'><a class='index' id='utility'></a></span><span class='indexparent'><a class='index' id='rel_ops'></a></span><b>Header <span class='texttt'>&lt;utility&gt;</span> synopsis</b></p></div><div class='para' id='utility-2'><div class='marginalizedparent'><a class='marginalized' href='#utility-2'>2</a></div><p >The header <span class='texttt'>&lt;utility&gt;</span> defines several types and function templates
that are described in this Clause. It also defines the template <span class='texttt'>pair</span>
and various function templates that operate on <span class='texttt'>pair</span> objects.</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='operators'>[operators]</a>, operators:
</span>  namespace rel_ops {
    template&lt;class T&gt; bool operator!=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt; (const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&lt;=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt;=(const T&amp;, const T&amp;);
  }

  <span class='comment'>// <a href='utility.swap'>[utility.swap]</a>, swap:
</span>  template&lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
  template &lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));

  <span class='comment'>// <a href='utility.exchange'>[utility.exchange]</a>, exchange:
</span>  template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);

  <span class='comment'>// <a href='forward'>[forward]</a>, forward/move:
</span>  template &lt;class T&gt; 
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp;) noexcept;
  template &lt;class T&gt;
    constexpr conditional_t&lt;
    !is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value,
    const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;

  <span class='comment'>// <a href='declval'>[declval]</a>, declval:
</span>  template &lt;class T&gt;
    add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span>
  <span class='comment'>// <a href='pairs'>[pairs]</a>, pairs:
</span>  template &lt;class T1, class T2&gt; struct pair;

  <span class='comment'>// <a href='pairs.spec'>[pairs.spec]</a>, pair specialized algorithms:
</span>  template &lt;class T1, class T2&gt;
    constexpr bool operator==(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt; (const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator!=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt; (const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt;=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt;=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    void swap(pair&lt;T1,T2&gt;&amp; x, pair&lt;T1,T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));
  template &lt;class T1, class T2&gt;
    constexpr <i><span class='texttt'>see below</span></i> make_pair(T1&amp;&amp;, T2&amp;&amp;);

  <span class='comment'>// <a href='pair.astuple'>[pair.astuple]</a>, tuple-like access to pair:
</span>  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;

  template &lt;class T1, class T2&gt; struct tuple_size&lt;pair&lt;T1, T2&gt; &gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;0, pair&lt;T1, T2&gt; &gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;1, pair&lt;T1, T2&gt; &gt;;

  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
      get(pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(const pair&lt;T1, T2&gt;&amp;) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;T, U&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;U, T&gt;&amp;&amp; p) noexcept;

  <span class='comment'>// <a href='pair.piecewise'>[pair.piecewise]</a>, pair piecewise construction
</span>  struct piecewise_construct_t { };
  constexpr piecewise_construct_t piecewise_construct{};
  template &lt;class... Types&gt; class tuple;  <span class='comment'>// defined in <span class='texttt'>&lt;tuple&gt;</span>
</span>
<span class='indexparent'><a class='index' id='index_sequence'></a></span><span class='indexparent'><a class='index' id='make_index_sequence'></a></span><span class='indexparent'><a class='index' id='index_sequence_for'></a></span>
  <span class='comment'>// <a href='intseq'>[intseq]</a>, Compile-time integer sequences
</span>  template&lt;class T, T...&gt; struct integer_sequence;
  template&lt;size_t... I&gt;
    using index_sequence = integer_sequence&lt;size_t, I...&gt;;

  template&lt;class T, T N&gt;
    using make_integer_sequence = integer_sequence&lt;T, <i><span class='texttt'>see below</span></i>&gt;;
  template&lt;size_t N&gt;
    using make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;

  template&lt;class... T&gt;
    using index_sequence_for = make_index_sequence&lt;sizeof...(T)&gt;;
}
</pre></div><div id='operators'><h3 ><a class='secnum' href='#operators' style='min-width:103pt'>20.2.1</a> Operators <a class='abbr_ref' href='operators'>[operators]</a></h3><div class='para' id='operators-1'><div class='marginalizedparent'><a class='marginalized' href='#operators-1'>1</a></div><p >To avoid redundant definitions of <span class='texttt'>operator!=</span> out of <span class='texttt'>operator==</span>
and operators <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, and <span class='texttt'>&gt;=</span> out of <span class='texttt'>operator&lt;</span>,
the library provides the following:</p><p ><span class='indexparent'><a class='index' id='operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator!=(const T&amp; x, const T&amp; y);
</code></p></div><div class='itemdescr'></div><div class='para' id='operators-2'><div class='marginalizedparent'><a class='marginalized' href='#operators-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>EqualityComparable</span> (Table <a href='equalitycomparable'>[equalitycomparable]</a>).</p></div></div><div class='para' id='operators-3'><div class='marginalizedparent'><a class='marginalized' href='#operators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-4'><div class='marginalizedparent'><a class='marginalized' href='#operators-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-5'><div class='marginalizedparent'><a class='marginalized' href='#operators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>y &lt; x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&lt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-6'><div class='marginalizedparent'><a class='marginalized' href='#operators-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-7'><div class='marginalizedparent'><a class='marginalized' href='#operators-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(y &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-8'><div class='marginalizedparent'><a class='marginalized' href='#operators-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-9'><div class='marginalizedparent'><a class='marginalized' href='#operators-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x &lt; y)</span>.
</p></div></div><div class='para' id='operators-10'><div class='marginalizedparent'><a class='marginalized' href='#operators-10'>10</a></div><p >In this library, whenever a declaration is provided for an <span class='texttt'>operator!=</span>,
<span class='texttt'>operator&gt;</span>, <span class='texttt'>operator&gt;=</span>, or <span class='texttt'>operator&lt;=</span>,
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this Clause.</p></div></div><div id='utility.swap'><h3 ><a class='secnum' href='#utility.swap' style='min-width:103pt'>20.2.2</a> swap <a class='abbr_ref' href='utility.swap'>[utility.swap]</a></h3><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template&lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='utility.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#utility.swap-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_nothrow_move_assignable&lt;T&gt;::value
</pre></div></div><div class='para' id='utility.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#utility.swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type
<span class='texttt'>T</span>
shall be
<span class='texttt'>MoveConstructible</span> (Table <a href='moveconstructible'>[moveconstructible]</a>)
and
<span class='texttt'>MoveAssignable</span> (Table <a href='moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='utility.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#utility.swap-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges values stored in two locations.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template&lt;class T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));
</code></p><div class='itemdescr'></div><div class='para' id='utility.swap-4'><div class='marginalizedparent'><a class='marginalized' href='#utility.swap-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>a[i]</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>) <span class='texttt'>b[i]</span>
for all <span class='texttt'>i</span> in the range <span class='texttt'>[<span class='discretionary'></span>0,<span class='discretionary'></span>N<span class='discretionary'></span>)</span>.</p></div></div><div class='para' id='utility.swap-5'><div class='marginalizedparent'><a class='marginalized' href='#utility.swap-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>swap_ranges(a, a + N, b)</span>
</p></div></div></div><div id='utility.exchange'><h3 ><a class='secnum' href='#utility.exchange' style='min-width:103pt'>20.2.3</a> exchange <a class='abbr_ref' href='utility.exchange'>[utility.exchange]</a></h3><p ><code class='itemdecl'>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</code></p><div class='itemdescr'></div><div class='para' id='utility.exchange-1'><div class='marginalizedparent'><a class='marginalized' href='#utility.exchange-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to:</p><pre class='codeblock'>
T old_val = std::move(obj);
obj = std::forward&lt;U&gt;(new_val);
return old_val;
</pre></div></div></div><div id='forward'><h3 ><a class='secnum' href='#forward' style='min-width:103pt'>20.2.4</a> forward/move helpers <a class='abbr_ref' href='forward'>[forward]</a></h3><div class='para' id='forward-1'><div class='marginalizedparent'><a class='marginalized' href='#forward-1'>1</a></div><p >The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.</p><p ><span class='indexparent'><a class='index' id='forward'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='forward-2'><div class='marginalizedparent'><a class='marginalized' href='#forward-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;T&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-3'><div class='marginalizedparent'><a class='marginalized' href='#forward-3'>3</a></div><div class='itemdescr'><p ><i>Remark:</i> If the second form is instantiated with an lvalue reference type, the program is ill-formed.</p></div></div><div class='para' id='forward-4'><div class='marginalizedparent'><a class='marginalized' href='#forward-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1, class A2&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1, A2&amp;&amp; a2) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2)));
}

struct A {
  A(int&amp;, const double&amp;);
};

void g() {
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(2, 1.414); <span class='comment'>// error: 2 will not bind to <span class='texttt'>int&amp;</span>
</span>  int i = 2;
  shared_ptr&lt;A&gt; sp2 = factory&lt;A&gt;(i, 1.414); <span class='comment'>// OK
</span>}
</pre></div></div><div class='para' id='forward-5'><div class='marginalizedparent'><a class='marginalized' href='#forward-5'>5</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int</span>, so 2 is forwarded
to <span class='texttt'>A</span>'s constructor as an rvalue.
In the second call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int&amp;</span>, so <span class='texttt'>i</span> is forwarded
to <span class='texttt'>A</span>'s constructor as an lvalue. In
both cases, <span class='texttt'>A2</span> is deduced as <span class='texttt'>double</span>, so
1.414 is forwarded to <span class='texttt'>A</span>'s constructor as an rvalue.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-6'><div class='marginalizedparent'><a class='marginalized' href='#forward-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-7'><div class='marginalizedparent'><a class='marginalized' href='#forward-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1)));
}

struct A {
  A();
  A(const A&amp;);  <span class='comment'>// copies from lvalues
</span>  A(A&amp;&amp;);       <span class='comment'>// moves from rvalues
</span>};

void g() {
  A a;
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(a);              <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(const A&amp;)</span>
</span>  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(std::move(a));   <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(A&amp;&amp;)</span>
</span>}
</pre></div></div><div class='para' id='forward-8'><div class='marginalizedparent'><a class='marginalized' href='#forward-8'>8</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A&amp;</span>, so <span class='texttt'>a</span> is forwarded
as a non-const lvalue. This binds to the constructor <span class='texttt'>A(const A&amp;)</span>,
which copies the value from <span class='texttt'>a</span>.
In the second call to <span class='texttt'>factory</span>, because of the call
<span class='texttt'>std::move(a)</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A</span>, so <span class='texttt'>a</span> is forwarded
as an rvalue. This binds to the constructor <span class='texttt'>A(A&amp;&amp;)</span>,
which moves the value from <span class='texttt'>a</span>.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move_if_noexcept'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr conditional_t&lt;
  !is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value,
  const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-9'><div class='marginalizedparent'><a class='marginalized' href='#forward-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(x)</span>
</p></div></div></div><div id='declval'><h3 ><a class='secnum' href='#declval' style='min-width:103pt'>20.2.5</a> Function template <span class='texttt'>declval</span> <a class='abbr_ref' href='declval'>[declval]</a></h3><div class='para' id='declval-1'><div class='marginalizedparent'><a class='marginalized' href='#declval-1'>1</a></div><p >The library provides the function template <span class='texttt'>declval</span> to simplify the definition of
expressions which occur as unevaluated operands (Clause <a href='expr'>[expr]</a>).</p><p ><span class='indexparent'><a class='index' id='declval'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span></code></p></div><div class='itemdescr'></div><div class='para' id='declval-2'><div class='marginalizedparent'><a class='marginalized' href='#declval-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>), the program is ill-formed.</p></div></div><div class='para' id='declval-3'><div class='marginalizedparent'><a class='marginalized' href='#declval-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> The template parameter <span class='texttt'>T</span> of <span class='texttt'>declval</span> may be an incomplete type.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class To, class From&gt;
  decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</pre><p >declares a function template <span class='texttt'>convert</span> which only participates in overloading if the
type <span class='texttt'>From</span> can be explicitly converted to type <span class='texttt'>To</span>. For another example see class
template <span class='texttt'>common_type</span> (<a href='meta.trans.other'>[meta.trans.other]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div></div><div id='pairs'><h2 ><a class='secnum' href='#pairs' style='min-width:88pt'>20.3</a> Pairs <a class='abbr_ref' href='pairs'>[pairs]</a></h2><div id='pairs.general'><h3 ><a class='secnum' href='#pairs.general' style='min-width:103pt'>20.3.1</a> In general <a class='abbr_ref' href='pairs.general'>[pairs.general]</a></h3><div class='para' id='pairs.general-1'><div class='marginalizedparent'><a class='marginalized' href='#pairs.general-1'>1</a></div><p >The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to <span class='texttt'>pair</span>
objects as if they were <span class='texttt'>tuple</span> objects (see <a href='tuple.helper'>[tuple.helper]</a>
and <a href='tuple.elem'>[tuple.elem]</a>).<span class='indexparent'><a class='index' id='pair'></a></span><span class='indexparent'><a class='index' id='pair,tuple_interface_to'></a></span><span class='indexparent'><a class='index' id='tuple,and_pair'></a></span>
</p></div></div><div id='pairs.pair'><h3 ><a class='secnum' href='#pairs.pair' style='min-width:103pt'>20.3.2</a> Class template <span class='texttt'>pair</span> <a class='abbr_ref' href='pairs.pair'>[pairs.pair]</a></h3><p ><span class='indexparent'><a class='index' id='pair'></a></span></p><pre class='codeblock'>
<span class='comment'>// defined in header <span class='texttt'>&lt;utility&gt;</span>
</span>
namespace std {
  template &lt;class T1, class T2&gt;
  struct pair {
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;
    pair(const pair&amp;) = default;
    pair(pair&amp;&amp;) = default;
    constexpr pair();
    constexpr pair(const T1&amp; x, const T2&amp; y);
    template&lt;class U, class V&gt; constexpr pair(U&amp;&amp; x, V&amp;&amp; y);
    template&lt;class U, class V&gt; constexpr pair(const pair&lt;U, V&gt;&amp; p);
    template&lt;class U, class V&gt; constexpr pair(pair&lt;U, V&gt;&amp;&amp; p);
    template &lt;class... Args1, class... Args2&gt;
      pair(piecewise_construct_t,
           tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);

    pair&amp; operator=(const pair&amp; p);
    template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
    pair&amp; operator=(pair&amp;&amp; p) noexcept(<i><span class='texttt'>see below</span></i>);
    template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);

    void swap(pair&amp; p) noexcept(<i><span class='texttt'>see below</span></i>);
  };
}
</pre><div class='para' id='pairs.pair-1'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-1'>1</a></div><p >Constructors and member functions of <span class='texttt'>pair</span> shall not throw exceptions unless one of
the element-wise operations specified to be called for that operation
throws an exception.</p></div><div class='para' id='pairs.pair-2'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-2'>2</a></div><p >The defaulted move and copy constructor, respectively, of pair shall
be a <span class='texttt'>constexpr</span> function if and only if all required element-wise
initializations for copy and move, respectively, would satisfy the
requirements for a <span class='texttt'>constexpr</span> function.</p><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
constexpr pair();
</code></p></div><div class='itemdescr'></div><div class='para' id='pairs.pair-3'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_default_constructible&lt;first_type&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_default_construct-</span><br/><span class='texttt'>ible&lt;second_type&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-4'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Value-initializes <span class='texttt'>first</span> and <span class='texttt'>second</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
constexpr pair(const T1&amp; x, const T2&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-5'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_copy_constructible&lt;first_type&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_copy_constructible&lt;second_type&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-6'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
The constructor initializes <span class='texttt'>first</span> with <span class='texttt'>x</span> and <span class='texttt'>second</span>
with <span class='texttt'>y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
template&lt;class U, class V&gt; constexpr pair(U&amp;&amp; x, V&amp;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-7'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_constructible&lt;first_type, U&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;second_type, V&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-8'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
The constructor initializes <span class='texttt'>first</span> with
<span class='texttt'>std::forward&lt;U&gt;(x)</span> and <span class='texttt'>second</span>
with <span class='texttt'>std::forward&lt;<span class='discretionary'></span>V&gt;(y)</span>.</p></div></div><div class='para' id='pairs.pair-9'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If <span class='texttt'>U</span> is not implicitly convertible to <span class='texttt'>first_type</span> or <span class='texttt'>V</span> is not
implicitly convertible to <span class='texttt'>second_type</span> this constructor shall not participate in
overload resolution.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
template&lt;class U, class V&gt; constexpr pair(const pair&lt;U, V&gt;&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-10'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_constructible&lt;first_type, const U&amp;&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;second_type, const V&amp;&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-11'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes members from the corresponding members of the argument.</p></div></div><div class='para' id='pairs.pair-12'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-12'>12</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>const U&amp;</span> is implicitly convertible to <span class='texttt'>first_type</span> and
<span class='texttt'>const V&amp;</span> is implicitly convertible to <span class='texttt'>second_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
template&lt;class U, class V&gt; constexpr pair(pair&lt;U, V&gt;&amp;&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-13'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_constructible&lt;first_type, U&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;second_type, V&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-14'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
The constructor initializes <span class='texttt'>first</span> with
<span class='texttt'>std::forward&lt;U&gt;(p.first)</span>
and <span class='texttt'>second</span> with
<span class='texttt'>std::<span class='discretionary'></span>forward&lt;V&gt;(p.second)</span>.</p></div></div><div class='para' id='pairs.pair-15'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-15'>15</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>U</span> is implicitly convertible to <span class='texttt'>first_type</span> and
<span class='texttt'>V</span> is implicitly convertible to <span class='texttt'>second_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,pair'></a></span>
<code class='itemdecl'>
template&lt;class... Args1, class... Args2&gt;
  pair(piecewise_construct_t,
       tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-16'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-16'>16</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_constructible&lt;first_type, Args1&amp;&amp;...&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;second_type, Args2&amp;&amp;...&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-17'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> The constructor initializes <span class='texttt'>first</span> with arguments of types
<span class='texttt'>Args1...</span> obtained by forwarding the elements of <span class='texttt'>first_args</span>
and initializes <span class='texttt'>second</span> with arguments of types <span class='texttt'>Args2...</span>
obtained by forwarding the elements of <span class='texttt'>second_args</span>. (Here, forwarding
an element <span class='texttt'>x</span> of type <span class='texttt'>U</span> within a <span class='texttt'>tuple</span> object means calling
<span class='texttt'>std::forward&lt;U&gt;(x)</span>.) This form of construction, whereby constructor
arguments for <span class='texttt'>first</span> and <span class='texttt'>second</span> are each provided in a separate
<span class='texttt'>tuple</span> object, is called <a class='hidden_link' href='#def:piecewise_construction' id='def:piecewise_construction'><i>piecewise construction</i></a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,operator='></a></span>
<code class='itemdecl'>
pair&amp; operator=(const pair&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-18'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_copy_assignable&lt;first_type&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_copy_assignable&lt;second_type&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-19'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>p.first</span> to <span class='texttt'>first</span> and <span class='texttt'>p.second</span> to <span class='texttt'>second</span>.</p></div></div><div class='para' id='pairs.pair-20'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,operator='></a></span>
<code class='itemdecl'>
template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-21'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-21'>21</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_assignable&lt;first_type&amp;, const U&amp;&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_assignable&lt;second_type&amp;, const V&amp;&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-22'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>p.first</span> to <span class='texttt'>first</span> and <span class='texttt'>p.second</span> to <span class='texttt'>second</span>.</p></div></div><div class='para' id='pairs.pair-23'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,operator='></a></span>
<code class='itemdecl'>
pair&amp; operator=(pair&amp;&amp; p) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-24'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-24'>24</a></div><div class='itemdescr'><p ><i>Remarks:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
is_nothrow_move_assignable&lt;T1&gt;::value &amp;&amp;
is_nothrow_move_assignable&lt;T2&gt;::value
</pre></div></div><div class='para' id='pairs.pair-25'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-25'>25</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_move_assignable&lt;first_type&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_move_assignable&lt;second_type&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-26'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns to <span class='texttt'>first</span> with <span class='texttt'>std::forward&lt;first_type&gt;(p.first)</span>
and to <span class='texttt'>second</span> with<br/> <span class='texttt'>std::forward&lt;second_type&gt;(p.second)</span>.</p></div></div><div class='para' id='pairs.pair-27'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,operator='></a></span>
<code class='itemdecl'>
template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-28'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-28'>28</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_assignable&lt;first_type&amp;, U&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_assignable&lt;second_type&amp;, V&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='pairs.pair-29'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns to <span class='texttt'>first</span> with <span class='texttt'>std::forward&lt;U&gt;(p.first)</span>
and to <span class='texttt'>second</span> with<br/> <span class='texttt'>std::forward&lt;V&gt;(p.second)</span>.</p></div></div><div class='para' id='pairs.pair-30'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-30'>30</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,pair'></a></span>
<span class='indexparent'><a class='index' id='pair,swap'></a></span>
<code class='itemdecl'>
void swap(pair&amp; p) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.pair-31'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-31'>31</a></div><div class='itemdescr'><p ><i>Remarks:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
noexcept(swap(first, p.first)) &amp;&amp;
noexcept(swap(second, p.second))
</pre></div></div><div class='para' id='pairs.pair-32'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-32'>32</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>first</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>)
<span class='texttt'>p.first</span> and <span class='texttt'>second</span> shall be swappable with <span class='texttt'>p.second</span>.</p></div></div><div class='para' id='pairs.pair-33'><div class='marginalizedparent'><a class='marginalized' href='#pairs.pair-33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> Swaps
<span class='texttt'>first</span> with <span class='texttt'>p.first</span> and
<span class='texttt'>second</span> with <span class='texttt'>p.second</span>.
</p></div></div></div><div id='pairs.spec'><h3 ><a class='secnum' href='#pairs.spec' style='min-width:103pt'>20.3.3</a> Specialized algorithms <a class='abbr_ref' href='pairs.spec'>[pairs.spec]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator==(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.first == y.first &amp;&amp; x.second == y.second</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator&lt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt; y.second)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x == y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator&gt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>y &lt; x</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-5'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x &lt; y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-6'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(y &lt; x)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,pair'></a></span><code class='itemdecl'>
template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y)
  noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-7'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='make_pair'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  constexpr pair&lt;V1, V2&gt; make_pair(T1&amp;&amp; x, T2&amp;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='pairs.spec-8'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pair&lt;V1, V2&gt;(std::forward&lt;T1&gt;(x), std::forward&lt;T2&gt;(y))</span>;</p><p >where <span class='texttt'>V1</span> and <span class='texttt'>V2</span> are determined as follows: Let <span class='texttt'>Ui</span> be
<span class='texttt'>decay_t&lt;Ti&gt;</span> for each <span class='texttt'>Ti</span>. Then each <span class='texttt'>Vi</span> is <span class='texttt'>X&amp;</span>
if <span class='texttt'>Ui</span> equals <span class='texttt'>reference_wrapper&lt;X&gt;</span>, otherwise <span class='texttt'>Vi</span> is
<span class='texttt'>Ui</span>.</p></div></div><div class='para' id='pairs.spec-9'><div class='marginalizedparent'><a class='marginalized' href='#pairs.spec-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
In place of:</p><pre class='codeblock'>
  return pair&lt;int, double&gt;(5, 3.1415926);   <span class='comment'>// explicit types
</span></pre><p >a C++ program may contain:</p><pre class='codeblock'>
  return make_pair(5, 3.1415926);           <span class='comment'>// types are deduced
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='pair.astuple'><h3 ><a class='secnum' href='#pair.astuple' style='min-width:103pt'>20.3.4</a> Tuple-like access to pair <a class='abbr_ref' href='pair.astuple'>[pair.astuple]</a></h3><p ><span class='indexparent'><a class='index' id='tuple_size'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
struct tuple_size&lt;pair&lt;T1, T2&gt;&gt;
  : integral_constant&lt;size_t, 2&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='tuple_element'></a></span><code class='itemdecl'>
tuple_element&lt;0, pair&lt;T1, T2&gt; &gt;::type
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-1'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-1'>1</a></div><div class='itemdescr'><p ><i>Value:</i> the type <span class='texttt'>T1</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple_element'></a></span><code class='itemdecl'>
tuple_element&lt;1, pair&lt;T1, T2&gt; &gt;::type
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-2'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-2'>2</a></div><div class='itemdescr'><p ><i>Value:</i> the type T2.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template&lt;size_t I, class T1, class T2&gt;
  constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
    get(pair&lt;T1, T2&gt;&amp; p) noexcept;
template&lt;size_t I, class T1, class T2&gt;
  constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
    get(const pair&lt;T1, T2&gt;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-3'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>I == 0</span> returns <span class='texttt'>p.first</span>;
if <span class='texttt'>I == 1</span> returns <span class='texttt'>p.second</span>; otherwise the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template&lt;size_t I, class T1, class T2&gt;
  constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
    get(pair&lt;T1, T2&gt;&amp;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-4'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>I == 0</span> returns <span class='texttt'>std::forward&lt;T1&amp;&amp;&gt;(p.first)</span>;
if <span class='texttt'>I == 1</span> returns
<span class='texttt'>std::forward&lt;T2&amp;&amp;&gt;(<span class='discretionary'></span>p.second)</span>;
otherwise the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  constexpr T&amp; get(pair&lt;T, U&gt;&amp; p) noexcept;
template &lt;class T, class U&gt;
  constexpr const T&amp; get(const pair&lt;T, U&gt;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-5'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> and <span class='texttt'>U</span> are distinct types. Otherwise, the program is ill-formed.</p></div></div><div class='para' id='pair.astuple-6'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get&lt;0&gt;(p);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  constexpr T&amp;&amp; get(pair&lt;T, U&gt;&amp;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-7'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> and <span class='texttt'>U</span> are distinct types. Otherwise, the program is ill-formed.</p></div></div><div class='para' id='pair.astuple-8'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get&lt;0&gt;(std::move(p));</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  constexpr T&amp; get(pair&lt;U, T&gt;&amp; p) noexcept;
template &lt;class T, class U&gt;
  constexpr const T&amp; get(const pair&lt;U, T&gt;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-9'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> and <span class='texttt'>U</span> are distinct types. Otherwise, the program is ill-formed.</p></div></div><div class='para' id='pair.astuple-10'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get&lt;1&gt;(p);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='pair,get'></a></span><span class='indexparent'><a class='index' id='get,pair'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  constexpr T&amp;&amp; get(pair&lt;U, T&gt;&amp;&amp; p) noexcept;
</code>
</p><div class='itemdescr'></div><div class='para' id='pair.astuple-11'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> and <span class='texttt'>U</span> are distinct types. Otherwise, the program is ill-formed.</p></div></div><div class='para' id='pair.astuple-12'><div class='marginalizedparent'><a class='marginalized' href='#pair.astuple-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get&lt;1&gt;(std::move(p));</span>
</p></div></div></div><div id='pair.piecewise'><h3 ><a class='secnum' href='#pair.piecewise' style='min-width:103pt'>20.3.5</a> Piecewise construction <a class='abbr_ref' href='pair.piecewise'>[pair.piecewise]</a></h3><p ><span class='indexparent'><a class='index' id='piecewise_construct_t'></a></span><span class='indexparent'><a class='index' id='piecewise_construct'></a></span><code class='itemdecl'>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</code></p><div class='para' id='pair.piecewise-1'><div class='marginalizedparent'><a class='marginalized' href='#pair.piecewise-1'>1</a></div><p >The <span class='texttt'>struct</span> <span class='texttt'>piecewise_construct_t</span> is an empty structure type
used as a unique type to disambiguate constructor and function overloading. Specifically,
<span class='texttt'>pair</span> has a constructor with <span class='texttt'>piecewise_construct_t</span> as the
first argument, immediately followed by two <span class='texttt'>tuple</span> (<a href='tuple'>[tuple]</a>) arguments used
for piecewise construction of the elements of the <span class='texttt'>pair</span> object.</p></div></div></div><div id='tuple'><h2 ><a class='secnum' href='#tuple' style='min-width:88pt'>20.4</a> Tuples <a class='abbr_ref' href='tuple'>[tuple]</a></h2><div id='tuple.general'><h3 ><a class='secnum' href='#tuple.general' style='min-width:103pt'>20.4.1</a> In general <a class='abbr_ref' href='tuple.general'>[tuple.general]</a></h3><div class='para' id='tuple.general-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='tuple'></a></span>This subclause describes the tuple library that provides a tuple type as
the class template <span class='texttt'>tuple</span> that can be instantiated with any number
of arguments. Each template argument specifies
the type of an element in the <span class='texttt'>tuple</span>.  Consequently, tuples are
heterogeneous, fixed-size collections of values. An instantiation of <span class='texttt'>tuple</span> with
two arguments is similar to an instantiation of <span class='texttt'>pair</span> with the same two arguments.
See <a href='pairs'>[pairs]</a>.</p></div><div class='para' id='tuple.general-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.general-2'>2</a></div><p ><b>Header <span class='texttt'>&lt;tuple&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='tuple'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='tuple.tuple'>[tuple.tuple]</a>, class template <span class='texttt'>tuple</span>:
</span>  template &lt;class... Types&gt; class tuple;

  <span class='comment'>// <a href='tuple.creation'>[tuple.creation]</a>, tuple creation functions:
</span>  const <i><span class='texttt'>unspecified</span></i> ignore;

  template &lt;class... Types&gt;
    constexpr tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;...);
  template &lt;class... Types&gt;
    constexpr tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;...) noexcept;

  template&lt;class... Types&gt;
    constexpr tuple&lt;Types&amp;...&gt; tie(Types&amp;...) noexcept;

  template &lt;class... Tuples&gt;
    constexpr tuple&lt;<i>Ctypes</i>...&gt; tuple_cat(Tuples&amp;&amp;...);

  <span class='comment'>// <a href='tuple.helper'>[tuple.helper]</a>, tuple helper classes:
</span>  template &lt;class T&gt; class tuple_size;  <span class='comment'>// undefined
</span>  template &lt;class T&gt; class tuple_size&lt;const T&gt;;
  template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;
  template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;

  template &lt;class... Types&gt; class tuple_size&lt;tuple&lt;Types...&gt; &gt;;

  template &lt;size_t I, class T&gt; class tuple_element;    <span class='comment'>// undefined
</span>  template &lt;size_t I, class T&gt; class tuple_element&lt;I, const T&gt;;
  template &lt;size_t I, class T&gt; class tuple_element&lt;I, volatile T&gt;;
  template &lt;size_t I, class T&gt; class tuple_element&lt;I, const volatile T&gt;;

  template &lt;size_t I, class... Types&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;

  template &lt;size_t I, class T&gt;
    using tuple_element_t = typename tuple_element&lt;I, T&gt;::type;

  <span class='comment'>// <a href='tuple.elem'>[tuple.elem]</a>, element access:
</span>  template &lt;size_t I, class... Types&gt;
    constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp;
      get(tuple&lt;Types...&gt;&amp;) noexcept;
  template &lt;size_t I, class... Types&gt;
    constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp;&amp;
      get(tuple&lt;Types...&gt;&amp;&amp;) noexcept;
  template &lt;size_t I, class... Types&gt;
    constexpr const tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp;
      get(const tuple&lt;Types...&gt;&amp;) noexcept;
  template &lt;class T, class... Types&gt;
    constexpr T&amp; get(tuple&lt;Types...&gt;&amp; t) noexcept;
  template &lt;class T, class... Types&gt;
    constexpr T&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; t) noexcept;
  template &lt;class T, class... Types&gt;
    constexpr const T&amp; get(const tuple&lt;Types...&gt;&amp; t) noexcept;

  <span class='comment'>// <a href='tuple.rel'>[tuple.rel]</a>, relational operators:
</span>  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

  <span class='comment'>// <a href='tuple.traits'>[tuple.traits]</a>, allocator-related traits
</span>  template &lt;class... Types, class Alloc&gt;
    struct uses_allocator&lt;tuple&lt;Types...&gt;, Alloc&gt;;

  <span class='comment'>// <a href='tuple.special'>[tuple.special]</a>, specialized algorithms:
</span>  template &lt;class... Types&gt;
    void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i><span class='texttt'>see below</span></i>);
}
</pre></div></div><div id='tuple.tuple'><h3 ><a class='secnum' href='#tuple.tuple' style='min-width:103pt'>20.4.2</a> Class template <span class='texttt'>tuple</span> <a class='abbr_ref' href='tuple.tuple'>[tuple.tuple]</a></h3><p ><span class='indexparent'><a class='index' id='tuple'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class... Types&gt;
  class tuple  {
  public:

    <span class='comment'>// <a href='tuple.cnstr'>[tuple.cnstr]</a>, <span class='texttt'>tuple</span> construction
</span>    constexpr tuple();
    constexpr explicit tuple(const Types&amp;...);
    template &lt;class... UTypes&gt;
      constexpr explicit tuple(UTypes&amp;&amp;...);

    tuple(const tuple&amp;) = default;
    tuple(tuple&amp;&amp;) = default;

    template &lt;class... UTypes&gt;
      constexpr tuple(const tuple&lt;UTypes...&gt;&amp;);
    template &lt;class... UTypes&gt;
      constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp;);

    template &lt;class U1, class U2&gt;
      constexpr tuple(const pair&lt;U1, U2&gt;&amp;);       <span class='comment'>// only if <span class='texttt'>sizeof...(Types) == 2</span>
</span>    template &lt;class U1, class U2&gt;
      constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp;);            <span class='comment'>// only if <span class='texttt'>sizeof...(Types) == 2</span>
</span>
    <span class='comment'>// allocator-extended constructors
</span>    template &lt;class Alloc&gt;
      tuple(allocator_arg_t, const Alloc&amp; a);
    template &lt;class Alloc&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, const Types&amp;...);
    template &lt;class Alloc, class... UTypes&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, UTypes&amp;&amp;...);
    template &lt;class Alloc&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, const tuple&amp;);
    template &lt;class Alloc&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, tuple&amp;&amp;);
    template &lt;class Alloc, class... UTypes&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, const tuple&lt;UTypes...&gt;&amp;);
    template &lt;class Alloc, class... UTypes&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, tuple&lt;UTypes...&gt;&amp;&amp;);
    template &lt;class Alloc, class U1, class U2&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;);
    template &lt;class Alloc, class U1, class U2&gt;
      tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;&amp;);

    <span class='comment'>// <a href='tuple.assign'>[tuple.assign]</a>, <span class='texttt'>tuple</span> assignment
</span>    tuple&amp; operator=(const tuple&amp;);
    tuple&amp; operator=(tuple&amp;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

    template &lt;class... UTypes&gt;
      tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp;);
    template &lt;class... UTypes&gt;
      tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp;);

    template &lt;class U1, class U2&gt;
      tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp;);    <span class='comment'>// only if <span class='texttt'>sizeof...(Types) == 2</span>
</span>    template &lt;class U1, class U2&gt;
      tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp;);         <span class='comment'>// only if <span class='texttt'>sizeof...(Types) == 2</span>
</span>
    <span class='comment'>// <a href='tuple.swap'>[tuple.swap]</a>, <span class='texttt'>tuple</span> swap
</span>    void swap(tuple&amp;) noexcept(<i><span class='texttt'>see below</span></i>);
  };
}
</pre><div id='tuple.cnstr'><h4 ><a class='secnum' href='#tuple.cnstr' style='min-width:118pt'>20.4.2.1</a> Construction <a class='abbr_ref' href='tuple.cnstr'>[tuple.cnstr]</a></h4><div class='para' id='tuple.cnstr-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-1'>1</a></div><p >For each <span class='texttt'>tuple</span> constructor, an exception is thrown only if the construction of
one of the types in <span class='texttt'>Types</span> throws an exception.</p></div><div class='para' id='tuple.cnstr-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-2'>2</a></div><p >The defaulted move and copy constructor, respectively, of
<span class='texttt'>tuple</span> shall be a <span class='texttt'>constexpr</span> function if and only if all
required element-wise initializations for copy and move, respectively,
would satisfy the requirements for a <span class='texttt'>constexpr</span> function. The
defaulted move and copy constructor of <span class='texttt'>tuple&lt;&gt;</span> shall be
<span class='texttt'>constexpr</span> functions.</p></div><div class='para' id='tuple.cnstr-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-3'>3</a></div><p >In the constructor descriptions that follow, let <span class='math'><span class='mathalpha'>i</span></span> be in the range
<span class='texttt'>[<span class='discretionary'></span>0,<span class='discretionary'></span>sizeof...(Types)<span class='discretionary'></span>)</span> in order, <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Types</span>, and
<span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in a template parameter pack named <span class='texttt'>UTypes</span>, where indexing
is zero-based.</p><p ><span class='indexparent'><a class='index' id='tuple,tuple'></a></span><code class='itemdecl'>
constexpr tuple();
</code></p></div><div class='itemdescr'></div><div class='para' id='tuple.cnstr-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_default_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is true for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-5'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>  Value initializes each element.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
constexpr explicit tuple(const Types&amp;...);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-6'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_copy_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is true for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-7'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes each element with the value of the
corresponding parameter.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
template &lt;class... UTypes&gt;
  constexpr explicit tuple(UTypes&amp;&amp;... u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-8'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sizeof...(Types)</span> <span class='texttt'>==</span> <span class='texttt'>sizeof...(UTypes)</span>.
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>, <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-9'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the elements in the tuple with the
corresponding value in <span class='texttt'>std::forward&lt;UTypes&gt;(u)</span>.</p></div></div><div class='para' id='tuple.cnstr-10'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-10'>10</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless each type
in <span class='texttt'>UTypes</span> is implicitly convertible to its corresponding type in <span class='texttt'>Types</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
tuple(const tuple&amp; u) = default;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-11'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_copy_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-12'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes each element of <span class='texttt'>*this</span> with the
corresponding element of <span class='texttt'>u</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
tuple(tuple&amp;&amp; u) = default;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-13'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_move_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-14'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, initializes the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> element of <span class='texttt'>*this</span> with
<span class='texttt'>std::forward&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(u))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
template &lt;class... UTypes&gt; constexpr tuple(const tuple&lt;UTypes...&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-15'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>sizeof...(Types)</span> <span class='texttt'>==</span> <span class='texttt'>sizeof...(UTypes)</span>.
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>, const <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-16'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs each element of <span class='texttt'>*this</span> with the corresponding
element of <span class='texttt'>u</span>.</p></div></div><div class='para' id='tuple.cnstr-17'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-17'>17</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>const <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;</span> is implicitly convertible to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> for all <span class='math'><span class='mathalpha'>i</span></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
template &lt;class... UTypes&gt; constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-18'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>sizeof...(Types)</span> <span class='texttt'>==</span> <span class='texttt'>sizeof...(UTypes)</span>.
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>, <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.cnstr-19'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, initializes the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> element of <span class='texttt'>*this</span> with
<span class='texttt'>std::forward&lt;<span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(u))</span>.</p></div></div><div class='para' id='tuple.cnstr-20'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-20'>20</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
each type in <span class='texttt'>UTypes</span> is implicitly convertible to its corresponding type in
<span class='texttt'>Types</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><span class='indexparent'><a class='index' id='pair'></a></span><code class='itemdecl'>
template &lt;class U1, class U2&gt; constexpr tuple(const pair&lt;U1, U2&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-21'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-21'>21</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sizeof...(Types) == 2</span>.
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>, const U1&amp;&gt;::value</span> is <span class='texttt'>true</span> for the first type
<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> in <span class='texttt'>Types</span> and
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>, const U2&amp;&gt;::value</span> is <span class='texttt'>true</span> for the second type
<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span> in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.cnstr-22'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs the first element with <span class='texttt'>u.first</span> and the
second element with <span class='texttt'>u.second</span>.</p></div></div><div class='para' id='tuple.cnstr-23'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-23'>23</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>const U1&amp;</span> is implicitly convertible to <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> and <span class='texttt'>const U2&amp;</span>
is implicitly convertible to <span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><span class='indexparent'><a class='index' id='pair'></a></span><code class='itemdecl'>
template &lt;class U1, class U2&gt; constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-24'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-24'>24</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sizeof...(Types) == 2</span>.
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>, U1&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for the first type
<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> in <span class='texttt'>Types</span> and
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>, U2&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for the second type
<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span> in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.cnstr-25'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-25'>25</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the first element with
<span class='texttt'>std::forward&lt;U1&gt;(u.first)</span> and the
second element with <span class='texttt'>std::forward&lt;U2&gt;(u.second)</span>.</p></div></div><div class='para' id='tuple.cnstr-26'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-26'>26</a></div><div class='itemdescr'><p ><i>Remark:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>U1</span> is implicitly convertible to <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> and <span class='texttt'>U2</span>
is implicitly convertible to <span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,constructor'></a></span><code class='itemdecl'>
template &lt;class Alloc&gt;
  tuple(allocator_arg_t, const Alloc&amp; a);
template &lt;class Alloc&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, const Types&amp;...);
template &lt;class Alloc, class... UTypes&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, UTypes&amp;&amp;...);
template &lt;class Alloc&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, const tuple&amp;);
template &lt;class Alloc&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, tuple&amp;&amp;);
template &lt;class Alloc, class... UTypes&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class Alloc, class... UTypes&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, tuple&lt;UTypes...&gt;&amp;&amp;);
template &lt;class Alloc, class U1, class U2&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;);
template &lt;class Alloc, class U1, class U2&gt;
  tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.cnstr-27'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-27'>27</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall meet the requirements for an
<span class='texttt'>Allocator</span> (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div></div><div class='para' id='tuple.cnstr-28'><div class='marginalizedparent'><a class='marginalized' href='#tuple.cnstr-28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to the preceding constructors except that each element is constructed with
uses-allocator construction (<a href='allocator.uses.construction'>[allocator.uses.construction]</a>).
</p></div></div></div><div id='tuple.assign'><h4 ><a class='secnum' href='#tuple.assign' style='min-width:118pt'>20.4.2.2</a> Assignment <a class='abbr_ref' href='tuple.assign'>[tuple.assign]</a></h4><div class='para' id='tuple.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-1'>1</a></div><p >For each <span class='texttt'>tuple</span> assignment operator, an exception is thrown only if the
assignment of one of the types in <span class='texttt'>Types</span> throws an exception.
In the function descriptions that follow, let <span class='math'><span class='mathalpha'>i</span></span> be in the range <span class='texttt'>[<span class='discretionary'></span>0,<span class='discretionary'></span>sizeof...<span class='discretionary'></span>(Types)<span class='discretionary'></span>)</span>
in order, <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Types</span>, and <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in a
template parameter pack named <span class='texttt'>UTypes</span>, where indexing is zero-based.</p><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><code class='itemdecl'>
tuple&amp; operator=(const tuple&amp; u);
</code></p></div><div class='itemdescr'></div><div class='para' id='tuple.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_copy_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>  Assigns each element of <span class='texttt'>u</span> to the corresponding
element of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='tuple.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><code class='itemdecl'>
tuple&amp; operator=(tuple&amp;&amp; u) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-5'>5</a></div><div class='itemdescr'><p ><i>Remark:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to the logical <span class='textsc'>and</span> of the
following expressions:</p><pre class='codeblock'>
is_nothrow_move_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value
</pre><p >where <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_move_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, assigns <span class='texttt'>std::forward&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(u))</span> to
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(*this)</span>.</p></div></div><div class='para' id='tuple.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><code class='itemdecl'>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.assign-9'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>sizeof...(Types) == sizeof...(UTypes)</span> and
<span class='texttt'>is_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;, const <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&gt;::value</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='tuple.assign-10'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>  Assigns each element of <span class='texttt'>u</span> to the corresponding element
of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='tuple.assign-11'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><code class='itemdecl'>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.assign-12'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_assignable&lt;Ti&amp;, Ui&amp;&amp;&gt;::value == true</span> for all <span class='texttt'>i</span>.
<span class='texttt'>sizeof...(Types)</span> <span class='texttt'>==</span><br/><span class='texttt'>sizeof...(UTypes)</span>.</p></div></div><div class='para' id='tuple.assign-13'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, assigns <span class='texttt'>std::forward&lt;<span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(get&lt;<span class='math'><span class='mathalpha'>i</span></span>)&gt;(u))</span> to
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(*this)</span>.</p></div></div><div class='para' id='tuple.assign-14'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><span class='indexparent'><a class='index' id='pair'></a></span><code class='itemdecl'>
template &lt;class U1, class U2&gt; tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.assign-15'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sizeof...(Types) == 2</span>.
<span class='texttt'>is_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>&amp;, const U1&amp;&gt;::value</span> is <span class='texttt'>true</span> for the first type <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> in
<span class='texttt'>Types</span> and <span class='texttt'>is_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>&amp;, const U2&amp;&gt;::value</span> is <span class='texttt'>true</span> for the
second type <span class='math'><span class='mathalpha'>T</span><sub >1</sub></span> in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.assign-16'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>  Assigns <span class='texttt'>u.first</span> to the first element of <span class='texttt'>*this</span>
and <span class='texttt'>u.second</span> to the second element of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='tuple.assign-17'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator='></a></span><span class='indexparent'><a class='index' id='operator=,tuple'></a></span><span class='indexparent'><a class='index' id='pair'></a></span><code class='itemdecl'>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.assign-18'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sizeof...(Types) == 2</span>.
<span class='texttt'>is_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>&amp;, U1&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for the first type <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> in
<span class='texttt'>Types</span> and <span class='texttt'>is_assignable&lt;<span class='math'><span class='mathalpha'>T</span><sub >1</sub></span>&amp;, U2&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span> for the second
type <span class='math'><span class='mathalpha'>T</span><sub >1</sub></span> in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.assign-19'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>std::forward&lt;U1&gt;(u.first)</span> to the first
element of <span class='texttt'>*this</span> and<br/> <span class='texttt'>std::forward&lt;U2&gt;(u.second)</span> to the
second element of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='tuple.assign-20'><div class='marginalizedparent'><a class='marginalized' href='#tuple.assign-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='tuple.swap'><h4 ><a class='secnum' href='#tuple.swap' style='min-width:118pt'>20.4.2.3</a> <span class='texttt'>swap</span> <a class='abbr_ref' href='tuple.swap'>[tuple.swap]</a></h4><p ><span class='indexparent'><a class='index' id='swap,tuple'></a></span>
<span class='indexparent'><a class='index' id='tuple,swap'></a></span>
<code class='itemdecl'>
void swap(tuple&amp; rhs) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.swap-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to the logical
<span class='textsc'>and</span> of the following expressions:</p><pre class='codeblock'>
noexcept(swap(declval&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&gt;&gt;(), declval&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&amp;&gt;()))
</pre><p >where <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Types</span>.</p></div></div><div class='para' id='tuple.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Each element in <span class='texttt'>*this</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>)
the corresponding element in <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='tuple.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.swap-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>swap</span> for each element in <span class='texttt'>*this</span> and its
corresponding element in <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='tuple.swap-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.swap-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless one of the element-wise <span class='texttt'>swap</span> calls throws an exception.
</p></div></div></div><div id='tuple.creation'><h4 ><a class='secnum' href='#tuple.creation' style='min-width:118pt'>20.4.2.4</a> Tuple creation functions <a class='abbr_ref' href='tuple.creation'>[tuple.creation]</a></h4><div class='para' id='tuple.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-1'>1</a></div><p >In the function descriptions that follow, let <span class='math'><span class='mathalpha'>i</span></span> be in the range <span class='texttt'>[<span class='discretionary'></span>0,<span class='discretionary'></span>sizeof...(TTypes)<span class='discretionary'></span>)</span>
in order and let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in a template parameter pack named <span class='texttt'>TTypes</span>;
let <span class='math'><span class='mathalpha'>j</span></span> be in the range <span class='texttt'>[<span class='discretionary'></span>0,<span class='discretionary'></span>sizeof...(UTypes)<span class='discretionary'></span>)</span> in order and <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>j</span></sub></span> be the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> type
in a template parameter pack named <span class='texttt'>UTypes</span>, where indexing is zero-based.</p><p ><span class='indexparent'><a class='index' id='make_tuple'></a></span><span class='indexparent'><a class='index' id='tuple,make_tuple'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;... t);
</code></p></div><div class='itemdescr'></div><div class='para' id='tuple.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'><span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span></span> be <span class='texttt'>decay_t&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> for each
<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>Types</span>. Then each <span class='math'><span class='mathalpha'>V</span><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>VTypes</span> is
<span class='texttt'>X&amp;</span> if <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> equals <span class='texttt'>reference_wrapper&lt;X&gt;</span>, otherwise
<span class='math'><span class='mathalpha'>V</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>.</p></div></div><div class='para' id='tuple.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tuple&lt;VTypes...&gt;(std::forward&lt;Types&gt;(t)...)</span>.</p></div></div><div class='para' id='tuple.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int i; float j;
make_tuple(1, ref(i), cref(j))
</pre><p >creates a tuple of type</p><pre class='codeblock'>
tuple&lt;int, int&amp;, const float&amp;&gt;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='forward_as_tuple'></a></span><span class='indexparent'><a class='index' id='tuple,forward_as_tuple'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;... t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a tuple of references to the arguments in <span class='texttt'>t</span> suitable
for forwarding as arguments to a function. Because the result may contain references
to temporary variables, a program shall ensure that the return value of this
function does not outlive any of its arguments. (e.g., the program should typically
not store the result in a named variable).</p></div></div><div class='para' id='tuple.creation-6'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tuple&lt;Types&amp;&amp;...&gt;(std::forward&lt;Types&gt;(t)...)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tie'></a></span><span class='indexparent'><a class='index' id='ignore'></a></span><span class='indexparent'><a class='index' id='tuple,tie'></a></span><code class='itemdecl'>
template&lt;class... Types&gt;
  constexpr tuple&lt;Types&amp;...&gt; tie(Types&amp;... t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.creation-7'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>tuple&lt;Types&amp;...&gt;(t...)</span>.  When an
argument in <span class='texttt'>t</span> is <span class='texttt'>ignore</span>, assigning
any value to the corresponding tuple element has no effect.</p></div></div><div class='para' id='tuple.creation-8'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
<span class='texttt'>tie</span> functions allow one to create tuples that unpack
tuples into variables. <span class='texttt'>ignore</span> can be used for elements that
are not needed:
</p><pre class='codeblock'>
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
<span class='comment'>// <span class='texttt'>i == 42</span>, <span class='texttt'>s == "C++"</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple_cat'></a></span>
<code class='itemdecl'>
template &lt;class... Tuples&gt;
  constexpr tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;... tpls);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.creation-9'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-9'>9</a></div><div class='itemdescr'><p >In the following paragraphs, let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Tuples</span>,
<span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> be <span class='texttt'>remove_reference_t&lt;Ti&gt;</span>, and <span class='math'><span class='mathalpha'>tp</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
parameter in the function parameter pack <span class='texttt'>tpls</span>, where all indexing is
zero-based.</p></div></div><div class='para' id='tuple.creation-10'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> For all <span class='math'><span class='mathalpha'>i</span></span>, <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span> shall be the type
<span class='math'><i>cv</i><sub ><span class='mathalpha'>i</span></sub></span> <span class='texttt'>tuple&lt;<span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub>...</span>&gt;</span>, where <span class='math'><i>cv</i><sub ><span class='mathalpha'>i</span></sub></span> is the (possibly empty) <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
cv-qualifier-seq and <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span> is the parameter pack representing the element
types in <span class='math'><span class='mathalpha'>U</span><sub ><span class='mathalpha'>i</span></sub></span>. Let <span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span> be the <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span>. For all
<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span> the following requirements shall be satisfied: If <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> is
deduced as an lvalue reference type, then
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>, <span class='math'><span class='mathalpha'>cv</span><sub ><span class='mathalpha'>i</span></sub></span> <span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>&amp;&gt;::value == true</span>, otherwise
<span class='texttt'>is_constructible&lt;<span class='math'><span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>, <span class='math'><span class='mathalpha'>cv</span><sub ><span class='mathalpha'>i</span></sub> <span class='mathalpha'>A</span><sub ><span class='mathalpha'>ik</span></sub></span>&amp;&amp;&gt;::value == true</span>.</p></div></div><div class='para' id='tuple.creation-11'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> The types in <span class='texttt'><i>Ctypes</i></span> shall be equal to the ordered
sequence of the extended types
<span class='texttt'><span class='math'><span class='mathalpha'>Args</span><sub >0</sub></span>..., <span class='math'><span class='mathalpha'>Args</span><sub >1</sub></span>...,</span> ... <span class='texttt'><span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>n</span>-1</sub></span>...</span>, where <span class='math'><span class='mathalpha'>n</span></span> is
equal to <span class='texttt'>sizeof...(Tuples)</span>. Let <span class='texttt'><span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span>...</span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span>
ordered sequence of tuple elements of the resulting <span class='texttt'>tuple</span> object
corresponding to the type sequence <span class='math'><span class='mathalpha'>Args</span><sub ><span class='mathalpha'>i</span></sub></span>.</p></div></div><div class='para' id='tuple.creation-12'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>tuple</span> object constructed by initializing the <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub><sup ><span class='mathalpha'>th</span></sup></span>
type element <span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>ik</span></sub></span> in <span class='texttt'><span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span>...</span> with<br/>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(std::forward&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;(<span class='math'><span class='mathalpha'>tp</span><sub ><span class='mathalpha'>i</span></sub></span>))</span> for each valid <span class='math'><span class='mathalpha'>k</span><sub ><span class='mathalpha'>i</span></sub></span> and
each group <span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>i</span></sub></span> in order.</p></div></div><div class='para' id='tuple.creation-13'><div class='marginalizedparent'><a class='marginalized' href='#tuple.creation-13'>13</a></div><div class='itemdescr'><p ><i>Note:</i> An implementation may support additional types in the parameter
pack <span class='texttt'>Tuples</span> that support the <span class='texttt'>tuple</span>-like protocol, such as
<span class='texttt'>pair</span> and <span class='texttt'>array</span>.
</p></div></div></div><div id='tuple.helper'><h4 ><a class='secnum' href='#tuple.helper' style='min-width:118pt'>20.4.2.5</a> Tuple helper classes <a class='abbr_ref' href='tuple.helper'>[tuple.helper]</a></h4><p ><span class='indexparent'><a class='index' id='tuple_size,in_general'></a></span><code class='itemdecl'>
template &lt;class T&gt; struct tuple_size;
</code></p><div class='itemdescr'><p ><i>Remarks:</i> All specializations of <span class='texttt'>tuple_size&lt;T&gt;</span> shall meet the
<span class='texttt'>UnaryTypeTrait</span> requirements (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
<span class='texttt'>BaseCharacteristic</span> of <span class='texttt'>integral_constant&lt;size_t, N&gt;</span>
for some <span class='texttt'>N</span>.
</p></div><p ><span class='indexparent'><a class='index' id='tuple_size'></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
class tuple_size&lt;tuple&lt;Types...&gt; &gt;
  : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='tuple_element'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};
</code></p><div class='itemdescr'></div><div class='para' id='tuple.helper-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.helper-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; sizeof...(Types)</span>.
The program is ill-formed if <span class='texttt'>I</span> is out of bounds.</p></div></div><div class='para' id='tuple.helper-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.helper-2'>2</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>TI</span> is the
type of the <span class='texttt'>I</span>th element of <span class='texttt'>Types</span>,
where indexing is zero-based.
</p></div></div><p ><code class='itemdecl'>
template &lt;class T&gt; class tuple_size&lt;const T&gt;;
template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;
template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.helper-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.helper-3'>3</a></div><div class='itemdescr'><p >Let <a class='hidden_link' href='#def:TS' id='def:TS'><i>TS</i></a> denote <span class='texttt'>tuple_size&lt;T&gt;</span> of the <i>cv</i>-unqualified type <span class='texttt'>T</span>. Then each
of the three templates shall meet the <span class='texttt'>UnaryTypeTrait</span> requirements (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a <span class='texttt'>BaseCharacteristic</span> of
</p><pre class='codeblock'>
integral_constant&lt;size_t, TS::value&gt;
</pre></div></div><p ><code class='itemdecl'>
template &lt;size_t I, class T&gt; class tuple_element&lt;I, const T&gt;;
template &lt;size_t I, class T&gt; class tuple_element&lt;I, volatile T&gt;;
template &lt;size_t I, class T&gt; class tuple_element&lt;I, const volatile T&gt;;
</code></p><div class='itemdescr'><p >Let <a class='hidden_link' href='#def:TE' id='def:TE'><i>TE</i></a> denote <span class='texttt'>tuple_element&lt;I, T&gt;</span> of the <i>cv</i>-unqualified type <span class='texttt'>T</span>. Then
each of the three templates shall meet the <span class='texttt'>TransformationTrait</span>
requirements (<a href='meta.rqmts'>[meta.rqmts]</a>) with a member typedef <span class='texttt'>type</span> that names the following
type:</p><ul class='itemize'><li ><p >for the first specialization, <span class='texttt'>add_const_t&lt;<a class='hidden_link' href='#def:TE' id='def:TE'><i>TE</i></a>::type&gt;</span>,</p></li><li ><p >for the second specialization, <span class='texttt'>add_volatile_t&lt;<a class='hidden_link' href='#def:TE' id='def:TE'><i>TE</i></a>::type&gt;</span>, and</p></li><li ><p >for the third specialization, <span class='texttt'>add_cv_t&lt;<a class='hidden_link' href='#def:TE' id='def:TE'><i>TE</i></a>::type&gt;</span>.</p></li></ul></div></div><div id='tuple.elem'><h4 ><a class='secnum' href='#tuple.elem' style='min-width:118pt'>20.4.2.6</a> Element access <a class='abbr_ref' href='tuple.elem'>[tuple.elem]</a></h4><p ><span class='indexparent'><a class='index' id='tuple,get'></a></span><span class='indexparent'><a class='index' id='get,tuple'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
  constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt; &gt;&amp; get(tuple&lt;Types...&gt;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.elem-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; sizeof...(Types)</span>.
The program is ill-formed if <span class='texttt'>I</span> is out of bounds.</p></div></div><div class='para' id='tuple.elem-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  A reference to the <span class='texttt'>I</span>th element of <span class='texttt'>t</span>, where
indexing is zero-based.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,get'></a></span><span class='indexparent'><a class='index' id='get,tuple'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
  constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt; &gt;&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.elem-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>return std::forward&lt;typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;</span><br/>
<span class='texttt'>::type&amp;&amp;&gt;(get&lt;I&gt;(t));</span></p></div></div><div class='para' id='tuple.elem-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-4'>4</a></div><div class='itemdescr'><p ><i>Note:</i> if a <span class='texttt'>T</span> in <span class='texttt'>Types</span> is some reference type <span class='texttt'>X&amp;</span>, the return
type is <span class='texttt'>X&amp;</span>, not <span class='texttt'>X&amp;&amp;</span>. However, if the element type is a non-reference type
<span class='texttt'>T</span>, the return type is <span class='texttt'>T&amp;&amp;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,get'></a></span><span class='indexparent'><a class='index' id='get,tuple'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
  constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt; &gt; const&amp; get(const tuple&lt;Types...&gt;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.elem-5'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; sizeof...(Types)</span>.
The program is ill-formed if <span class='texttt'>I</span> is out of bounds.</p></div></div><div class='para' id='tuple.elem-6'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>  A const reference to the <span class='texttt'>I</span>th element of <span class='texttt'>t</span>, where
indexing is zero-based.</p></div></div><div class='para' id='tuple.elem-7'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Constness is shallow. If a <span class='texttt'>T</span>
in <span class='texttt'>Types</span> is some
reference type <span class='texttt'>X&amp;</span>, the return type is <span class='texttt'>X&amp;</span>, not <span class='texttt'>const X&amp;</span>.
However, if the element type is non-reference type <span class='texttt'>T</span>, the return
type is <span class='texttt'>const T&amp;</span>.
This is consistent with how constness is defined to work
for member variables of reference type. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,get'></a></span><span class='indexparent'><a class='index' id='get,tuple'></a></span><code class='itemdecl'>
template &lt;class T, class... Types&gt;
  constexpr T&amp; get(tuple&lt;Types...&gt;&amp; t) noexcept;
template &lt;class T, class... Types&gt;
  constexpr T&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; t) noexcept;
template &lt;class T, class... Types&gt;
  constexpr const T&amp; get(const tuple&lt;Types...&gt;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tuple.elem-8'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> The type <span class='texttt'>T</span> occurs exactly once in <span class='texttt'>Types...</span>.
Otherwise, the program is ill-formed.</p></div></div><div class='para' id='tuple.elem-9'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the element of <span class='texttt'>t</span> corresponding to the type
<span class='texttt'>T</span> in <span class='texttt'>Types...</span>.</p></div></div><div class='para' id='tuple.elem-10'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-10'>10</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
  const tuple&lt;int, const int, double, double&gt; t(1, 2, 3.4, 5.6);
  const int &amp;i1 = get&lt;int&gt;(t);        <span class='comment'>// OK. Not ambiguous. i1 == 1
</span>  const int &amp;i2 = get&lt;const int&gt;(t);  <span class='comment'>// OK. Not ambiguous. i2 == 2
</span>  const double &amp;d = get&lt;double&gt;(t);   <span class='comment'>// ERROR. ill-formed
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><div class='para' id='tuple.elem-11'><div class='marginalizedparent'><a class='marginalized' href='#tuple.elem-11'>11</a></div><p >[&nbsp;<i>Note:</i> The reason <span class='texttt'>get</span> is a
nonmember function is that if this functionality had been
provided as a member function, code where the type
depended on a template parameter would have required using
the <span class='texttt'>template</span> keyword. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='tuple.rel'><h4 ><a class='secnum' href='#tuple.rel' style='min-width:118pt'>20.4.2.7</a> Relational operators <a class='abbr_ref' href='tuple.rel'>[tuple.rel]</a></h4><p ><span class='indexparent'><a class='index' id='tuple,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.rel-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>  For all <span class='texttt'>i</span>,
where <span class='texttt'>0 &lt;= i</span> and
<span class='texttt'>i &lt; sizeof...(TTypes)</span>, <span class='texttt'>get&lt;i&gt;(t) == get&lt;i&gt;(u)</span> is a valid expression
returning a type that is convertible to <span class='texttt'>bool</span>.
<span class='texttt'>sizeof...(TTypes)</span> <span class='texttt'>==</span>
<span class='texttt'>sizeof...(UTypes)</span>.</p></div></div><div class='para' id='tuple.rel-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>true</span> if <span class='texttt'>get&lt;i&gt;(t) == get&lt;i&gt;(u)</span> for all
<span class='texttt'>i</span>, otherwise <span class='texttt'>false</span>.
For any two zero-length tuples <span class='texttt'>e</span> and <span class='texttt'>f</span>, <span class='texttt'>e == f</span> returns <span class='texttt'>true</span>.</p></div></div><div class='para' id='tuple.rel-3'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>  The elementary comparisons are performed in order from the
zeroth index upwards.  No comparisons or element accesses are
performed after the first equality comparison that evaluates to
<span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.rel-4'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>  For all <span class='texttt'>i</span>,
where <span class='texttt'>0 &lt;= i</span> and
<span class='texttt'>i &lt; sizeof...(TTypes)</span>, <span class='texttt'>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</span>
and <span class='texttt'>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</span>
are valid expressions returning types that are
convertible to <span class='texttt'>bool</span>.
<span class='texttt'>sizeof...(TTypes)</span> <span class='texttt'>==</span>
<span class='texttt'>sizeof...(UTypes)</span>.</p></div></div><div class='para' id='tuple.rel-5'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>  The result of a lexicographical comparison
between <span class='texttt'>t</span> and <span class='texttt'>u</span>. The result is defined
as: <span class='texttt'>(bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
(!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; t<span class='math'><sub ><span class='mathrm'>tail</span></sub></span> &lt;
u<span class='math'><sub ><span class='mathrm'>tail</span></sub></span>)</span>, where <span class='texttt'>r<span class='math'><sub ><span class='mathrm'>tail</span></sub></span></span> for some
tuple <span class='texttt'>r</span> is a tuple containing all but the first element
of <span class='texttt'>r</span>.  For any two zero-length tuples <span class='texttt'>e</span>
and <span class='texttt'>f</span>, <span class='texttt'>e &lt; f</span> returns <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code>
</p><div class='itemdescr'></div><div class='para' id='tuple.rel-6'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(t == u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code>
</p><div class='itemdescr'></div><div class='para' id='tuple.rel-7'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>u &lt; t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code>
</p><div class='itemdescr'></div><div class='para' id='tuple.rel-8'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(u &lt; t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='tuple,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,tuple'></a></span><code class='itemdecl'>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.rel-9'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(t &lt; u)</span>
</p></div></div><div class='para' id='tuple.rel-10'><div class='marginalizedparent'><a class='marginalized' href='#tuple.rel-10'>10</a></div><p >[&nbsp;<i>Note:</i> The above definitions for comparison operators
do not require <span class='texttt'>t<span class='math'><sub ><span class='mathrm'>tail</span></sub></span></span>
(or <span class='texttt'>u<span class='math'><sub ><span class='mathrm'>tail</span></sub></span></span>) to be constructed. It may not
even be possible, as <span class='texttt'>t</span> and <span class='texttt'>u</span> are not required to be copy
constructible. Also, all comparison operators are short circuited;
they do not perform element accesses beyond what is required to determine the
result of the comparison. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='tuple.traits'><h4 ><a class='secnum' href='#tuple.traits' style='min-width:118pt'>20.4.2.8</a> Tuple traits <a class='abbr_ref' href='tuple.traits'>[tuple.traits]</a></h4><p ><span class='indexparent'><a class='index' id='uses_allocator<tuple>'></a></span>
<code class='itemdecl'>
template &lt;class... Types, class Alloc&gt;
  struct uses_allocator&lt;tuple&lt;Types...&gt;, Alloc&gt; : true_type { };
</code></p><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall be an <span class='texttt'>Allocator</span> (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div><div class='para' id='tuple.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.traits-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Specialization of this trait informs other library components that
<span class='texttt'>tuple</span> can be constructed with an allocator, even though it does not have
a nested <span class='texttt'>allocator_type</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='tuple.special'><h4 ><a class='secnum' href='#tuple.special' style='min-width:118pt'>20.4.2.9</a> Tuple specialized algorithms <a class='abbr_ref' href='tuple.special'>[tuple.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='tuple.special-1'><div class='marginalizedparent'><a class='marginalized' href='#tuple.special-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
noexcept(x.swap(y))
</pre></div></div><div class='para' id='tuple.special-2'><div class='marginalizedparent'><a class='marginalized' href='#tuple.special-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>
</p></div></div></div></div></div><div id='intseq'><h2 ><a class='secnum' href='#intseq' style='min-width:88pt'>20.5</a> Compile-time integer sequences <a class='abbr_ref' href='intseq'>[intseq]</a></h2><div id='intseq.general'><h3 ><a class='secnum' href='#intseq.general' style='min-width:103pt'>20.5.1</a> In general <a class='abbr_ref' href='intseq.general'>[intseq.general]</a></h3><div class='para' id='intseq.general-1'><div class='marginalizedparent'><a class='marginalized' href='#intseq.general-1'>1</a></div><p >The library provides a class template that can represent an integer sequence.
When used as an argument to a function template the parameter pack defining the
sequence can be deduced and used in a pack expansion.</p></div><div class='para' id='intseq.general-2'><div class='marginalizedparent'><a class='marginalized' href='#intseq.general-2'>2</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class F, class Tuple, std::size_t... I&gt;
  decltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
    return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
  }

template&lt;class F, class Tuple&gt;
  decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) {
    using Indices = make_index_sequence&lt;std::tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;;
    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t), Indices());
  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
The <span class='texttt'>index_sequence</span> alias template is provided for the common case of
an integer sequence of type <span class='texttt'>size_t</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='intseq.intseq'><h3 ><a class='secnum' href='#intseq.intseq' style='min-width:103pt'>20.5.2</a> Class template <span class='texttt'>integer_sequence</span> <a class='abbr_ref' href='intseq.intseq'>[intseq.intseq]</a></h3><p ><span class='indexparent'><a class='index' id='integer_sequence'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T, T... I&gt;
  struct integer_sequence {
    typedef T value_type;
    static constexpr size_t size() noexcept { return sizeof...(I); }
  };
}
</pre><div class='para' id='intseq.intseq-1'><div class='marginalizedparent'><a class='marginalized' href='#intseq.intseq-1'>1</a></div><p ><span class='texttt'>T</span> shall be an integer type.</p></div></div><div id='intseq.make'><h3 ><a class='secnum' href='#intseq.make' style='min-width:103pt'>20.5.3</a> Alias template <span class='texttt'>make_integer_sequence</span> <a class='abbr_ref' href='intseq.make'>[intseq.make]</a></h3><p ><span class='indexparent'><a class='index' id='make_integer_sequence'></a></span><code class='itemdecl'>
template&lt;class T, T N&gt;
  using make_integer_sequence = integer_sequence&lt;T, <i><span class='texttt'>see below</span></i>&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='intseq.make-1'><div class='marginalizedparent'><a class='marginalized' href='#intseq.make-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>N</span> is negative the program is ill-formed. The alias template
<span class='texttt'>make_integer_sequence</span> denotes a specialization of
<span class='texttt'>integer_sequence</span> with <span class='texttt'>N</span> template non-type arguments.
The type <span class='texttt'>make_integer_sequence&lt;T, N&gt;</span> denotes the type
<span class='texttt'>integer_sequence&lt;T, 0, 1, ..., N-1&gt;</span>.
[&nbsp;<i>Note:</i> <span class='texttt'>make_integer_sequence&lt;int, 0&gt;</span> denotes the type
<span class='texttt'>integer_sequence&lt;int&gt;</span> <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div><div id='template.bitset'><h2 ><a class='secnum' href='#template.bitset' style='min-width:88pt'>20.6</a> Class template <span class='texttt'>bitset</span> <a class='abbr_ref' href='template.bitset'>[template.bitset]</a></h2><p ><span class='indexparent'><a class='index' id='bitset'></a></span></p><p ><b>Header <span class='texttt'>&lt;bitset&gt;</span> synopsis</b><span class='indexparent'><a class='index' id='bitset'></a></span></p><pre class='codeblock'>
#include &lt;string&gt;
#include &lt;iosfwd&gt;               <span class='comment'>// for <span class='texttt'>istream</span>, <span class='texttt'>ostream</span>
</span>namespace std {
  template &lt;size_t N&gt; class bitset;

  <span class='comment'>// <a href='bitset.operators'>[bitset.operators]</a> bitset operators:
</span>  template &lt;size_t N&gt;
    bitset&lt;N&gt; operator&amp;(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template &lt;size_t N&gt;
    bitset&lt;N&gt; operator|(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template &lt;size_t N&gt;
    bitset&lt;N&gt; operator^(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template &lt;class charT, class traits, size_t N&gt;
    basic_istream&lt;charT, traits&gt;&amp;
    operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, bitset&lt;N&gt;&amp; x);
  template &lt;class charT, class traits, size_t N&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const bitset&lt;N&gt;&amp; x);
}
</pre><div class='para' id='template.bitset-1'><div class='marginalizedparent'><a class='marginalized' href='#template.bitset-1'>1</a></div><p >The header
<span class='texttt'>&lt;bitset&gt;</span>
defines a
class template
and several related functions for representing
and manipulating fixed-size sequences of bits.</p><pre class='codeblock'>
namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    <span class='comment'>// bit reference:
</span>    class reference {
      friend class bitset;
      reference() noexcept;
    public:
     ~reference() noexcept;
      reference&amp; operator=(bool x) noexcept;             <span class='comment'>// for <span class='texttt'>b[i] = x;</span>
</span>      reference&amp; operator=(const reference&amp;) noexcept;   <span class='comment'>// for <span class='texttt'>b[i] = b[j];</span>
</span>      bool operator~() const noexcept;                   <span class='comment'>// flips the bit
</span>      operator bool() const noexcept;                    <span class='comment'>// for <span class='texttt'>x = b[i];</span>
</span>      reference&amp; flip() noexcept;                        <span class='comment'>// for <span class='texttt'>b[i].flip();</span>
</span>    };

    <span class='comment'>// <a href='bitset.cons'>[bitset.cons]</a> constructors:
</span>    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
          basic_string&lt;charT,traits,Allocator&gt;::npos,
          charT zero = charT('0'), charT one = charT('1'));
    template &lt;class charT&gt;
      explicit bitset(
        const charT* str,
        typename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,
        charT zero = charT('0'), charT one = charT('1'));

    <span class='comment'>// <a href='bitset.members'>[bitset.members]</a> bitset operations:
</span>    bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) noexcept;
    bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) noexcept;
    bitset&lt;N&gt;&amp; set() noexcept;
    bitset&lt;N&gt;&amp; set(size_t pos, bool val = true);
    bitset&lt;N&gt;&amp; reset() noexcept;
    bitset&lt;N&gt;&amp; reset(size_t pos);
    bitset&lt;N&gt;  operator~() const noexcept;
    bitset&lt;N&gt;&amp; flip() noexcept;
    bitset&lt;N&gt;&amp; flip(size_t pos);

    <span class='comment'>// element access:
</span>    constexpr bool operator[](size_t pos) const;       <span class='comment'>// for <span class='texttt'>b[i];</span>
</span>    reference operator[](size_t pos);                  <span class='comment'>// for <span class='texttt'>b[i];</span>
</span>
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template &lt;class charT = char,
        class traits = char_traits&lt;charT&gt;,
        class Allocator = allocator&lt;charT&gt; &gt;
      basic_string&lt;charT, traits, Allocator&gt;
      to_string(charT zero = charT('0'), charT one = charT('1')) const;
    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset&lt;N&gt;&amp; rhs) const noexcept;
    bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset&lt;N&gt; operator&lt;&lt;(size_t pos) const noexcept;
    bitset&lt;N&gt; operator&gt;&gt;(size_t pos) const noexcept;
  };

  <span class='comment'>// <a href='bitset.hash'>[bitset.hash]</a> hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
}
</pre></div><div class='para' id='template.bitset-2'><div class='marginalizedparent'><a class='marginalized' href='#template.bitset-2'>2</a></div><p >The class template
<span class='texttt'>bitset&lt;N&gt;</span>describes an object that can store a sequence consisting of a fixed number of
bits, <span class='texttt'>N</span>.</p></div><div class='para' id='template.bitset-3'><div class='marginalizedparent'><a class='marginalized' href='#template.bitset-3'>3</a></div><p >Each bit represents either the value zero (reset) or one (set).
To
<a class='hidden_link' href='#def:toggle' id='def:toggle'><i>toggle</i></a>
a bit is to change the value zero to one, or the value one to
zero.
Each bit has a non-negative position <span class='texttt'>pos</span>.
When converting
between an object of class
<span class='texttt'>bitset&lt;N&gt;</span>
and a value of some
integral type, bit position <span class='texttt'>pos</span> corresponds to the
<a class='hidden_link' href='#def:bit_value' id='def:bit_value'><i>bit value</i></a>
<span class='texttt'>1 &lt;&lt; pos</span>.
The integral value corresponding to two
or more bits is the sum of their bit values.</p></div><div class='para' id='template.bitset-4'><div class='marginalizedparent'><a class='marginalized' href='#template.bitset-4'>4</a></div><p >The functions described in this subclause can report three kinds of
errors, each associated with a distinct exception:</p><ul class='itemize'><li id='template.bitset-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#template.bitset-4.1'>(4.1)</a></div><p >an
<a class='hidden_link' href='#def:invalid-argument' id='def:invalid-argument'><i>invalid-argument</i></a>
error is associated with exceptions of type
<span class='texttt'>invalid_argument</span> (<a href='invalid.argument'>[invalid.argument]</a>);
<span class='indexparent'><a class='index' id='invalid_argument'></a></span></p></li><li id='template.bitset-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#template.bitset-4.2'>(4.2)</a></div><p >an
<a class='hidden_link' href='#def:out-of-range' id='def:out-of-range'><i>out-of-range</i></a>
error is associated with exceptions of type
<span class='texttt'>out_of_range</span> (<a href='out.of.range'>[out.of.range]</a>);
<span class='indexparent'><a class='index' id='out_of_range'></a></span></p></li><li id='template.bitset-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#template.bitset-4.3'>(4.3)</a></div><p >an
<a class='hidden_link' href='#def:overflow' id='def:overflow'><i>overflow</i></a>
error is associated with exceptions of type
<span class='texttt'>overflow_error</span> (<a href='overflow.error'>[overflow.error]</a>).
<span class='indexparent'><a class='index' id='overflow_error'></a></span></p></li></ul></div><div id='bitset.cons'><h3 ><a class='secnum' href='#bitset.cons' style='min-width:103pt'>20.6.1</a> <span class='texttt'>bitset</span> constructors <a class='abbr_ref' href='bitset.cons'>[bitset.cons]</a></h3><p ><span class='indexparent'><a class='index' id='bitset,bitset'></a></span><code class='itemdecl'>
constexpr bitset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>bitset&lt;N&gt;</span>,
initializing all bits to zero.
</p></div></div><p ><span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<code class='itemdecl'>
constexpr bitset(unsigned long long val) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>bitset&lt;N&gt;</span>,
initializing the first <span class='texttt'>M</span> bit positions to the corresponding bit
values in <span class='texttt'>val</span>.
<span class='texttt'>M</span> is the smaller of <span class='texttt'>N</span> and the number of bits in the value
representation (<a href='basic.types'>[basic.types]</a>) of <span class='texttt'>unsigned long long</span>.
If <span class='texttt'>M &lt; N</span>, the remaining bit positions are initialized to zero.
</p></div></div><p ><span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<code class='itemdecl'>
template &lt;class charT, class traits, class Allocator&gt;
explicit
bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
         basic_string&lt;charT, traits, Allocator&gt;::npos,
         charT zero = charT('0'), charT one = charT('1'));
</code></p><div class='itemdescr'></div><div class='para' id='bitset.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos &lt;= str.size()</span>.</p></div></div><div class='para' id='bitset.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if
<span class='texttt'>pos &gt; str.size()</span>.<span class='indexparent'><a class='index' id='out_of_range'></a></span></p></div></div><div class='para' id='bitset.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Determines the effective length
<span class='texttt'>rlen</span> of the initializing string as the smaller of
<span class='texttt'>n</span> and
<span class='texttt'>str.size() - pos</span>.</p><p >The function then throws<span class='indexparent'><a class='index' id='invalid_argument'></a></span>
<span class='texttt'>invalid_argument</span>
if any of the <span class='texttt'>rlen</span>
characters in <span class='texttt'>str</span> beginning at position <span class='texttt'>pos</span> is
other than <span class='texttt'>zero</span> or <span class='texttt'>one</span>. The function uses <span class='texttt'>traits::eq()</span>
to compare the character values.</p><p >Otherwise, the function constructs an object of class
<span class='texttt'>bitset&lt;N&gt;</span>,
initializing the first <span class='texttt'>M</span> bit
positions to values determined from the corresponding characters in the string
<span class='texttt'>str</span>.
<span class='texttt'>M</span> is the smaller of <span class='texttt'>N</span> and <span class='texttt'>rlen</span>.</p></div></div><div class='para' id='bitset.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-6'>6</a></div><div class='itemdescr'><p >An element of the constructed object has value zero if the
corresponding character in <span class='texttt'>str</span>, beginning at position
<span class='texttt'>pos</span>, is
<span class='texttt'>zero</span>.
Otherwise, the element has the value one.
Character position <span class='texttt'>pos + M - 1</span> corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit positions.</p></div></div><div class='para' id='bitset.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-7'>7</a></div><div class='itemdescr'><p >If <span class='texttt'>M &lt; N</span>, remaining bit positions are initialized to zero.
</p></div></div><p ><span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,bitset'></a></span>
<code class='itemdecl'>
template &lt;class charT&gt;
  explicit bitset(
    const charT* str,
    typename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,
    charT zero = charT('0'), charT one = charT('1'));
</code></p><div class='itemdescr'></div><div class='para' id='bitset.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#bitset.cons-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>bitset&lt;N&gt;</span> as if by</p><pre class='codeblock'>
bitset(
  n == basic_string&lt;charT&gt;::npos
    ? basic_string&lt;charT&gt;(str)
    : basic_string&lt;charT&gt;(str, n),
  0, n, zero, one)
</pre></div></div></div><div id='bitset.members'><h3 ><a class='secnum' href='#bitset.members' style='min-width:103pt'>20.6.2</a> <span class='texttt'>bitset</span> members <a class='abbr_ref' href='bitset.members'>[bitset.members]</a></h3><p ><span class='indexparent'><a class='index' id='operator&=,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-1'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Clears each bit in
<span class='texttt'>*this</span>
for which the corresponding bit in <span class='texttt'>rhs</span> is clear, and leaves all other bits unchanged.</p></div></div><div class='para' id='bitset.members-2'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator|=,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-3'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sets each bit in
<span class='texttt'>*this</span>
for which the corresponding bit in <span class='texttt'>rhs</span> is set, and leaves all other bits unchanged.</p></div></div><div class='para' id='bitset.members-4'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator^=,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-5'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Toggles each bit in
<span class='texttt'>*this</span>
for which the corresponding bit in <span class='texttt'>rhs</span> is set, and leaves all other bits unchanged.</p></div></div><div class='para' id='bitset.members-6'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<=,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-7'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Replaces each bit at position <span class='texttt'>I</span> in
<span class='texttt'>*this</span>
with a value determined as follows:</p><ul class='itemize'><li id='bitset.members-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.members-7.1'>(7.1)</a></div><p >If <span class='texttt'>I &lt; pos</span>, the new value is zero;
</p></li><li id='bitset.members-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.members-7.2'>(7.2)</a></div><p >If <span class='texttt'>I &gt;= pos</span>, the new value is the previous
value of the bit at position <span class='texttt'>I - pos</span>.
</p></li></ul></div></div><div class='para' id='bitset.members-8'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>>=,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-9'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Replaces each bit at position <span class='texttt'>I</span> in
<span class='texttt'>*this</span>
with a value determined as follows:</p><ul class='itemize'><li id='bitset.members-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.members-9.1'>(9.1)</a></div><p >If <span class='texttt'>pos &gt;= N - I</span>, the new value is zero;
</p></li><li id='bitset.members-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.members-9.2'>(9.2)</a></div><p >If <span class='texttt'>pos &lt; N - I</span>, the new value is the previous value of the bit at position <span class='texttt'>I + pos</span>.
</p></li></ul></div></div><div class='para' id='bitset.members-10'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='set,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,set'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;&amp; set() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-11'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sets all bits in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-12'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='set,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,set'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;&amp; set(size_t pos, bool val = true);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-13'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> is valid</p></div></div><div class='para' id='bitset.members-14'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-14'>14</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if <span class='texttt'>pos</span> does not correspond to a valid bit position.<span class='indexparent'><a class='index' id='out_of_range'></a></span></p></div></div><div class='para' id='bitset.members-15'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>
Stores a new value in the bit at position <span class='texttt'>pos</span> in
<span class='texttt'>*this</span>.
If <span class='texttt'>val</span> is nonzero, the stored value is one, otherwise it is zero.</p></div></div><div class='para' id='bitset.members-16'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,reset'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;&amp; reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-17'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i>
Resets all bits in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-18'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,reset'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;&amp; reset(size_t pos);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-19'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> is valid</p></div></div><div class='para' id='bitset.members-20'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if <span class='texttt'>pos</span> does not correspond to a valid bit position.
<span class='indexparent'><a class='index' id='out_of_range'></a></span>
</p></div></div><div class='para' id='bitset.members-21'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i>
Resets the bit at position <span class='texttt'>pos</span> in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-22'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator~() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-23'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object <span class='texttt'>x</span> of class
<span class='texttt'>bitset&lt;N&gt;</span>
and initializes it with
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-24'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.flip()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='flip,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt;&amp; flip() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-25'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-25'>25</a></div><div class='itemdescr'><p ><i>Effects:</i>
Toggles all bits in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-26'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-26'>26</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='flip,bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,flip'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;&amp; flip(size_t pos);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-27'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-27'>27</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> is valid</p></div></div><div class='para' id='bitset.members-28'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-28'>28</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if <span class='texttt'>pos</span> does not correspond to a valid bit position.<span class='indexparent'><a class='index' id='out_of_range'></a></span></p></div></div><div class='para' id='bitset.members-29'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i>
Toggles the bit at position <span class='texttt'>pos</span> in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='bitset.members-30'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-30'>30</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_ulong,bitset'></a></span><code class='itemdecl'>
unsigned long to_ulong() const;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-31'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-31'>31</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>overflow_error</span><span class='indexparent'><a class='index' id='overflow_error'></a></span>
if the integral value <span class='texttt'>x</span> corresponding to the bits in
<span class='texttt'>*this</span>
cannot be represented as type
<span class='texttt'>unsigned long</span>.</p></div></div><div class='para' id='bitset.members-32'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-32'>32</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_ullong,bitset'></a></span><code class='itemdecl'>
unsigned long long to_ullong() const;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-33'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-33'>33</a></div><div class='itemdescr'><p ><span class='indexparent'><a class='index' id='overflow_error'></a></span><i>Throws:</i>
<span class='texttt'>overflow_error</span>
if the integral value <span class='texttt'>x</span> corresponding to the bits in
<span class='texttt'>*this</span>
cannot be represented as type
<span class='texttt'>unsigned long long</span>.</p></div></div><div class='para' id='bitset.members-34'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-34'>34</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,bitset'></a></span><code class='itemdecl'>
template &lt;class charT = char,
    class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt; &gt;
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-35'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a string object of the appropriate type
and initializes it to a string of length <span class='texttt'>N</span> characters.
Each character is determined by the value of its corresponding bit position in
<span class='texttt'>*this</span>.
Character position <span class='texttt'>N - 1</span> corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit
positions.
Bit value zero becomes the character <span class='texttt'>zero</span>,
bit value one becomes the character
<span class='texttt'>one</span>.</p></div></div><div class='para' id='bitset.members-36'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i>
The created object.
</p></div></div><p ><span class='indexparent'><a class='index' id='count,bitset'></a></span><code class='itemdecl'>
size_t count() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-37'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-37'>37</a></div><div class='itemdescr'><p ><i>Returns:</i>
A count of the number of bits set in
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,bitset'></a></span><code class='itemdecl'>
constexpr size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-38'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-38'>38</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>N</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,bitset'></a></span><code class='itemdecl'>
bool operator==(const bitset&lt;N&gt;&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-39'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-39'>39</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if the value of each bit in
<span class='texttt'>*this</span>
equals the value of the corresponding bit in <span class='texttt'>rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,bitset'></a></span><code class='itemdecl'>
bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-40'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-40'>40</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if
<span class='texttt'>!(*this == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='test,bitset'></a></span><code class='itemdecl'>
bool test(size_t pos) const;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-41'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-41'>41</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> is valid</p></div></div><div class='para' id='bitset.members-42'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-42'>42</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if <span class='texttt'>pos</span> does not correspond to a valid bit position.<span class='indexparent'><a class='index' id='out_of_range'></a></span></p></div></div><div class='para' id='bitset.members-43'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-43'>43</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if the bit at position <span class='texttt'>pos</span>
in
<span class='texttt'>*this</span>
has the value one.
</p></div></div><p ><span class='indexparent'><a class='index' id='all,bitset'></a></span><code class='itemdecl'>
bool all() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-44'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-44'>44</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>count() == size()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='any,bitset'></a></span><code class='itemdecl'>
bool any() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-45'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-45'>45</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>count() != 0</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='none,bitset'></a></span><code class='itemdecl'>
bool none() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-46'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-46'>46</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>count() == 0</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator&lt;&lt;(size_t pos) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-47'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-47'>47</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>bitset&lt;N&gt;(*this) &lt;&lt;= pos</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>>,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator&gt;&gt;(size_t pos) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-48'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-48'>48</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>bitset&lt;N&gt;(*this) &gt;&gt;= pos</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,operator[]'></a></span>
<code class='itemdecl'>
constexpr bool operator[](size_t pos) const;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-49'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-49'>49</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> shall be valid.</p></div></div><div class='para' id='bitset.members-50'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-50'>50</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if the bit at position <span class='texttt'>pos</span> in <span class='texttt'>*this</span> has the value
one, otherwise <span class='texttt'>false</span>.</p></div></div><div class='para' id='bitset.members-51'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-51'>51</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],bitset'></a></span>
<span class='indexparent'><a class='index' id='bitset,operator[]'></a></span>
<code class='itemdecl'>
bitset&lt;N&gt;::reference operator[](size_t pos);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.members-52'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-52'>52</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos</span> shall be valid.</p></div></div><div class='para' id='bitset.members-53'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-53'>53</a></div><div class='itemdescr'><p ><i>Returns:</i>
An object of type
<span class='texttt'>bitset&lt;N&gt;::reference</span>
such that
<span class='texttt'>(*this)[pos] == this-&gt;test(pos)</span>,
and such that
<span class='texttt'>(*this)[pos] = val</span>
is equivalent to
<span class='texttt'>this-&gt;set(pos, val)</span>.</p></div></div><div class='para' id='bitset.members-54'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-54'>54</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='bitset.members-55'><div class='marginalizedparent'><a class='marginalized' href='#bitset.members-55'>55</a></div><div class='itemdescr'><p ><i>Remark:</i> For the purpose of determining the presence of a data
race (<a href='intro.multithread'>[intro.multithread]</a>), any access or update through the resulting
reference potentially accesses or modifies, respectively, the entire
underlying bitset.
</p></div></div></div><div id='bitset.hash'><h3 ><a class='secnum' href='#bitset.hash' style='min-width:103pt'>20.6.3</a> <span class='texttt'>bitset</span> hash support <a class='abbr_ref' href='bitset.hash'>[bitset.hash]</a></h3><p ><span class='indexparent'><a class='index' id='hash_code'></a></span><code class='itemdecl'>
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#bitset.hash-1'>1</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div><div id='bitset.operators'><h3 ><a class='secnum' href='#bitset.operators' style='min-width:103pt'>20.6.4</a> <span class='texttt'>bitset</span> operators <a class='abbr_ref' href='bitset.operators'>[bitset.operators]</a></h3><p ><span class='indexparent'><a class='index' id='operator&,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator&amp;(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.operators-1'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>bitset&lt;N&gt;(lhs) &amp;= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator|,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator|(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.operators-2'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>bitset&lt;N&gt;(lhs) |= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator^,bitset'></a></span><code class='itemdecl'>
bitset&lt;N&gt; operator^(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='bitset.operators-3'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>bitset&lt;N&gt;(lhs) ^= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>>,bitset'></a></span><code class='itemdecl'>
template &lt;class charT, class traits, size_t N&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, bitset&lt;N&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.operators-4'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-4'>4</a></div><div class='itemdescr'><p >A formatted input function (<a href='istream.formatted'>[istream.formatted]</a>).</p></div></div><div class='para' id='bitset.operators-5'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Extracts up to <span class='texttt'>N</span> characters from <span class='texttt'>is</span>.
Stores these characters in a temporary object <span class='texttt'>str</span> of type
<span class='texttt'>basic_string&lt;charT, traits&gt;</span>,
then evaluates the expression
<span class='texttt'>x = bitset&lt;N&gt;(str)</span>.
Characters are extracted and stored until any of the following occurs:</p><ul class='itemize'><li id='bitset.operators-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.operators-5.1'>(5.1)</a></div><p ><span class='texttt'>N</span> characters have been extracted and stored;
</p></li><li id='bitset.operators-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.operators-5.2'>(5.2)</a></div><p >end-of-file occurs on the input sequence;<span class='indexparent'><a class='index' id='end-of-file'></a></span>
</p></li><li id='bitset.operators-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bitset.operators-5.3'>(5.3)</a></div><p >the next input character is neither
<span class='texttt'>is.widen('0')</span>
nor
<span class='texttt'>is.widen('1')</span>
(in which case the input character is not extracted).
</p></li></ul></div></div><div class='para' id='bitset.operators-6'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-6'>6</a></div><div class='itemdescr'><p >If no characters are stored in <span class='texttt'>str</span>, calls
<span class='texttt'>is.setstate(ios_base::failbit)</span>
(which may throw
<span class='texttt'>ios_base::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).</p></div></div><div class='para' id='bitset.operators-7'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>is</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<,bitset'></a></span><code class='itemdecl'>
template &lt;class charT, class traits, size_t N&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const bitset&lt;N&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='bitset.operators-8'><div class='marginalizedparent'><a class='marginalized' href='#bitset.operators-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
os &lt;&lt; x.template to_string&lt;charT,traits,allocator&lt;charT&gt; &gt;(
  use_facet&lt;ctype&lt;charT&gt; &gt;(os.getloc()).widen('0'),
  use_facet&lt;ctype&lt;charT&gt; &gt;(os.getloc()).widen('1'))
</pre><p >(see <a href='ostream.formatted'>[ostream.formatted]</a>).
</p></div></div></div></div><div id='memory'><h2 ><a class='secnum' href='#memory' style='min-width:88pt'>20.7</a> Memory <a class='abbr_ref' href='memory'>[memory]</a></h2><div id='memory.general'><h3 ><a class='secnum' href='#memory.general' style='min-width:103pt'>20.7.1</a> In general <a class='abbr_ref' href='memory.general'>[memory.general]</a></h3><div class='para' id='memory.general-1'><div class='marginalizedparent'><a class='marginalized' href='#memory.general-1'>1</a></div><p >This subclause describes the contents of the header
<span class='texttt'>&lt;memory&gt;</span> (<a href='memory.syn'>[memory.syn]</a>) and some
of the contents of the C headers <span class='texttt'>&lt;cstdlib&gt;</span> and
<span class='texttt'>&lt;cstring&gt;</span> (<a href='c.malloc'>[c.malloc]</a>).</p></div></div><div id='memory.syn'><h3 ><a class='secnum' href='#memory.syn' style='min-width:103pt'>20.7.2</a> Header <span class='texttt'>&lt;memory&gt;</span> synopsis <a class='abbr_ref' href='memory.syn'>[memory.syn]</a></h3><div class='para' id='memory.syn-1'><div class='marginalizedparent'><a class='marginalized' href='#memory.syn-1'>1</a></div><p >The header <span class='texttt'>&lt;memory&gt;</span> defines several types and function templates that
describe properties of pointers and pointer-like types, manage memory
for containers and other template types, and construct multiple objects in
uninitialized memory
buffers (<a href='pointer.traits'>[pointer.traits]</a>–<a href='specialized.algorithms'>[specialized.algorithms]</a>).
The header also defines the templates
<span class='texttt'>unique_ptr</span>, <span class='texttt'>shared_ptr</span>, <span class='texttt'>weak_ptr</span>, and various function
templates that operate on objects of these types (<a href='smartptr'>[smartptr]</a>).</p><p ><span class='indexparent'><a class='index' id='memory'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='pointer.traits'>[pointer.traits]</a>, pointer traits
</span>  template &lt;class Ptr&gt; struct pointer_traits;
  template &lt;class T&gt; struct pointer_traits&lt;T*&gt;;

  <span class='comment'>// <a href='util.dynamic.safety'>[util.dynamic.safety]</a>, pointer safety
</span>  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template &lt;class T&gt; T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;

  <span class='comment'>// <a href='ptr.align'>[ptr.align]</a>, pointer alignment function
</span>  void* align(std::size_t alignment, std::size_t size,
    void*&amp; ptr, std::size_t&amp; space);

  <span class='comment'>// <a href='allocator.tag'>[allocator.tag]</a>, allocator argument tag
</span>  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};

  <span class='comment'>// <a href='allocator.uses'>[allocator.uses]</a>, <span class='texttt'>uses_allocator</span>
</span>  template &lt;class T, class Alloc&gt; struct uses_allocator;

  <span class='comment'>// <a href='allocator.traits'>[allocator.traits]</a>, allocator traits
</span>  template &lt;class Alloc&gt; struct allocator_traits;

  <span class='comment'>// <a href='default.allocator'>[default.allocator]</a>, the default allocator:
</span>  template &lt;class T&gt; class allocator;
  template &lt;&gt; class allocator&lt;void&gt;;
  template &lt;class T, class U&gt;
    bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
  template &lt;class T, class U&gt;
    bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;

  <span class='comment'>// <a href='storage.iterator'>[storage.iterator]</a>, raw storage iterator:
</span>  template &lt;class OutputIterator, class T&gt; class raw_storage_iterator;

  <span class='comment'>// <a href='temporary.buffer'>[temporary.buffer]</a>, temporary buffers:
</span>  template &lt;class T&gt;
    pair&lt;T*,ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t n) noexcept;
  template &lt;class T&gt;
    void return_temporary_buffer(T* p);

  <span class='comment'>// <a href='specialized.algorithms'>[specialized.algorithms]</a>, specialized algorithms:
</span>  template &lt;class T&gt; T* addressof(T&amp; r) noexcept;
  template &lt;class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template &lt;class InputIterator, class Size, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template &lt;class ForwardIterator, class T&gt;
    void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                            const T&amp; x);
  template &lt;class ForwardIterator, class Size, class T&gt;
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);

  <span class='comment'>// <a href='unique.ptr'>[unique.ptr]</a> class template unique_ptr:
</span>  template &lt;class T&gt; struct default_delete;
  template &lt;class T&gt; struct default_delete&lt;T[]&gt;;
  template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;

  template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);
  template &lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);
  template &lt;class T, class... Args&gt; <i><span class='texttt'>unspecified</span></i> make_unique(Args&amp;&amp;...) = delete;

  template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;

  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  template &lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);

  <span class='comment'>// <a href='util.smartptr.weakptr'>[util.smartptr.weakptr]</a>, class bad_weak_ptr:
</span>  class bad_weak_ptr;

  <span class='comment'>// <a href='util.smartptr.shared'>[util.smartptr.shared]</a>, class template shared_ptr:
</span>  template&lt;class T&gt; class shared_ptr;

  <span class='comment'>// <a href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a>, shared_ptr creation
</span>  template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

  <span class='comment'>// <a href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a>, shared_ptr comparisons:
</span>  template&lt;class T, class U&gt;
    bool operator==(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;

  template &lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a>, shared_ptr specialized algorithms:
</span>  template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a>, shared_ptr casts:
</span>  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;

  <span class='comment'>// <a href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a>, shared_ptr get_deleter:
</span>  template&lt;class D, class T&gt; D* get_deleter(shared_ptr&lt;T&gt; const&amp; p) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a>, shared_ptr I/O:
</span>  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, shared_ptr&lt;Y&gt; const&amp; p);

  <span class='comment'>// <a href='util.smartptr.weak'>[util.smartptr.weak]</a>, class template weak_ptr:
</span>  template&lt;class T&gt; class weak_ptr;

  <span class='comment'>// <a href='util.smartptr.weak.spec'>[util.smartptr.weak.spec]</a>, weak_ptr specialized algorithms:
</span>  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.ownerless'>[util.smartptr.ownerless]</a>, class template owner_less:
</span>  template&lt;class T&gt; class owner_less;

  <span class='comment'>// <a href='util.smartptr.enab'>[util.smartptr.enab]</a>, class template enable_shared_from_this:
</span>  template&lt;class T&gt; class enable_shared_from_this;

  <span class='comment'>// <a href='util.smartptr.shared.atomic'>[util.smartptr.shared.atomic]</a>, shared_ptr atomic access:
</span>  template&lt;class T&gt;
    bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);

  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);

  template&lt;class T&gt;
    void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);

  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                           memory_order mo);

  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);

  <span class='comment'>// <a href='util.smartptr.hash'>[util.smartptr.hash]</a> hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
  template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;

  <span class='comment'>// <a href='depr.auto.ptr'>[depr.auto.ptr]</a>, auto_ptr (deprecated)
</span>  template &lt;class X&gt; class auto_ptr;
}
</pre></div></div><div id='pointer.traits'><h3 ><a class='secnum' href='#pointer.traits' style='min-width:103pt'>20.7.3</a> Pointer traits <a class='abbr_ref' href='pointer.traits'>[pointer.traits]</a></h3><div class='para' id='pointer.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits-1'>1</a></div><p >The class template <span class='texttt'>pointer_traits</span> supplies a uniform interface to certain
attributes of pointer-like types.</p><p ><span class='indexparent'><a class='index' id='pointer_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Ptr&gt; struct pointer_traits {
    typedef Ptr       pointer;
    typedef <i><span class='texttt'>see below</span></i> element_type;
    typedef <i><span class='texttt'>see below</span></i> difference_type;

    template &lt;class U&gt; using rebind = <i><span class='texttt'>see below</span></i>;

    static pointer pointer_to(<i><span class='texttt'>see below</span></i> r);
  };

  template &lt;class T&gt; struct pointer_traits&lt;T*&gt; {
    typedef T*        pointer;
    typedef T         element_type;
    typedef ptrdiff_t difference_type;

    template &lt;class U&gt; using rebind = U*;

    static pointer pointer_to(<i><span class='texttt'>see below</span></i> r) noexcept;
  };
}
</pre></div><div id='pointer.traits.types'><h4 ><a class='secnum' href='#pointer.traits.types' style='min-width:118pt'>20.7.3.1</a> Pointer traits member types <a class='abbr_ref' href='pointer.traits.types'>[pointer.traits.types]</a></h4><p ><span class='indexparent'><a class='index' id='pointer_traits,element_type'></a></span><span class='indexparent'><a class='index' id='element_type,pointer_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> element_type;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Ptr::element_type</span> if such a type exists; otherwise, <span class='texttt'>T</span> if
<span class='texttt'>Ptr</span> is a class template instantiation of the form <span class='texttt'>SomePointer&lt;T, Args&gt;</span>,
where <span class='texttt'>Args</span> is zero or more type arguments; otherwise, the specialization is
ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='pointer_traits,difference_type'></a></span><span class='indexparent'><a class='index' id='difference_type,pointer_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> difference_type;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-2'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-2'>2</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Ptr::difference_type</span> if such a type exists; otherwise,
<span class='texttt'>std::ptrdiff_t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pointer_traits,rebind'></a></span><span class='indexparent'><a class='index' id='rebind,pointer_traits'></a></span><code class='itemdecl'>
template &lt;class U&gt; using rebind = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-3'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-3'>3</a></div><div class='itemdescr'><p ><i>Alias template:</i> <span class='texttt'>Ptr::rebind&lt;U&gt;</span> if such a type exists; otherwise,
<span class='texttt'>SomePointer&lt;U, Args&gt;</span> if
<span class='texttt'>Ptr</span> is a class template instantiation of the form <span class='texttt'>SomePointer&lt;T, Args&gt;</span>,
where <span class='texttt'>Args</span> is zero or more type arguments; otherwise, the instantiation of
<span class='texttt'>rebind</span> is ill-formed.
</p></div></div></div><div id='pointer.traits.functions'><h4 ><a class='secnum' href='#pointer.traits.functions' style='min-width:118pt'>20.7.3.2</a> Pointer traits member functions <a class='abbr_ref' href='pointer.traits.functions'>[pointer.traits.functions]</a></h4><p ><span class='indexparent'><a class='index' id='pointer_traits,pointer_to'></a></span><span class='indexparent'><a class='index' id='pointer_to,pointer_traits'></a></span><code class='itemdecl'>
static pointer pointer_traits::pointer_to(<i><span class='texttt'>see below</span></i> r);
static pointer pointer_traits&lt;T*&gt;::pointer_to(<i><span class='texttt'>see below</span></i> r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.functions-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.functions-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> If <span class='texttt'>element_type</span> is (possibly cv-qualified) <span class='texttt'>void</span>, the type of
<span class='texttt'>r</span> is unspecified; otherwise, it is <span class='texttt'>element_type&amp;</span>.</p></div></div><div class='para' id='pointer.traits.functions-2'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.functions-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The first member function returns a pointer to <span class='texttt'>r</span>
obtained by calling <span class='texttt'>Ptr::pointer_to(r)</span> through which
indirection is valid; an instantiation of this function is
ill-formed if <span class='texttt'>Ptr</span> does not have a matching <span class='texttt'>pointer_to</span> static member
function. The second member function returns <span class='texttt'>std::addressof(r)</span>.
</p></div></div></div></div><div id='util.dynamic.safety'><h3 ><a class='secnum' href='#util.dynamic.safety' style='min-width:103pt'>20.7.4</a> Pointer safety <a class='abbr_ref' href='util.dynamic.safety'>[util.dynamic.safety]</a></h3><div class='para' id='util.dynamic.safety-1'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-1'>1</a></div><p >A complete object is <i>declared reachable</i> while the number of calls to
<span class='texttt'>declare_reachable</span> with an argument referencing the object exceeds the
number of calls to <span class='texttt'>undeclare_reachable</span> with an argument referencing the
object.</p><p ><span class='indexparent'><a class='index' id='declare_reachable'></a></span><code class='itemdecl'>
void declare_reachable(void* p);
</code></p></div><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-2'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall be a safely-derived
pointer (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>) or a null pointer value.</p></div></div><div class='para' id='util.dynamic.safety-3'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>p</span> is not null, the complete object referenced by <span class='texttt'>p</span>
is subsequently declared reachable (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>).</p></div></div><div class='para' id='util.dynamic.safety-4'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> May throw <span class='texttt'>std::bad_alloc</span> if the system cannot allocate
additional memory that may be required to track objects declared reachable.
</p></div></div><p ><span class='indexparent'><a class='index' id='undeclare_reachable'></a></span><code class='itemdecl'>
template &lt;class T&gt; T* undeclare_reachable(T* p);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-5'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>p</span> is not null, the complete object referenced by <span class='texttt'>p</span>
shall have been previously declared reachable, and shall be
live (<a href='basic.life'>[basic.life]</a>) from the time of the call until the last
<span class='texttt'>undeclare_reachable(p)</span> call on the object.</p></div></div><div class='para' id='util.dynamic.safety-6'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> A safely derived copy of <span class='texttt'>p</span> which shall compare equal to <span class='texttt'>p</span>.</p></div></div><div class='para' id='util.dynamic.safety-7'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='util.dynamic.safety-8'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> It is expected that calls to <span class='texttt'>declare_reachable(p)</span> will consume
a small amount of memory in addition to that occupied by the referenced object until the
matching call to <span class='texttt'>undeclare_reachable(p)</span> is encountered. Long running programs
should arrange that calls are matched. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div></div><p ><span class='indexparent'><a class='index' id='declare_no_pointers'></a></span><code class='itemdecl'>
void declare_no_pointers(char* p, size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-9'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> No bytes in the specified range
are currently registered with
<span class='texttt'>declare_no_pointers()</span>. If the specified range is in an allocated object,
then it must be entirely within a single allocated object. The object must be
live until the corresponding <span class='texttt'>undeclare_no_pointers()</span> call. [&nbsp;<i>Note:</i> In
a garbage-collecting implementation, the fact that a region in an object is
registered with <span class='texttt'>declare_no_pointers()</span> should not prevent the object from
being collected. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='util.dynamic.safety-10'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> The <span class='texttt'>n</span> bytes starting at <span class='texttt'>p</span> no longer contain
traceable pointer locations, independent of their type. Hence
indirection through a pointer located there is undefined if the object
it points to was created by global <span class='texttt'>operator new</span> and not
previously declared reachable. [&nbsp;<i>Note:</i> This may be used to inform a
garbage collector or leak detector that this region of memory need not
be traced. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='util.dynamic.safety-11'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='util.dynamic.safety-12'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-12'>12</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Under some conditions implementations may need to allocate memory.
However, the request can be ignored if memory allocation fails. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='undeclare_no_pointers'></a></span><code class='itemdecl'>
void undeclare_no_pointers(char* p, size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-13'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> The same range must previously have been passed to
<span class='texttt'>declare_no_pointers()</span>.</p></div></div><div class='para' id='util.dynamic.safety-14'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Unregisters a range registered with <span class='texttt'>declare_no_pointers()</span> for
destruction. It must be called before the lifetime of the object ends.</p></div></div><div class='para' id='util.dynamic.safety-15'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_pointer_safety'></a></span><code class='itemdecl'>
pointer_safety get_pointer_safety() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-16'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pointer_safety::strict</span> if the implementation has strict pointer
safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>). It is implementation defined<span class='indexparent'><a class='index' id='whether_get_pointer_safety_returns_pointer_safety::relaxed_or_pointer_safety::preferred_if_the_implementation_has_relaxed_pointer_safety'></a></span>
whether
<span class='texttt'>get_pointer_safety</span> returns <span class='texttt'>pointer_safety::relaxed</span> or
<span class='texttt'>pointer_safety::preferred</span> if the implementation has relaxed pointer
safety.<a class='footnotenum' href='#footnote-230'>230</a>
</p></div></div><div class='footnote' id='footnote-229'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-229'>229)</a></div><p ><span class='texttt'>pointer_safety::preferred</span> might be returned to indicate
that a leak detector is running so that the program can avoid spurious leak
reports.</p></div></div><div id='ptr.align'><h3 ><a class='secnum' href='#ptr.align' style='min-width:103pt'>20.7.5</a> Align <a class='abbr_ref' href='ptr.align'>[ptr.align]</a></h3><p ><span class='indexparent'><a class='index' id='align'></a></span><code class='itemdecl'>
void* align(std::size_t alignment, std::size_t size,
    void*&amp; ptr, std::size_t&amp; space);
</code></p><div class='itemdescr'></div><div class='para' id='ptr.align-1'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If it is possible to fit <span class='texttt'>size</span> bytes
of storage aligned by <span class='texttt'>alignment</span> into the buffer pointed to by
<span class='texttt'>ptr</span> with length <span class='texttt'>space</span>, the function updates
<span class='texttt'>ptr</span> to point to the first possible address of such storage
and decreases <span class='texttt'>space</span> by the number of bytes used for alignment.
Otherwise, the function does nothing.</p></div></div><div class='para' id='ptr.align-2'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i></p><ul class='itemize'><li id='ptr.align-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ptr.align-2.1'>(2.1)</a></div><p ><span class='texttt'>alignment</span> shall be a fundamental alignment value or an
extended alignment value supported by the implementation in this context</p></li><li id='ptr.align-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ptr.align-2.2'>(2.2)</a></div><p ><span class='texttt'>ptr</span> shall point to contiguous storage of at least
<span class='texttt'>space</span> bytes
</p></li></ul></div></div><div class='para' id='ptr.align-3'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A null pointer if the requested aligned buffer
would not fit into the available space, otherwise the adjusted value
of <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='ptr.align-4'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The function updates its <span class='texttt'>ptr</span>
and <span class='texttt'>space</span> arguments so that it can be called repeatedly
with possibly different <span class='texttt'>alignment</span> and <span class='texttt'>size</span>
arguments for the same buffer.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='allocator.tag'><h3 ><a class='secnum' href='#allocator.tag' style='min-width:103pt'>20.7.6</a> Allocator argument tag <a class='abbr_ref' href='allocator.tag'>[allocator.tag]</a></h3><p ><span class='indexparent'><a class='index' id='allocator_arg_t'></a></span>
<span class='indexparent'><a class='index' id='allocator_arg'></a></span>
<code class='itemdecl'>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</code></p><div class='para' id='allocator.tag-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.tag-1'>1</a></div><p >The <span class='texttt'>allocator_arg_t</span> struct is an empty structure type used as a unique type to
disambiguate constructor and function overloading. Specifically, several types (see
<span class='texttt'>tuple</span> <a href='tuple'>[tuple]</a>) have constructors with <span class='texttt'>allocator_arg_t</span> as the first
argument, immediately followed by an argument of a type that satisfies the
<span class='texttt'>Allocator</span> requirements (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div></div><div id='allocator.uses'><h3 ><a class='secnum' href='#allocator.uses' style='min-width:103pt'>20.7.7</a> <span class='texttt'>uses_allocator</span> <a class='abbr_ref' href='allocator.uses'>[allocator.uses]</a></h3><div id='allocator.uses.trait'><h4 ><a class='secnum' href='#allocator.uses.trait' style='min-width:118pt'>20.7.7.1</a> <span class='texttt'>uses_allocator</span> trait <a class='abbr_ref' href='allocator.uses.trait'>[allocator.uses.trait]</a></h4><p ><span class='indexparent'><a class='index' id='uses_allocator'></a></span><code class='itemdecl'>
template &lt;class T, class Alloc&gt; struct uses_allocator;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.uses.trait-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.uses.trait-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> automatically detects whether <span class='texttt'>T</span> has a nested <span class='texttt'>allocator_type</span> that
is convertible from <span class='texttt'>Alloc</span>. Meets the BinaryTypeTrait
requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation shall provide a definition that is
derived from <span class='texttt'>true_type</span> if a type <span class='texttt'>T::allocator_type</span> exists and
<span class='texttt'>is_convertible&lt;Alloc, T::allocator_type&gt;::value != false</span>, otherwise it shall be
derived from <span class='texttt'>false_type</span>. A program may specialize this template to derive from
<span class='texttt'>true_type</span> for a user-defined type <span class='texttt'>T</span> that does not have a nested
<span class='texttt'>allocator_type</span> but nonetheless can be constructed with an allocator where
either:</p><ul class='itemize'><li id='allocator.uses.trait-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.trait-1.1'>(1.1)</a></div><p >the first argument of a constructor has type <span class='texttt'>allocator_arg_t</span> and the
second argument has type <span class='texttt'>Alloc</span> or</p></li><li id='allocator.uses.trait-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.trait-1.2'>(1.2)</a></div><p >the last argument of a constructor has type <span class='texttt'>Alloc</span>.
</p></li></ul></div></div></div><div id='allocator.uses.construction'><h4 ><a class='secnum' href='#allocator.uses.construction' style='min-width:118pt'>20.7.7.2</a> uses-allocator construction <a class='abbr_ref' href='allocator.uses.construction'>[allocator.uses.construction]</a></h4><div class='para' id='allocator.uses.construction-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.uses.construction-1'>1</a></div><p ><a class='hidden_link' href='#def:Uses-allocator_construction' id='def:Uses-allocator_construction'><i>Uses-allocator construction</i></a> with allocator <span class='texttt'>Alloc</span> refers to the
construction of an object <span class='texttt'>obj</span> of type <span class='texttt'>T</span>, using constructor arguments
<span class='texttt'>v1, v2, ..., vN</span> of types <span class='texttt'>V1, V2, ..., VN</span>, respectively, and an allocator
<span class='texttt'>alloc</span> of type <span class='texttt'>Alloc</span>, according to the following rules:</p><ul class='itemize'><li id='allocator.uses.construction-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.1'>(1.1)</a></div><p >if <span class='texttt'>uses_allocator&lt;T, Alloc&gt;::value</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible&lt;T, V1, V2, ..., VN&gt;::value</span> is <span class='texttt'>true</span>, then <span class='texttt'>obj</span> is
initialized as <span class='texttt'>obj(v1, v2, ..., vN)</span>;</p></li><li id='allocator.uses.construction-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.2'>(1.2)</a></div><p >otherwise, if <span class='texttt'>uses_allocator&lt;T, Alloc&gt;::value</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T, allocator_arg_t, Alloc,</span> <span class='texttt'>V1, V2, ..., VN&gt;::value</span> is
<span class='texttt'>true</span>, then <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(allocator_arg, alloc, v1,
v2, ..., vN)</span>;</p></li><li id='allocator.uses.construction-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.3'>(1.3)</a></div><p >otherwise, if <span class='texttt'>uses_allocator&lt;T, Alloc&gt;::value</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T, V1, V2, ..., VN, Alloc&gt;::value</span> is <span class='texttt'>true</span>, then
<span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(v1, v2, ..., vN, alloc)</span>;</p></li><li id='allocator.uses.construction-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.4'>(1.4)</a></div><p >otherwise, the request for uses-allocator construction is ill-formed. [&nbsp;<i>Note:</i>
An error will result if <span class='texttt'>uses_allocator&lt;T, Alloc&gt;::value</span> is <span class='texttt'>true</span> but the
specific constructor does not take an allocator. This definition prevents a silent
failure to pass the allocator to an element. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div></div><div id='allocator.traits'><h3 ><a class='secnum' href='#allocator.traits' style='min-width:103pt'>20.7.8</a> Allocator traits <a class='abbr_ref' href='allocator.traits'>[allocator.traits]</a></h3><div class='para' id='allocator.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits-1'>1</a></div><p >The class template <span class='texttt'>allocator_traits</span> supplies a uniform interface to all
allocator types.
An allocator cannot be a non-class type, however, even if <span class='texttt'>allocator_traits</span>
supplies the entire required interface. [&nbsp;<i>Note:</i> Thus, it is always possible to create
a derived class from an allocator. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='allocator_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Alloc&gt; struct allocator_traits {
    typedef Alloc allocator_type;

    typedef typename Alloc::value_type value_type;

    typedef <i><span class='texttt'>see below</span></i> pointer;
    typedef <i><span class='texttt'>see below</span></i> const_pointer;
    typedef <i><span class='texttt'>see below</span></i> void_pointer;
    typedef <i><span class='texttt'>see below</span></i> const_void_pointer;

    typedef <i><span class='texttt'>see below</span></i> difference_type;
    typedef <i><span class='texttt'>see below</span></i> size_type;

    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_copy_assignment;
    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_move_assignment;
    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_swap;

    template &lt;class T&gt; using rebind_alloc = <i><span class='texttt'>see below</span></i>;
    template &lt;class T&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;T&gt; &gt;;

    static pointer allocate(Alloc&amp; a, size_type n);
    static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);

    static void deallocate(Alloc&amp; a, pointer p, size_type n);

    template &lt;class T, class... Args&gt;
      static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);

    template &lt;class T&gt;
      static void destroy(Alloc&amp; a, T* p);

    static size_type max_size(const Alloc&amp; a) noexcept;

    static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
  };
}
</pre></div><div id='allocator.traits.types'><h4 ><a class='secnum' href='#allocator.traits.types' style='min-width:118pt'>20.7.8.1</a> Allocator traits member types <a class='abbr_ref' href='allocator.traits.types'>[allocator.traits.types]</a></h4><p ><span class='indexparent'><a class='index' id='allocator_traits,pointer'></a></span><span class='indexparent'><a class='index' id='pointer,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> pointer;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::pointer</span> if such a type exists; otherwise, <span class='texttt'>value_type*</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,const_pointer'></a></span><span class='indexparent'><a class='index' id='const_pointer,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> const_pointer;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-2'>2</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::const_pointer</span> if such a type exists; otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::rebind&lt;<span class='discretionary'></span>const value_type&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,void_pointer'></a></span><span class='indexparent'><a class='index' id='void_pointer,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> void_pointer;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-3'>3</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::void_pointer</span> if such a type exists; otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::rebind&lt;<span class='discretionary'></span>void&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,const_void_pointer'></a></span><span class='indexparent'><a class='index' id='const_void_pointer,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> const_void_pointer;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-4'>4</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::const_void_pointer</span> if such a type exists; otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::<span class='discretionary'></span>rebind&lt;const void&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,difference_type'></a></span><span class='indexparent'><a class='index' id='difference_type,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> difference_type;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-5'>5</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::difference_type</span> if such a type exists; otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::difference_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,size_type'></a></span><span class='indexparent'><a class='index' id='size_type,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> size_type;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-6'>6</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::size_type</span> if such a type exists; otherwise,
<span class='texttt'>make_unsigned_t&lt;difference_type&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_copy_assignment'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_copy_assignment,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_copy_assignment;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-7'>7</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_copy_assignment</span> if such a type
exists, otherwise <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_move_assignment'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_move_assignment,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_move_assignment;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-8'>8</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_move_assignment</span> if such a type
exists, otherwise <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_swap'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_swap,allocator_traits'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_swap;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-9'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-9'>9</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_swap</span> if such a type exists, otherwise <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,rebind_alloc'></a></span><span class='indexparent'><a class='index' id='rebind_alloc,allocator_traits'></a></span><code class='itemdecl'>
template &lt;class T&gt; using rebind_alloc = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-10'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-10'>10</a></div><div class='itemdescr'><p ><i>Alias template:</i> <span class='texttt'>Alloc::rebind&lt;T&gt;::other</span> if such a type exists; otherwise,
<span class='texttt'>Alloc&lt;T, Args&gt;</span> if <span class='texttt'>Alloc</span> is a class template instantiation
of the form <span class='texttt'>Alloc&lt;U, Args&gt;</span>, where <span class='texttt'>Args</span> is zero or more type arguments;
otherwise, the instantiation of <span class='texttt'>rebind_alloc</span> is ill-formed.
</p></div></div></div><div id='allocator.traits.members'><h4 ><a class='secnum' href='#allocator.traits.members' style='min-width:118pt'>20.7.8.2</a> Allocator traits static member functions <a class='abbr_ref' href='allocator.traits.members'>[allocator.traits.members]</a></h4><p ><span class='indexparent'><a class='index' id='allocator_traits,allocate'></a></span><span class='indexparent'><a class='index' id='allocate,allocator_traits'></a></span><code class='itemdecl'>
static pointer allocate(Alloc&amp; a, size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.allocate(n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,allocate'></a></span><span class='indexparent'><a class='index' id='allocate,allocator_traits'></a></span><code class='itemdecl'>
static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.allocate(n, hint)</span> if that expression is well-formed; otherwise, <span class='texttt'>a.allocate(n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,deallocate'></a></span><span class='indexparent'><a class='index' id='deallocate,allocator_traits'></a></span><code class='itemdecl'>
static void deallocate(Alloc&amp; a, pointer p, size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>a.deallocate(p, n)</span>.</p></div></div><div class='para' id='allocator.traits.members-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,constructor'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
  static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>a.construct(p, std::forward&lt;Args&gt;(args)...)</span>
if that call is well-formed;
otherwise, invokes <span class='texttt'>::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,destructor'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  static void destroy(Alloc&amp; a, T* p);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>a.destroy(p)</span> if that call is well-formed; otherwise, invokes
<span class='texttt'>p-&gt;~T()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,max_size'></a></span><span class='indexparent'><a class='index' id='max_size,allocator_traits'></a></span><code class='itemdecl'>
static size_type max_size(const Alloc&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.max_size()</span> if that expression is well-formed; otherwise,
<span class='texttt'>numeric_limits&lt;size_type&gt;::<span class='discretionary'></span>max()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator_traits,select_on_container_copy_construction'></a></span><span class='indexparent'><a class='index' id='select_on_container_copy_construction,allocator_traits'></a></span><code class='itemdecl'>
static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.select_on_container_copy_construction()</span> if that expression is
well-formed; otherwise, <span class='texttt'>rhs</span>.
</p></div></div></div></div><div id='default.allocator'><h3 ><a class='secnum' href='#default.allocator' style='min-width:103pt'>20.7.9</a> The default allocator <a class='abbr_ref' href='default.allocator'>[default.allocator]</a></h3><p ><span class='indexparent'><a class='index' id='allocator'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class allocator;

  <span class='comment'>// specialize for <span class='texttt'>void</span>:
</span>  template &lt;&gt; class allocator&lt;void&gt; {
  public:
    typedef void*   pointer;
    typedef const void* const_pointer;
    <span class='comment'>// reference-to-<span class='texttt'>void</span> members are impossible.
</span>    typedef void  value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
  };

  template &lt;class T&gt; class allocator {
   public:
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;
    typedef T*        pointer;
    typedef const T*  const_pointer;
    typedef T&amp;        reference;
    typedef const T&amp;  const_reference;
    typedef T         value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
    typedef true_type propagate_on_container_move_assignment;
    
    allocator() noexcept;
    allocator(const allocator&amp;) noexcept;
    template &lt;class U&gt; allocator(const allocator&lt;U&gt;&amp;) noexcept;
   ~allocator();

    pointer address(reference x) const noexcept;
    const_pointer address(const_reference x) const noexcept;

    pointer allocate(
      size_type, allocator&lt;void&gt;::const_pointer hint = 0);
    void deallocate(pointer p, size_type n);
    size_type max_size() const noexcept;

    template&lt;class U, class... Args&gt;
      void construct(U* p, Args&amp;&amp;... args);
    template &lt;class U&gt;
      void destroy(U* p);
  };
}
</pre><div id='allocator.members'><h4 ><a class='secnum' href='#allocator.members' style='min-width:118pt'>20.7.9.1</a> <span class='texttt'>allocator</span> members <a class='abbr_ref' href='allocator.members'>[allocator.members]</a></h4><div class='para' id='allocator.members-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-1'>1</a></div><p >Except for the destructor, member functions of the default allocator shall not introduce
data races (<a href='intro.multithread'>[intro.multithread]</a>) as a result of concurrent calls to those member
functions from different threads. Calls to these functions that allocate or deallocate a
particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.</p><p ><span class='indexparent'><a class='index' id='address,allocator'></a></span>
<span class='indexparent'><a class='index' id='allocator,address'></a></span>
<code class='itemdecl'>
pointer address(reference x) const noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='allocator.members-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The actual address of the object referenced by <span class='texttt'>x</span>, even in the presence of an
overloaded operator&amp;.
</p></div></div><p ><span class='indexparent'><a class='index' id='address,allocator'></a></span>
<span class='indexparent'><a class='index' id='allocator,address'></a></span>
<code class='itemdecl'>
const_pointer address(const_reference x) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
The actual address of the object referenced by <span class='texttt'>x</span>, even in the presence of an
overloaded operator&amp;.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocate,allocator'></a></span>
<span class='indexparent'><a class='index' id='allocator,allocate'></a></span>
<code class='itemdecl'>
pointer allocate(size_type n, allocator&lt;void&gt;::const_pointer hint = 0);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> In a container member function, the address of an adjacent
element is often a good choice to pass for the <span class='texttt'>hint</span> argument. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='allocator.members-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to the initial element of an array of storage of size <span class='texttt'>n</span>
<span class='texttt'>* sizeof(T)</span>, aligned appropriately for objects of type <span class='texttt'>T</span>.
It is <span class='indexparent'><a class='index' id='support_for_over-aligned_types'></a></span>implementation-defined whether over-aligned types are
supported (<a href='basic.align'>[basic.align]</a>).</p></div></div><div class='para' id='allocator.members-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-6'>6</a></div><div class='itemdescr'><p ><i>Remark:</i>
the storage is obtained by calling <span class='texttt'>::operator
new(std::size_t)</span> (<a href='new.delete'>[new.delete]</a>), but it is unspecified when or how often this
function is called. The use of <span class='texttt'>hint</span> is unspecified, but intended as an aid to
locality if an implementation so desires.</p></div></div><div class='para' id='allocator.members-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_alloc</span> if the storage cannot be obtained.
</p></div></div><p ><span class='indexparent'><a class='index' id='deallocate,allocator'></a></span>
<span class='indexparent'><a class='index' id='allocator,deallocate'></a></span>
<code class='itemdecl'>
void deallocate(pointer p, size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>p</span> shall be a pointer value obtained from <span class='texttt'>allocate()</span>.
<span class='texttt'>n</span> shall equal the value passed as the first argument
to the invocation of allocate which returned <span class='texttt'>p</span>.</p></div></div><div class='para' id='allocator.members-9'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Deallocates the storage referenced by <span class='texttt'>p</span> .</p></div></div><div class='para' id='allocator.members-10'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Uses
<span class='texttt'>::operator delete(void*, std::size_t)</span> (<a href='new.delete'>[new.delete]</a>), but it is unspecified
when this function is called.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size,allocator'></a></span>
<span class='indexparent'><a class='index' id='allocator,max_size'></a></span>
<code class='itemdecl'>
size_type max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-11'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
The largest value <i>N</i> for which the call <span class='texttt'>allocate(N,0)</span>
might succeed.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator,constructor'></a></span><code class='itemdecl'>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-12'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='allocator,destructor'></a></span><code class='itemdecl'>
template &lt;class U&gt;
  void destroy(U* p);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-13'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>p-&gt;~U()</span>
</p></div></div></div><div id='allocator.globals'><h4 ><a class='secnum' href='#allocator.globals' style='min-width:118pt'>20.7.9.2</a> <span class='texttt'>allocator</span> globals <a class='abbr_ref' href='allocator.globals'>[allocator.globals]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,operator=='></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  bool operator==(const allocator&lt;T1&gt;&amp;, const allocator&lt;T2&gt;&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.globals-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.globals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,operator!='></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  bool operator!=(const allocator&lt;T1&gt;&amp;, const allocator&lt;T2&gt;&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.globals-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.globals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>false</span>.
</p></div></div></div></div><div id='storage.iterator'><h3 ><a class='secnum' href='#storage.iterator' style='min-width:103pt'>20.7.10</a> Raw storage iterator <a class='abbr_ref' href='storage.iterator'>[storage.iterator]</a></h3><div class='para' id='storage.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-1'>1</a></div><p ><span class='texttt'>raw_storage_iterator</span> is provided to enable algorithms to store their
results into uninitialized memory. The template parameter
<span class='texttt'>OutputIterator</span> is required to have its <span class='texttt'>operator*</span> return an
object for which <span class='texttt'>operator&amp;</span> is defined and returns a pointer to
<span class='texttt'>T</span>, and is also required to satisfy the requirements of an output
iterator (<a href='output.iterators'>[output.iterators]</a>).</p><pre class='codeblock'>
namespace std {
  template &lt;class OutputIterator, class T&gt;
  class raw_storage_iterator
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
  public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator&amp; operator*();
    raw_storage_iterator&amp; operator=(const T&amp; element);
    raw_storage_iterator&amp; operator++();
    raw_storage_iterator  operator++(int);
  };
}
</pre><p ><span class='indexparent'><a class='index' id='raw_storage_iterator,constructor'></a></span><code class='itemdecl'>
explicit raw_storage_iterator(OutputIterator x);
</code></p></div><div class='itemdescr'></div><div class='para' id='storage.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes the iterator to point to the same value to which <span class='texttt'>x</span> points.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,raw_storage_iterator'></a></span>
<span class='indexparent'><a class='index' id='raw_storage_iterator,operator*'></a></span>
<code class='itemdecl'>
raw_storage_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='storage.iterator-3'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,raw_storage_iterator'></a></span>
<span class='indexparent'><a class='index' id='raw_storage_iterator,operator='></a></span>
<code class='itemdecl'>
raw_storage_iterator&amp; operator=(const T&amp; element);
</code></p><div class='itemdescr'></div><div class='para' id='storage.iterator-4'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a value from <span class='texttt'>element</span> at the location to which the iterator points.</p></div></div><div class='para' id='storage.iterator-5'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A reference to the iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,raw_storage_iterator'></a></span>
<span class='indexparent'><a class='index' id='raw_storage_iterator,operator++'></a></span>
<code class='itemdecl'>
raw_storage_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='storage.iterator-6'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Pre-increment:  advances the iterator and returns a reference to the updated iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,raw_storage_iterator'></a></span>
<span class='indexparent'><a class='index' id='raw_storage_iterator,operator++'></a></span>
<code class='itemdecl'>
raw_storage_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='storage.iterator-7'><div class='marginalizedparent'><a class='marginalized' href='#storage.iterator-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Post-increment:  advances the iterator and returns the old value of the iterator.
</p></div></div></div><div id='temporary.buffer'><h3 ><a class='secnum' href='#temporary.buffer' style='min-width:103pt'>20.7.11</a> Temporary buffers <a class='abbr_ref' href='temporary.buffer'>[temporary.buffer]</a></h3><p ><span class='indexparent'><a class='index' id='get_temporary_buffer'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  pair&lt;T*, ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='temporary.buffer-1'><div class='marginalizedparent'><a class='marginalized' href='#temporary.buffer-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Obtains a pointer to storage sufficient to store up to <span class='texttt'>n</span>
adjacent <span class='texttt'>T</span> objects.
It is <span class='indexparent'><a class='index' id='support_for_over-aligned_types'></a></span>implementation-defined whether over-aligned types are
supported (<a href='basic.align'>[basic.align]</a>).</p></div></div><div class='para' id='temporary.buffer-2'><div class='marginalizedparent'><a class='marginalized' href='#temporary.buffer-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>pair</span> containing the buffer's address and capacity (in the units of
<span class='texttt'>sizeof(T)</span>), or a pair of 0 values if no storage can be obtained or
if <span class='texttt'>n &lt;= 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='return_temporary_buffer'></a></span><code class='itemdecl'>
template &lt;class T&gt; void return_temporary_buffer(T* p);
</code></p><div class='itemdescr'></div><div class='para' id='temporary.buffer-3'><div class='marginalizedparent'><a class='marginalized' href='#temporary.buffer-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Deallocates the buffer to which <span class='texttt'>p</span>
points.</p></div></div><div class='para' id='temporary.buffer-4'><div class='marginalizedparent'><a class='marginalized' href='#temporary.buffer-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
The buffer shall have been previously allocated by <span class='texttt'>get_temporary_buffer</span>.
</p></div></div></div><div id='specialized.algorithms'><h3 ><a class='secnum' href='#specialized.algorithms' style='min-width:103pt'>20.7.12</a> Specialized algorithms <a class='abbr_ref' href='specialized.algorithms'>[specialized.algorithms]</a></h3><div class='para' id='specialized.algorithms-1'><div class='marginalizedparent'><a class='marginalized' href='#specialized.algorithms-1'>1</a></div><p >All the iterators that are used as template parameters in the following
algorithms are required to  have their <span class='texttt'>operator*</span> return an object
for which <span class='texttt'>operator&amp;</span> is defined and returns a pointer to <span class='texttt'>T</span>.
In the algorithm <span class='texttt'>uninitialized_copy</span>, the template parameter
<span class='texttt'>InputIterator</span> is required to satisfy the requirements of an input
iterator (<a href='input.iterators'>[input.iterators]</a>). In all of the following algorithms,
the template parameter <span class='texttt'>ForwardIterator</span> is required to satisfy the
requirements of a forward iterator (<a href='forward.iterators'>[forward.iterators]</a>),
and is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
In the following algorithms, if an exception is thrown there are no effects.</p></div><div id='specialized.addressof'><h4 ><a class='secnum' href='#specialized.addressof' style='min-width:118pt'>20.7.12.1</a> <span class='texttt'>addressof</span> <a class='abbr_ref' href='specialized.addressof'>[specialized.addressof]</a></h4><p ><span class='indexparent'><a class='index' id='addressof'></a></span><code class='itemdecl'>
template &lt;class T&gt; T* addressof(T&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='specialized.addressof-1'><div class='marginalizedparent'><a class='marginalized' href='#specialized.addressof-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The actual address of the object or function referenced by <span class='texttt'>r</span>, even in the
presence of an overloaded <span class='texttt'>operator&amp;</span>.
</p></div></div></div><div id='uninitialized.copy'><h4 ><a class='secnum' href='#uninitialized.copy' style='min-width:118pt'>20.7.12.2</a> <span class='texttt'>uninitialized_copy</span> <a class='abbr_ref' href='uninitialized.copy'>[uninitialized.copy]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_copy'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.copy-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
for (; first != last; ++result, ++first)
  ::new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre></div></div><div class='para' id='uninitialized.copy-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>result</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_copy_n'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class Size, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.copy-3'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
for ( ; n &gt; 0; ++result, ++first, --n) {
  ::new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
}
</pre></div></div><div class='para' id='uninitialized.copy-4'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>
</p></div></div></div><div id='uninitialized.fill'><h4 ><a class='secnum' href='#uninitialized.fill' style='min-width:118pt'>20.7.12.3</a> <span class='texttt'>uninitialized_fill</span> <a class='abbr_ref' href='uninitialized.fill'>[uninitialized.fill]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_fill'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class T&gt;
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.fill-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
for (; first != last; ++first)
  ::new (static_cast&lt;void*&gt;(&amp;*first))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
</pre></div></div></div><div id='uninitialized.fill.n'><h4 ><a class='secnum' href='#uninitialized.fill.n' style='min-width:118pt'>20.7.12.4</a> <span class='texttt'>uninitialized_fill_n</span> <a class='abbr_ref' href='uninitialized.fill.n'>[uninitialized.fill.n]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_fill_n'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class Size, class T&gt;
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.fill.n-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.fill.n-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
for (; n--; ++first)
  ::new (static_cast&lt;void*&gt;(&amp;*first))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
return first;
</pre></div></div></div></div><div id='c.malloc'><h3 ><a class='secnum' href='#c.malloc' style='min-width:103pt'>20.7.13</a> C library <a class='abbr_ref' href='c.malloc'>[c.malloc]</a></h3><div class='para' id='c.malloc-1'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-1'>1</a></div><p >Table <a href='#tab:util.hdr.cstdlib'>[tab:util.hdr.cstdlib]</a> describes the header
<span class='texttt'>&lt;cstdlib&gt;</span>.</p><div class='numberedTable' id='tab:util.hdr.cstdlib'>Table <a href='#tab:util.hdr.cstdlib'>45</a> — Header <span class='texttt'>&lt;cstdlib&gt;</span> synopsis<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='2' class='center'><b>Name(s)</b></td></tr><tr class='capsep'><td class='left'> 



<b>Functions</b>:  </td><td class='left'>   <span class='texttt'>calloc</span>  </td><td class='left'>   <span class='texttt'>malloc</span>      </td></tr><tr ><td class='left'>
            </td><td class='left'>   <span class='texttt'>free</span>    </td><td class='left'>   <span class='texttt'>realloc</span>     </td></tr></table></div></div><div class='para' id='c.malloc-2'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-2'>2</a></div><p >The contents are the same as the Standard C library header
<span class='texttt'>&lt;stdlib.h&gt;,</span>
with the following changes:</p></div><div class='para' id='c.malloc-3'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-3'>3</a></div><p >The functions <span class='texttt'>calloc()</span><span class='indexparent'><a class='index' id='calloc'></a></span>,
<span class='texttt'>malloc()</span><span class='indexparent'><a class='index' id='malloc'></a></span>, and
<span class='texttt'>realloc()</span><span class='indexparent'><a class='index' id='realloc'></a></span> do not attempt to allocate
storage by calling <span class='texttt'>::operator new()</span> (<a href='support.dynamic'>[support.dynamic]</a>).
<span class='indexparent'><a class='index' id='new,operator'></a></span>
</p></div><div class='para' id='c.malloc-4'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-4'>4</a></div><p >The function <span class='texttt'>free()</span><span class='indexparent'><a class='index' id='free'></a></span> does not attempt to
deallocate storage by calling
<span class='texttt'>::operator delete()</span><span class='indexparent'><a class='index' id='delete,operator'></a></span>.</p><p ><span class='textsc'>See also:</span>
ISO C Clause 7.11.2.</p></div><div class='para' id='c.malloc-5'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-5'>5</a></div><p >Storage allocated directly with <span class='texttt'>malloc()</span>, <span class='texttt'>calloc()</span>, or
<span class='texttt'>realloc()</span> is implicitly declared reachable
(see <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>) on allocation, ceases to be declared
reachable on deallocation, and need not cease to be declared reachable as the
result of an <span class='texttt'>undeclare_reachable()</span> call. [&nbsp;<i>Note:</i> This allows existing
C libraries to remain unaffected by restrictions on pointers that are not safely
derived, at the expense of providing far fewer garbage collection and leak
detection options for <span class='texttt'>malloc()</span>-allocated objects. It also allows
<span class='texttt'>malloc()</span> to be implemented with a separate allocation arena, bypassing
the normal <span class='texttt'>declare_reachable()</span> implementation. The above functions
should never intentionally be used as a replacement for
<span class='texttt'>declare_reachable()</span>, and newly written code is strongly encouraged to
treat memory allocated with these functions as though it were allocated with
<span class='texttt'>operator new</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='c.malloc-6'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-6'>6</a></div><p >Table <a href='#tab:util.hdr.cstring'>[tab:util.hdr.cstring]</a> describes the header
<span class='texttt'>&lt;cstring&gt;</span>.</p><div class='numberedTable' id='tab:util.hdr.cstring'>Table <a href='#tab:util.hdr.cstring'>46</a> — Header <span class='texttt'>&lt;cstring&gt;</span> synopsis<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='2' class='center'><b>Name(s)</b></td></tr><tr class='capsep'><td class='left'> 



<b>Macro</b>:          </td><td class='left'>   <span class='texttt'>NULL</span>    </td><td class='left'>                   </td></tr><tr class='rowsep'><td class='left'> 
<b>Type</b>:           </td><td class='left'>   <span class='texttt'>size_t</span>  </td><td class='left'>                   </td></tr><tr class='rowsep'><td class='left'> 
<b>Functions</b>:      </td><td class='left'>   <span class='texttt'>memchr</span>  </td><td class='left'>   <span class='texttt'>memcmp</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>memcpy</span>  </td><td class='left'>   <span class='texttt'>memmove</span> </td><td class='left'>   <span class='texttt'>memset</span>  </td></tr></table></div></div><div class='para' id='c.malloc-7'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-7'>7</a></div><p >The contents are the same as the Standard C library header
<span class='texttt'>&lt;string.h&gt;</span>, with the change to <span class='texttt'>memchr()</span> specified
in <a href='c.strings'>[c.strings]</a>.</p><p ><span class='textsc'>See also:</span>
ISO C Clause 7.11.2.</p></div></div></div><div id='smartptr'><h2 ><a class='secnum' href='#smartptr' style='min-width:88pt'>20.8</a> Smart pointers <a class='abbr_ref' href='smartptr'>[smartptr]</a></h2><div id='unique.ptr'><h3 ><a class='secnum' href='#unique.ptr' style='min-width:103pt'>20.8.1</a> Class template <span class='texttt'>unique_ptr</span> <a class='abbr_ref' href='unique.ptr'>[unique.ptr]</a></h3><div class='para' id='unique.ptr-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-1'>1</a></div><p >A <a class='hidden_link' href='#def:unique_pointer' id='def:unique_pointer'><i>unique pointer</i></a> is an object that owns another object and
manages that other object through a pointer. More precisely, a unique pointer
is an object <i>u</i> that stores a pointer to a second object <i>p</i> and
will dispose of <i>p</i> when <i>u</i> is itself destroyed (e.g., when
leaving block scope (<a href='stmt.dcl'>[stmt.dcl]</a>)). In this context, <i>u</i> is said
to <a class='hidden_link' href='#def:own' id='def:own'><i>own</i></a> <span class='texttt'>p</span>.</p></div><div class='para' id='unique.ptr-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-2'>2</a></div><p >The mechanism by which <i>u</i> disposes of <i>p</i> is known as
<i>p</i>'s associated <a class='hidden_link' href='#def:deleter' id='def:deleter'><i>deleter</i></a>, a function object whose correct
invocation results in <i>p</i>'s appropriate disposition (typically its deletion).</p></div><div class='para' id='unique.ptr-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-3'>3</a></div><p >Let the notation <i>u.p</i> denote the pointer stored by <i>u</i>, and
let <i>u.d</i> denote the associated deleter. Upon request, <i>u</i> can
<a class='hidden_link' href='#def:reset' id='def:reset'><i>reset</i></a> (replace) <i>u.p</i> and <i>u.d</i> with another pointer and
deleter, but must properly dispose of its owned object via the associated
deleter before such replacement is considered completed.</p></div><div class='para' id='unique.ptr-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-4'>4</a></div><p >Additionally, <i>u</i> can, upon request, <a class='hidden_link' href='#def:transfer_ownership' id='def:transfer_ownership'><i>transfer ownership</i></a> to another
unique pointer <i>u2</i>. Upon completion of such a transfer, the following
postconditions hold:</p><ul class='itemize'><li id='unique.ptr-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr-4.1'>(4.1)</a></div><p ><i>u2.p</i> is equal to the pre-transfer <i>u.p</i>,
</p></li><li id='unique.ptr-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr-4.2'>(4.2)</a></div><p ><i>u.p</i> is equal to <span class='texttt'>nullptr</span>, and
</p></li><li id='unique.ptr-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr-4.3'>(4.3)</a></div><p >if the pre-transfer <i>u.d</i> maintained state, such state has been
transferred to <i>u2.d</i>.
</p></li></ul><p >As in the case of a reset, <i>u2</i> must properly dispose of its pre-transfer
owned object via the pre-transfer associated deleter before the ownership
transfer is considered complete. [&nbsp;<i>Note:</i> A deleter's state need never be
copied, only moved or swapped as ownership is transferred. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unique.ptr-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-5'>5</a></div><p >Each object of a type <span class='texttt'>U</span> instantiated from the <span class='texttt'>unique_ptr</span> template
specified in this subclause has the strict ownership semantics, specified above,
of a unique pointer. In partial satisfaction of these semantics, each such <span class='texttt'>U</span>
is <span class='texttt'>MoveConstructible</span> and <span class='texttt'>MoveAssignable</span>, but is not
<span class='texttt'>CopyConstructible</span> nor <span class='texttt'>CopyAssignable</span>.
The template parameter <span class='texttt'>T</span> of <span class='texttt'>unique_ptr</span> may be an incomplete type.</p></div><div class='para' id='unique.ptr-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr-6'>6</a></div><p >[&nbsp;<i>Note:</i> The uses
of <span class='texttt'>unique_ptr</span> include providing exception safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct default_delete;
  template&lt;class T&gt; struct default_delete&lt;T[]&gt;;

  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;

  template&lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);
  template&lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);
  template&lt;class T, class... Args&gt; <i><span class='texttt'>unspecified</span></i> make_unique(Args&amp;&amp;...) = delete;

  template&lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;

  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  template &lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);

}
</pre></div><div id='unique.ptr.dltr'><h4 ><a class='secnum' href='#unique.ptr.dltr' style='min-width:118pt'>20.8.1.1</a> Default deleters <a class='abbr_ref' href='unique.ptr.dltr'>[unique.ptr.dltr]</a></h4><div id='unique.ptr.dltr.general'><h4 ><a class='secnum' href='#unique.ptr.dltr.general' style='min-width:133pt'>20.8.1.1.1</a> In general <a class='abbr_ref' href='unique.ptr.dltr.general'>[unique.ptr.dltr.general]</a></h4><div class='para' id='unique.ptr.dltr.general-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.general-1'>1</a></div><p >The class template <span class='texttt'>default_delete</span> serves as the default deleter (destruction policy)
for the class template <span class='texttt'>unique_ptr</span>.</p></div><div class='para' id='unique.ptr.dltr.general-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.general-2'>2</a></div><p >The template parameter <span class='texttt'>T</span> of <span class='texttt'>default_delete</span> may be
an incomplete type.</p></div></div><div id='unique.ptr.dltr.dflt'><h4 ><a class='secnum' href='#unique.ptr.dltr.dflt' style='min-width:133pt'>20.8.1.1.2</a> <span class='texttt'>default_delete</span> <a class='abbr_ref' href='unique.ptr.dltr.dflt'>[unique.ptr.dltr.dflt]</a></h4><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct default_delete {
    constexpr default_delete() noexcept = default;
    template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp;) noexcept;
    void operator()(T*) const;
  };
}
</pre><p ><span class='indexparent'><a class='index' id='default_delete,default_delete'></a></span>
<span class='indexparent'><a class='index' id='default_delete,default_delete'></a></span>
<code class='itemdecl'>
template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.dltr.dflt-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>default_delete</span> object
from another <span class='texttt'>default_delete&lt;U&gt;</span> object.</p></div></div><div class='para' id='unique.ptr.dltr.dflt-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>U*</span> is implicitly convertible to <span class='texttt'>T*</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator(),default_delete'></a></span>
<span class='indexparent'><a class='index' id='default_delete,operator()'></a></span>
<code class='itemdecl'>
void operator()(T* ptr) const;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.dltr.dflt-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>delete</span> on <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='unique.ptr.dltr.dflt-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>T</span> is an incomplete type, the program is ill-formed.
</p></div></div></div><div id='unique.ptr.dltr.dflt1'><h4 ><a class='secnum' href='#unique.ptr.dltr.dflt1' style='min-width:133pt'>20.8.1.1.3</a> <span class='texttt'>default_delete&lt;T[]&gt;</span> <a class='abbr_ref' href='unique.ptr.dltr.dflt1'>[unique.ptr.dltr.dflt1]</a></h4><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct default_delete&lt;T[]&gt; {
    constexpr default_delete() noexcept = default;
    void operator()(T*) const;
    template &lt;class U&gt; void operator()(U*) const = delete;
  };
}
</pre><p ><span class='indexparent'><a class='index' id='operator(),default_delete'></a></span>
<span class='indexparent'><a class='index' id='default_delete,operator()'></a></span>
<code class='itemdecl'>
void operator()(T* ptr) const;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.dltr.dflt1-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt1-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
calls <span class='texttt'>delete[]</span> on <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='unique.ptr.dltr.dflt1-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.dltr.dflt1-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> If T is an incomplete type, the program is ill-formed.
</p></div></div></div></div><div id='unique.ptr.single'><h4 ><a class='secnum' href='#unique.ptr.single' style='min-width:118pt'>20.8.1.2</a> <span class='texttt'>unique_ptr</span> for single objects <a class='abbr_ref' href='unique.ptr.single'>[unique.ptr.single]</a></h4><pre class='codeblock'>
namespace std {
  template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  public:
    typedef <i><span class='texttt'>see below</span></i> pointer;
    typedef T element_type;
    typedef D deleter_type;

    <span class='comment'>// <a href='unique.ptr.single.ctor'>[unique.ptr.single.ctor]</a>, constructors
</span>    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d1) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d2) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept
      : unique_ptr() { }
    template &lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u) noexcept;

    <span class='comment'>// <a href='unique.ptr.single.dtor'>[unique.ptr.single.dtor]</a>, destructor
</span>    ~unique_ptr();

    <span class='comment'>// <a href='unique.ptr.single.asgn'>[unique.ptr.single.asgn]</a>, assignment
</span>    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;

    <span class='comment'>// <a href='unique.ptr.single.observers'>[unique.ptr.single.observers]</a>, observers
</span>    add_lvalue_reference_t&lt;T&gt; operator*() const;
    pointer operator-&gt;() const noexcept;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    <span class='comment'>// <a href='unique.ptr.single.modifiers'>[unique.ptr.single.modifiers]</a> modifiers
</span>    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr&amp; u) noexcept;

    <span class='comment'>// disable copy from lvalue
</span>    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}
</pre><div class='para' id='unique.ptr.single-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single-1'>1</a></div><p >The default type for the template parameter <span class='texttt'>D</span> is
<span class='texttt'>default_delete</span>. A client-supplied template argument
<span class='texttt'>D</span> shall be a function
object type (<a href='function.objects'>[function.objects]</a>), lvalue-reference to function, or
lvalue-reference to function object type
for which, given
a value <span class='texttt'>d</span> of type <span class='texttt'>D</span> and a value
<span class='texttt'>ptr</span> of type <span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span>, the expression
<span class='texttt'>d(ptr)</span> is valid and has the effect of disposing of the
pointer as appropriate for that deleter.</p></div><div class='para' id='unique.ptr.single-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single-2'>2</a></div><p >If the deleter's type <span class='texttt'>D</span> is not a reference type, <span class='texttt'>D</span> shall satisfy
the requirements of <span class='texttt'>Destructible</span> (Table <a href='destructible'>[destructible]</a>).</p></div><div class='para' id='unique.ptr.single-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single-3'>3</a></div><p >If the type <span class='texttt'>remove_reference_t&lt;D&gt;::pointer</span> exists, then <span class='texttt'>unique_ptr&lt;T,
D&gt;::pointer</span> shall be a synonym for <span class='texttt'>remove_reference_t&lt;D&gt;::pointer</span>. Otherwise
<span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span> shall be a synonym for <span class='texttt'>T*</span>. The type <span class='texttt'>unique_ptr&lt;T,
D&gt;::pointer</span> shall
satisfy the requirements of <span class='texttt'>NullablePointer</span> (<a href='nullablepointer.requirements'>[nullablepointer.requirements]</a>).</p></div><div class='para' id='unique.ptr.single-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single-4'>4</a></div><p >[&nbsp;<i>Example:</i> Given an allocator type <span class='texttt'>X</span> (<a href='allocator.requirements'>[allocator.requirements]</a>) and
letting <span class='texttt'>A</span> be a synonym for <span class='texttt'>allocator_traits&lt;X&gt;</span>, the types <span class='texttt'>A::pointer</span>,
<span class='texttt'>A::const_pointer</span>, <span class='texttt'>A::void_pointer</span>, and <span class='texttt'>A::const_void_pointer</span>
may be used as <span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='unique.ptr.single.ctor'><h4 ><a class='secnum' href='#unique.ptr.single.ctor' style='min-width:133pt'>20.8.1.2.1</a> <span class='texttt'>unique_ptr</span> constructors <a class='abbr_ref' href='unique.ptr.single.ctor'>[unique.ptr.single.ctor]</a></h4><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
constexpr unique_ptr() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>D</span> shall
satisfy the requirements of <span class='texttt'>DefaultConstructible</span> (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
and that construction shall not throw an exception.</p></div></div><div class='para' id='unique.ptr.single.ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object that owns
nothing, value-initializing the stored pointer and the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == nullptr</span>. <span class='texttt'>get_deleter()</span>
returns a reference to the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this constructor is instantiated with a pointer type or reference type
for the template argument <span class='texttt'>D</span>, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
explicit unique_ptr(pointer p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>D</span> shall
satisfy the requirements of <span class='texttt'>DefaultConstructible</span> (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
and that construction shall not throw an exception.</p></div></div><div class='para' id='unique.ptr.single.ctor-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> which owns
<span class='texttt'>p</span>, initializing the stored pointer with <span class='texttt'>p</span> and
value-initializing the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-7'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>. <span class='texttt'>get_deleter()</span>
returns a reference to the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-8'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this constructor is instantiated with a pointer type or reference type
for the template argument <span class='texttt'>D</span>, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d1) noexcept;
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d2) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-9'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-9'>9</a></div><div class='itemdescr'><p >The signature of these constructors depends upon whether <span class='texttt'>D</span>
is a reference type. If <span class='texttt'>D</span> is non-reference type
<span class='texttt'>A</span>, then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, const A&amp; d);
unique_ptr(pointer p, A&amp;&amp; d);
</pre></div></div><div class='para' id='unique.ptr.single.ctor-10'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-10'>10</a></div><div class='itemdescr'><p >If <span class='texttt'>D</span> is an lvalue-reference type <span class='texttt'>A&amp;</span>,
then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, A&amp; d);
unique_ptr(pointer p, A&amp;&amp; d);
</pre></div></div><div class='para' id='unique.ptr.single.ctor-11'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-11'>11</a></div><div class='itemdescr'><p >If <span class='texttt'>D</span> is an lvalue-reference type <span class='texttt'>const A&amp;</span>,
then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, const A&amp; d);
unique_ptr(pointer p, const A&amp;&amp; d);
</pre></div></div><div class='para' id='unique.ptr.single.ctor-12'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
</p><ul class='itemize'><li id='unique.ptr.single.ctor-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.ctor-12.1'>(12.1)</a></div><p >If <span class='texttt'>D</span> is not an lvalue-reference type then</p><ul class='itemize'><li id='unique.ptr.single.ctor-12.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#unique.ptr.single.ctor-12.1.1'>(12.1.1)</a></div><p >If <span class='texttt'>d</span> is an lvalue or <span class='texttt'>const</span> rvalue then
the first constructor of this pair will be selected. <span class='texttt'>D</span>
shall satisfy the requirements of
<span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>), and
the copy constructor of <span class='texttt'>D</span> shall
not throw an exception.
This <span class='texttt'>unique_ptr</span> will hold
a copy of <span class='texttt'>d</span>.</p></li><li id='unique.ptr.single.ctor-12.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#unique.ptr.single.ctor-12.1.2'>(12.1.2)</a></div><p >Otherwise, <span class='texttt'>d</span> is a non-const rvalue and the second
constructor of this pair will be selected. <span class='texttt'>D</span>
shall satisfy the requirements of
<span class='texttt'>MoveConstructible</span> (Table <a href='moveconstructible'>[moveconstructible]</a>), and the
move constructor of <span class='texttt'>D</span> shall not throw an exception.
This <span class='texttt'>unique_ptr</span> will
hold a value move constructed from <span class='texttt'>d</span>.
</p></li></ul></li><li id='unique.ptr.single.ctor-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.ctor-12.2'>(12.2)</a></div><p >Otherwise <span class='texttt'>D</span> is an lvalue-reference type. <span class='texttt'>d</span>
shall be reference-compatible with one of the constructors. If <span class='texttt'>d</span> is
an rvalue, it will bind to the second constructor of this pair and the program is
ill-formed. [&nbsp;<i>Note:</i> The diagnostic could
be implemented using a <span class='texttt'>static_assert</span> which assures that
<span class='texttt'>D</span> is not a reference type. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Else <span class='texttt'>d</span>
is an lvalue and will bind to the first constructor of this pair. The type
which <span class='texttt'>D</span> references need not be <span class='texttt'>CopyConstructible</span>
nor <span class='texttt'>MoveConstructible</span>. This <span class='texttt'>unique_ptr</span> will
hold a <span class='texttt'>D</span> which refers to the lvalue <span class='texttt'>d</span>.
[&nbsp;<i>Note:</i> <span class='texttt'>D</span> may not be an rvalue-reference type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><div class='para' id='unique.ptr.single.ctor-13'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object which owns <span class='texttt'>p</span>, initializing
the stored pointer with <span class='texttt'>p</span> and initializing the deleter as described above.</p></div></div><div class='para' id='unique.ptr.single.ctor-14'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>.
<span class='texttt'>get_deleter()</span> returns a reference to the stored
deleter. If <span class='texttt'>D</span> is a reference type then <span class='texttt'>get_deleter()</span>
returns a reference to the lvalue <span class='texttt'>d</span>.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
D d;
unique_ptr&lt;int, D&gt; p1(new int, D());        <span class='comment'>// <span class='texttt'>D</span> must be <span class='texttt'>MoveConstructible</span>
</span>unique_ptr&lt;int, D&gt; p2(new int, d);          <span class='comment'>// <span class='texttt'>D</span> must be <span class='texttt'>CopyConstructible</span>
</span>unique_ptr&lt;int, D&amp;&gt; p3(new int, d);         <span class='comment'>// <span class='texttt'>p3</span> holds a reference to <span class='texttt'>d</span>
</span>unique_ptr&lt;int, const D&amp;&gt; p4(new int, D()); <span class='comment'>// error: rvalue deleter object combined
</span>                                            <span class='comment'>// with reference deleter type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
unique_ptr(unique_ptr&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-15'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>D</span> is not a reference type,
<span class='texttt'>D</span> shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>
(Table <a href='moveconstructible'>[moveconstructible]</a>).
Construction
of the deleter from an rvalue of type <span class='texttt'>D</span> shall not
throw an exception.</p></div></div><div class='para' id='unique.ptr.single.ctor-16'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> by transferring ownership from
<span class='texttt'>u</span> to <span class='texttt'>*this</span>. If <span class='texttt'>D</span> is a reference type, this
deleter is copy constructed from <span class='texttt'>u</span>'s deleter; otherwise, this
deleter is move constructed from <span class='texttt'>u</span>'s deleter. [&nbsp;<i>Note:</i> The
deleter constructor can be implemented with <span class='texttt'>std::forward&lt;D&gt;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='unique.ptr.single.ctor-17'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span>
yielded before the construction. <span class='texttt'>get_deleter()</span> returns a reference
to the stored deleter that was constructed from
<span class='texttt'>u.get_deleter()</span>. If <span class='texttt'>D</span> is a reference type then
<span class='texttt'>get_deleter()</span> and <span class='texttt'>u.get_deleter()</span> both reference
the same lvalue deleter.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-18'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>E</span> is not a reference type,
construction of the deleter from an rvalue of type
<span class='texttt'>E</span> shall be well formed and shall not throw an exception.
Otherwise, <span class='texttt'>E</span> is a reference type and construction of the deleter from an
lvalue of type <span class='texttt'>E</span> shall be well formed and shall not throw an exception.</p></div></div><div class='para' id='unique.ptr.single.ctor-19'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-19'>19</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless:</p><ul class='itemize'><li id='unique.ptr.single.ctor-19.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.ctor-19.1'>(19.1)</a></div><p ><span class='texttt'>unique_ptr&lt;U, E&gt;::pointer</span> is implicitly convertible to <span class='texttt'>pointer</span>,
</p></li><li id='unique.ptr.single.ctor-19.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.ctor-19.2'>(19.2)</a></div><p ><span class='texttt'>U</span> is not an array type, and
</p></li><li id='unique.ptr.single.ctor-19.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.ctor-19.3'>(19.3)</a></div><p >either <span class='texttt'>D</span> is a reference type and <span class='texttt'>E</span> is the same type as <span class='texttt'>D</span>, or
<span class='texttt'>D</span> is not a reference type and <span class='texttt'>E</span> is implicitly convertible to <span class='texttt'>D</span>.
</p></li></ul></div></div><div class='para' id='unique.ptr.single.ctor-20'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> by transferring ownership from <span class='texttt'>u</span>
to <span class='texttt'>*this</span>. If <span class='texttt'>E</span> is a reference type, this deleter is copy constructed from
<span class='texttt'>u</span>'s deleter; otherwise, this deleter is move constructed from <span class='texttt'>u</span>'s
deleter. [&nbsp;<i>Note:</i> The deleter constructor can be implemented with
<span class='texttt'>std::forward&lt;E&gt;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='unique.ptr.single.ctor-21'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-21'>21</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span>
yielded before the construction.
<span class='texttt'>get_deleter()</span> returns a reference
to the stored deleter that was constructed from
<span class='texttt'>u.get_deleter()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.ctor-22'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object, initializing the
stored pointer with <span class='texttt'>u.release()</span> and value-initializing the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-23'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-23'>23</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span> yielded
before the construction.
<span class='texttt'>u.get() == nullptr</span>.
<span class='texttt'>get_deleter()</span> returns a reference to the stored deleter.</p></div></div><div class='para' id='unique.ptr.single.ctor-24'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.ctor-24'>24</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>U*</span> is implicitly convertible to <span class='texttt'>T*</span> and <span class='texttt'>D</span> is
the same type as <span class='texttt'>default_delete&lt;T&gt;</span>.
</p></div></div></div><div id='unique.ptr.single.dtor'><h4 ><a class='secnum' href='#unique.ptr.single.dtor' style='min-width:133pt'>20.8.1.2.2</a> <span class='texttt'>unique_ptr</span> destructor <a class='abbr_ref' href='unique.ptr.single.dtor'>[unique.ptr.single.dtor]</a></h4><p ><span class='indexparent'><a class='index' id='unique_ptr,destructor'></a></span>
<code class='itemdecl'>
~unique_ptr();
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>get_deleter()(get())</span> shall be well formed,
shall have well-defined behavior, and shall not throw exceptions. [&nbsp;<i>Note:</i> The
use of <span class='texttt'>default_delete</span> requires <span class='texttt'>T</span> to be a complete type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='unique.ptr.single.dtor-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.dtor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>get() == nullptr</span> there are no effects.
Otherwise <span class='texttt'>get_deleter()(get())</span>.
</p></div></div></div><div id='unique.ptr.single.asgn'><h4 ><a class='secnum' href='#unique.ptr.single.asgn' style='min-width:133pt'>20.8.1.2.3</a> <span class='texttt'>unique_ptr</span> assignment <a class='abbr_ref' href='unique.ptr.single.asgn'>[unique.ptr.single.asgn]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.asgn-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>D</span> is not a reference type, <span class='texttt'>D</span> shall satisfy the
requirements of <span class='texttt'>MoveAssignable</span> (Table <a href='moveassignable'>[moveassignable]</a>) and assignment
of the deleter from an rvalue of type <span class='texttt'>D</span> shall not throw an exception.
Otherwise, <span class='texttt'>D</span> is a reference type;
<span class='texttt'>remove_reference_t&lt;D&gt;</span> shall satisfy the <span class='texttt'>CopyAssignable</span>
requirements and assignment of the deleter from an
lvalue of type <span class='texttt'>D</span> shall not throw an exception.</p></div></div><div class='para' id='unique.ptr.single.asgn-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Transfers ownership from <span class='texttt'>u</span> to <span class='texttt'>*this</span> as if by calling
<span class='texttt'>reset(u.release())</span> followed by
<span class='texttt'>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</span>.</p></div></div><div class='para' id='unique.ptr.single.asgn-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.asgn-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>E</span> is not a reference type, assignment of the deleter from
an rvalue of type <span class='texttt'>E</span> shall be well-formed and shall not throw an exception.
Otherwise, <span class='texttt'>E</span> is a reference type and assignment of the deleter from an lvalue
of type <span class='texttt'>E</span> shall be well-formed and shall not throw an exception.</p></div></div><div class='para' id='unique.ptr.single.asgn-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload resolution unless:</p><ul class='itemize'><li id='unique.ptr.single.asgn-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.asgn-5.1'>(5.1)</a></div><p ><span class='texttt'>unique_ptr&lt;U, E&gt;::pointer</span> is implicitly convertible to <span class='texttt'>pointer</span> and
</p></li><li id='unique.ptr.single.asgn-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.single.asgn-5.2'>(5.2)</a></div><p ><span class='texttt'>U</span> is not an array type.
</p></li></ul></div></div><div class='para' id='unique.ptr.single.asgn-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Transfers ownership from <span class='texttt'>u</span> to <span class='texttt'>*this</span> as if by calling
<span class='texttt'>reset(u.release())</span> followed by
<span class='texttt'>get_deleter() = std::forward&lt;E&gt;(u.get_deleter())</span>.</p></div></div><div class='para' id='unique.ptr.single.asgn-7'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
unique_ptr&amp; operator=(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.asgn-8'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>reset()</span>.</p></div></div><div class='para' id='unique.ptr.single.asgn-9'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-9'>9</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get() == nullptr</span></p></div></div><div class='para' id='unique.ptr.single.asgn-10'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.asgn-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='unique.ptr.single.observers'><h4 ><a class='secnum' href='#unique.ptr.single.observers' style='min-width:133pt'>20.8.1.2.4</a> <span class='texttt'>unique_ptr</span> observers <a class='abbr_ref' href='unique.ptr.single.observers'>[unique.ptr.single.observers]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator*'></a></span>
<code class='itemdecl'>
add_lvalue_reference_t&lt;T&gt; operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.observers-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get() != nullptr</span>.</p></div></div><div class='para' id='unique.ptr.single.observers-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*get()</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator->'></a></span>
<code class='itemdecl'>
pointer operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.observers-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get() != nullptr</span>.</p></div></div><div class='para' id='unique.ptr.single.observers-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get()</span>.</p></div></div><div class='para' id='unique.ptr.single.observers-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-5'>5</a></div><div class='itemdescr'><p ><i>Note:</i> use typically requires that <span class='texttt'>T</span> be a complete type.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,get'></a></span>
<code class='itemdecl'>
pointer get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.observers-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_deleter,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,get_deleter'></a></span>
<code class='itemdecl'>
deleter_type&amp; get_deleter() noexcept;
const deleter_type&amp; get_deleter() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.observers-7'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the stored deleter.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator_bool'></a></span>
<code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.observers-8'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.observers-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get() != nullptr</span>.
</p></div></div></div><div id='unique.ptr.single.modifiers'><h4 ><a class='secnum' href='#unique.ptr.single.modifiers' style='min-width:133pt'>20.8.1.2.5</a> <span class='texttt'>unique_ptr</span> modifiers <a class='abbr_ref' href='unique.ptr.single.modifiers'>[unique.ptr.single.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='release,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,release'></a></span>
<code class='itemdecl'>
pointer release() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get() == nullptr</span>.</p></div></div><div class='para' id='unique.ptr.single.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The value <span class='texttt'>get()</span> had at the start of
the call to <span class='texttt'>release</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,reset'></a></span>
<code class='itemdecl'>
void reset(pointer p = pointer()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>get_deleter()(get())</span> shall be well formed, shall have
well-defined behavior, and shall not throw exceptions.</p></div></div><div class='para' id='unique.ptr.single.modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> assigns <span class='texttt'>p</span> to the stored pointer, and then if the old value of the
stored pointer, <span class='texttt'>old_p</span>, was not equal to <span class='texttt'>nullptr</span>, calls
<span class='texttt'>get_deleter()(old_p)</span>. [&nbsp;<i>Note:</i> The order of these operations is significant
because the call to <span class='texttt'>get_deleter()</span> may destroy <span class='texttt'>*this</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='unique.ptr.single.modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>.
[&nbsp;<i>Note:</i> The postcondition does not hold if the call to <span class='texttt'>get_deleter()</span>
destroys <span class='texttt'>*this</span> since <span class='texttt'>this-&gt;get()</span> is no longer a valid expression.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,swap'></a></span>
<code class='itemdecl'>
void swap(unique_ptr&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.single.modifiers-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get_deleter()</span> shall be
swappable (<a href='swappable.requirements'>[swappable.requirements]</a>) and shall
not throw an exception
under <span class='texttt'>swap</span>.</p></div></div><div class='para' id='unique.ptr.single.modifiers-7'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.single.modifiers-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Invokes <span class='texttt'>swap</span> on the stored pointers and on the stored
deleters of <span class='texttt'>*this</span> and <span class='texttt'>u</span>.
</p></div></div></div></div><div id='unique.ptr.runtime'><h4 ><a class='secnum' href='#unique.ptr.runtime' style='min-width:118pt'>20.8.1.3</a> <span class='texttt'>unique_ptr</span> for array objects with a runtime length <a class='abbr_ref' href='unique.ptr.runtime'>[unique.ptr.runtime]</a></h4><pre class='codeblock'>
namespace std {
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
  public:
    typedef <i><span class='texttt'>see below</span></i> pointer;
    typedef T element_type;
    typedef D deleter_type;

    <span class='comment'>// <a href='unique.ptr.runtime.ctor'>[unique.ptr.runtime.ctor]</a>, constructors
</span>    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

    <span class='comment'>// destructor
</span>    ~unique_ptr();

    <span class='comment'>// assignment
</span>    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;

    <span class='comment'>// <a href='unique.ptr.runtime.observers'>[unique.ptr.runtime.observers]</a>, observers
</span>    T&amp; operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    <span class='comment'>// <a href='unique.ptr.runtime.modifiers'>[unique.ptr.runtime.modifiers]</a> modifiers
</span>    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
    template &lt;class U&gt; void reset(U) = delete;
    void swap(unique_ptr&amp; u) noexcept;

    <span class='comment'>// disable copy from lvalue
</span>    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}
</pre><div class='para' id='unique.ptr.runtime-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime-1'>1</a></div><p >A specialization for array types is provided with a slightly altered
interface.</p><ul class='itemize'><li id='unique.ptr.runtime-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.runtime-1.1'>(1.1)</a></div><p >Conversions between different types of
<span class='texttt'>unique_ptr&lt;T[], D&gt;</span> or to or from the non-array forms of
<span class='texttt'>unique_ptr</span> produce an ill-formed program.</p></li><li id='unique.ptr.runtime-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.runtime-1.2'>(1.2)</a></div><p >Pointers to types derived from <span class='texttt'>T</span> are
rejected by the constructors, and by <span class='texttt'>reset</span>.</p></li><li id='unique.ptr.runtime-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.runtime-1.3'>(1.3)</a></div><p >The observers <span class='texttt'>operator*</span> and
<span class='texttt'>operator-&gt;</span> are not provided.</p></li><li id='unique.ptr.runtime-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.runtime-1.4'>(1.4)</a></div><p >The indexing observer <span class='texttt'>operator[]</span> is provided.</p></li><li id='unique.ptr.runtime-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unique.ptr.runtime-1.5'>(1.5)</a></div><p >The default deleter will call <span class='texttt'>delete[]</span>.
</p></li></ul></div><div class='para' id='unique.ptr.runtime-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime-2'>2</a></div><p >Descriptions are provided below only for member functions that
have behavior different from the primary template.</p></div><div class='para' id='unique.ptr.runtime-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime-3'>3</a></div><p >The template argument <span class='texttt'>T</span> shall be a complete type.</p></div><div id='unique.ptr.runtime.ctor'><h4 ><a class='secnum' href='#unique.ptr.runtime.ctor' style='min-width:133pt'>20.8.1.3.1</a> <span class='texttt'>unique_ptr</span> constructors <a class='abbr_ref' href='unique.ptr.runtime.ctor'>[unique.ptr.runtime.ctor]</a></h4><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d) noexcept;
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d) noexcept;
</code></p><div class='itemdescr'><p >These constructors behave the same as in the primary template
except that they do not accept pointer types which are convertible
to <span class='texttt'>pointer</span>. [&nbsp;<i>Note:</i> One implementation technique
is to create private templated overloads of these members. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div id='unique.ptr.runtime.observers'><h4 ><a class='secnum' href='#unique.ptr.runtime.observers' style='min-width:133pt'>20.8.1.3.2</a> <span class='texttt'>unique_ptr</span> observers <a class='abbr_ref' href='unique.ptr.runtime.observers'>[unique.ptr.runtime.observers]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator[]'></a></span>
<code class='itemdecl'>
T&amp; operator[](size_t i) const;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.runtime.observers-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime.observers-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>i &lt;</span> the
number of elements in the array to which
the stored pointer points.</p></div></div><div class='para' id='unique.ptr.runtime.observers-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime.observers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get()[i]</span>.
</p></div></div></div><div id='unique.ptr.runtime.modifiers'><h4 ><a class='secnum' href='#unique.ptr.runtime.modifiers' style='min-width:133pt'>20.8.1.3.3</a> <span class='texttt'>unique_ptr</span> modifiers <a class='abbr_ref' href='unique.ptr.runtime.modifiers'>[unique.ptr.runtime.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='reset,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,reset'></a></span>
<code class='itemdecl'>
void reset(nullptr_t p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.runtime.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.runtime.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>reset(pointer())</span>.
</p></div></div></div></div><div id='unique.ptr.create'><h4 ><a class='secnum' href='#unique.ptr.create' style='min-width:118pt'>20.8.1.4</a> <span class='texttt'>unique_ptr</span> creation <a class='abbr_ref' href='unique.ptr.create'>[unique.ptr.create]</a></h4><p ><span class='indexparent'><a class='index' id='make_unique'></a></span>
<code class='itemdecl'>
template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.create-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.create-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>T</span> is not an array.</p></div></div><div class='para' id='unique.ptr.create-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.create-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))</span>.</p></div></div><p ><code class='itemdecl'>
template &lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.create-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.create-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>T</span> is an array of unknown bound.</p></div></div><div class='para' id='unique.ptr.create-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.create-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>unique_ptr&lt;T&gt;(new remove_extent_t&lt;T&gt;[n]())</span>.</p></div></div><p ><code class='itemdecl'>
template &lt;class T, class... Args&gt; <i><span class='texttt'>unspecified</span></i> make_unique(Args&amp;&amp;...) = delete;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.create-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.create-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>T</span> is an array of known bound.</p></div></div></div><div id='unique.ptr.special'><h4 ><a class='secnum' href='#unique.ptr.special' style='min-width:118pt'>20.8.1.5</a> <span class='texttt'>unique_ptr</span> specialized algorithms <a class='abbr_ref' href='unique.ptr.special'>[unique.ptr.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap(unique_ptr&,_unique_ptr&)'></a></span>
<code class='itemdecl'>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-1'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>x.swap(y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator=='></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-2'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>x.get() == y.get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator!='></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-3'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>x.get() != y.get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator<'></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-4'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> Let <span class='texttt'>CT</span> be <span class='texttt'>common_type&lt;unique_ptr&lt;T1, D1&gt;::pointer,</span>
<span class='texttt'>unique_ptr&lt;T2, D2&gt;::pointer&gt;::type</span>. Then the specialization
<span class='texttt'>less&lt;CT&gt;</span> shall be a function object type (<a href='function.objects'>[function.objects]</a>) that
induces a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>) on the pointer values.</p></div></div><div class='para' id='unique.ptr.special-5'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>less&lt;CT&gt;()(x.get(), y.get()).</span></p></div></div><div class='para' id='unique.ptr.special-6'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>unique_ptr&lt;T1, D1&gt;::pointer</span> is not implicitly convertible
to <span class='texttt'>CT</span> or <span class='texttt'>unique_ptr&lt;T2, D2&gt;::pointer</span> is not implicitly
convertible to <span class='texttt'>CT</span>, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<='></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-7'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(y &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator>'></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-8'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>y &lt; x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator>='></a></span><code class='itemdecl'>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-9'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x &lt; y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator=='></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
template &lt;class T, class D&gt;
  bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-10'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator!='></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
template &lt;class T, class D&gt;
  bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-11'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(bool)x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator<'></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
template &lt;class T, class D&gt;
  bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-12'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i> The specialization <span class='texttt'>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt;</span> shall be
a function object type (<a href='function.objects'>[function.objects]</a>) that induces a strict weak
ordering (<a href='alg.sorting'>[alg.sorting]</a>) on the pointer values.</p></div></div><div class='para' id='unique.ptr.special-13'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns
<span class='texttt'>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt;()(x.get(),<br/>nullptr)</span>.
The second function template returns
<span class='texttt'>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt;()(nullptr, x.get())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator>'></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
template &lt;class T, class D&gt;
  bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-14'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>nullptr &lt; x</span>.
The second function template returns <span class='texttt'>x &lt; nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator<='></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
template &lt;class T, class D&gt;
  bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-15'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(nullptr &lt; x)</span>.
The second function template returns <span class='texttt'>!(x &lt; nullptr)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,unique_ptr'></a></span><span class='indexparent'><a class='index' id='unique_ptr,operator>='></a></span><code class='itemdecl'>
template &lt;class T, class D&gt;
  bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
template &lt;class T, class D&gt;
  bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='unique.ptr.special-16'><div class='marginalizedparent'><a class='marginalized' href='#unique.ptr.special-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(x &lt; nullptr)</span>.
The second function template returns <span class='texttt'>!(nullptr &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='smart_pointers'></a></span></p></div></div><div id='util.smartptr'><h3 ><a class='secnum' href='#util.smartptr' style='min-width:103pt'>20.8.2</a> Shared-ownership pointers <a class='abbr_ref' href='util.smartptr'>[util.smartptr]</a></h3><div id='util.smartptr.weakptr'><h4 ><a class='secnum' href='#util.smartptr.weakptr' style='min-width:118pt'>20.8.2.1</a> Class <span class='texttt'>bad_weak_ptr</span> <a class='abbr_ref' href='util.smartptr.weakptr'>[util.smartptr.weakptr]</a></h4><p ><span class='indexparent'><a class='index' id='exception,bad_weak_ptr'></a></span><span class='indexparent'><a class='index' id='bad_weak_ptr'></a></span></p><pre class='codeblock'>
namespace std {
  class bad_weak_ptr: public std::exception {
  public:
    bad_weak_ptr() noexcept;
  };
} <span class='comment'>// namespace std
</span></pre><div class='para' id='util.smartptr.weakptr-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weakptr-1'>1</a></div><p >An exception of type <span class='texttt'>bad_weak_ptr</span> is thrown by the <span class='texttt'>shared_ptr</span>
constructor taking a <span class='texttt'>weak_ptr</span>.</p><p ><span class='indexparent'><a class='index' id='bad_weak_ptr,bad_weak_ptr'></a></span><span class='indexparent'><a class='index' id='bad_weak_ptr,what'></a></span><span class='indexparent'><a class='index' id='what,bad_weak_ptr'></a></span><code class='itemdecl'>
bad_weak_ptr() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='util.smartptr.weakptr-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weakptr-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>what()</span> returns <span class='texttt'>"bad_weak_ptr"</span>.
</p></div></div></div><div id='util.smartptr.shared'><h4 ><a class='secnum' href='#util.smartptr.shared' style='min-width:118pt'>20.8.2.2</a> Class template <span class='texttt'>shared_ptr</span> <a class='abbr_ref' href='util.smartptr.shared'>[util.smartptr.shared]</a></h4><div class='para' id='util.smartptr.shared-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared-1'>1</a></div><p ><span class='indexparent'><a class='index' id='shared_ptr'></a></span>The <span class='texttt'>shared_ptr</span> class template stores a pointer, usually obtained
via <span class='texttt'>new</span>. <span class='texttt'>shared_ptr</span> implements semantics of shared ownership;
the last remaining owner of the pointer is responsible for destroying
the object, or otherwise releasing the resources associated with the stored pointer. A
<span class='texttt'>shared_ptr</span> object is <a class='hidden_link' href='#def:empty' id='def:empty'><i>empty</i></a> if it does not own a pointer.</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class shared_ptr {
  public:
    typedef T element_type;

    <span class='comment'>// <a href='util.smartptr.shared.const'>[util.smartptr.shared.const]</a>, constructors:
</span>    constexpr shared_ptr() noexcept;
    template&lt;class Y&gt; explicit shared_ptr(Y* p);
    template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
    template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
    template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
    template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T* p) noexcept;
    shared_ptr(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
    template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
    constexpr shared_ptr(nullptr_t) : shared_ptr() { }

    <span class='comment'>// <a href='util.smartptr.shared.dest'>[util.smartptr.shared.dest]</a>, destructor:
</span>    ~shared_ptr();

    <span class='comment'>// <a href='util.smartptr.shared.assign'>[util.smartptr.shared.assign]</a>, assignment:
</span>    shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);

    <span class='comment'>// <a href='util.smartptr.shared.mod'>[util.smartptr.shared.mod]</a>, modifiers:
</span>    void swap(shared_ptr&amp; r) noexcept;
    void reset() noexcept;
    template&lt;class Y&gt; void reset(Y* p);
    template&lt;class Y, class D&gt; void reset(Y* p, D d);
    template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);

    <span class='comment'>// <a href='util.smartptr.shared.obs'>[util.smartptr.shared.obs]</a>, observers:
</span>    T* get() const noexcept;
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
  };

  <span class='comment'>// <a href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a>, shared_ptr creation
</span>  template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

  <span class='comment'>// <a href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a>, shared_ptr comparisons:
</span>  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;

  template &lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a>, shared_ptr specialized algorithms:
</span>  template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a>, shared_ptr casts:
</span>  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

  <span class='comment'>// <a href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a>, shared_ptr get_deleter:
</span>  template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a>, shared_ptr I/O:
</span>  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);
} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='util.smartptr.shared-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared-2'>2</a></div><p >Specializations of <span class='texttt'>shared_ptr</span> shall be <span class='texttt'>CopyConstructible</span>,
<span class='texttt'>CopyAssignable</span>, and <span class='texttt'>LessThanComparable</span>, allowing their use in standard
containers. Specializations of <span class='texttt'>shared_ptr</span> shall be convertible to <span class='texttt'>bool</span>,
allowing their use in boolean expressions and declarations in conditions. The template
parameter <span class='texttt'>T</span> of <span class='texttt'>shared_ptr</span> may be an incomplete type.</p></div><div class='para' id='util.smartptr.shared-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
if(shared_ptr&lt;X&gt; px = dynamic_pointer_cast&lt;X&gt;(py)) {
  <span class='comment'>// do something with px
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='util.smartptr.shared-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared-4'>4</a></div><p >For purposes of determining the presence of a data race, member functions shall
access and modify only the <span class='texttt'>shared_ptr</span> and <span class='texttt'>weak_ptr</span> objects
themselves and not objects they refer to. Changes in <span class='texttt'>use_count()</span> do not
reflect modifications that can introduce data races.</p></div><div id='util.smartptr.shared.const'><h4 ><a class='secnum' href='#util.smartptr.shared.const' style='min-width:133pt'>20.8.2.2.1</a> <span class='texttt'>shared_ptr</span> constructors <a class='abbr_ref' href='util.smartptr.shared.const'>[util.smartptr.shared.const]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,shared_ptr'></a></span><code class='itemdecl'>
constexpr shared_ptr() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an <i>empty</i> <span class='texttt'>shared_ptr</span> object.</p></div></div><div class='para' id='util.smartptr.shared.const-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 0 &amp;&amp; get() == nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall be convertible to <span class='texttt'>T*</span>.
<span class='texttt'>Y</span> shall be a complete type. The expression <span class='texttt'>delete p</span>
shall be well formed, shall have well defined behavior, and shall not
throw exceptions.</p></div></div><div class='para' id='util.smartptr.shared.const-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>shared_ptr</span> object that <i>owns</i> the pointer
<span class='texttt'>p</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1 &amp;&amp; get() == p</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception when a resource other than memory could not be obtained.</p></div></div><div class='para' id='util.smartptr.shared.const-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-7'>7</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, <span class='texttt'>delete p</span> is
called.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall be convertible to <span class='texttt'>T*</span>. <span class='texttt'>D</span> shall be
<span class='texttt'>CopyConstructible</span>. The copy constructor and destructor of <span class='texttt'> D</span>
shall not throw exceptions. The expression <span class='texttt'>d(p)</span> shall be
well formed, shall have well defined behavior, and shall not throw exceptions.
<span class='texttt'>A</span> shall be an allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).
The copy constructor and destructor of <span class='texttt'>A</span> shall not throw exceptions.</p></div></div><div class='para' id='util.smartptr.shared.const-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that <i>owns</i> the
object <span class='texttt'>p</span> and the deleter <span class='texttt'>d</span>.
The second and fourth constructors shall use a copy of <span class='texttt'>a</span> to
allocate memory for internal use.</p></div></div><div class='para' id='util.smartptr.shared.const-10'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1 &amp;&amp; get() == p</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-11'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception
when a resource other than memory could not be obtained.</p></div></div><div class='para' id='util.smartptr.shared.const-12'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-12'>12</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, <span class='texttt'>d(p)</span> is called.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T* p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-13'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>shared_ptr</span> instance that
stores <span class='texttt'>p</span> and <i>shares ownership</i> with <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-14'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p &amp;&amp; use_count() == r.use_count()</span></p></div></div><div class='para' id='util.smartptr.shared.const-15'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-15'>15</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> To avoid the possibility of a dangling pointer, the
user of this constructor must ensure that <span class='texttt'>p</span> remains valid at
least until the ownership group of <span class='texttt'>r</span> is destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='util.smartptr.shared.const-16'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-16'>16</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This constructor allows creation of an <i>empty</i>
<span class='texttt'>shared_ptr</span> instance with a non-null stored pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
shared_ptr(const shared_ptr&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-17'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-17'>17</a></div><div class='itemdescr'><p ><i>Remark:</i>
The second constructor shall not participate in overload resolution unless
<span class='texttt'>Y*</span> is implicitly convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-18'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i>  If <span class='texttt'>r</span> is <i>empty</i>, constructs
an <i>empty</i> <span class='texttt'>shared_ptr</span> object; otherwise, constructs
a <span class='texttt'>shared_ptr</span> object that <i>shares ownership</i> with <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-19'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-19'>19</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>get() == r.get() &amp;&amp; use_count() == r.use_count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
shared_ptr(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-20'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-20'>20</a></div><div class='itemdescr'><p ><i>Remark:</i> The second constructor shall not participate in overload resolution unless
<span class='texttt'>Y*</span> is convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-21'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i> Move-constructs a <span class='texttt'>shared_ptr</span> instance from
<span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-22'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-22'>22</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> shall contain the old value of
<span class='texttt'>r</span>. <span class='texttt'>r</span> shall be <i>empty</i>. <span class='texttt'>r.get() == nullptr.</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='weak_ptr'></a></span><code class='itemdecl'>
template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-23'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Y*</span> shall be convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-24'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that <i>shares ownership</i> with
<span class='texttt'>r</span> and stores a copy of the pointer stored in <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-25'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-25'>25</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == r.use_count()</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-26'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_weak_ptr</span> when <span class='texttt'>r.expired()</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-27'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-27'>27</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, the constructor has no
effect.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='auto_ptr'></a></span>
<code class='itemdecl'>
template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-28'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-28'>28</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>r.release()</span> shall be convertible to <span class='texttt'>T*</span>.
<span class='texttt'>Y</span> shall be a complete type. The expression <span class='texttt'>delete
r.release()</span> shall be well formed, shall have well defined behavior,
and shall not throw exceptions.</p></div></div><div class='para' id='util.smartptr.shared.const-29'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that stores and <i>owns</i>
<span class='texttt'>r.release()</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-30'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-30'>30</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1</span> <span class='texttt'>&amp;&amp;</span> <span class='texttt'>r.get() == nullptr</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-31'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-31'>31</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception when a
resource other than memory could not be obtained.</p></div></div><div class='para' id='util.smartptr.shared.const-32'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-32'>32</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, the constructor has no
effect.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='unique_ptr'></a></span><code class='itemdecl'>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.const-33'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(r.release(), r.get_deleter())</span> when
<span class='texttt'>D</span> is not a reference type, otherwise <span class='texttt'>shared_ptr(r.release(),
ref(r.get_deleter()))</span>.</p></div></div><div class='para' id='util.smartptr.shared.const-34'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.const-34'>34</a></div><div class='itemdescr'><p ><i>Exception safety:</i> If an exception is thrown, the constructor has no effect.
</p></div></div></div><div id='util.smartptr.shared.dest'><h4 ><a class='secnum' href='#util.smartptr.shared.dest' style='min-width:133pt'>20.8.2.2.2</a> <span class='texttt'>shared_ptr</span> destructor <a class='abbr_ref' href='util.smartptr.shared.dest'>[util.smartptr.shared.dest]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,destructor'></a></span><code class='itemdecl'>
~shared_ptr();
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.dest-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.dest-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='util.smartptr.shared.dest-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.dest-1.1'>(1.1)</a></div><p >If <span class='texttt'>*this</span> is <i>empty</i> or shares ownership with another
<span class='texttt'>shared_ptr</span> instance (<span class='texttt'>use_count() &gt; 1</span>), there are no side effects.</p></li><li id='util.smartptr.shared.dest-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.dest-1.2'>(1.2)</a></div><p >Otherwise, if <span class='texttt'>*this</span> <i>owns</i> an object
<span class='texttt'>p</span> and a deleter <span class='texttt'>d</span>, <span class='texttt'>d(p)</span> is called.</p></li><li id='util.smartptr.shared.dest-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.dest-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>*this</span> <i>owns</i> a pointer <span class='texttt'>p</span>,
and <span class='texttt'>delete p</span> is called.
</p></li></ul></div></div><div class='para' id='util.smartptr.shared.dest-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.dest-2'>2</a></div><p >[&nbsp;<i>Note:</i> Since the destruction of <span class='texttt'>*this</span>
decreases the number of instances that share ownership with <span class='texttt'>*this</span>
by one,
after <span class='texttt'>*this</span> has been destroyed
all <span class='texttt'>shared_ptr</span> instances that shared ownership with
<span class='texttt'>*this</span> will report a <span class='texttt'>use_count()</span> that is one less
than its previous value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='util.smartptr.shared.assign'><h4 ><a class='secnum' href='#util.smartptr.shared.assign' style='min-width:133pt'>20.8.2.2.3</a> <span class='texttt'>shared_ptr</span> assignment <a class='abbr_ref' href='util.smartptr.shared.assign'>[util.smartptr.shared.assign]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><code class='itemdecl'>
shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(r).swap(*this)</span>.</p></div></div><div class='para' id='util.smartptr.shared.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>.</p></div></div><div class='para' id='util.smartptr.shared.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
The use count updates caused by the temporary object
construction and destruction are not observable side
effects, so the implementation may meet the effects (and the
implied guarantees) via different means, without creating a
temporary. In particular, in the example:
</p><pre class='codeblock'>
shared_ptr&lt;int&gt; p(new int);
shared_ptr&lt;void&gt; q(p);
p = p;
q = p;
</pre><p >both assignments may be no-ops. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><code class='itemdecl'>
shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(std::move(r)).swap(*this)</span>.</p></div></div><div class='para' id='util.smartptr.shared.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><code class='itemdecl'>
template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(std::move(r)).swap(*this)</span>.</p></div></div><div class='para' id='util.smartptr.shared.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.assign-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='util.smartptr.shared.mod'><h4 ><a class='secnum' href='#util.smartptr.shared.mod' style='min-width:133pt'>20.8.2.2.4</a> <span class='texttt'>shared_ptr</span> modifiers <a class='abbr_ref' href='util.smartptr.shared.mod'>[util.smartptr.shared.mod]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,shared_ptr'></a></span><code class='itemdecl'>
void swap(shared_ptr&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Exchanges the contents of <span class='texttt'>*this</span> and <span class='texttt'>r</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
void reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.mod-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr().swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y&gt; void reset(Y* p);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.mod-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.mod-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p).swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y, class D&gt; void reset(Y* p, D d);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.mod-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.mod-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p, d).swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.mod-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.mod-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p, d, a).swap(*this)</span>.
</p></div></div></div><div id='util.smartptr.shared.obs'><h4 ><a class='secnum' href='#util.smartptr.shared.obs' style='min-width:133pt'>20.8.2.2.5</a> <span class='texttt'>shared_ptr</span> observers <a class='abbr_ref' href='util.smartptr.shared.obs'>[util.smartptr.shared.obs]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,get'></a></span><span class='indexparent'><a class='index' id='get,shared_ptr'></a></span><code class='itemdecl'>
T* get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  the stored pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator*'></a></span><span class='indexparent'><a class='index' id='operator*,shared_ptr'></a></span><code class='itemdecl'>
T&amp; operator*() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>get() != 0</span>.</p></div></div><div class='para' id='util.smartptr.shared.obs-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*get()</span>.</p></div></div><div class='para' id='util.smartptr.shared.obs-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> When <span class='texttt'>T</span> is <span class='texttt'>void</span>, it is unspecified whether this
member function is declared. If it is declared, it is unspecified what its
return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator->'></a></span><span class='indexparent'><a class='index' id='operator->,shared_ptr'></a></span><code class='itemdecl'>
T* operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>get() != 0</span>.</p></div></div><div class='para' id='util.smartptr.shared.obs-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,use_count'></a></span><span class='indexparent'><a class='index' id='use_count,shared_ptr'></a></span><code class='itemdecl'>
long use_count() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>  the number of <span class='texttt'>shared_ptr</span> objects, <span class='texttt'>*this</span> included,
that <i>share ownership</i> with <span class='texttt'>*this</span>, or <span class='texttt'>0</span> when <span class='texttt'>*this</span> is
<i>empty</i>.</p></div></div><div class='para' id='util.smartptr.shared.obs-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>use_count()</span> is not necessarily
efficient.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,unique'></a></span><span class='indexparent'><a class='index' id='unique,shared_ptr'></a></span><code class='itemdecl'>
bool unique() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>use_count() == 1</span>.</p></div></div><div class='para' id='util.smartptr.shared.obs-10'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-10'>10</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>unique()</span> may be faster than <span class='texttt'>use_count()</span>.  If you are
using <span class='texttt'>unique()</span> to implement copy on write, do not rely on a
specific value when <span class='texttt'>get() == nullptr</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-11'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get() != 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='owner_before,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,owner_before'></a></span><code class='itemdecl'>
template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.obs-12'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.obs-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> An unspecified value such that</p><ul class='itemize'><li id='util.smartptr.shared.obs-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.obs-12.1'>(12.1)</a></div><p ><span class='texttt'>x.owner_before(y)</span> defines a strict weak ordering as defined in <a href='alg.sorting'>[alg.sorting]</a>;</p></li><li id='util.smartptr.shared.obs-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.obs-12.2'>(12.2)</a></div><p >under the equivalence relation defined by <span class='texttt'>owner_before</span>,
<span class='texttt'>!a.owner_before(b) &amp;&amp; !b.owner_before(a)</span>, two <span class='texttt'>shared_ptr</span> or
<span class='texttt'>weak_ptr</span> instances are equivalent if and only if they share ownership or
are both empty.
</p></li></ul></div></div></div><div id='util.smartptr.shared.create'><h4 ><a class='secnum' href='#util.smartptr.shared.create' style='min-width:133pt'>20.8.2.2.6</a> <span class='texttt'>shared_ptr</span> creation <a class='abbr_ref' href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a></h4><p ><span class='indexparent'><a class='index' id='make_shared'></a></span><span class='indexparent'><a class='index' id='allocate_shared'></a></span><code class='itemdecl'>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.create-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>::new (pv) T(std::forward&lt;Args&gt;(args)...)</span>,
where <span class='texttt'>pv</span> has type <span class='texttt'>void*</span> and points to storage suitable
to hold an object of type <span class='texttt'>T</span>, shall be well formed. <span class='texttt'>A</span> shall
be an <i>allocator</i> (<a href='allocator.requirements'>[allocator.requirements]</a>). The copy constructor
and destructor of <span class='texttt'>A</span> shall not throw exceptions.</p></div></div><div class='para' id='util.smartptr.shared.create-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Allocates memory suitable for an object of type <span class='texttt'>T</span>
and constructs an object in that memory via the placement new expression
<span class='texttt'>::new (pv) T(std::forward&lt;Args&gt;(args)...)</span>.
The template <span class='texttt'>allocate_shared</span> uses a copy of <span class='texttt'>a</span> to
allocate memory. If an exception is thrown, the functions have no effect.</p></div></div><div class='para' id='util.smartptr.shared.create-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>shared_ptr</span> instance that stores and owns
the address of the newly constructed object of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='util.smartptr.shared.create-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() != 0 &amp;&amp; use_count() == 1</span></p></div></div><div class='para' id='util.smartptr.shared.create-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span>, or an exception thrown from
<span class='texttt'>A::allocate</span> or from the constructor of <span class='texttt'>T</span>.</p></div></div><div class='para' id='util.smartptr.shared.create-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> Implementations should
perform no more than one memory allocation. [&nbsp;<i>Note:</i> This provides
efficiency equivalent to an intrusive smart pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='util.smartptr.shared.create-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.create-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> These functions will typically allocate more memory
than <span class='texttt'>sizeof(T)</span> to allow for internal bookkeeping structures such
as the reference counts. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='util.smartptr.shared.cmp'><h4 ><a class='secnum' href='#util.smartptr.shared.cmp' style='min-width:133pt'>20.8.2.2.7</a> <span class='texttt'>shared_ptr</span> comparison <a class='abbr_ref' href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>a.get() == b.get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>less&lt;V&gt;()(a.get(), b.get())</span>,
where <span class='texttt'>V</span> is the composite pointer type (Clause <a href='expr'>[expr]</a>) of <span class='texttt'>T*</span> and <span class='texttt'>U*</span>.</p></div></div><div class='para' id='util.smartptr.shared.cmp-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
Defining a comparison operator allows <span class='texttt'>shared_ptr</span> objects to be
used as keys in associative containers.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator=='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(bool)a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns
<span class='texttt'>less&lt;T*&gt;()(a.get(), nullptr)</span>.
The second function template returns
<span class='texttt'>less&lt;T*&gt;()(nullptr, a.get())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>nullptr &lt; a</span>.
The second function template returns <span class='texttt'>a &lt; nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(nullptr &lt; a)</span>.
The second function template returns <span class='texttt'>!(a &lt; nullptr)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cmp-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cmp-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(a &lt; nullptr)</span>.
The second function template returns <span class='texttt'>!(nullptr &lt; a)</span>.
</p></div></div></div><div id='util.smartptr.shared.spec'><h4 ><a class='secnum' href='#util.smartptr.shared.spec' style='min-width:133pt'>20.8.2.2.8</a> <span class='texttt'>shared_ptr</span> specialized algorithms <a class='abbr_ref' href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>a.swap(b)</span>.
</p></div></div></div><div id='util.smartptr.shared.cast'><h4 ><a class='secnum' href='#util.smartptr.shared.cast' style='min-width:133pt'>20.8.2.2.9</a> <span class='texttt'>shared_ptr</span> casts <a class='abbr_ref' href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,static_pointer_cast'></a></span><span class='indexparent'><a class='index' id='static_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cast-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>static_cast&lt;T*&gt;(r.get())</span> shall
be well formed.</p></div></div><div class='para' id='util.smartptr.shared.cast-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>r</span> is <i>empty</i>, an <i>empty</i>
<span class='texttt'>shared_ptr&lt;T&gt;</span>; otherwise, a <span class='texttt'>shared_ptr&lt;T&gt;</span> object that
stores <span class='texttt'>static_cast&lt;T*&gt;(r.get())</span> and <i>shares ownership</i>
with <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.cast-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>w.get() == static_cast&lt;T*&gt;(r.get())</span> and
<span class='texttt'>w.use_count() == r.use_count()</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='util.smartptr.shared.cast-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</span>
will eventually result in undefined behavior, attempting to delete the
same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,dynamic_pointer_cast'></a></span><span class='indexparent'><a class='index' id='dynamic_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cast-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>dynamic_cast&lt;T*&gt;(r.get())</span>
shall be well formed and shall have well defined behavior.</p></div></div><div class='para' id='util.smartptr.shared.cast-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='util.smartptr.shared.cast-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.cast-6.1'>(6.1)</a></div><p >When <span class='texttt'>dynamic_cast&lt;T*&gt;(r.get())</span> returns a nonzero value, a
  <span class='texttt'>shared_ptr&lt;T&gt;</span> object that stores a copy of it and <i>shares
  ownership</i> with <span class='texttt'>r</span>;</p></li><li id='util.smartptr.shared.cast-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.shared.cast-6.2'>(6.2)</a></div><p >Otherwise, an <i>empty</i> <span class='texttt'>shared_ptr&lt;T&gt;</span> object.
</p></li></ul></div></div><div class='para' id='util.smartptr.shared.cast-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-7'>7</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>w.get() == dynamic_cast&lt;T*&gt;(r.get())</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='util.smartptr.shared.cast-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>  The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</span> will eventually result in
undefined behavior, attempting to delete the same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,const_pointer_cast'></a></span><span class='indexparent'><a class='index' id='const_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.cast-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>const_cast&lt;T*&gt;(r.get())</span> shall
be well formed.</p></div></div><div class='para' id='util.smartptr.shared.cast-10'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>r</span> is empty, an empty <span class='texttt'>shared_ptr&lt;T&gt;</span>; otherwise, a
<span class='texttt'>shared_ptr&lt;T&gt;</span> object that stores <span class='texttt'>const_cast&lt;T*&gt;(r.get())</span> and shares
ownership with <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.shared.cast-11'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>w.get() == const_cast&lt;T*&gt;(r.get())</span> and
<span class='texttt'>w.use_count() == r.use_count()</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='util.smartptr.shared.cast-12'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.cast-12'>12</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))</span> will eventually result in
undefined behavior, attempting to delete the same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='util.smartptr.getdeleter'><h4 ><a class='secnum' href='#util.smartptr.getdeleter' style='min-width:133pt'>20.8.2.2.10</a> get_deleter <a class='abbr_ref' href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,get_deleter'></a></span><span class='indexparent'><a class='index' id='get_deleter,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.getdeleter-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.getdeleter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>p</span> <i>owns</i> a deleter <span class='texttt'>d</span> of type cv-unqualified
<span class='texttt'>D</span>, returns <span class='texttt'>&amp;d</span>; otherwise returns <span class='texttt'>nullptr</span>. The returned
pointer remains valid as long as there exists a <span class='texttt'>shared_ptr</span> instance
that owns <span class='texttt'>d</span>. [&nbsp;<i>Note:</i> It is unspecified whether the pointer
remains valid longer than that. This can happen if the implementation doesn't destroy
the deleter until all <span class='texttt'>weak_ptr</span> instances that share ownership with
<span class='texttt'>p</span> have been destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='util.smartptr.shared.io'><h4 ><a class='secnum' href='#util.smartptr.shared.io' style='min-width:133pt'>20.8.2.2.11</a> <span class='texttt'>shared_ptr</span> I/O <a class='abbr_ref' href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a></h4><p ><span class='indexparent'><a class='index' id='operator<<,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<<'></a></span><code class='itemdecl'>
template&lt;class E, class T, class Y&gt;
  basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, shared_ptr&lt;Y&gt; const&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.io-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.io-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  <span class='texttt'>os &lt;&lt; p.get();</span>.</p></div></div><div class='para' id='util.smartptr.shared.io-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.io-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>os</span>.
</p></div></div></div></div><div id='util.smartptr.weak'><h4 ><a class='secnum' href='#util.smartptr.weak' style='min-width:118pt'>20.8.2.3</a> Class template <span class='texttt'>weak_ptr</span> <a class='abbr_ref' href='util.smartptr.weak'>[util.smartptr.weak]</a></h4><div class='para' id='util.smartptr.weak-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak-1'>1</a></div><p ><span class='indexparent'><a class='index' id='weak_ptr'></a></span>The <span class='texttt'>weak_ptr</span> class template stores a weak reference to an object
that is already managed by a <span class='texttt'>shared_ptr</span>. To access the object, a
<span class='texttt'>weak_ptr</span> can be converted to a <span class='texttt'>shared_ptr</span> using the member
function <span class='texttt'>lock</span>.</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class weak_ptr {
  public:
    typedef T element_type;

    <span class='comment'>// <a href='util.smartptr.weak.const'>[util.smartptr.weak.const]</a>, constructors
</span>    constexpr weak_ptr() noexcept;
    template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr(weak_ptr const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;

    <span class='comment'>// <a href='util.smartptr.weak.dest'>[util.smartptr.weak.dest]</a>, destructor
</span>    ~weak_ptr();

    <span class='comment'>// <a href='util.smartptr.weak.assign'>[util.smartptr.weak.assign]</a>, assignment
</span>    weak_ptr&amp; operator=(weak_ptr const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;    

    <span class='comment'>// <a href='util.smartptr.weak.mod'>[util.smartptr.weak.mod]</a>, modifiers
</span>    void swap(weak_ptr&amp; r) noexcept;
    void reset() noexcept;

    <span class='comment'>// <a href='util.smartptr.weak.obs'>[util.smartptr.weak.obs]</a>, observers
</span>    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr&lt;T&gt; lock() const noexcept;
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
  };

  <span class='comment'>// <a href='util.smartptr.weak.spec'>[util.smartptr.weak.spec]</a>, specialized algorithms
</span>  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;
} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='util.smartptr.weak-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak-2'>2</a></div><p >Specializations of <span class='texttt'>weak_ptr</span> shall be <span class='texttt'>CopyConstructible</span> and
<span class='texttt'>CopyAssignable</span>, allowing their use in standard
containers.  The template parameter <span class='texttt'>T</span> of <span class='texttt'>weak_ptr</span> may be an
incomplete type.</p></div><div id='util.smartptr.weak.const'><h4 ><a class='secnum' href='#util.smartptr.weak.const' style='min-width:133pt'>20.8.2.3.1</a> <span class='texttt'>weak_ptr</span> constructors <a class='abbr_ref' href='util.smartptr.weak.const'>[util.smartptr.weak.const]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,constructor'></a></span><code class='itemdecl'>
constexpr weak_ptr() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.const-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an <i>empty</i> <span class='texttt'>weak_ptr</span> object.</p></div></div><div class='para' id='util.smartptr.weak.const-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,constructor'></a></span><code class='itemdecl'>
weak_ptr(const weak_ptr&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.const-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-3'>3</a></div><div class='itemdescr'><p ><i>Remark:</i> The second and third constructors shall not participate in
overload resolution unless <span class='texttt'>Y*</span> is implicitly convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='util.smartptr.weak.const-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  If <span class='texttt'>r</span> is <i>empty</i>, constructs
an <i>empty</i> <span class='texttt'>weak_ptr</span> object; otherwise, constructs
a <span class='texttt'>weak_ptr</span> object that <i>shares ownership</i>
with <span class='texttt'>r</span> and stores a copy of the pointer stored in <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.weak.const-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == r.use_count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,constructor'></a></span><code class='itemdecl'>
weak_ptr(weak_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.const-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-6'>6</a></div><div class='itemdescr'><p ><i>Remark:</i> The second constructor shall not participate in overload resolution unless
<span class='texttt'>Y*</span> is implicitly convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='util.smartptr.weak.const-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Move-constructs a <span class='texttt'>weak_ptr</span> instance from <span class='texttt'>r</span>.</p></div></div><div class='para' id='util.smartptr.weak.const-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.const-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> shall contain the old value of <span class='texttt'>r</span>.
<span class='texttt'>r</span> shall be <i>empty</i>. <span class='texttt'>r.use_count() == 0</span>.
</p></div></div></div><div id='util.smartptr.weak.dest'><h4 ><a class='secnum' href='#util.smartptr.weak.dest' style='min-width:133pt'>20.8.2.3.2</a> <span class='texttt'>weak_ptr</span> destructor <a class='abbr_ref' href='util.smartptr.weak.dest'>[util.smartptr.weak.dest]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,destructor'></a></span><code class='itemdecl'>
~weak_ptr();
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.dest-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.dest-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Destroys this <span class='texttt'>weak_ptr</span> object but has no
effect on the object its stored pointer points to.
</p></div></div></div><div id='util.smartptr.weak.assign'><h4 ><a class='secnum' href='#util.smartptr.weak.assign' style='min-width:133pt'>20.8.2.3.3</a> <span class='texttt'>weak_ptr</span> assignment <a class='abbr_ref' href='util.smartptr.weak.assign'>[util.smartptr.weak.assign]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,operator='></a></span><span class='indexparent'><a class='index' id='operator=,weak_ptr'></a></span><code class='itemdecl'>
weak_ptr&amp; operator=(const weak_ptr&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr&amp; operator=(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>weak_ptr(r).swap(*this)</span>.</p></div></div><div class='para' id='util.smartptr.weak.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.assign-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>  The implementation may meet the effects (and the
implied guarantees) via different means, without creating a temporary.</p></div></div><div class='para' id='util.smartptr.weak.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,operator='></a></span><span class='indexparent'><a class='index' id='operator=,weak_ptr'></a></span><code class='itemdecl'>
weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>weak_ptr(std::move(r)).swap(*this)</span>.</p></div></div><div class='para' id='util.smartptr.weak.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.assign-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>.
</p></div></div></div><div id='util.smartptr.weak.mod'><h4 ><a class='secnum' href='#util.smartptr.weak.mod' style='min-width:133pt'>20.8.2.3.4</a> <span class='texttt'>weak_ptr</span> modifiers <a class='abbr_ref' href='util.smartptr.weak.mod'>[util.smartptr.weak.mod]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,weak_ptr'></a></span><code class='itemdecl'>
void swap(weak_ptr&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Exchanges the contents of <span class='texttt'>*this</span> and <span class='texttt'>r</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,reset'></a></span><span class='indexparent'><a class='index' id='reset,weak_ptr'></a></span><code class='itemdecl'>
void reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.mod-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>weak_ptr().swap(*this)</span>.
</p></div></div></div><div id='util.smartptr.weak.obs'><h4 ><a class='secnum' href='#util.smartptr.weak.obs' style='min-width:133pt'>20.8.2.3.5</a> <span class='texttt'>weak_ptr</span> observers <a class='abbr_ref' href='util.smartptr.weak.obs'>[util.smartptr.weak.obs]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,use_count'></a></span><span class='indexparent'><a class='index' id='use_count,weak_ptr'></a></span><code class='itemdecl'>
long use_count() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.obs-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>0</span> if <span class='texttt'>*this</span> is <i>empty</i>;
otherwise, the number of <span class='texttt'>shared_ptr</span> instances
that <i>share ownership</i> with <span class='texttt'>*this</span>.</p></div></div><div class='para' id='util.smartptr.weak.obs-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>use_count()</span> is not necessarily
efficient.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,expired'></a></span><span class='indexparent'><a class='index' id='expired,weak_ptr'></a></span><code class='itemdecl'>
bool expired() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.obs-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>use_count() == 0</span>.</p></div></div><div class='para' id='util.smartptr.weak.obs-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>  <span class='texttt'>expired()</span> may be faster
than <span class='texttt'>use_count()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='weak_ptr,lock'></a></span><span class='indexparent'><a class='index' id='lock,weak_ptr'></a></span><code class='itemdecl'>
shared_ptr&lt;T&gt; lock() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.obs-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)</span>, executed atomically.
</p></div></div><p ><span class='indexparent'><a class='index' id='owner_before,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,owner_before'></a></span><code class='itemdecl'>
template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.obs-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.obs-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> An unspecified value such that</p><ul class='itemize'><li id='util.smartptr.weak.obs-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.weak.obs-6.1'>(6.1)</a></div><p ><span class='texttt'>x.owner_before(y)</span> defines a strict weak ordering as defined in <a href='alg.sorting'>[alg.sorting]</a>;</p></li><li id='util.smartptr.weak.obs-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.weak.obs-6.2'>(6.2)</a></div><p >under the equivalence relation defined by <span class='texttt'>owner_before</span>,
<span class='texttt'>!a.owner_before(b) &amp;&amp; !b.owner_before(a)</span>, two <span class='texttt'>shared_ptr</span> or
<span class='texttt'>weak_ptr</span> instances are equivalent if and only if they share ownership or are
both empty.
</p></li></ul></div></div></div><div id='util.smartptr.weak.spec'><h4 ><a class='secnum' href='#util.smartptr.weak.spec' style='min-width:133pt'>20.8.2.3.6</a> <span class='texttt'>weak_ptr</span> specialized algorithms <a class='abbr_ref' href='util.smartptr.weak.spec'>[util.smartptr.weak.spec]</a></h4><p ><span class='indexparent'><a class='index' id='weak_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,weak_ptr'></a></span><code class='itemdecl'>
template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.weak.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.weak.spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>a.swap(b)</span>.
</p></div></div></div></div><div id='util.smartptr.ownerless'><h4 ><a class='secnum' href='#util.smartptr.ownerless' style='min-width:118pt'>20.8.2.4</a> Class template <span class='texttt'>owner_less</span> <a class='abbr_ref' href='util.smartptr.ownerless'>[util.smartptr.ownerless]</a></h4><div class='para' id='util.smartptr.ownerless-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.ownerless-1'>1</a></div><p >The class template <span class='texttt'>owner_less</span> allows ownership-based mixed comparisons of shared
and weak pointers.</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct owner_less;

  template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt; &gt; {
    typedef bool result_type;
    typedef shared_ptr&lt;T&gt; first_argument_type;
    typedef shared_ptr&lt;T&gt; second_argument_type;
    bool operator()(shared_ptr&lt;T&gt; const&amp;, shared_ptr&lt;T&gt; const&amp;) const;
    bool operator()(shared_ptr&lt;T&gt; const&amp;, weak_ptr&lt;T&gt; const&amp;) const;
    bool operator()(weak_ptr&lt;T&gt; const&amp;, shared_ptr&lt;T&gt; const&amp;) const;
  };

  template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt; &gt; {
    typedef bool result_type;
    typedef weak_ptr&lt;T&gt; first_argument_type;
    typedef weak_ptr&lt;T&gt; second_argument_type;
    bool operator()(weak_ptr&lt;T&gt; const&amp;, weak_ptr&lt;T&gt; const&amp;) const;
    bool operator()(shared_ptr&lt;T&gt; const&amp;, weak_ptr&lt;T&gt; const&amp;) const;
    bool operator()(weak_ptr&lt;T&gt; const&amp;, shared_ptr&lt;T&gt; const&amp;) const;
  };
}
</pre></div><div class='para' id='util.smartptr.ownerless-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.ownerless-2'>2</a></div><p ><span class='texttt'>operator()(x,y)</span> shall return <span class='texttt'>x.owner_before(y)</span>. [&nbsp;<i>Note:</i>
Note that</p><ul class='itemize'><li id='util.smartptr.ownerless-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.ownerless-2.1'>(2.1)</a></div><p ><span class='texttt'>operator()</span> defines a strict weak ordering as defined in <a href='alg.sorting'>[alg.sorting]</a>;</p></li><li id='util.smartptr.ownerless-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#util.smartptr.ownerless-2.2'>(2.2)</a></div><p >under the equivalence relation defined by <span class='texttt'>operator()</span>,
<span class='texttt'>!operator()(a, b) &amp;&amp; !operator()(b, a)</span>, two <span class='texttt'>shared_ptr</span> or
<span class='texttt'>weak_ptr</span> instances are equivalent if and only if they share ownership or are
both empty.
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='util.smartptr.enab'><h4 ><a class='secnum' href='#util.smartptr.enab' style='min-width:118pt'>20.8.2.5</a> Class template <span class='texttt'>enable_shared_from_this</span> <a class='abbr_ref' href='util.smartptr.enab'>[util.smartptr.enab]</a></h4><div class='para' id='util.smartptr.enab-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-1'>1</a></div><p ><span class='indexparent'><a class='index' id='enable_shared_from_this'></a></span>A class <span class='texttt'>T</span> can inherit from <span class='texttt'>enable_shared_from_this&lt;T&gt;</span>
to inherit the <span class='texttt'>shared_from_this</span> member functions that obtain
a <i>shared_ptr</i> instance pointing to <span class='texttt'>*this</span>.</p></div><div class='para' id='util.smartptr.enab-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-2'>2</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X: public enable_shared_from_this&lt;X&gt; {
};

int main() {
  shared_ptr&lt;X&gt; p(new X);
  shared_ptr&lt;X&gt; q = p-&gt;shared_from_this();
  assert(p == q);
  assert(!(p &lt; q ) &amp;&amp; !(q &lt; p)); <span class='comment'>// p and q share ownership
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(enable_shared_from_this const&amp;) noexcept;
    enable_shared_from_this&amp; operator=(enable_shared_from_this const&amp;) noexcept;
    ~enable_shared_from_this();
  public:
    shared_ptr&lt;T&gt; shared_from_this();
    shared_ptr&lt;T const&gt; shared_from_this() const;
  };
} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='util.smartptr.enab-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-3'>3</a></div><p >The template parameter <span class='texttt'>T</span> of <span class='texttt'>enable_shared_from_this</span>
may be an incomplete type.</p><p ><span class='indexparent'><a class='index' id='enable_shared_from_this,constructor'></a></span><code class='itemdecl'>
constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(const enable_shared_from_this&lt;T&gt;&amp;) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='util.smartptr.enab-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an <span class='texttt'>enable_shared_from_this&lt;T&gt;</span> object.
</p></div></div><p ><span class='indexparent'><a class='index' id='enable_shared_from_this,operator='></a></span><span class='indexparent'><a class='index' id='operator=,enable_shared_from_this'></a></span><code class='itemdecl'>
enable_shared_from_this&lt;T&gt;&amp; operator=(const enable_shared_from_this&lt;T&gt;&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.enab-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='enable_shared_from_this,destructor'></a></span>
<code class='itemdecl'>
~enable_shared_from_this();
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.enab-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>  Destroys <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr'></a></span><span class='indexparent'><a class='index' id='enable_shared_from_this,shared_from_this'></a></span><span class='indexparent'><a class='index' id='shared_from_this,enable_shared_from_this'></a></span><code class='itemdecl'>
shared_ptr&lt;T&gt;       shared_from_this();
shared_ptr&lt;T const&gt; shared_from_this() const;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.enab-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>enable_shared_from_this&lt;T&gt;</span> shall be an accessible base
class of <span class='texttt'>T</span>. <span class='texttt'>*this</span> shall be a subobject of an object <span class='texttt'>t</span> of
type <span class='texttt'>T</span>. There shall be at least one <span class='texttt'>shared_ptr</span> instance <span class='texttt'>p</span>
that <i>owns</i> <span class='texttt'>&amp;t</span>.</p></div></div><div class='para' id='util.smartptr.enab-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>  A <span class='texttt'>shared_ptr&lt;T&gt;</span> object <span class='texttt'>r</span>
that <i>shares ownership with</i> <span class='texttt'>p</span>.</p></div></div><div class='para' id='util.smartptr.enab-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>r.get() == this</span>.
</p></div></div><div class='para' id='util.smartptr.enab-10'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-10'>10</a></div><p >[&nbsp;<i>Note:</i> A possible implementation is shown below:
</p><pre class='codeblock'>
template&lt;class T&gt; class enable_shared_from_this {
private:
  weak_ptr&lt;T&gt; __weak_this;
protected:
  constexpr enable_shared_from_this() : __weak_this() { }
  enable_shared_from_this(enable_shared_from_this const &amp;) { }
  enable_shared_from_this&amp; operator=(enable_shared_from_this const &amp;) { return *this; }
  ~enable_shared_from_this() { }
public:
  shared_ptr&lt;T&gt; shared_from_this() { return shared_ptr&lt;T&gt;(__weak_this); }
  shared_ptr&lt;T const&gt; shared_from_this() const { return shared_ptr&lt;T const&gt;(__weak_this); }
};
</pre></div><div class='para' id='util.smartptr.enab-11'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.enab-11'>11</a></div><p >The <span class='texttt'>shared_ptr</span> constructors that create unique pointers
can detect the presence of an <span class='texttt'>enable_shared_from_this</span> base and
assign the newly created <span class='texttt'>shared_ptr</span> to its <span class='texttt'>__weak_this</span>
member. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='util.smartptr.shared.atomic'><h4 ><a class='secnum' href='#util.smartptr.shared.atomic' style='min-width:118pt'>20.8.2.6</a> <span class='texttt'>shared_ptr</span> atomic access <a class='abbr_ref' href='util.smartptr.shared.atomic'>[util.smartptr.shared.atomic]</a></h4><div class='para' id='util.smartptr.shared.atomic-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-1'>1</a></div><p >Concurrent access to a <span class='texttt'>shared_ptr</span> object from multiple threads does not
introduce a data race if the access is done exclusively via the functions in
this section and the instance is passed as their first argument.</p></div><div class='para' id='util.smartptr.shared.atomic-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-2'>2</a></div><p >The meaning of the arguments of type <span class='texttt'>memory_order</span> is explained in <a href='atomics.order'>[atomics.order]</a>.</p><p ><span class='indexparent'><a class='index' id='atomic_is_lock_free,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_is_lock_free'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
</code></p></div><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-4'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if atomic access to <span class='texttt'>*p</span> is lock-free, <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='util.smartptr.shared.atomic-5'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_load,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_load'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-6'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-7'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>atomic_load_explicit(p, memory_order_seq_cst)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-8'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_load_explicit,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_load_explicit'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-9'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-10'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>mo</span> shall not be <span class='texttt'>memory_order_release</span> or <span class='texttt'>memory_order_acq_rel</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-11'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*p</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-12'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-12'>12</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_store,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_store'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-13'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-14'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>atomic_store_explicit(p, r, memory_order_seq_cst)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-15'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_store_explicit,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_store_explicit'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-16'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-16'>16</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-17'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-17'>17</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>mo</span> shall not be <span class='texttt'>memory_order_acquire</span> or <span class='texttt'>memory_order_acq_rel</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-18'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>p-&gt;swap(r)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-19'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-19'>19</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_exchange,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_exchange'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-20'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-20'>20</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-21'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>atomic_exchange_explicit(p, r, memory_order_seq_cst)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-22'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-22'>22</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_exchange_explicit,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_exchange_explicit'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                         memory_order mo);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-23'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-24'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>p-&gt;swap(r)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-25'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i> The previous value of <span class='texttt'>*p</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-26'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_compare_exchange_weak'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  bool atomic_compare_exchange_weak(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-27'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-27'>27</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null and <span class='texttt'>v</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-28'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-28'>28</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>atomic_compare_exchange_weak_explicit(p, v, w,
memory_order_seq_cst, memory_order_seq_cst)</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-29'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-29'>29</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_compare_exchange_strong'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  bool atomic_compare_exchange_strong(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-30'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-30'>30</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>atomic_compare_exchange_strong_explicit(p, v, w,</span>
<span class='texttt'>memory_order_seq_cst, memory_order_seq_cst)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak_explicit,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_compare_exchange_weak_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong_explicit,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,atomic_compare_exchange_strong_explicit'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
    memory_order success, memory_order failure);
template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
    memory_order success, memory_order failure);
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.shared.atomic-31'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-31'>31</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> shall not be null and <span class='texttt'>v</span> shall not be null.</p></div></div><div class='para' id='util.smartptr.shared.atomic-32'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-32'>32</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>failure</span> shall not be <span class='texttt'>memory_order_release</span>,
<span class='texttt'>memory_order_acq_rel</span>, or stronger than <span class='texttt'>success</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-33'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*p</span> is equivalent to <span class='texttt'>*v</span>, assigns <span class='texttt'>w</span> to
<span class='texttt'>*p</span> and has synchronization semantics corresponding to the value of
<span class='texttt'>success</span>, otherwise assigns <span class='texttt'>*p</span> to <span class='texttt'>*v</span> and has
synchronization semantics corresponding to the value of <span class='texttt'>failure</span>.</p></div></div><div class='para' id='util.smartptr.shared.atomic-34'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-34'>34</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*p</span> was equivalent to <span class='texttt'>*v</span>, <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='util.smartptr.shared.atomic-35'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-35'>35</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='util.smartptr.shared.atomic-36'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-36'>36</a></div><div class='itemdescr'><p ><i>Remarks:</i> two <span class='texttt'>shared_ptr</span> objects are equivalent if they store the same
pointer value and share ownership.</p></div></div><div class='para' id='util.smartptr.shared.atomic-37'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.shared.atomic-37'>37</a></div><div class='itemdescr'><p ><i>Remarks:</i> the weak forms may fail spuriously. See <a href='atomics.types.operations'>[atomics.types.operations]</a>.
</p></div></div></div><div id='util.smartptr.hash'><h4 ><a class='secnum' href='#util.smartptr.hash' style='min-width:118pt'>20.8.2.7</a> Smart pointer hash support <a class='abbr_ref' href='util.smartptr.hash'>[util.smartptr.hash]</a></h4><p ><span class='indexparent'><a class='index' id='hash'></a></span><code class='itemdecl'>
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.hash-1'>1</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class
template <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>). For an object <span class='texttt'>p</span> of type <span class='texttt'>UP</span>,
where <span class='texttt'>UP</span> is <span class='texttt'>unique_ptr&lt;T, D&gt;</span>, <span class='texttt'>hash&lt;UP&gt;()(p)</span> shall evaluate to
the same value as <span class='texttt'>hash&lt;typename UP::pointer&gt;()(p.get())</span>.</p></div></div><div class='para' id='util.smartptr.hash-2'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.hash-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> The specialization <span class='texttt'>hash&lt;typename UP::pointer&gt;</span> shall be
well-formed and well-defined, and shall meet the requirements of class
template <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='hash'></a></span><code class='itemdecl'>
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.hash-3'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.hash-3'>3</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class
template <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>). For an object <span class='texttt'>p</span> of type <span class='texttt'>shared_ptr&lt;T&gt;</span>,
<span class='texttt'>hash&lt;shared_ptr&lt;T&gt; &gt;()(p)</span> shall evaluate to
the same value as <span class='texttt'>hash&lt;T*&gt;()(p.get())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='smart_pointers'></a></span></p></div></div></div><div id='function.objects'><h2 ><a class='secnum' href='#function.objects' style='min-width:88pt'>20.9</a> Function objects <a class='abbr_ref' href='function.objects'>[function.objects]</a></h2><div class='para' id='function.objects-1'><div class='marginalizedparent'><a class='marginalized' href='#function.objects-1'>1</a></div><p >A <span class='indexparent'><a class='index' id='function_object,type'></a></span><a class='hidden_link' href='#def:function_object_type' id='def:function_object_type'><i>function object type</i></a> is an object
type (<a href='basic.types'>[basic.types]</a>) that can be the type of the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> in a function call
(<a href='expr.call'>[expr.call]</a>, <a href='over.match.call'>[over.match.call]</a>).<a class='footnotenum' href='#footnote-231'>231</a> A <a class='hidden_link' href='#def:function_object' id='def:function_object'><i>function object</i></a> is an
object of a function object type. In the places where one would expect to pass a
pointer to a function to an algorithmic template (Clause <a href='algorithms'>[algorithms]</a>), the
interface is specified to accept a function object. This not only makes
algorithmic templates work with pointers to functions, but also enables them to
work with arbitrary function objects.</p></div><div class='para' id='function.objects-2'><div class='marginalizedparent'><a class='marginalized' href='#function.objects-2'>2</a></div><p ><b>Header <span class='texttt'>&lt;functional&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='functional'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='depr.base'>[depr.base]</a>, base (deprecated):
</span>  template &lt;class Arg, class Result&gt; struct unary_function;
  template &lt;class Arg1, class Arg2, class Result&gt; struct binary_function;

  <span class='comment'>// <a href='refwrap'>[refwrap]</a>, reference_wrapper:
</span>  template &lt;class T&gt; class reference_wrapper;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept;
  template &lt;class T&gt; void ref(const T&amp;&amp;) = delete;
  template &lt;class T&gt; void cref(const T&amp;&amp;) = delete;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;) noexcept;

  <span class='comment'>// <a href='arithmetic.operations'>[arithmetic.operations]</a>, arithmetic operations:
</span>  template &lt;class T = void&gt; struct plus;
  template &lt;class T = void&gt; struct minus;
  template &lt;class T = void&gt; struct multiplies;
  template &lt;class T = void&gt; struct divides;
  template &lt;class T = void&gt; struct modulus;
  template &lt;class T = void&gt; struct negate;
  template &lt;&gt; struct plus&lt;void&gt;;
  template &lt;&gt; struct minus&lt;void&gt;;
  template &lt;&gt; struct multiplies&lt;void&gt;;
  template &lt;&gt; struct divides&lt;void&gt;;
  template &lt;&gt; struct modulus&lt;void&gt;;
  template &lt;&gt; struct negate&lt;void&gt;;

  <span class='comment'>// <a href='comparisons'>[comparisons]</a>, comparisons:
</span>  template &lt;class T = void&gt; struct equal_to;
  template &lt;class T = void&gt; struct not_equal_to;
  template &lt;class T = void&gt; struct greater;
  template &lt;class T = void&gt; struct less;
  template &lt;class T = void&gt; struct greater_equal;
  template &lt;class T = void&gt; struct less_equal;
  template &lt;&gt; struct equal_to&lt;void&gt;;
  template &lt;&gt; struct not_equal_to&lt;void&gt;;
  template &lt;&gt; struct greater&lt;void&gt;;
  template &lt;&gt; struct less&lt;void&gt;;
  template &lt;&gt; struct greater_equal&lt;void&gt;;
  template &lt;&gt; struct less_equal&lt;void&gt;;

  <span class='comment'>// <a href='logical.operations'>[logical.operations]</a>, logical operations:
</span>  template &lt;class T = void&gt; struct logical_and;
  template &lt;class T = void&gt; struct logical_or;
  template &lt;class T = void&gt; struct logical_not;
  template &lt;&gt; struct logical_and&lt;void&gt;;
  template &lt;&gt; struct logical_or&lt;void&gt;;
  template &lt;&gt; struct logical_not&lt;void&gt;;

  <span class='comment'>// <a href='bitwise.operations'>[bitwise.operations]</a>, bitwise operations:
</span>  template &lt;class T = void&gt; struct bit_and;
  template &lt;class T = void&gt; struct bit_or;
  template &lt;class T = void&gt; struct bit_xor;
  template &lt;class T = void&gt; struct bit_not;
  template &lt;&gt; struct bit_and&lt;void&gt;;
  template &lt;&gt; struct bit_or&lt;void&gt;;
  template &lt;&gt; struct bit_xor&lt;void&gt;;
  template &lt;&gt; struct bit_not&lt;void&gt;;

  <span class='comment'>// <a href='negators'>[negators]</a>, negators:
</span>  template &lt;class Predicate&gt; class unary_negate;
  template &lt;class Predicate&gt;
    constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp;);
  template &lt;class Predicate&gt; class binary_negate;
  template &lt;class Predicate&gt;
    constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp;);

  <span class='comment'>// <a href='func.bind'>[func.bind]</a>, bind:
</span>  template&lt;class T&gt; struct is_bind_expression;
  template&lt;class T&gt; struct is_placeholder;

  template&lt;class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);
  template&lt;class R, class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);

  namespace placeholders {
    <span class='comment'>// M is the implementation-defined number of placeholders
</span>    extern <i><span class='texttt'>unspecified</span></i> _1;
    extern <i><span class='texttt'>unspecified</span></i> _2;
                .
                .
                .
    extern <i><span class='texttt'>unspecified</span></i> _M;
  }

  <span class='comment'>// <a href='depr.lib.binders'>[depr.lib.binders]</a>, binders (deprecated):
</span>  template &lt;class Fn&gt; class binder1st;
  template &lt;class Fn, class T&gt;
    binder1st&lt;Fn&gt; bind1st(const Fn&amp;, const T&amp;);
  template &lt;class Fn&gt; class binder2nd;
  template &lt;class Fn, class T&gt;
    binder2nd&lt;Fn&gt; bind2nd(const Fn&amp;, const T&amp;);

  <span class='comment'>// <a href='depr.function.pointer.adaptors'>[depr.function.pointer.adaptors]</a>, adaptors (deprecated):
</span>  template &lt;class Arg, class Result&gt; class pointer_to_unary_function;
  template &lt;class Arg, class Result&gt;
    pointer_to_unary_function&lt;Arg,Result&gt; ptr_fun(Result (*)(Arg));
  template &lt;class Arg1, class Arg2, class Result&gt;
    class pointer_to_binary_function;
  template &lt;class Arg1, class Arg2, class Result&gt;
    pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;
      ptr_fun(Result (*)(Arg1,Arg2));

  <span class='comment'>// <a href='depr.member.pointer.adaptors'>[depr.member.pointer.adaptors]</a>, adaptors (deprecated):
</span>  template&lt;class S, class T&gt; class mem_fun_t;
  template&lt;class S, class T, class A&gt; class mem_fun1_t;
  template&lt;class S, class T&gt;
      mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)());
  template&lt;class S, class T, class A&gt;
      mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A));
  template&lt;class S, class T&gt; class mem_fun_ref_t;
  template&lt;class S, class T, class A&gt; class mem_fun1_ref_t;
  template&lt;class S, class T&gt;
      mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)());
  template&lt;class S, class T, class A&gt;
      mem_fun1_ref_t&lt;S,T,A&gt; mem_fun_ref(S (T::*f)(A));

  template &lt;class S, class T&gt; class const_mem_fun_t;
  template &lt;class S, class T, class A&gt; class const_mem_fun1_t;
  template &lt;class S, class T&gt;
    const_mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)() const);
  template &lt;class S, class T, class A&gt;
    const_mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A) const);
  template &lt;class S, class T&gt; class const_mem_fun_ref_t;
  template &lt;class S, class T, class A&gt; class const_mem_fun1_ref_t;
  template &lt;class S, class T&gt;
    const_mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)() const);
  template &lt;class S, class T, class A&gt;
    const_mem_fun1_ref_t&lt;S,T,A&gt; mem_fun_ref(S (T::*f)(A) const);

  <span class='comment'>// <a href='func.memfn'>[func.memfn]</a>, member function adaptors:
</span>  template&lt;class R, class T&gt; <i><span class='texttt'>unspecified</span></i> mem_fn(R T::*);

  <span class='comment'>// <a href='func.wrap'>[func.wrap]</a> polymorphic function wrappers:
</span>  class bad_function_call;

  template&lt;class&gt; class function; <span class='comment'>// undefined
</span>  template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;

  template&lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;);
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;);

  <span class='comment'>// <a href='unord.hash'>[unord.hash]</a>, hash function primary template:
</span>  template &lt;class T&gt; struct hash;

  <span class='comment'>// Hash function specializations
</span>  template &lt;&gt; struct hash&lt;bool&gt;;
  template &lt;&gt; struct hash&lt;char&gt;;
  template &lt;&gt; struct hash&lt;signed char&gt;;
  template &lt;&gt; struct hash&lt;unsigned char&gt;;
  template &lt;&gt; struct hash&lt;char16_t&gt;;
  template &lt;&gt; struct hash&lt;char32_t&gt;;
  template &lt;&gt; struct hash&lt;wchar_t&gt;;
  template &lt;&gt; struct hash&lt;short&gt;;
  template &lt;&gt; struct hash&lt;unsigned short&gt;;
  template &lt;&gt; struct hash&lt;int&gt;;
  template &lt;&gt; struct hash&lt;unsigned int&gt;;
  template &lt;&gt; struct hash&lt;long&gt;;
  template &lt;&gt; struct hash&lt;long long&gt;;
  template &lt;&gt; struct hash&lt;unsigned long&gt;;
  template &lt;&gt; struct hash&lt;unsigned long long&gt;;

  template &lt;&gt; struct hash&lt;float&gt;;
  template &lt;&gt; struct hash&lt;double&gt;;
  template &lt;&gt; struct hash&lt;long double&gt;;

  template&lt;class T&gt; struct hash&lt;T*&gt;;
}
</pre></div><div class='para' id='function.objects-3'><div class='marginalizedparent'><a class='marginalized' href='#function.objects-3'>3</a></div><p >[&nbsp;<i>Example:</i>
If a C++ program wants to have a by-element addition of two vectors <span class='texttt'>a</span>
and <span class='texttt'>b</span> containing <span class='texttt'>double</span> and put the result into <span class='texttt'>a</span>,
it can do:</p><pre class='codeblock'>
transform(a.begin(), a.end(), b.begin(), a.begin(), plus&lt;double&gt;());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='function.objects-4'><div class='marginalizedparent'><a class='marginalized' href='#function.objects-4'>4</a></div><p >[&nbsp;<i>Example:</i>
To negate every element of <span class='texttt'>a</span>:</p><pre class='codeblock'>
transform(a.begin(), a.end(), a.begin(), negate&lt;double&gt;());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='function.objects-5'><div class='marginalizedparent'><a class='marginalized' href='#function.objects-5'>5</a></div><p >[&nbsp;<i>Note:</i>
To enable adaptors and other components to manipulate function objects that
take one or two arguments many of the function objects in this clause
correspondingly provide typedefs
<span class='texttt'>argument_type</span>
and
<span class='texttt'>result_type</span>
for function objects that take one argument and <span class='texttt'>first_argument_type</span>,
<span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span> for function objects
that take two arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-230'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-230'>230)</a></div><p >Such a type is a function
pointer or a class type which has a member <span class='texttt'>operator()</span> or a class type
which has a conversion to a pointer to function.</p></div><div id='func.def'><h3 ><a class='secnum' href='#func.def' style='min-width:103pt'>20.9.1</a> Definitions <a class='abbr_ref' href='func.def'>[func.def]</a></h3><div class='para' id='func.def-1'><div class='marginalizedparent'><a class='marginalized' href='#func.def-1'>1</a></div><p >The following definitions apply to this Clause:</p></div><div class='para' id='func.def-2'><div class='marginalizedparent'><a class='marginalized' href='#func.def-2'>2</a></div><p ><span class='indexparent'><a class='index' id='call_signature'></a></span>A <a class='hidden_link' href='#def:call_signature' id='def:call_signature'><i>call signature</i></a> is the name of a return type followed by a
parenthesized comma-separated list of zero or more argument types.</p></div><div class='para' id='func.def-3'><div class='marginalizedparent'><a class='marginalized' href='#func.def-3'>3</a></div><p ><span class='indexparent'><a class='index' id='callable_type'></a></span>A <a class='hidden_link' href='#def:callable_type' id='def:callable_type'><i>callable type</i></a> is a function object type (<a href='function.objects'>[function.objects]</a>) or a pointer to member.</p></div><div class='para' id='func.def-4'><div class='marginalizedparent'><a class='marginalized' href='#func.def-4'>4</a></div><p ><span class='indexparent'><a class='index' id='callable_object'></a></span>A <a class='hidden_link' href='#def:callable_object' id='def:callable_object'><i>callable object</i></a> is an object of a callable type.</p></div><div class='para' id='func.def-5'><div class='marginalizedparent'><a class='marginalized' href='#func.def-5'>5</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper,type'></a></span>A <a class='hidden_link' href='#def:call_wrapper_type' id='def:call_wrapper_type'><i>call wrapper type</i></a> is a type that holds a callable object
and supports a call operation that forwards to that object.</p></div><div class='para' id='func.def-6'><div class='marginalizedparent'><a class='marginalized' href='#func.def-6'>6</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper'></a></span>A <a class='hidden_link' href='#def:call_wrapper' id='def:call_wrapper'><i>call wrapper</i></a> is an object of a call wrapper type.</p></div><div class='para' id='func.def-7'><div class='marginalizedparent'><a class='marginalized' href='#func.def-7'>7</a></div><p ><span class='indexparent'><a class='index' id='target_object'></a></span>A <a class='hidden_link' href='#def:target_object' id='def:target_object'><i>target object</i></a> is the callable object held by a call wrapper.</p></div></div><div id='func.require'><h3 ><a class='secnum' href='#func.require' style='min-width:103pt'>20.9.2</a> Requirements <a class='abbr_ref' href='func.require'>[func.require]</a></h3><div class='para' id='func.require-1'><div class='marginalizedparent'><a class='marginalized' href='#func.require-1'>1</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> as follows:</p><ul class='itemize'><li id='func.require-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.1'>(1.1)</a></div><p ><span class='texttt'>(t1.*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of
type <span class='texttt'>T</span> or a reference to an object of type <span class='texttt'>T</span> or a
reference to an object of a type derived from <span class='texttt'>T</span>;</p></li><li id='func.require-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.2'>(1.2)</a></div><p ><span class='texttt'>((*t1).*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the
types described in the previous item;</p></li><li id='func.require-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.3'>(1.3)</a></div><p ><span class='texttt'>t1.*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of type <span class='texttt'>T</span> or a
reference to an object of type <span class='texttt'>T</span> or a reference to an object
of a type derived from <span class='texttt'>T</span>;</p></li><li id='func.require-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.4'>(1.4)</a></div><p ><span class='texttt'>(*t1).*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the types described in
the previous item;</p></li><li id='func.require-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.5'>(1.5)</a></div><p ><span class='texttt'>f(t1, t2, ..., tN)</span> in all other cases.
</p></li></ul></div><div class='para' id='func.require-2'><div class='marginalizedparent'><a class='marginalized' href='#func.require-2'>2</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span> as
<span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> implicitly converted
to <span class='texttt'>R</span>.</p></div><div class='para' id='func.require-3'><div class='marginalizedparent'><a class='marginalized' href='#func.require-3'>3</a></div><p ><span class='indexparent'><a class='index' id='weak_result_type'></a></span><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='target_object'></a></span>If a call wrapper (<a href='func.def'>[func.def]</a>) has a <i>weak result type</i>
the type of its member type <span class='texttt'>result_type</span> is based on the
type <span class='texttt'>T</span> of the wrapper's target object (<a href='func.def'>[func.def]</a>):
</p><ul class='itemize'><li id='func.require-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.1'>(3.1)</a></div><p >if <span class='texttt'>T</span> is a pointer to
function type, <span class='texttt'>result_type</span> shall be a synonym for the return
type of <span class='texttt'>T</span>;</p></li><li id='func.require-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.2'>(3.2)</a></div><p >if <span class='texttt'>T</span> is a pointer to member function, <span class='texttt'>result_type</span>
shall be a synonym for the return type of <span class='texttt'>T</span>;</p></li><li id='func.require-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.3'>(3.3)</a></div><p >if <span class='texttt'>T</span> is a class type with a member type <span class='texttt'>result_type</span>,
then <span class='texttt'>result_type</span> shall be a synonym for <span class='texttt'>T::result_type</span>;</p></li><li id='func.require-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.4'>(3.4)</a></div><p >otherwise <span class='texttt'>result_type</span> shall not be defined.
</p></li></ul></div><div class='para' id='func.require-4'><div class='marginalizedparent'><a class='marginalized' href='#func.require-4'>4</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='call_wrapper,simple'></a></span><span class='indexparent'><a class='index' id='call_wrapper,forwarding'></a></span><span class='indexparent'><a class='index' id='simple_call_wrapper'></a></span><span class='indexparent'><a class='index' id='forwarding_call_wrapper'></a></span>Every call wrapper (<a href='func.def'>[func.def]</a>) shall be
<span class='texttt'>MoveConstructible</span>. A <a class='hidden_link' href='#def:simple_call_wrapper' id='def:simple_call_wrapper'><i>simple call wrapper</i></a> is a call wrapper
that is <span class='texttt'>CopyConstructible</span> and <span class='texttt'>CopyAssignable</span> and whose copy
constructor, move constructor, and assignment operator
do not throw exceptions. A <a class='hidden_link' href='#def:forwarding_call_wrapper' id='def:forwarding_call_wrapper'><i>forwarding call wrapper</i></a> is a
call wrapper that can be called with an arbitrary argument list
and delivers the arguments to the wrapped callable object as references.
This forwarding step shall ensure that rvalue arguments are delivered as rvalue-references
and lvalue arguments are delivered as lvalue-references.
[&nbsp;<i>Note:</i> In a typical implementation
forwarding call wrappers have an overloaded function call
operator of
the form</p><pre class='codeblock'>
template&lt;class... UnBoundArgs&gt;
R operator()(UnBoundArgs&amp;&amp;... unbound_args) <i>cv-qual</i>;
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='refwrap'><h3 ><a class='secnum' href='#refwrap' style='min-width:103pt'>20.9.3</a> Class template <span class='texttt'>reference_wrapper</span> <a class='abbr_ref' href='refwrap'>[refwrap]</a></h3><p ><span class='indexparent'><a class='index' id='reference_wrapper'></a></span><span class='indexparent'><a class='index' id='function_object,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='unary_function'></a></span><span class='indexparent'><a class='index' id='binary_function'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class reference_wrapper {
  public :
    <span class='comment'>// types
</span>    typedef T type;
    typedef <i><span class='texttt'>see below</span></i> result_type;               <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> argument_type;             <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> first_argument_type;       <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> second_argument_type;      <span class='comment'>// not always defined
</span>
    <span class='comment'>// construct/copy/destroy
</span>    reference_wrapper(T&amp;) noexcept;
    reference_wrapper(T&amp;&amp;) = delete;     <span class='comment'>// do not bind to temporary objects
</span>    reference_wrapper(const reference_wrapper&amp; x) noexcept;

    <span class='comment'>// assignment
</span>    reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;

    <span class='comment'>// access
</span>    operator T&amp; () const noexcept;
    T&amp; get() const noexcept;

    <span class='comment'>// invocation
</span>    template &lt;class... ArgTypes&gt;
    result_of_t&lt;T&amp;(ArgTypes&amp;&amp;...)&gt;
    operator() (ArgTypes&amp;&amp;...) const;
  };
}
</pre><div class='para' id='refwrap-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-1'>1</a></div><p ><span class='texttt'>reference_wrapper&lt;T&gt;</span> is a <span class='texttt'>CopyConstructible</span> and <span class='texttt'>CopyAssignable</span> wrapper
around a reference to an object or function of type <span class='texttt'>T</span>.</p></div><div class='para' id='refwrap-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-2'>2</a></div><p ><span class='texttt'>reference_wrapper&lt;T&gt;</span> has a weak result type (<a href='func.require'>[func.require]</a>).
If <span class='texttt'>T</span> is a function type, <span class='texttt'>result_type</span> shall be a synonym for the
return type of <span class='texttt'>T</span>.</p></div><div class='para' id='refwrap-3'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-3'>3</a></div><p ><span class='indexparent'><a class='index' id='unary_function'></a></span>The template specialization <span class='texttt'>reference_wrapper&lt;T&gt;</span> shall
define a nested type named <span class='texttt'>argument_type</span> as a synonym for <span class='texttt'>T1</span>
only if the type <span class='texttt'>T</span> is any of the
following:</p><ul class='itemize'><li id='refwrap-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.1'>(3.1)</a></div><p >a function type or a pointer to function type taking one argument of type <span class='texttt'>T1</span></p></li><li id='refwrap-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.2'>(3.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f</span> <i>cv</i> (where <i>cv</i> represents the
member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span></p></li><li id='refwrap-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.3'>(3.3)</a></div><p >a class type with a member type <span class='texttt'>argument_type</span>; the type <span class='texttt'>T1</span> is
<span class='texttt'>T::argument_type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='binary_function'></a></span></p></div><div class='para' id='refwrap-4'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-4'>4</a></div><p >The template instantiation <span class='texttt'>reference_wrapper&lt;T&gt;</span> shall
define two nested types named <span class='texttt'>first_argument_type</span> and <span class='texttt'>second_argument_type</span>
as synonyms for <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively,
only if the type
<span class='texttt'>T</span> is any of the following:</p><ul class='itemize'><li id='refwrap-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.1'>(4.1)</a></div><p >a function type or a pointer to function type taking two arguments of types <span class='texttt'>T1</span> and
<span class='texttt'>T2</span></p></li><li id='refwrap-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.2'>(4.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f(T2)</span> <i>cv</i> (where <i>cv</i> represents the
member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span></p></li><li id='refwrap-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.3'>(4.3)</a></div><p >a class type with member types <span class='texttt'>first_argument_type</span> and
<span class='texttt'>second_argument_type</span>;
the type <span class='texttt'>T1</span> is <span class='texttt'>T::first_argument_type</span>
and the type <span class='texttt'>T2</span> is <span class='texttt'>T::second_argument_type</span>.</p></li></ul></div><div id='refwrap.const'><h4 ><a class='secnum' href='#refwrap.const' style='min-width:118pt'>20.9.3.1</a> <span class='texttt'>reference_wrapper</span> construct/copy/destroy <a class='abbr_ref' href='refwrap.const'>[refwrap.const]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,reference_wrapper'></a></span><code class='itemdecl'>
reference_wrapper(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.const-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>reference_wrapper</span> object that stores a
reference to <span class='texttt'>t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,reference_wrapper'></a></span><code class='itemdecl'>
reference_wrapper(const reference_wrapper&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.const-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>reference_wrapper</span> object that
stores a reference to <span class='texttt'>x.get()</span>.
</p></div></div></div><div id='refwrap.assign'><h4 ><a class='secnum' href='#refwrap.assign' style='min-width:118pt'>20.9.3.2</a> <span class='texttt'>reference_wrapper</span> assignment <a class='abbr_ref' href='refwrap.assign'>[refwrap.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,reference_wrapper'></a></span>
<span class='indexparent'><a class='index' id='reference_wrapper,operator='></a></span>
<code class='itemdecl'>
reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> stores a reference to  <span class='texttt'>x.get()</span>.
</p></div></div></div><div id='refwrap.access'><h4 ><a class='secnum' href='#refwrap.access' style='min-width:118pt'>20.9.3.3</a> <span class='texttt'>reference_wrapper</span> access <a class='abbr_ref' href='refwrap.access'>[refwrap.access]</a></h4><p ><span class='indexparent'><a class='index' id='operator_T&,reference_wrapper'></a></span>
<span class='indexparent'><a class='index' id='reference_wrapper,operator_T&'></a></span>
<code class='itemdecl'>
operator T&amp; () const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.access-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored reference.
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,get'></a></span><span class='indexparent'><a class='index' id='get,reference_wrapper'></a></span><code class='itemdecl'>
T&amp; get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.access-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored reference.
</p></div></div></div><div id='refwrap.invoke'><h4 ><a class='secnum' href='#refwrap.invoke' style='min-width:118pt'>20.9.3.4</a> reference_wrapper invocation <a class='abbr_ref' href='refwrap.invoke'>[refwrap.invoke]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class... ArgTypes&gt;
  result_of_t&lt;T&amp;(ArgTypes&amp;&amp;... )&gt;
    operator()(ArgTypes&amp;&amp;... args) const;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.invoke-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.invoke-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'><i>INVOKE</i>(get(), std::forward&lt;ArgTypes&gt;(args)...)</span>. (<a href='func.require'>[func.require]</a>)</p></div></div><div class='para' id='refwrap.invoke-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.invoke-2'>2</a></div><div class='itemdescr'><p ><i>Remark:</i> <span class='texttt'>operator()</span> is described for exposition only.
Implementations are not required to provide an actual
<span class='texttt'>reference_wrapper::operator()</span>.  Implementations are
permitted to support <span class='texttt'>reference_wrapper</span> function invocation
through multiple overloaded operators or through other means.</p></div></div></div><div id='refwrap.helpers'><h4 ><a class='secnum' href='#refwrap.helpers' style='min-width:118pt'>20.9.3.5</a> reference_wrapper helper functions <a class='abbr_ref' href='refwrap.helpers'>[refwrap.helpers]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,ref'></a></span><span class='indexparent'><a class='index' id='ref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>reference_wrapper&lt;T&gt;(t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,ref'></a></span><span class='indexparent'><a class='index' id='ref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ref(t.get())</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,cref'></a></span><span class='indexparent'><a class='index' id='cref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-3'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>reference_wrapper &lt;const T&gt;(t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,cref'></a></span><span class='indexparent'><a class='index' id='cref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-4'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cref(t.get());</span>
</p></div></div></div></div><div id='arithmetic.operations'><h3 ><a class='secnum' href='#arithmetic.operations' style='min-width:103pt'>20.9.4</a> Arithmetic operations <a class='abbr_ref' href='arithmetic.operations'>[arithmetic.operations]</a></h3><div class='para' id='arithmetic.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-1'>1</a></div><p >The library provides basic function object classes for all of the arithmetic
operators in the language (<a href='expr.mul'>[expr.mul]</a>, <a href='expr.add'>[expr.add]</a>).</p><p ><span class='indexparent'><a class='index' id='plus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct plus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='arithmetic.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x + y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='minus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct minus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x - y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multiplies'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct multiplies {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x * y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='divides'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct divides {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x / y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='modulus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct modulus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x % y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='negate'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct negate {
  constexpr T operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>-x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='plus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct plus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='minus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct minus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) - std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) - std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multiplies<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct multiplies&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) * std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-10'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-10'>10</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) * std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='divides<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct divides&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) / std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-11'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-11'>11</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) / std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='modulus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct modulus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) % std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-12'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-12'>12</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) % std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='negate<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct negate&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(-std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-13'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-13'>13</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>-std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='comparisons'><h3 ><a class='secnum' href='#comparisons' style='min-width:103pt'>20.9.5</a> Comparisons <a class='abbr_ref' href='comparisons'>[comparisons]</a></h3><div class='para' id='comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-1'>1</a></div><p >The library provides basic function object classes for all of the comparison
operators in the language (<a href='expr.rel'>[expr.rel]</a>, <a href='expr.eq'>[expr.eq]</a>).</p><p ><span class='indexparent'><a class='index' id='equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x == y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct not_equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x != y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct greater {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &gt; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct less {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &lt; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct greater_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &gt;= y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct less_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-7'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &lt;= y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct equal_to&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-8'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct not_equal_to&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) != std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-9'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) != std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-10'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-10'>10</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-11'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-11'>11</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater_equal&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &gt;= std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-12'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-12'>12</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &gt;= std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less_equal&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &lt;= std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-13'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-13'>13</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &lt;= std::forward&lt;U&gt;(u)</span>.
</p></div></div><div class='para' id='comparisons-14'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-14'>14</a></div><p >For templates <span class='texttt'>greater</span>, <span class='texttt'>less</span>, <span class='texttt'>greater_equal</span>, and
<span class='texttt'>less_equal</span>, the specializations for any pointer type yield a total order,
even if the built-in operators <span class='texttt'>&lt;</span>, <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, <span class='texttt'>&gt;=</span>
do not.</p></div></div><div id='logical.operations'><h3 ><a class='secnum' href='#logical.operations' style='min-width:103pt'>20.9.6</a> Logical operations <a class='abbr_ref' href='logical.operations'>[logical.operations]</a></h3><div class='para' id='logical.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-1'>1</a></div><p >The library provides basic function object classes for all of the logical
operators in the language (<a href='expr.log.and'>[expr.log.and]</a>, <a href='expr.log.or'>[expr.log.or]</a>, <a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='logical_and'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_and {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='logical.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &amp;&amp; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_or'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_or {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x || y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_not'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_not {
  constexpr bool operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_and<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_and&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &amp;&amp; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &amp;&amp; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_or<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_or&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) || std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) || std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_not<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_not&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(!std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='bitwise.operations'><h3 ><a class='secnum' href='#bitwise.operations' style='min-width:103pt'>20.9.7</a> Bitwise operations <a class='abbr_ref' href='bitwise.operations'>[bitwise.operations]</a></h3><div class='para' id='bitwise.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-1'>1</a></div><p >The library provides basic function object classes for all of the bitwise
operators in the language (<a href='expr.bit.and'>[expr.bit.and]</a>, <a href='expr.or'>[expr.or]</a>,
<a href='expr.xor'>[expr.xor]</a>, <a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='bit_and'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_and {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='bitwise.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &amp; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_or'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_or {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x | y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_xor'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_xor {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x ^ y</span>.
</p></div></div><p ><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_not {
  constexpr T operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>~x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_and<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_and&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &amp; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &amp; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_or<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_or&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) | std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) | std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_xor<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_xor&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) ^ std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) ^ std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_not<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_not&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(~std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>~std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='negators'><h3 ><a class='secnum' href='#negators' style='min-width:103pt'>20.9.8</a> Negators <a class='abbr_ref' href='negators'>[negators]</a></h3><div class='para' id='negators-1'><div class='marginalizedparent'><a class='marginalized' href='#negators-1'>1</a></div><p >Negators <span class='texttt'>not1</span> and <span class='texttt'>not2</span> take a unary and a binary predicate,
respectively, and return their complements (<a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='unary_negate'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate&amp; pred);
  constexpr bool operator()(const typename Predicate::argument_type&amp; x) const;
  typedef typename Predicate::argument_type argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='negators-2'><div class='marginalizedparent'><a class='marginalized' href='#negators-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!pred(x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not1'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='negators-3'><div class='marginalizedparent'><a class='marginalized' href='#negators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>unary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='binary_negate'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  class binary_negate {
  public:
    constexpr explicit binary_negate(const Predicate&amp; pred);
    constexpr bool operator()(const typename Predicate::first_argument_type&amp; x,
        const typename Predicate::second_argument_type&amp; y) const;
  typedef typename Predicate::first_argument_type first_argument_type;
  typedef typename Predicate::second_argument_type second_argument_type;
  typedef bool result_type;
  };
</code></p><div class='itemdescr'></div><div class='para' id='negators-4'><div class='marginalizedparent'><a class='marginalized' href='#negators-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!pred(x,y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not2'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='negators-5'><div class='marginalizedparent'><a class='marginalized' href='#negators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>binary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div></div><div id='func.bind'><h3 ><a class='secnum' href='#func.bind' style='min-width:103pt'>20.9.9</a> Function object binders <a class='abbr_ref' href='func.bind'>[func.bind]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p><div class='para' id='func.bind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind-1'>1</a></div><p >This subclause describes a uniform mechanism for binding
arguments of callable objects.</p></div><div id='func.bind.isbind'><h4 ><a class='secnum' href='#func.bind.isbind' style='min-width:118pt'>20.9.9.1</a> Class template <span class='texttt'>is_bind_expression</span> <a class='abbr_ref' href='func.bind.isbind'>[func.bind.isbind]</a></h4><p ><span class='indexparent'><a class='index' id='is_bind_expression'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_bind_expression; <span class='comment'>// see below
</span>}
</pre><div class='para' id='func.bind.isbind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isbind-1'>1</a></div><p ><span class='texttt'>is_bind_expression</span> can be used to detect function objects
generated by <span class='texttt'>bind</span>. <span class='texttt'>bind</span>
uses <span class='texttt'>is_bind_expression</span> to detect subexpressions.</p></div><div class='para' id='func.bind.isbind-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isbind-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_bind_expression</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has a BaseCharacteristic of
<span class='texttt'>true_type</span> if <span class='texttt'>T</span> is a type returned from <span class='texttt'>bind</span>,
otherwise it shall have a BaseCharacteristic of <span class='texttt'>false_type</span>.
A program may specialize this template for a user-defined type <span class='texttt'>T</span>
to have a BaseCharacteristic of <span class='texttt'>true_type</span> to indicate that
<span class='texttt'>T</span> should be treated as a subexpression in a <span class='texttt'>bind</span> call.</p></div></div><div id='func.bind.isplace'><h4 ><a class='secnum' href='#func.bind.isplace' style='min-width:118pt'>20.9.9.2</a> Class template <span class='texttt'>is_placeholder</span> <a class='abbr_ref' href='func.bind.isplace'>[func.bind.isplace]</a></h4><p ><span class='indexparent'><a class='index' id='is_placeholder'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_placeholder; <span class='comment'>// see below
</span>}
</pre><div class='para' id='func.bind.isplace-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isplace-1'>1</a></div><p ><span class='texttt'>is_placeholder</span> can be used to detect the standard placeholders
<span class='texttt'>_1</span>, <span class='texttt'>_2</span>, and so on. <span class='texttt'>bind</span> uses
<span class='texttt'>is_placeholder</span> to detect placeholders.</p></div><div class='para' id='func.bind.isplace-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isplace-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_placeholder</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has the BaseCharacteristic of
<span class='texttt'>integral_constant&lt;int, J&gt;</span> if <span class='texttt'>T</span> is the type of
<span class='texttt'>std::placeholders::_J</span>, otherwise it shall have a
BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, 0&gt;</span>. A program
may specialize this template for a user-defined type <span class='texttt'>T</span> to
have a BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, <i>N</i>&gt;</span>
with <span class='texttt'><i>N</i> &gt; 0</span> to indicate that <span class='texttt'>T</span> should be
treated as a placeholder type.</p></div></div><div id='func.bind.bind'><h4 ><a class='secnum' href='#func.bind.bind' style='min-width:118pt'>20.9.9.3</a> Function template <span class='texttt'>bind</span> <a class='abbr_ref' href='func.bind.bind'>[func.bind.bind]</a></h4><p ><span class='indexparent'><a class='index' id='bind'></a></span></p><div class='para' id='func.bind.bind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-1'>1</a></div><p >In the text that follows, the following names have the following meanings:</p><ul class='itemize'><li id='func.bind.bind-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.1'>(1.1)</a></div><p ><span class='texttt'>FD</span> is the type <span class='texttt'>decay_t&lt;F&gt;</span>,
</p></li><li id='func.bind.bind-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.2'>(1.2)</a></div><p ><span class='texttt'>fd</span> is an lvalue of type <span class='texttt'>FD</span> constructed from <span class='texttt'>std::forward&lt;F&gt;(f)</span>,
</p></li><li id='func.bind.bind-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.3'>(1.3)</a></div><p ><span class='texttt'>Ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in the template parameter pack <span class='texttt'>BoundArgs</span>,
</p></li><li id='func.bind.bind-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.4'>(1.4)</a></div><p ><span class='texttt'>TiD</span> is the type <span class='texttt'>decay_t&lt;Ti&gt;</span>,
</p></li><li id='func.bind.bind-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.5'>(1.5)</a></div><p ><span class='texttt'>ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> argument in the function parameter pack <span class='texttt'>bound_args</span>,
</p></li><li id='func.bind.bind-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.6'>(1.6)</a></div><p ><span class='texttt'>tid</span> is an lvalue of type <span class='texttt'>TiD</span> constructed from <span class='texttt'>std::forward&lt;Ti&gt;(ti)</span>,
</p></li><li id='func.bind.bind-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.7'>(1.7)</a></div><p ><span class='texttt'>Uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> deduced type of the <span class='texttt'>UnBoundArgs&amp;&amp;...</span> parameter
  of the forwarding call wrapper, and
</p></li><li id='func.bind.bind-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.8'>(1.8)</a></div><p ><span class='texttt'>uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> argument associated with <span class='texttt'>Uj</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='bind'></a></span>
<code class='itemdecl'>
template&lt;class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p></div><div class='itemdescr'></div><div class='para' id='func.bind.bind-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible&lt;FD, F&gt;::value</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible&lt;TiD, Ti&gt;::value</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i> (fd, w1, w2, ...,
wN)</span> (<a href='func.require'>[func.require]</a>) shall be a valid expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.</p></div></div><div class='para' id='func.bind.bind-3'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A forwarding call wrapper <span class='texttt'>g</span> with a weak result
type (<a href='func.require'>[func.require]</a>). The effect of <span class='texttt'>g(u1, u2, ..., uM)</span> shall
be <span class='texttt'><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), result_of_t&lt;FD <i>cv</i> &amp;
(V1, V2, ..., VN)&gt;)</span>, where <span class='texttt'><i>cv</i></span> represents the
<i>cv</i>-qualifiers of <span class='texttt'>g</span> and the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-4'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-5'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='bind'></a></span>
<code class='itemdecl'>
template&lt;class R, class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p><div class='itemdescr'></div><div class='para' id='func.bind.bind-6'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible&lt;FD, F&gt;::value</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible&lt;TiD, Ti&gt;::value</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i>(fd, w1, w2, ..., wN)</span> shall be  a valid
expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.</p></div></div><div class='para' id='func.bind.bind-7'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A forwarding call wrapper <span class='texttt'>g</span> with a nested  type
<span class='texttt'>result_type</span> defined as a synonym for <span class='texttt'>R</span>.  The effect of
<span class='texttt'>g(u1, u2, ..., uM)</span> shall be <span class='texttt'><i>INVOKE</i>(fd,
std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ...,
std::forward&lt;VN&gt;(vN), R)</span>, where the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-8'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-9'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div class='para' id='func.bind.bind-10'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-10'>10</a></div><p ><span class='indexparent'><a class='index' id='bound_arguments'></a></span>The values of the <i>bound arguments</i> <span class='texttt'>v1, v2, ..., vN</span> and their
corresponding types <span class='texttt'>V1, V2, ..., VN</span> depend on the
types <span class='texttt'>TiD</span> derived from
the call to <span class='texttt'>bind</span> and the
<i>cv</i>-qualifiers <i>cv</i> of the call wrapper <span class='texttt'>g</span> as follows:</p><ul class='itemize'><li id='func.bind.bind-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.1'>(10.1)</a></div><p >if <span class='texttt'>TiD</span> is <span class='texttt'>reference_wrapper&lt;T&gt;</span>, the
argument is <span class='texttt'>tid.get()</span> and its type <span class='texttt'>Vi</span> is <span class='texttt'>T&amp;</span>;</p></li><li id='func.bind.bind-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.2'>(10.2)</a></div><p >if the value of <span class='texttt'>is_bind_expression&lt;TiD&gt;::value</span>
is <span class='texttt'>true</span>, the argument is <span class='texttt'>tid(std::forward&lt;Uj&gt;(<span class='discretionary'></span>uj)...)</span>  and its
type <span class='texttt'>Vi</span> is
<span class='texttt'>result_of_t&lt;TiD <i>cv</i> &amp; (Uj&amp;&amp;...)&gt;&amp;&amp;</span>;</p></li><li id='func.bind.bind-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.3'>(10.3)</a></div><p >if the value <span class='texttt'>j</span> of <span class='texttt'>is_placeholder&lt;TiD&gt;::value</span>
is not zero, the  argument is <span class='texttt'>std::forward&lt;Uj&gt;(uj)</span>
and its type <span class='texttt'>Vi</span>
is <span class='texttt'>Uj&amp;&amp;</span>;</p></li><li id='func.bind.bind-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.4'>(10.4)</a></div><p >otherwise, the value is <span class='texttt'>tid</span> and its type <span class='texttt'>Vi</span>
is <span class='texttt'>TiD <i>cv</i> &amp;</span>.
</p></li></ul></div></div><div id='func.bind.place'><h4 ><a class='secnum' href='#func.bind.place' style='min-width:118pt'>20.9.9.4</a> Placeholders <a class='abbr_ref' href='func.bind.place'>[func.bind.place]</a></h4><p ><span class='indexparent'><a class='index' id='placeholders'></a></span><span class='indexparent'><a class='index' id='1'></a></span></p><pre class='codeblock'>
namespace std {
  namespace placeholders {
    <span class='comment'>// M is the implementation-defined number of placeholders
</span>    extern <i><span class='texttt'>unspecified</span></i> _1;
    extern <i><span class='texttt'>unspecified</span></i> _2;
                .
                .
                .
    extern <i>unspecified</i> _M;
  }
}
</pre><div class='para' id='func.bind.place-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.place-1'>1</a></div><p >All placeholder types shall be <span class='texttt'>DefaultConstructible</span> and
<span class='texttt'>CopyConstructible</span>, and their default constructors and copy/move
constructors shall not throw exceptions. It is <span class='indexparent'><a class='index' id='assignability_of_placeholder_objects'></a></span>implementation-defined whether
placeholder types are <span class='texttt'>CopyAssignable</span>. <span class='texttt'>CopyAssignable</span> placeholders' copy
assignment operators shall not throw exceptions.<span class='indexparent'><a class='index' id='bind'></a></span><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p></div></div></div><div id='func.memfn'><h3 ><a class='secnum' href='#func.memfn' style='min-width:103pt'>20.9.10</a> Function template <span class='texttt'>mem_fn</span> <a class='abbr_ref' href='func.memfn'>[func.memfn]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,mem_fn'></a></span></p><p ><span class='indexparent'><a class='index' id='mem_fn'></a></span><code class='itemdecl'>
template&lt;class R, class T&gt; <i><span class='texttt'>unspecified</span></i> mem_fn(R T::* pm);
</code></p><div class='itemdescr'></div><div class='para' id='func.memfn-1'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A simple call wrapper (<a href='func.def'>[func.def]</a>) <span class='texttt'>fn</span>
such that the expression <span class='texttt'>fn(t, a2, ..., aN)</span> is equivalent
to <span class='texttt'><i>INVOKE</i>(pm, t, a2, ..., aN)</span> (<a href='func.require'>[func.require]</a>).
<span class='texttt'>fn</span> shall have a nested type <span class='texttt'>result_type</span> that is a synonym
for the return type of <span class='texttt'>pm</span> when <span class='texttt'>pm</span> is a pointer to
member function.</p></div></div><div class='para' id='func.memfn-2'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-2'>2</a></div><div class='itemdescr'><p >The simple call wrapper shall
define two nested types named <span class='texttt'>argument_type</span> and <span class='texttt'>result_type</span> as synonyms
for <span class='texttt'><i>cv</i> T*</span> and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is
a pointer to member function with cv-qualifier <i>cv</i> and taking no
arguments, where <i>Ret</i> is <span class='texttt'>pm</span>'s return type.</p></div></div><div class='para' id='func.memfn-3'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-3'>3</a></div><div class='itemdescr'><p >The simple call wrapper shall
define three nested types named <span class='texttt'>first_argument_type</span>,
<span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span> as synonyms
for <span class='texttt'><i>cv</i> T*</span>, <span class='texttt'>T1</span>, and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is
a pointer to member function with cv-qualifier <i>cv</i> and taking
one argument of type <span class='texttt'>T1</span>, where <i>Ret</i> is <span class='texttt'>pm</span>'s return type.</p></div></div><div class='para' id='func.memfn-4'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='function_object,mem_fn'></a></span></p></div><div id='func.wrap'><h3 ><a class='secnum' href='#func.wrap' style='min-width:103pt'>20.9.11</a> Polymorphic function wrappers <a class='abbr_ref' href='func.wrap'>[func.wrap]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,wrapper'></a></span></p><div class='para' id='func.wrap-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap-1'>1</a></div><p >This subclause describes a polymorphic wrapper class that
encapsulates arbitrary callable objects.</p></div><div id='func.wrap.badcall'><h4 ><a class='secnum' href='#func.wrap.badcall' style='min-width:118pt'>20.9.11.1</a> Class <span class='texttt'>bad_function_call</span> <a class='abbr_ref' href='func.wrap.badcall'>[func.wrap.badcall]</a></h4><p ><span class='indexparent'><a class='index' id='bad_function_call'></a></span><span class='indexparent'><a class='index' id='exception,bad_function_call'></a></span></p><div class='para' id='func.wrap.badcall-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.badcall-1'>1</a></div><p >An exception of type <span class='texttt'>bad_function_call</span> is thrown by
<span class='texttt'>function::operator()</span> (<a href='func.wrap.func.inv'>[func.wrap.func.inv]</a>)
when the function wrapper object has no target.</p><pre class='codeblock'>
namespace std {
  class bad_function_call : public std::exception {
  public:
    <span class='comment'>// <a href='func.wrap.badcall.const'>[func.wrap.badcall.const]</a>, constructor:
</span>    bad_function_call() noexcept;
  };
} <span class='comment'>// namespace std
</span></pre></div><div id='func.wrap.badcall.const'><h4 ><a class='secnum' href='#func.wrap.badcall.const' style='min-width:133pt'>20.9.11.1.1</a> <span class='texttt'>bad_function_call</span> constructor <a class='abbr_ref' href='func.wrap.badcall.const'>[func.wrap.badcall.const]</a></h4><p ><span class='indexparent'><a class='index' id='bad_function_call,bad_function_call'></a></span><code class='itemdecl'>
bad_function_call() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.badcall.const-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.badcall.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_function_call</span> object.
</p></div></div></div></div><div id='func.wrap.func'><h4 ><a class='secnum' href='#func.wrap.func' style='min-width:118pt'>20.9.11.2</a> Class template <span class='texttt'>function</span> <a class='abbr_ref' href='func.wrap.func'>[func.wrap.func]</a></h4><p ><span class='indexparent'><a class='index' id='function'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class&gt; class function; <span class='comment'>// undefined
</span>
  template&lt;class R, class... ArgTypes&gt;
  class function&lt;R(ArgTypes...)&gt; {
  public:
    typedef R result_type;
    typedef T1 argument_type;           <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 1</span> and
</span>                                        <span class='comment'>// the type in <span class='texttt'>ArgTypes</span> is <span class='texttt'>T1</span>
</span>    typedef T1 first_argument_type;     <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 2</span> and
</span>                                        <span class='comment'>// <span class='texttt'>ArgTypes</span> contains <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</span>    typedef T2 second_argument_type;    <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 2</span> and
</span>                                        <span class='comment'>// <span class='texttt'>ArgTypes</span> contains <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</span>
    <span class='comment'>// <a href='func.wrap.func.con'>[func.wrap.func.con]</a>, construct/copy/destroy:
</span>    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&amp;);
    function(function&amp;&amp;);
    template&lt;class F&gt; function(F);
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      nullptr_t) noexcept;
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      const function&amp;);
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      function&amp;&amp;);
    template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(function&amp;&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class F&gt; function&amp; operator=(F&amp;&amp;);
    template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;) noexcept;

    ~function();

    <span class='comment'>// <a href='func.wrap.func.mod'>[func.wrap.func.mod]</a>, function modifiers:
</span>    void swap(function&amp;) noexcept;
    template&lt;class F, class A&gt; void assign(F&amp;&amp;, const A&amp;);

    <span class='comment'>// <a href='func.wrap.func.cap'>[func.wrap.func.cap]</a>, function capacity:
</span>    explicit operator bool() const noexcept;

    <span class='comment'>// <a href='func.wrap.func.inv'>[func.wrap.func.inv]</a>, function invocation:
</span>    R operator()(ArgTypes...) const;

    <span class='comment'>// <a href='func.wrap.func.targ'>[func.wrap.func.targ]</a>, function target access:
</span>    const std::type_info&amp; target_type() const noexcept;
    template&lt;class T&gt;       T* target() noexcept;
    template&lt;class T&gt; const T* target() const noexcept;

  };

  <span class='comment'>// <a href='func.wrap.func.nullptr'>[func.wrap.func.nullptr]</a>, Null pointer comparisons:
</span>  template &lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  <span class='comment'>// <a href='func.wrap.func.alg'>[func.wrap.func.alg]</a>, specialized algorithms:
</span>  template &lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

  template&lt;class R, class... ArgTypes, class Alloc&gt;
    struct uses_allocator&lt;function&lt;R(ArgTypes...)&gt;, Alloc&gt;
      : true_type { };
}
</pre><div class='para' id='func.wrap.func-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-1'>1</a></div><p >The <span class='texttt'>function</span> class template provides polymorphic wrappers that
generalize the notion of a function pointer. Wrappers can store, copy,
and call arbitrary callable objects (<a href='func.def'>[func.def]</a>), given a call
signature (<a href='func.def'>[func.def]</a>), allowing functions to be first-class objects.</p></div><div class='para' id='func.wrap.func-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-2'>2</a></div><p ><span class='indexparent'><a class='index' id='callable_object'></a></span>A callable object <span class='texttt'>f</span> of type <span class='texttt'>F</span>
is <a class='hidden_link' href='#def:Callable' id='def:Callable'><i>Callable</i></a> for argument
types <span class='texttt'>ArgTypes</span>
and return type <span class='texttt'>R</span>
if the expression
<span class='texttt'><i>INVOKE</i>(f, declval&lt;ArgTypes&gt;()..., R)</span>,
considered as an unevaluated operand (Clause <a href='expr'>[expr]</a>), is
well formed (<a href='func.require'>[func.require]</a>).</p></div><div class='para' id='func.wrap.func-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-3'>3</a></div><p >The <span class='texttt'>function</span> class template is a call
wrapper (<a href='func.def'>[func.def]</a>) whose call signature (<a href='func.def'>[func.def]</a>)
is <span class='texttt'>R(ArgTypes...)</span>.</p></div><div id='func.wrap.func.con'><h4 ><a class='secnum' href='#func.wrap.func.con' style='min-width:133pt'>20.9.11.2.1</a> <span class='texttt'>function</span> construct/copy/destroy <a class='abbr_ref' href='func.wrap.func.con'>[func.wrap.func.con]</a></h4><div class='para' id='func.wrap.func.con-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-1'>1</a></div><p >When any <span class='texttt'>function</span> constructor that takes a first argument of type
<span class='texttt'>allocator_arg_t</span> is invoked, the second argument shall have a type that conforms
to the requirements for Allocator (Table <a href='allocator.requirements'>[allocator.requirements]</a>). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data
structures of the constructed <span class='texttt'>function</span> object.</p><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function() noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(nullptr_t) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(const function&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-4'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if <span class='texttt'>!f</span>; otherwise,
<span class='texttt'>*this</span> targets a copy of <span class='texttt'>f.target()</span>.</p></div></div><div class='para' id='func.wrap.func.con-5'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> shall not throw exceptions if <span class='texttt'>f</span>'s target is
a callable object passed via <span class='texttt'>reference_wrapper</span> or
a function pointer. Otherwise, may throw <span class='texttt'>bad_alloc</span>
or any exception thrown by the copy constructor of the stored callable object.
[&nbsp;<i>Note:</i> Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example, where
<span class='texttt'>f</span>'s target is an object holding only a pointer or reference
to an object and a member function pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(function&amp;&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-6'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>!f</span>, <span class='texttt'>*this</span> has
no target; otherwise, move-constructs the target of <span class='texttt'>f</span>
into the target of <span class='texttt'>*this</span>, leaving <span class='texttt'>f</span> in
a valid state with an unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-7'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> shall be <span class='texttt'>CopyConstructible</span>.</p></div></div><div class='para' id='func.wrap.func.con-8'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> These constructors shall not participate in overload resolution unless
<span class='texttt'>f</span> is Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for argument types
<span class='texttt'>ArgTypes...</span> and return type <span class='texttt'>R</span>.</p></div></div><div class='para' id='func.wrap.func.con-9'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if any of the following hold:
</p><ul class='itemize'><li id='func.wrap.func.con-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.1'>(9.1)</a></div><p ><span class='texttt'>f</span> is a null function pointer value.
</p></li><li id='func.wrap.func.con-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.2'>(9.2)</a></div><p ><span class='texttt'>f</span> is a null member pointer value.
</p></li><li id='func.wrap.func.con-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.3'>(9.3)</a></div><p ><span class='texttt'>F</span> is an instance of the <span class='texttt'>function</span> class template, and
  <span class='texttt'>!f</span>.
</p></li></ul></div></div><div class='para' id='func.wrap.func.con-10'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-10'>10</a></div><div class='itemdescr'><p >Otherwise, <span class='texttt'>*this</span> targets a copy of <span class='texttt'>f</span>
initialized with <span class='texttt'>std::move(f)</span>.
[&nbsp;<i>Note:</i> Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example,
where <span class='texttt'>f</span>'s target is an object holding only a pointer or
reference to an object and a member function pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='func.wrap.func.con-11'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i> shall not throw exceptions when <span class='texttt'>f</span> is a function pointer
or a <span class='texttt'>reference_wrapper&lt;T&gt;</span> for some <span class='texttt'>T</span>. Otherwise,
may throw <span class='texttt'>bad_alloc</span> or any exception thrown by <span class='texttt'>F</span>'s copy
or move constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(const function&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-12'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(f).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-13'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(function&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-14'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Replaces the target of <span class='texttt'>*this</span>
with the target of <span class='texttt'>f</span>.</p></div></div><div class='para' id='func.wrap.func.con-15'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(nullptr_t);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-16'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, destroys the target of <span class='texttt'>this</span>.</p></div></div><div class='para' id='func.wrap.func.con-17'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!(*this)</span>.</p></div></div><div class='para' id='func.wrap.func.con-18'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-19'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(std::forward&lt;F&gt;(f)).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-20'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span></p></div></div><div class='para' id='func.wrap.func.con-21'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-21'>21</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload
resolution unless <span class='texttt'>declval&lt;typename decay&lt;F&gt;::type&amp;&gt;()</span> is
Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for argument types <span class='texttt'>ArgTypes...</span> and
return type <span class='texttt'>R</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-22'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(f).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-23'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,destructor'></a></span><code class='itemdecl'>
~function();
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-24'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, destroys the target of <span class='texttt'>this</span>.
</p></div></div></div><div id='func.wrap.func.mod'><h4 ><a class='secnum' href='#func.wrap.func.mod' style='min-width:133pt'>20.9.11.2.2</a> <span class='texttt'>function</span> modifiers <a class='abbr_ref' href='func.wrap.func.mod'>[func.wrap.func.mod]</a></h4><p ><span class='indexparent'><a class='index' id='function,swap'></a></span><span class='indexparent'><a class='index' id='swap,function'></a></span><code class='itemdecl'>
void swap(function&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> interchanges the targets of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,assign'></a></span><span class='indexparent'><a class='index' id='assign,function'></a></span><code class='itemdecl'>
template&lt;class F, class A&gt;
  void assign(F&amp;&amp; f, const A&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.mod-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(allocator_arg, a, std::forward&lt;F&gt;(f)).swap(*this)</span>
</p></div></div></div><div id='func.wrap.func.cap'><h4 ><a class='secnum' href='#func.wrap.func.cap' style='min-width:133pt'>20.9.11.2.3</a> <span class='texttt'>function</span> capacity <a class='abbr_ref' href='func.wrap.func.cap'>[func.wrap.func.cap]</a></h4><p ><span class='indexparent'><a class='index' id='function,bool_conversion'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.cap-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.cap-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> has a target, otherwise <span class='texttt'>false</span>.
</p></div></div></div><div id='func.wrap.func.inv'><h4 ><a class='secnum' href='#func.wrap.func.inv' style='min-width:133pt'>20.9.11.2.4</a> <span class='texttt'>function</span> invocation <a class='abbr_ref' href='func.wrap.func.inv'>[func.wrap.func.inv]</a></h4><p ><span class='indexparent'><a class='index' id='function,invocation'></a></span><span class='indexparent'><a class='index' id='function,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),function'></a></span><code class='itemdecl'>
R operator()(ArgTypes... args) const
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.inv-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'><i>INVOKE</i>(f, std::forward&lt;ArgTypes&gt;(args)..., R)</span> (<a href='func.require'>[func.require]</a>),
where <span class='texttt'>f</span> is the target object (<a href='func.def'>[func.def]</a>) of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='func.wrap.func.inv-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> Nothing if <span class='texttt'>R</span> is <span class='texttt'>void</span>, otherwise the
return value of
<span class='texttt'><i>INVOKE</i>(f, std::forward&lt;ArgTypes&gt;(<span class='discretionary'></span>args)..., R)</span>.</p></div></div><div class='para' id='func.wrap.func.inv-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_function_call</span> if <span class='texttt'>!*this</span>; otherwise, any
exception thrown by the wrapped callable object.
</p></div></div></div><div id='func.wrap.func.targ'><h4 ><a class='secnum' href='#func.wrap.func.targ' style='min-width:133pt'>20.9.11.2.5</a> function target access <a class='abbr_ref' href='func.wrap.func.targ'>[func.wrap.func.targ]</a></h4><p ><span class='indexparent'><a class='index' id='function,target_type'></a></span><span class='indexparent'><a class='index' id='target_type,function'></a></span><code class='itemdecl'>
const std::type_info&amp; target_type() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.targ-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>*this</span> has a target of type <span class='texttt'>T</span>,
  <span class='texttt'>typeid(T)</span>; otherwise, <span class='texttt'>typeid(void)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,target'></a></span><span class='indexparent'><a class='index' id='target,function'></a></span><code class='itemdecl'>
template&lt;class T&gt;       T* target() noexcept;
template&lt;class T&gt; const T* target() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.targ-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be a type that is
Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for parameter types
<span class='texttt'>ArgTypes</span>
and return type <span class='texttt'>R</span>.</p></div></div><div class='para' id='func.wrap.func.targ-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>target_type() == typeid(T)</span>
a pointer to the stored function target; otherwise a null pointer.
</p></div></div></div><div id='func.wrap.func.nullptr'><h4 ><a class='secnum' href='#func.wrap.func.nullptr' style='min-width:133pt'>20.9.11.2.6</a> null pointer comparison operators <a class='abbr_ref' href='func.wrap.func.nullptr'>[func.wrap.func.nullptr]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,function'></a></span><span class='indexparent'><a class='index' id='function,operator=='></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
template &lt;class R, class... ArgTypes&gt;
  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.nullptr-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.nullptr-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!f</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,function'></a></span><span class='indexparent'><a class='index' id='function,operator!='></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.nullptr-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.nullptr-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'> (bool) f</span>.
</p></div></div></div><div id='func.wrap.func.alg'><h4 ><a class='secnum' href='#func.wrap.func.alg' style='min-width:133pt'>20.9.11.2.7</a> specialized algorithms <a class='abbr_ref' href='func.wrap.func.alg'>[func.wrap.func.alg]</a></h4><p ><span class='indexparent'><a class='index' id='function,swap'></a></span><span class='indexparent'><a class='index' id='swap,function'></a></span><code class='itemdecl'>
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.alg-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.alg-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>f1.swap(f2);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function_object,wrapper'></a></span></p></div></div></div><div id='unord.hash'><h3 ><a class='secnum' href='#unord.hash' style='min-width:103pt'>20.9.12</a> Class template <span class='texttt'>hash</span> <a class='abbr_ref' href='unord.hash'>[unord.hash]</a></h3><div class='para' id='unord.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#unord.hash-1'>1</a></div><p ><span class='indexparent'><a class='index' id='hash'></a></span><span class='indexparent'><a class='index' id='hash,instantiation_restrictions'></a></span>The unordered associative containers defined in <a href='unord'>[unord]</a> use
specializations of the class template <span class='texttt'>hash</span> as the default hash function.
For all object types <span class='texttt'>Key</span> for which there exists a specialization <span class='texttt'>hash&lt;Key&gt;</span>,
and for all enumeration types (<a href='dcl.enum'>[dcl.enum]</a>) <span class='texttt'>Key</span>,
the instantiation <span class='texttt'>hash&lt;Key&gt;</span> shall:</p><ul class='itemize'><li id='unord.hash-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.1'>(1.1)</a></div><p >satisfy the <span class='texttt'>Hash</span> requirements (<a href='hash.requirements'>[hash.requirements]</a>),
with <span class='texttt'>Key</span> as the function
call argument type, the <span class='texttt'>DefaultConstructible</span> requirements (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
the <span class='texttt'>CopyAssignable</span> requirements (Table <a href='copyassignable'>[copyassignable]</a>),
</p></li><li id='unord.hash-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.2'>(1.2)</a></div><p >be swappable (<a href='swappable.requirements'>[swappable.requirements]</a>) for lvalues,
</p></li><li id='unord.hash-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.3'>(1.3)</a></div><p >provide two nested types <span class='texttt'>result_type</span> and <span class='texttt'>argument_type</span> which shall be
synonyms for <span class='texttt'>size_t</span> and <span class='texttt'>Key</span>, respectively,
</p></li><li id='unord.hash-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.4'>(1.4)</a></div><p >satisfy the requirement that if <span class='texttt'>k1 == k2</span> is true, <span class='texttt'>h(k1) == h(k2)</span> is
also true, where <span class='texttt'>h</span> is an object of type <span class='texttt'>hash&lt;Key&gt;</span> and <span class='texttt'>k1</span> and <span class='texttt'>k2</span>
are objects of type <span class='texttt'>Key</span>;
</p></li><li id='unord.hash-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.5'>(1.5)</a></div><p >satisfy the requirement that the expression <span class='texttt'>h(k)</span>, where <span class='texttt'>h</span>
is an object of type <span class='texttt'>hash&lt;Key&gt;</span> and <span class='texttt'>k</span> is an object of type
<span class='texttt'>Key</span>, shall not throw an exception unless <span class='texttt'>hash&lt;Key&gt;</span> is a
user-defined specialization that depends on at least one user-defined type.
</p></li></ul><p ><span class='indexparent'><a class='index' id='hash'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
template &lt;&gt; struct hash&lt;signed char&gt;;
template &lt;&gt; struct hash&lt;unsigned char&gt;;
template &lt;&gt; struct hash&lt;char16_t&gt;;
template &lt;&gt; struct hash&lt;char32_t&gt;;
template &lt;&gt; struct hash&lt;wchar_t&gt;;
template &lt;&gt; struct hash&lt;short&gt;;
template &lt;&gt; struct hash&lt;unsigned short&gt;;
template &lt;&gt; struct hash&lt;int&gt;;
template &lt;&gt; struct hash&lt;unsigned int&gt;;
template &lt;&gt; struct hash&lt;long&gt;;
template &lt;&gt; struct hash&lt;unsigned long&gt;;
template &lt;&gt; struct hash&lt;long long&gt;;
template &lt;&gt; struct hash&lt;unsigned long long&gt;;
template &lt;&gt; struct hash&lt;float&gt;;
template &lt;&gt; struct hash&lt;double&gt;;
template &lt;&gt; struct hash&lt;long double&gt;;
template &lt;class T&gt; struct hash&lt;T*&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='unord.hash-2'><div class='marginalizedparent'><a class='marginalized' href='#unord.hash-2'>2</a></div><div class='itemdescr'><p >The template specializations shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div></div><div id='meta'><h2 ><a class='secnum' href='#meta' style='min-width:88pt'>20.10</a> Metaprogramming and type traits <a class='abbr_ref' href='meta'>[meta]</a></h2><div class='para' id='meta-1'><div class='marginalizedparent'><a class='marginalized' href='#meta-1'>1</a></div><p >This subclause describes components used by C++ programs, particularly in
templates, to support the widest possible range of types, optimise
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible C++ types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.</p></div><div id='meta.rqmts'><h3 ><a class='secnum' href='#meta.rqmts' style='min-width:103pt'>20.10.1</a> Requirements <a class='abbr_ref' href='meta.rqmts'>[meta.rqmts]</a></h3><div class='para' id='meta.rqmts-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.rqmts-1'>1</a></div><p >A <a class='hidden_link' href='#def:UnaryTypeTrait' id='def:UnaryTypeTrait'><i>UnaryTypeTrait</i></a> describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be <span class='texttt'>DefaultConstructible</span>,
<span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or indirectly, from
its <a class='hidden_link' href='#def:BaseCharacteristic' id='def:BaseCharacteristic'><i>BaseCharacteristic</i></a>, which is
a specialization of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular property being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the UnaryTypeTrait.</p></div><div class='para' id='meta.rqmts-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.rqmts-2'>2</a></div><p >A <a class='hidden_link' href='#def:BinaryTypeTrait' id='def:BinaryTypeTrait'><i>BinaryTypeTrait</i></a> describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be <span class='texttt'>DefaultConstructible</span>, <span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or
indirectly, from
its <a class='hidden_link' href='#def:BaseCharacteristic' id='def:BaseCharacteristic'><i>BaseCharacteristic</i></a>, which is a specialization
of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular relationship being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the BinaryTypeTrait.</p></div><div class='para' id='meta.rqmts-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.rqmts-3'>3</a></div><p >A <a class='hidden_link' href='#def:TransformationTrait' id='def:TransformationTrait'><i>TransformationTrait</i></a>
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named <span class='texttt'>type</span>, which shall be a synonym for the modified type.</p></div></div><div id='meta.type.synop'><h3 ><a class='secnum' href='#meta.type.synop' style='min-width:103pt'>20.10.2</a> Header <span class='texttt'>&lt;type_traits&gt;</span> synopsis <a class='abbr_ref' href='meta.type.synop'>[meta.type.synop]</a></h3><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='meta.help'>[meta.help]</a>, helper class:
</span>  template &lt;class T, T v&gt; struct integral_constant;
  typedef integral_constant&lt;bool, true&gt;  true_type;
  typedef integral_constant&lt;bool, false&gt; false_type;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories:
</span>  template &lt;class T&gt; struct is_void;
  template &lt;class T&gt; struct is_null_pointer;
  template &lt;class T&gt; struct is_integral;
  template &lt;class T&gt; struct is_floating_point;
  template &lt;class T&gt; struct is_array;
  template &lt;class T&gt; struct is_pointer;
  template &lt;class T&gt; struct is_lvalue_reference;
  template &lt;class T&gt; struct is_rvalue_reference;
  template &lt;class T&gt; struct is_member_object_pointer;
  template &lt;class T&gt; struct is_member_function_pointer;
  template &lt;class T&gt; struct is_enum;
  template &lt;class T&gt; struct is_union;
  template &lt;class T&gt; struct is_class;
  template &lt;class T&gt; struct is_function;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories:
</span>  template &lt;class T&gt; struct is_reference;
  template &lt;class T&gt; struct is_arithmetic;
  template &lt;class T&gt; struct is_fundamental;
  template &lt;class T&gt; struct is_object;
  template &lt;class T&gt; struct is_scalar;
  template &lt;class T&gt; struct is_compound;
  template &lt;class T&gt; struct is_member_pointer;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties:
</span>  template &lt;class T&gt; struct is_const;
  template &lt;class T&gt; struct is_volatile;
  template &lt;class T&gt; struct is_trivial;
  template &lt;class T&gt; struct is_trivially_copyable;
  template &lt;class T&gt; struct is_standard_layout;
  template &lt;class T&gt; struct is_pod;
  template &lt;class T&gt; struct is_literal_type;
  template &lt;class T&gt; struct is_empty;
  template &lt;class T&gt; struct is_polymorphic;
  template &lt;class T&gt; struct is_abstract;
  template &lt;class T&gt; struct is_final;

  template &lt;class T&gt; struct is_signed;
  template &lt;class T&gt; struct is_unsigned;

  template &lt;class T, class... Args&gt; struct is_constructible;
  template &lt;class T&gt; struct is_default_constructible;
  template &lt;class T&gt; struct is_copy_constructible;
  template &lt;class T&gt; struct is_move_constructible;

  template &lt;class T, class U&gt; struct is_assignable;
  template &lt;class T&gt; struct is_copy_assignable;
  template &lt;class T&gt; struct is_move_assignable;

  template &lt;class T&gt; struct is_destructible;

  template &lt;class T, class... Args&gt; struct is_trivially_constructible;
  template &lt;class T&gt; struct is_trivially_default_constructible;
  template &lt;class T&gt; struct is_trivially_copy_constructible;
  template &lt;class T&gt; struct is_trivially_move_constructible;

  template &lt;class T, class U&gt; struct is_trivially_assignable;
  template &lt;class T&gt; struct is_trivially_copy_assignable;
  template &lt;class T&gt; struct is_trivially_move_assignable;
  template &lt;class T&gt; struct is_trivially_destructible;

  template &lt;class T, class... Args&gt; struct is_nothrow_constructible;
  template &lt;class T&gt; struct is_nothrow_default_constructible;
  template &lt;class T&gt; struct is_nothrow_copy_constructible;
  template &lt;class T&gt; struct is_nothrow_move_constructible;

  template &lt;class T, class U&gt; struct is_nothrow_assignable;
  template &lt;class T&gt; struct  is_nothrow_copy_assignable;
  template &lt;class T&gt; struct is_nothrow_move_assignable;

  template &lt;class T&gt; struct is_nothrow_destructible;
  template &lt;class T&gt; struct has_virtual_destructor;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries:
</span>  template &lt;class T&gt; struct alignment_of;
  template &lt;class T&gt; struct rank;
  template &lt;class T, unsigned I = 0&gt; struct extent;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations:
</span>  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;

  <span class='comment'>// <a href='meta.trans.cv'>[meta.trans.cv]</a>, const-volatile modifications:
</span>  template &lt;class T&gt; struct remove_const;
  template &lt;class T&gt; struct remove_volatile;
  template &lt;class T&gt; struct remove_cv;
  template &lt;class T&gt; struct add_const;
  template &lt;class T&gt; struct add_volatile;
  template &lt;class T&gt; struct add_cv;

  template &lt;class T&gt;
    using remove_const_t    = typename remove_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_cv_t       = typename remove_cv&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_const_t       = typename add_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_volatile_t    = typename add_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_cv_t          = typename add_cv&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ref'>[meta.trans.ref]</a>, reference modifications:
</span>  template &lt;class T&gt; struct remove_reference;
  template &lt;class T&gt; struct add_lvalue_reference;
  template &lt;class T&gt; struct add_rvalue_reference;

  template &lt;class T&gt;
    using remove_reference_t     = typename remove_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.sign'>[meta.trans.sign]</a>, sign modifications:
</span>  template &lt;class T&gt; struct make_signed;
  template &lt;class T&gt; struct make_unsigned;

  template &lt;class T&gt;
    using make_signed_t   = typename make_signed&lt;T&gt;::type;
  template &lt;class T&gt;
    using make_unsigned_t = typename make_unsigned&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.arr'>[meta.trans.arr]</a>, array modifications:
</span>  template &lt;class T&gt; struct remove_extent;
  template &lt;class T&gt; struct remove_all_extents;

  template &lt;class T&gt;
    using remove_extent_t      = typename remove_extent&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ptr'>[meta.trans.ptr]</a>, pointer modifications:
</span>  template &lt;class T&gt; struct remove_pointer;
  template &lt;class T&gt; struct add_pointer;

  template &lt;class T&gt;
    using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_pointer_t    = typename add_pointer&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations:
</span>  template &lt;std::size_t Len,
            std::size_t Align = default-alignment&gt;   <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    struct aligned_storage;      
  template &lt;std::size_t Len, class... Types&gt; struct aligned_union;
  template &lt;class T&gt; struct decay;
  template &lt;bool, class T = void&gt; struct enable_if;
  template &lt;bool, class T, class F&gt; struct conditional;
  template &lt;class... T&gt; struct common_type;
  template &lt;class T&gt; struct underlying_type;
  template &lt;class&gt; class result_of;   <span class='comment'>// not defined
</span>  template &lt;class F, class... ArgTypes&gt; class result_of&lt;F(ArgTypes...)&gt;;

  template &lt;std::size_t Len,
            std::size_t Align = default-alignment &gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    using aligned_storage_t = typename aligned_storage&lt;Len,Align&gt;::type;
  template &lt;std::size_t Len, class... Types&gt;
    using aligned_union_t   = typename aligned_union&lt;Len,Types...&gt;::type;
  template &lt;class T&gt;
    using decay_t           = typename decay&lt;T&gt;::type;
  template &lt;bool b, class T = void&gt;
    using enable_if_t       = typename enable_if&lt;b,T&gt;::type;
  template &lt;bool b, class T, class F&gt;
    using conditional_t     = typename conditional&lt;b,T,F&gt;::type;
  template &lt;class... T&gt;
    using common_type_t     = typename common_type&lt;T...&gt;::type;
  template &lt;class T&gt;
    using underlying_type_t = typename underlying_type&lt;T&gt;::type;
  template &lt;class T&gt;
    using result_of_t       = typename result_of&lt;T&gt;::type;  
} <span class='comment'>// namespace std
</span></pre><div class='para' id='meta.type.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.type.synop-1'>1</a></div><p >The behavior of a program that adds specializations for any of
the class templates defined in this subclause is undefined unless otherwise specified.</p></div></div><div id='meta.help'><h3 ><a class='secnum' href='#meta.help' style='min-width:103pt'>20.10.3</a> Helper classes <a class='abbr_ref' href='meta.help'>[meta.help]</a></h3><pre class='codeblock'>
namespace std {
  template &lt;class T, T v&gt;
  struct integral_constant {
    static constexpr T value = v;
    typedef T value_type;
    typedef integral_constant&lt;T,v&gt; type;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
  typedef integral_constant&lt;bool, true&gt; true_type;
  typedef integral_constant&lt;bool, false&gt; false_type;
}
</pre><div class='para' id='meta.help-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.help-1'>1</a></div><p >The class template <span class='texttt'>integral_constant</span> and its associated typedefs
<span class='texttt'>true_type</span> and <span class='texttt'>false_type</span> are used as base classes to define
the interface for various type traits.</p></div></div><div id='meta.unary'><h3 ><a class='secnum' href='#meta.unary' style='min-width:103pt'>20.10.4</a> Unary type traits <a class='abbr_ref' href='meta.unary'>[meta.unary]</a></h3><div class='para' id='meta.unary-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary-1'>1</a></div><p >This sub-clause contains templates that may be used to query the
properties of a type at compile time.</p></div><div class='para' id='meta.unary-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary-2'>2</a></div><p >Each of these templates shall be a
UnaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p></div><div id='meta.unary.cat'><h4 ><a class='secnum' href='#meta.unary.cat' style='min-width:118pt'>20.10.4.1</a> Primary type categories <a class='abbr_ref' href='meta.unary.cat'>[meta.unary.cat]</a></h4><div class='para' id='meta.unary.cat-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.cat-1'>1</a></div><p >The primary type categories correspond to the descriptions given in
section <a href='basic.types'>[basic.types]</a> of the C++ standard.</p></div><div class='para' id='meta.unary.cat-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.cat-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p></div><div class='para' id='meta.unary.cat-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.cat-3'>3</a></div><p >[&nbsp;<i>Note:</i>
For any given type <span class='texttt'>T</span>, exactly one of the primary type categories
has a <span class='texttt'>value</span> member that evaluates to <span class='texttt'>true</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:type-traits.primary'>Table <a href='#tab:type-traits.primary'>47</a> — Primary type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_void;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>void</span>       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_null_pointer;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>std::nullptr_t</span> (<a href='basic.fundamental'>[basic.fundamental]</a>)       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_integral;</span>        </td><td class='left'>
<span class='texttt'>T</span> is an integral type (<a href='basic.fundamental'>[basic.fundamental]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_floating_point;</span>  </td><td class='left'>
<span class='texttt'>T</span> is a floating point type (<a href='basic.fundamental'>[basic.fundamental]</a>)            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_array;</span>           </td><td class='left'>
<span class='texttt'>T</span> is an array type (<a href='basic.compound'>[basic.compound]</a>) of known or unknown extent    </td><td class='left'>
Class template <span class='texttt'>array</span> (<a href='array'>[array]</a>)
is not an array type.                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pointer;</span>         </td><td class='left'>
<span class='texttt'>T</span> is a pointer type (<a href='basic.compound'>[basic.compound]</a>)                      </td><td class='left'>
Includes pointers to functions
but not pointers to non-static members.                        </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_lvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_rvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an rvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_object_pointer;</span></td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member                              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_function_pointer;</span></td><td class='left'>
<span class='texttt'>T</span> is a pointer to non-static member function                           </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_enum;</span>            </td><td class='left'>
<span class='texttt'>T</span> is an enumeration type (<a href='basic.compound'>[basic.compound]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_union;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a union type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_class;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a class type but not a union type (<a href='basic.compound'>[basic.compound]</a>) </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_function;</span>        </td><td class='left'>
<span class='texttt'>T</span> is a function type (<a href='basic.compound'>[basic.compound]</a>)                     </td><td class='left'>   </td></tr></table></div></div></div><div id='meta.unary.comp'><h4 ><a class='secnum' href='#meta.unary.comp' style='min-width:118pt'>20.10.4.2</a> Composite type traits <a class='abbr_ref' href='meta.unary.comp'>[meta.unary.comp]</a></h4><div class='para' id='meta.unary.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.comp-1'>1</a></div><p >These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section <a href='basic.types'>[basic.types]</a>.</p></div><div class='para' id='meta.unary.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.comp-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span>, and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p><div class='numberedTable' id='tab:type-traits.composite'>Table <a href='#tab:type-traits.composite'>48</a> — Composite type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_reference;</span>   </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference or an rvalue reference </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_arithmetic;</span>          </td><td class='left'>
 <span class='texttt'>T</span> is an arithmetic type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_fundamental;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a fundamental type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_object;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is an object type (<a href='basic.types'>[basic.types]</a>)                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_scalar;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is a scalar type (<a href='basic.types'>[basic.types]</a>)                         </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_compound;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is a compound type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_pointer;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member
 or non-static member function             </td><td class='left'>   </td></tr></table></div></div></div><div id='meta.unary.prop'><h4 ><a class='secnum' href='#meta.unary.prop' style='min-width:118pt'>20.10.4.3</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h4><div class='para' id='meta.unary.prop-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='meta.unary.prop-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='meta.unary.prop-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this Clause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>49</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 (possibly cv-qualified) <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_literal_type;</span>        </td><td class='left'>
 <span class='texttt'>T</span> is a literal type (<a href='basic.types'>[basic.types]</a>)  </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 (possibly cv-qualified) <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty&lt;B&gt;::value</span> is false. </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_final;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type marked with the <span class='grammarterm'>class-virt-specifier</span>
 <span class='texttt'>final</span> (Clause <a href='class'>[class]</a>). [&nbsp;<i>Note:</i> A union is a class type that
 can be marked with <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                        </td><td class='left'>
 If <span class='texttt'>T</span> is a class type, <span class='texttt'>T</span> shall be a complete type.                          </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  If <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>integral_constant&lt;bool, T(-1) &lt; T(0)&gt;::value</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  If <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>integral_constant&lt;bool, T(0) &lt; T(-1)&gt;::value</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 <i><span class='texttt'>see below</span></i>                          </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  For reference types, <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. <span class='hfill'></span><br/>
  For incomplete types and function types, <span class='texttt'>is_destructible&lt;T&gt;::value</span> is
  <span class='texttt'>false</span>. <span class='hfill'></span><br/>
  For object types and given <span class='texttt'>U</span> equal to <span class='texttt'>remove_all_extents_t&lt;T&gt;</span>,
  if the expression <span class='texttt'>std::declval&lt;U&amp;&gt;().~U()</span> is well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>), <span class='hfill'></span><br/> then
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>,
  otherwise it is <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct</span><span class='hfill'></span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T,</span><span class='hfill'></span><br/>
  <span class='texttt'>Args...&gt;::value</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible&lt;T,</span> <span class='texttt'> Args...&gt;::value</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_nothrow_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) void, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr></table></div></div><div class='para' id='meta.unary.prop-4'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
is_const&lt;const volatile int&gt;::value     <span class='comment'>// true
</span>is_const&lt;const int*&gt;::value             <span class='comment'>// false
</span>is_const&lt;const int&amp;&gt;::value             <span class='comment'>// false
</span>is_const&lt;int[3]&gt;::value                 <span class='comment'>// false
</span>is_const&lt;const int[3]&gt;::value           <span class='comment'>// true
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.unary.prop-5'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
remove_const_t&lt;const volatile int&gt;  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const_t&lt;const int* const&gt;    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const_t&lt;const int&amp;&gt;          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const_t&lt;const int[3]&gt;        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.unary.prop-6'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-6'>6</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Given:
</span>struct P final { };
union U1 { };
union U2 final { };

<span class='comment'>// the following assertions hold:
</span>static_assert(!is_final&lt;int&gt;::value, "Error!");
static_assert( is_final&lt;P&gt;::value, "Error!");
static_assert(!is_final&lt;U1&gt;::value, "Error!");
static_assert( is_final&lt;U2&gt;::value, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.unary.prop-7'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop-7'>7</a></div><p >Given the following function prototype:
</p><pre class='codeblock'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre><p >the predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(create&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='meta.unary.prop.query'><h3 ><a class='secnum' href='#meta.unary.prop.query' style='min-width:103pt'>20.10.5</a> Type property queries <a class='abbr_ref' href='meta.unary.prop.query'>[meta.unary.prop.query]</a></h3><div class='para' id='meta.unary.prop.query-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop.query-1'>1</a></div><p >This sub-clause contains templates that may be used to query
properties of types at compile time.</p><div class='numberedTable' id='tab:type-traits.properties.queries'>Table <a href='#tab:type-traits.properties.queries'>50</a> — Type property queries<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct alignment_of;</span>      </td><td class='left'>
 <span class='texttt'>alignof(T)</span>.<span class='hfill'></span><br/>
 <i>Requires:</i>
 <span class='texttt'>alignof(T)</span> shall be a valid expression (<a href='expr.alignof'>[expr.alignof]</a>)  </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct rank;</span>      </td><td class='left'>
 If <span class='texttt'>T</span> names an array type, an integer value representing
 the number of dimensions of <span class='texttt'>T</span>; otherwise, 0. </td></tr><tr class='rowsep'><td class='left'>    <span class='texttt'>template &lt;class T,<span class='hfill'></span><br/>
 unsigned I = 0&gt;<span class='hfill'></span><br/>
 struct extent;</span>        </td><td class='left'>
 If <span class='texttt'>T</span> is not an array type, or if it has rank less
 than or equal to <span class='texttt'>I</span>, or if <span class='texttt'>I</span> is 0 and <span class='texttt'>T</span>
 has type “array of unknown bound of <span class='texttt'>U</span>”, then
 0; otherwise, the bound (<a href='dcl.array'>[dcl.array]</a>) of the <span class='texttt'>I</span>'th dimension of
<span class='texttt'>T</span>, where indexing of <span class='texttt'>I</span> is zero-based </td></tr></table></div></div><div class='para' id='meta.unary.prop.query-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop.query-2'>2</a></div><p >Each of these templates shall be a <span class='texttt'>UnaryTypeTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
<span class='texttt'>BaseCharacteristic</span> of <span class='texttt'>integral_constant&lt;size_t, Value&gt;</span>.</p></div><div class='para' id='meta.unary.prop.query-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop.query-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert(rank&lt;int&gt;::value == 0);
assert(rank&lt;int[2]&gt;::value == 1);
assert(rank&lt;int[][4]&gt;::value == 2);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.unary.prop.query-4'><div class='marginalizedparent'><a class='marginalized' href='#meta.unary.prop.query-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
 <span class='comment'>// the following assertions hold:
</span>assert(extent&lt;int&gt;::value == 0);
assert(extent&lt;int[2]&gt;::value == 2);
assert(extent&lt;int[2][4]&gt;::value == 2);
assert(extent&lt;int[][4]&gt;::value == 0);
assert((extent&lt;int, 1&gt;::value) == 0);
assert((extent&lt;int[2], 1&gt;::value) == 0);
assert((extent&lt;int[2][4], 1&gt;::value) == 4);
assert((extent&lt;int[][4], 1&gt;::value) == 4);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='meta.rel'><h3 ><a class='secnum' href='#meta.rel' style='min-width:103pt'>20.10.6</a> Relationships between types <a class='abbr_ref' href='meta.rel'>[meta.rel]</a></h3><div class='para' id='meta.rel-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.rel-1'>1</a></div><p >This sub-clause contains templates that may be used to query
relationships between types at compile time.</p></div><div class='para' id='meta.rel-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.rel-2'>2</a></div><p >Each of these templates shall be a
BinaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p><div class='numberedTable' id='tab:type-traits.relationship'>Table <a href='#tab:type-traits.relationship'>51</a> — Type relationship predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_same;</span>                    </td><td class='left'>
 <span class='texttt'>T</span> and <span class='texttt'>U</span> name the same type with the same cv-qualifications                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class Base, class Derived&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_base_of;</span>                 </td><td class='left'>
 <span class='texttt'>Base</span> is a base class of <span class='texttt'>Derived</span> (Clause <a href='class.derived'>[class.derived]</a>)
 without regard to cv-qualifiers
 or <span class='texttt'>Base</span> and <span class='texttt'>Derived</span> are not unions and
 name the same class type
 without regard to cv-qualifiers</td><td class='left'>
 If <span class='texttt'>Base</span> and
 <span class='texttt'>Derived</span> are non-union class types and are different types (ignoring
 possible cv-qualifiers) then
 <span class='texttt'>Derived</span> shall be a complete
 type.
 [&nbsp;<i>Note:</i> Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class From, class To&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_convertible;</span>             </td><td class='left'>
 <i><span class='texttt'>see below</span></i>
  </td><td class='left'>
 <span class='texttt'>From</span> and <span class='texttt'>To</span> shall be complete
 types, arrays of unknown
 bound, or (possibly cv-qualified) <span class='texttt'>void</span> types.                      </td></tr></table></div></div><div class='para' id='meta.rel-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.rel-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of&lt;B, D&gt;::value         <span class='comment'>// true
</span>is_base_of&lt;const B, D&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;B, const D&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;B, const B&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;D, B&gt;::value         <span class='comment'>// false
</span>is_base_of&lt;B&amp;, D&amp;&gt;::value       <span class='comment'>// false
</span>is_base_of&lt;B[3], D[3]&gt;::value   <span class='comment'>// false
</span>is_base_of&lt;int, int&gt;::value     <span class='comment'>// false
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.rel-4'><div class='marginalizedparent'><a class='marginalized' href='#meta.rel-4'>4</a></div><p >Given the following function prototype:</p><pre class='codeblock'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre><p >the predicate condition for a template specialization <span class='texttt'>is_convertible&lt;From, To&gt;</span>
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:</p><pre class='codeblock'>
To test() {
  return create&lt;From&gt;();
}
</pre><p >[&nbsp;<i>Note:</i> This requirement gives well defined results for reference types, void
types, array types, and function types.<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as
if in a context unrelated to <span class='texttt'>To</span> and <span class='texttt'>From</span>. Only the validity of
the immediate context of the expression of the <span class='grammarterm'>return-statement</span>
(including conversions to the return type) is considered. [&nbsp;<i>Note:</i> The
evaluation of the conversion can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the “immediate context” and can result in the program
being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='meta.trans'><h3 ><a class='secnum' href='#meta.trans' style='min-width:103pt'>20.10.7</a> Transformations between types <a class='abbr_ref' href='meta.trans'>[meta.trans]</a></h3><div class='para' id='meta.trans-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans-1'>1</a></div><p >This sub-clause contains templates that may be used to transform one
type to another following some predefined rule.</p></div><div class='para' id='meta.trans-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans-2'>2</a></div><p >Each of the templates in this subclause shall be a
<a class='hidden_link' href='#def:TransformationTrait' id='def:TransformationTrait'><i>TransformationTrait</i></a> (<a href='meta.rqmts'>[meta.rqmts]</a>).</p></div><div id='meta.trans.cv'><h4 ><a class='secnum' href='#meta.trans.cv' style='min-width:118pt'>20.10.7.1</a> Const-volatile modifications <a class='abbr_ref' href='meta.trans.cv'>[meta.trans.cv]</a></h4><div class='numberedTable' id='tab:type-traits.const-volatile'>Table <a href='#tab:type-traits.const-volatile'>52</a> — Const-volatile modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_const;</span>                  </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level const-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_const_t&lt;const volatile int&gt;</span> evaluates
 to <span class='texttt'>volatile int</span>, whereas <span class='texttt'>remove_const_t&lt;const int*&gt;</span> evaluates to
 <span class='texttt'>const int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]                          </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_volatile;</span>               </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level volatile-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_volatile_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>const int</span>,
 whereas <span class='texttt'>remove_volatile_t&lt;volatile int*&gt;</span> evaluates to <span class='texttt'>volatile int*</span>.
 <i>&nbsp;—&nbsp;end example</i>&nbsp;]                                              </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_cv;</span>                 </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be the same as <span class='texttt'>T</span>
 except that any top-level cv-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_cv_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>int</span>, whereas <span class='texttt'>remove_cv_t&lt;const volatile int*&gt;</span>
 evaluates to <span class='texttt'>const volatile int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct add_const;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level const-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T const</span>.                                                           </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct add_volatile;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level volatile-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T volatile</span>.                                                            </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct add_cv;</span>                    </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as
 <span class='texttt'>add_const_t&lt;add_volatile_t&lt;T&gt;&gt;</span>.                               </td></tr></table></div></div><div id='meta.trans.ref'><h4 ><a class='secnum' href='#meta.trans.ref' style='min-width:118pt'>20.10.7.2</a> Reference modifications <a class='abbr_ref' href='meta.trans.ref'>[meta.trans.ref]</a></h4><div class='numberedTable' id='tab:type-traits.reference'>Table <a href='#tab:type-traits.reference'>53</a> — Reference modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_reference;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> has type “reference to <span class='texttt'>T1</span>” then the
 member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T1</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct add_lvalue_reference;</span>                     </td><td class='left'>
 If <span class='texttt'>T</span> names an object or function type then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;</span>;
 otherwise, if <span class='texttt'>T</span> names a
  type “rvalue reference to <span class='texttt'>T1</span>” then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T1&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall
 name <span class='texttt'>T</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct add_rvalue_reference;</span>    </td><td class='left'>
 If <span class='texttt'>T</span> names an object or function type then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> This rule reflects the semantics of reference collapsing (<a href='dcl.ref'>[dcl.ref]</a>).
 For example, when a type <span class='texttt'>T</span> names a type <span class='texttt'>T1&amp;</span>, the type
 <span class='texttt'>add_rvalue_reference_t&lt;T&gt;</span> is not an rvalue reference.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr></table></div></div><div id='meta.trans.sign'><h4 ><a class='secnum' href='#meta.trans.sign' style='min-width:118pt'>20.10.7.3</a> Sign modifications <a class='abbr_ref' href='meta.trans.sign'>[meta.trans.sign]</a></h4><div class='numberedTable' id='tab:type-traits.sign'>Table <a href='#tab:type-traits.sign'>54</a> — Sign modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct make_signed;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type then <span class='texttt'>type</span> shall name the corresponding
 signed integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the signed integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<span class='hfill'></span><br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct make_unsigned;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type then <span class='texttt'>type</span> shall name the corresponding
 unsigned integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the unsigned integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<span class='hfill'></span><br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr></table></div></div><div id='meta.trans.arr'><h4 ><a class='secnum' href='#meta.trans.arr' style='min-width:118pt'>20.10.7.4</a> Array modifications <a class='abbr_ref' href='meta.trans.arr'>[meta.trans.arr]</a></h4><div class='numberedTable' id='tab:type-traits.array'>Table <a href='#tab:type-traits.array'>55</a> — Array modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_extent;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> names a type “array of <span class='texttt'>U</span>”,
 the member typedef <span class='texttt'>type</span> shall
 be <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> For multidimensional arrays, only the first array dimension is
 removed. For a type “array of <span class='texttt'>const U</span>”, the resulting type is
 <span class='texttt'>const U</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                 </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_all_extents;</span>                </td><td class='left'>
 If <span class='texttt'>T</span> is “multi-dimensional array of <span class='texttt'>U</span>”, the resulting member
 typedef <span class='texttt'>type</span> is <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.                                       </td></tr></table></div><div class='para' id='meta.trans.arr-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.arr-1'>1</a></div><p >[<i>Example</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same&lt;remove_extent_t&lt;int&gt;, int&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[2]&gt;, int&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[2][3]&gt;, int[3]&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[][3]&gt;, int[3]&gt;::value));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='meta.trans.arr-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.arr-2'>2</a></div><p >[<i>Example</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same&lt;remove_all_extents_t&lt;int&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[2]&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[2][3]&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[][3]&gt;, int&gt;::value));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='meta.trans.ptr'><h4 ><a class='secnum' href='#meta.trans.ptr' style='min-width:118pt'>20.10.7.5</a> Pointer modifications <a class='abbr_ref' href='meta.trans.ptr'>[meta.trans.ptr]</a></h4><div class='numberedTable' id='tab:type-traits.pointer'>Table <a href='#tab:type-traits.pointer'>56</a> — Pointer modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct remove_pointer;</span>                    </td><td class='left'>
 If <span class='texttt'>T</span> has type “(possibly cv-qualified) pointer
 to <span class='texttt'>T1</span>” then the member typedef <span class='texttt'>type</span>
 shall name <span class='texttt'>T1</span>; otherwise, it shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;<span class='hfill'></span><br/>
 struct add_pointer;</span>                       </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name the same type as
 <span class='texttt'>remove_reference_t&lt;T&gt;*</span>.                         </td></tr></table></div></div><div id='meta.trans.other'><h4 ><a class='secnum' href='#meta.trans.other' style='min-width:118pt'>20.10.7.6</a> Other transformations <a class='abbr_ref' href='meta.trans.other'>[meta.trans.other]</a></h4><div class='numberedTable' id='tab:type-traits.other'>Table <a href='#tab:type-traits.other'>57</a> — Other transformations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>template &lt;std::size_t Len,<span class='hfill'></span><br/>
 std::size_t Align<span class='hfill'></span><br/>
 = <i>default-alignment</i>&gt;<span class='hfill'></span><br/>
 struct aligned_storage;</span>
 </td><td class='left'>
 <span class='texttt'>Len</span> shall not be zero.
 <span class='texttt'>Align</span> shall be equal
 to <span class='texttt'>alignof(T)</span> for some type <span class='texttt'>T</span>
 or to <i>default-alignment</i>.
 </td><td class='left'>
 The value of <i>default-alignment</i> shall be the most
 stringent alignment requirement for any C++ object type whose size
 is no greater than <span class='texttt'>Len</span> (<a href='basic.types'>[basic.types]</a>).
 The member typedef <span class='texttt'>type</span> shall be a POD type
 suitable for use as uninitialized storage for any object whose size
 is at most <i>Len</i> and whose alignment is a divisor of <i>Align</i>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;std::size_t Len,<span class='hfill'></span><br/>
  class... Types&gt;<span class='hfill'></span><br/>
  struct aligned_union;</span>
  </td><td class='left'>
  At least one type is provided.
  </td><td class='left'>
  The member typedef <span class='texttt'>type</span> shall be a POD type suitable for use as
  uninitialized storage for any object whose type is listed in <span class='texttt'>Types</span>;
  its size shall be at least <span class='texttt'>Len</span>. The static member <span class='texttt'>alignment_value</span>
  shall be an integral constant of type <span class='texttt'>std::size_t</span> whose value is the
  strictest alignment of all types listed in <span class='texttt'>Types</span>.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt; struct</span> <span class='texttt'>decay;</span> </td><td class='left'>   </td><td class='left'>
 Let <span class='texttt'>U</span> be <span class='texttt'>remove_reference_t&lt;T&gt;</span>. If <span class='texttt'>is_array&lt;U&gt;::value</span>
 is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span> shall equal
 <span class='texttt'>remove_extent_t&lt;U&gt;*</span>. If <span class='texttt'>is_function&lt;U&gt;::value</span> is <span class='texttt'>true</span>,
 the member typedef <span class='texttt'>type</span> shall equal <span class='texttt'>add_pointer_t&lt;U&gt;</span>. Otherwise
 the member typedef <span class='texttt'>type</span> equals <span class='texttt'>remove_cv_t&lt;U&gt;</span>.
 [&nbsp;<i>Note:</i> This behavior is similar to the lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
 array-to-pointer (<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>)
 conversions applied when an lvalue expression is used as an rvalue, but also
 strips <i>cv</i>-qualifiers from class types in order to more closely model by-value
 argument passing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
 </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;bool B, class T = void&gt;</span> <span class='texttt'>struct enable_if;</span> </td><td class='left'> </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>T</span>; otherwise, there shall be no member
 <span class='texttt'>type</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;bool B, class T,</span> <span class='texttt'>class F&gt; struct conditional</span>; </td><td class='left'> </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>T</span>.
 If <span class='texttt'>B</span> is <span class='texttt'>false</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>F</span>. </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class... T&gt;</span> <span class='texttt'>struct common_type;</span> </td><td class='left'> </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be defined as set out below. All types in
the parameter pack <span class='texttt'>T</span> shall be complete or (possibly <i>cv</i>) <span class='texttt'>void</span>. A
program may specialize this trait if at least one template parameter in the
specialization is a user-defined type. [&nbsp;<i>Note:</i> Such specializations are
needed when only explicit conversions are desired among the template arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct underlying_type;</span>  </td><td class='left'>
 <span class='texttt'>T</span> shall be an enumeration type (<a href='dcl.enum'>[dcl.enum]</a>) </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name the underlying type
 of <span class='texttt'>T</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class Fn,</span><span class='hfill'></span><br/>
 <span class='texttt'>class... ArgTypes&gt; struct</span>
 <span class='texttt'>result_of&lt;Fn(ArgTypes...)&gt;;</span>  </td><td class='left'>
 <span class='texttt'>Fn</span> and all types in the parameter pack <span class='texttt'>ArgTypes</span> shall
 be complete types, (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of
 unknown bound. </td><td class='left'>
 If the expression <span class='texttt'>INVOKE(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</span>
 is well formed when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>),
 the member typedef <span class='texttt'>type</span> shall name the type
 <span class='texttt'>decltype(INVOKE(declval&lt;Fn&gt;(),</span> <span class='texttt'>declval&lt;ArgTypes&gt;()...))</span>;
 otherwise, there shall be no member <span class='texttt'>type</span>. Access checking is
 performed as if in a context unrelated to <span class='texttt'>Fn</span> and
 <span class='texttt'>ArgTypes</span>. Only the validity of the immediate context of the
 expression is considered.
 [&nbsp;<i>Note:</i>
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the “immediate
 context” and can result in the program being ill-formed.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr></table></div><div class='para' id='meta.trans.other-1'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.other-1'>1</a></div><p >[&nbsp;<i>Note:</i> A typical implementation would define <span class='texttt'>aligned_storage</span> as:</p><pre class='codeblock'>
template &lt;std::size_t Len, std::size_t Alignment&gt;
struct aligned_storage {
  typedef struct {
    alignas(Alignment) unsigned char __data[Len];
  } type;
};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='meta.trans.other-2'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.other-2'>2</a></div><p >It is <span class='indexparent'><a class='index' id='support_for_extended_alignment'></a></span>implementation-defined whether any extended alignment is
supported (<a href='basic.align'>[basic.align]</a>).</p></div><div class='para' id='meta.trans.other-3'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.other-3'>3</a></div><p >The nested typedef <span class='texttt'>common_type::type</span> shall be defined as follows:</p><pre class='codeblock'>
template &lt;class ...T&gt; struct common_type;

template &lt;class T&gt;
struct common_type&lt;T&gt; {
  typedef decay_t&lt;T&gt; type;
};

template &lt;class T, class U&gt;
struct common_type&lt;T, U&gt; {
  typedef decay_t&lt;decltype(true ? declval&lt;T&gt;() : declval&lt;U&gt;())&gt; type;
};

template &lt;class T, class U, class... V&gt;
struct common_type&lt;T, U, V...&gt; {
  typedef common_type_t&lt;common_type_t&lt;T, U&gt;, V...&gt; type;
};
</pre></div><div class='para' id='meta.trans.other-4'><div class='marginalizedparent'><a class='marginalized' href='#meta.trans.other-4'>4</a></div><p >[&nbsp;<i>Example:</i>
Given these definitions:
</p><pre class='codeblock'>
typedef bool (&amp;PF1)();
typedef short (*PF2)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&amp;);
  void fn(long) const;
  char data;
};

typedef void (S::*PMF)(long) const;
typedef char S::*PMD;
</pre><p >the following assertions will hold:</p><pre class='codeblock'>
static_assert(is_same&lt;result_of_t&lt;S(int)&gt;, short&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;S&amp;(unsigned char, int&amp;)&gt;, double&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PF1()&gt;, bool&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMF(unique_ptr&lt;S&gt;, int)&gt;, void&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMD(S)&gt;, char&amp;&amp;&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMD(const S*)&gt;, const char&amp;&gt;::value, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div><div id='ratio'><h2 ><a class='secnum' href='#ratio' style='min-width:88pt'>20.11</a> Compile-time rational arithmetic <a class='abbr_ref' href='ratio'>[ratio]</a></h2><div id='ratio.general'><h3 ><a class='secnum' href='#ratio.general' style='min-width:103pt'>20.11.1</a> In general <a class='abbr_ref' href='ratio.general'>[ratio.general]</a></h3><div class='para' id='ratio.general-1'><div class='marginalizedparent'><a class='marginalized' href='#ratio.general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ratio'></a></span>This subclause describes the ratio library. It provides a class template
<span class='texttt'>ratio</span> which exactly represents any finite rational number with a
numerator and denominator representable by compile-time constants of type
<span class='texttt'>intmax_t</span>.</p></div><div class='para' id='ratio.general-2'><div class='marginalizedparent'><a class='marginalized' href='#ratio.general-2'>2</a></div><p >Throughout this subclause, the names of template parameters are used to express
type requirements. If a template parameter is named <span class='texttt'>R1</span> or <span class='texttt'>R2</span>,
and the template argument is not a specialization of the <span class='texttt'>ratio</span> template,
the program is ill-formed.</p></div></div><div id='ratio.syn'><h3 ><a class='secnum' href='#ratio.syn' style='min-width:103pt'>20.11.2</a> Header <span class='texttt'>&lt;ratio&gt;</span> synopsis <a class='abbr_ref' href='ratio.syn'>[ratio.syn]</a></h3><pre class='codeblock'>
namespace std 
  // <a href='ratio.ratio'>[ratio.ratio]</a>, class template <span class='texttt'>ratio</span>
  template &lt;intmax_t N, intmax_t D = 1&gt; class ratio;

  // <a href='ratio.arithmetic'>[ratio.arithmetic]</a>, ratio arithmetic
  template &lt;class R1, class R2&gt; using ratio_add = @<i><span class='texttt'>see below</span></i>@;
  template &lt;class R1, class R2&gt; using ratio_subtract = @<i><span class='texttt'>see below</span></i>@;
  template &lt;class R1, class R2&gt; using ratio_multiply = @<i><span class='texttt'>see below</span></i>@;
  template &lt;class R1, class R2&gt; using ratio_divide = @<i><span class='texttt'>see below</span></i>@;

  // <a href='ratio.comparison'>[ratio.comparison]</a>, ratio comparison
  template &lt;class R1, class R2&gt; struct ratio_equal;
  template &lt;class R1, class R2&gt; struct ratio_not_equal;
  template &lt;class R1, class R2&gt; struct ratio_less;
  template &lt;class R1, class R2&gt; struct ratio_less_equal;
  template &lt;class R1, class R2&gt; struct ratio_greater;
  template &lt;class R1, class R2&gt; struct ratio_greater_equal;

  // <a href='ratio.si'>[ratio.si]</a>, convenience SI typedefs
  typedef ratio&lt;1, 1'000'000'000'000'000'000'000'000&gt; yocto;  // <i><span class='texttt'>see below</span></i>
  typedef ratio&lt;1,     1'000'000'000'000'000'000'000&gt; zepto;  // <i><span class='texttt'>see below</span></i>
  typedef ratio&lt;1,         1'000'000'000'000'000'000&gt; atto;
  typedef ratio&lt;1,             1'000'000'000'000'000&gt; femto;
  typedef ratio&lt;1,                 1'000'000'000'000&gt; pico;
  typedef ratio&lt;1,                     1'000'000'000&gt; nano;
  typedef ratio&lt;1,                         1'000'000&gt; micro;
  typedef ratio&lt;1,                             1'000&gt; milli;
  typedef ratio&lt;1,                               100&gt; centi;
  typedef ratio&lt;1,                                10&gt; deci;
  typedef ratio&lt;                               10, 1&gt; deca;
  typedef ratio&lt;                              100, 1&gt; hecto;
  typedef ratio&lt;                            1'000, 1&gt; kilo;
  typedef ratio&lt;                        1'000'000, 1&gt; mega;
  typedef ratio&lt;                    1'000'000'000, 1&gt; giga;
  typedef ratio&lt;                1'000'000'000'000, 1&gt; tera;
  typedef ratio&lt;            1'000'000'000'000'000, 1&gt; peta;
  typedef ratio&lt;        1'000'000'000'000'000'000, 1&gt; exa;
  typedef ratio&lt;    1'000'000'000'000'000'000'000, 1&gt; zetta;  // <i><span class='texttt'>see below</span></i>
  typedef ratio&lt;1'000'000'000'000'000'000'000'000, 1&gt; yotta;  // <i><span class='texttt'>see below</span></i>

</pre></div><div id='ratio.ratio'><h3 ><a class='secnum' href='#ratio.ratio' style='min-width:103pt'>20.11.3</a> Class template <span class='texttt'>ratio</span> <a class='abbr_ref' href='ratio.ratio'>[ratio.ratio]</a></h3><pre class='codeblock'>
namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    static constexpr intmax_t num;
    static constexpr intmax_t den;
    typedef ratio&lt;num, den&gt; type;
  };
}
</pre><div class='para' id='ratio.ratio-1'><div class='marginalizedparent'><a class='marginalized' href='#ratio.ratio-1'>1</a></div><p >If the template argument <span class='texttt'>D</span> is zero or the absolute values of either of the
template arguments <span class='texttt'>N</span> and <span class='texttt'>D</span> is not representable by type
<span class='texttt'>intmax_t</span>, the program is ill-formed. [&nbsp;<i>Note:</i> These rules ensure that infinite
ratios are avoided and that for any negative input, there exists a representable value
of its absolute value which is positive. In a two's complement representation, this
excludes the most negative value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='ratio.ratio-2'><div class='marginalizedparent'><a class='marginalized' href='#ratio.ratio-2'>2</a></div><p >The static data members <span class='texttt'>num</span> and <span class='texttt'>den</span> shall have the following values,
where <span class='texttt'>gcd</span> represents the greatest common divisor of the absolute values of
<span class='texttt'>N</span> and <span class='texttt'>D</span>:</p><ul class='itemize'><li id='ratio.ratio-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ratio.ratio-2.1'>(2.1)</a></div><p ><span class='texttt'>num</span> shall have the value <span class='texttt'>sign(N) * sign(D) * abs(N) / gcd</span>.
</p></li><li id='ratio.ratio-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ratio.ratio-2.2'>(2.2)</a></div><p ><span class='texttt'>den</span> shall have the value <span class='texttt'>abs(D) / gcd</span>.
</p></li></ul></div></div><div id='ratio.arithmetic'><h3 ><a class='secnum' href='#ratio.arithmetic' style='min-width:103pt'>20.11.4</a> Arithmetic on <span class='texttt'>ratio</span>s <a class='abbr_ref' href='ratio.arithmetic'>[ratio.arithmetic]</a></h3><div class='para' id='ratio.arithmetic-1'><div class='marginalizedparent'><a class='marginalized' href='#ratio.arithmetic-1'>1</a></div><p >Each of the alias templates <span class='texttt'>ratio_add</span>, <span class='texttt'>ratio_subtract</span>, <span class='texttt'>ratio_multiply</span>,
and <span class='texttt'>ratio_divide</span> denotes the result of an arithmetic computation on two
<span class='texttt'>ratio</span>s <span class='texttt'>R1</span> and <span class='texttt'>R2</span>. With <span class='texttt'>X</span> and <span class='texttt'>Y</span> computed (in the
absence of arithmetic overflow) as specified by Table <a href='#tab:ratio.arithmetic'>[tab:ratio.arithmetic]</a>, each alias
denotes a <span class='texttt'>ratio&lt;U, V&gt;</span> such that <span class='texttt'>U</span> is the same as <span class='texttt'>ratio&lt;X, Y&gt;::num</span> and
<span class='texttt'>V</span> is the same as <span class='texttt'>ratio&lt;X, Y&gt;::den</span>.</p></div><div class='para' id='ratio.arithmetic-2'><div class='marginalizedparent'><a class='marginalized' href='#ratio.arithmetic-2'>2</a></div><p >If it is not possible to represent <span class='texttt'>U</span> or <span class='texttt'>V</span> with <span class='texttt'>intmax_t</span>, the program is
ill-formed. Otherwise, an implementation should yield correct values of <span class='texttt'>U</span> and
<span class='texttt'>V</span>. If it is not possible to represent <span class='texttt'>X</span> or <span class='texttt'>Y</span> with <span class='texttt'>intmax_t</span>, the
program is ill-formed unless the implementation yields correct values of <span class='texttt'>U</span> and
<span class='texttt'>V</span>.</p><div class='numberedTable' id='tab:ratio.arithmetic'>Table <a href='#tab:ratio.arithmetic'>58</a> — Expressions used to perform ratio arithmetic<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='1' class='center'><b>Value of <span class='texttt'>X</span></b></td><td colspan='1' class='center'><b>Value of <span class='texttt'>Y</span></b></td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ratio_add&lt;R1, R2&gt;</span>       </td><td class='left'>
  <span class='texttt'>R1::num * R2::den +</span>   </td><td class='left'>
  <span class='texttt'>R1::den * R2::den</span>     </td></tr><tr ><td class='left'>
                                </td><td class='left'>
  <span class='texttt'>R2::num * R1::den</span>     </td><td class='left'>
                                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ratio_subtract&lt;R1, R2&gt;</span>  </td><td class='left'>
  <span class='texttt'>R1::num * R2::den -</span>   </td><td class='left'>
  <span class='texttt'>R1::den * R2::den</span>     </td></tr><tr ><td class='left'>
                                </td><td class='left'>
  <span class='texttt'>R2::num * R1::den</span>     </td><td class='left'>
                                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ratio_multiply&lt;R1, R2&gt;</span>  </td><td class='left'>
  <span class='texttt'>R1::num * R2::num</span>     </td><td class='left'>
  <span class='texttt'>R1::den * R2::den</span>     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ratio_divide&lt;R1, R2&gt;</span>    </td><td class='left'>
  <span class='texttt'>R1::num * R2::den</span>     </td><td class='left'>
  <span class='texttt'>R1::den * R2::num</span>     </td></tr></table></div></div><div class='para' id='ratio.arithmetic-3'><div class='marginalizedparent'><a class='marginalized' href='#ratio.arithmetic-3'>3</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
static_assert(ratio_add&lt;ratio&lt;1,3&gt;, ratio&lt;1,6&gt;&gt;::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add&lt;ratio&lt;1,3&gt;, ratio&lt;1,6&gt;&gt;::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply&lt;ratio&lt;1,3&gt;, ratio&lt;3,2&gt;&gt;::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply&lt;ratio&lt;1,3&gt;, ratio&lt;3,2&gt;&gt;::den == 2, "1/3*3/2 == 1/2");

  <span class='comment'>// The following cases may cause the program to be ill-formed under some implementations
</span>static_assert(ratio_add&lt;ratio&lt;1,INT_MAX&gt;, ratio&lt;1,INT_MAX&gt;&gt;::num == 2,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add&lt;ratio&lt;1,INT_MAX&gt;, ratio&lt;1,INT_MAX&gt;&gt;::den == INT_MAX,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply&lt;ratio&lt;1,INT_MAX&gt;, ratio&lt;INT_MAX,2&gt;&gt;::num == 1,
  "1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply&lt;ratio&lt;1,INT_MAX&gt;, ratio&lt;INT_MAX,2&gt;&gt;::den == 2,
  "1/MAX * MAX/2 == 1/2");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='ratio.comparison'><h3 ><a class='secnum' href='#ratio.comparison' style='min-width:103pt'>20.11.5</a> Comparison of <span class='texttt'>ratio</span>s <a class='abbr_ref' href='ratio.comparison'>[ratio.comparison]</a></h3><p ><span class='indexparent'><a class='index' id='ratio_equal'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_equal
  : integral_constant&lt;bool, <i><span class='texttt'>see below</span></i>&gt; { };
</code></p><div class='itemdescr'></div><div class='para' id='ratio.comparison-1'><div class='marginalizedparent'><a class='marginalized' href='#ratio.comparison-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>R1::num == R2::num</span> and <span class='texttt'>R1::den == R2::den</span>, <span class='texttt'>ratio_equal&lt;R1,
R2&gt;</span> shall be derived from<br/> <span class='texttt'>integral_constant&lt;bool, true&gt;</span>; otherwise it shall
be derived from <span class='texttt'>integral_constant&lt;bool, false&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ratio_not_equal'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_not_equal
  : integral_constant&lt;bool, !ratio_equal&lt;R1, R2&gt;::value&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='ratio_less'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_less
  : integral_constant&lt;bool, <i><span class='texttt'>see below</span></i>&gt; { };
</code></p><div class='itemdescr'></div><div class='para' id='ratio.comparison-2'><div class='marginalizedparent'><a class='marginalized' href='#ratio.comparison-2'>2</a></div><div class='itemdescr'><p >If <span class='texttt'>R1::num * R2::den &lt; R2::num * R1::den</span>, <span class='texttt'>ratio_less&lt;R1, R2&gt;</span> shall be
derived from <span class='texttt'>integral_constant&lt;bool, true&gt;</span>; otherwise it shall be derived from
<span class='texttt'>integral_constant&lt;bool, false&gt;</span>. Implementations may use other algorithms to
compute this relationship to avoid overflow. If overflow occurs, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='ratio_less_equal'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_less_equal
  : integral_constant&lt;bool, !ratio_less&lt;R2, R1&gt;::value&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='ratio_greater'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_greater
  : integral_constant&lt;bool, ratio_less&lt;R2, R1&gt;::value&gt; { };
</code></p><p ><span class='indexparent'><a class='index' id='ratio_greater_equal'></a></span>
<code class='itemdecl'>
template &lt;class R1, class R2&gt; struct ratio_greater_equal
  : integral_constant&lt;bool, !ratio_less&lt;R1, R2&gt;::value&gt; { };
</code></p></div><div id='ratio.si'><h3 ><a class='secnum' href='#ratio.si' style='min-width:103pt'>20.11.6</a> SI types for <span class='texttt'>ratio</span> <a class='abbr_ref' href='ratio.si'>[ratio.si]</a></h3><div class='para' id='ratio.si-1'><div class='marginalizedparent'><a class='marginalized' href='#ratio.si-1'>1</a></div><p >For each of the typedefs <span class='texttt'>yocto</span>, <span class='texttt'>zepto</span>, <span class='texttt'>zetta</span>, and <span class='texttt'>yotta</span>,
if both of the constants used in its specification are representable by
<span class='texttt'>intmax_t</span>, the typedef shall be defined; if either of the constants is not
representable by <span class='texttt'>intmax_t</span>, the typedef shall not be defined.</p></div></div></div><div id='time'><h2 ><a class='secnum' href='#time' style='min-width:88pt'>20.12</a> Time utilities <a class='abbr_ref' href='time'>[time]</a></h2><div id='time.general'><h3 ><a class='secnum' href='#time.general' style='min-width:103pt'>20.12.1</a> In general <a class='abbr_ref' href='time.general'>[time.general]</a></h3><div class='para' id='time.general-1'><div class='marginalizedparent'><a class='marginalized' href='#time.general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='chrono'></a></span>This subclause describes the chrono library (<a href='time.syn'>[time.syn]</a>) and various C
functions (<a href='date.time'>[date.time]</a>) that provide generally useful time
utilities.</p></div></div><div id='time.syn'><h3 ><a class='secnum' href='#time.syn' style='min-width:103pt'>20.12.2</a> Header <span class='texttt'>&lt;chrono&gt;</span> synopsis <a class='abbr_ref' href='time.syn'>[time.syn]</a></h3><pre class='codeblock'>
namespace std {
namespace chrono {

<span class='comment'>// <a href='time.duration'>[time.duration]</a>, class template <span class='texttt'>duration</span>
</span>template &lt;class Rep, class Period = ratio&lt;1&gt; &gt; class duration;

<span class='comment'>// <a href='time.point'>[time.point]</a>, class template <span class='texttt'>time_point</span>
</span>template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point;

}  <span class='comment'>// namespace chrono
</span>
<span class='comment'>// <a href='time.traits.specializations'>[time.traits.specializations]</a> <span class='texttt'>common_type</span> specializations
</span>template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  struct common_type&lt;chrono::duration&lt;Rep1, Period1&gt;, chrono::duration&lt;Rep2, Period2&gt;&gt;;

template &lt;class Clock, class Duration1, class Duration2&gt;
  struct common_type&lt;chrono::time_point&lt;Clock, Duration1&gt;, chrono::time_point&lt;Clock, Duration2&gt;&gt;;

namespace chrono {

<span class='comment'>// <a href='time.traits'>[time.traits]</a>, customization traits
</span>template &lt;class Rep&gt; struct treat_as_floating_point;
template &lt;class Rep&gt; struct duration_values;

<span class='comment'>// <a href='time.duration.nonmember'>[time.duration.nonmember]</a>, duration arithmetic
</span>template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  constexpr operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  constexpr operator-(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  constexpr operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Rep2, class Period&gt;
  duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  constexpr operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  constexpr operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  common_type_t&lt;Rep1, Rep2&gt;
  constexpr operator/(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  constexpr operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  constexpr operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);

<span class='comment'>// <a href='time.duration.comparisons'>[time.duration.comparisons]</a>, duration comparisons
</span>template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator==(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator!=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&lt; (const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&lt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&gt; (const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&gt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                            const duration&lt;Rep2, Period2&gt;&amp; rhs);

<span class='comment'>// <a href='time.duration.cast'>[time.duration.cast]</a>, duration_cast
</span>template &lt;class ToDuration, class Rep, class Period&gt;
  constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);

<span class='comment'>// convenience typedefs
</span>typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_64_bits' id='def:signed_integer_type_of_at_least_64_bits'><i>signed integer type of at least 64 bits</i></a>,        nano&gt; nanoseconds;
typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_55_bits' id='def:signed_integer_type_of_at_least_55_bits'><i>signed integer type of at least 55 bits</i></a>,       micro&gt; microseconds;
typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_45_bits' id='def:signed_integer_type_of_at_least_45_bits'><i>signed integer type of at least 45 bits</i></a>,       milli&gt; milliseconds;
typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_35_bits' id='def:signed_integer_type_of_at_least_35_bits'><i>signed integer type of at least 35 bits</i></a>             &gt; seconds;
typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_29_bits' id='def:signed_integer_type_of_at_least_29_bits'><i>signed integer type of at least 29 bits</i></a>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<a class='hidden_link' href='#def:signed_integer_type_of_at_least_23_bits' id='def:signed_integer_type_of_at_least_23_bits'><i>signed integer type of at least 23 bits</i></a>, ratio&lt;3600&gt;&gt; hours;

<span class='comment'>// <a href='time.point.nonmember'>[time.point.nonmember]</a>, time_point arithmetic
</span>template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Clock, class Duration2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;duration&lt;Rep1, Period1&gt;, Duration2&gt;&gt;
  operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr common_type_t&lt;Duration1, Duration2&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);

<span class='comment'>// <a href='time.point.comparisons'>[time.point.comparisons]</a> time_point comparisons
</span>template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator==(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator!=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator&lt; (const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator&lt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator&gt; (const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);
template &lt;class Clock, class Duration1, class Duration2&gt;
   constexpr bool operator&gt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                             const time_point&lt;Clock, Duration2&gt;&amp; rhs);

<span class='comment'>// <a href='time.point.cast'>[time.point.cast]</a>, time_point_cast
</span>template &lt;class ToDuration, class Clock, class Duration&gt;
  constexpr time_point&lt;Clock, ToDuration&gt;
  time_point_cast(const time_point&lt;Clock, Duration&gt;&amp; t);

<span class='comment'>// <a href='time.clock'>[time.clock]</a>, clocks
</span>class system_clock;
class steady_clock;
class high_resolution_clock;

}  <span class='comment'>// namespace chrono
</span>
inline namespace literals {
inline namespace chrono_literals {

<span class='comment'>//  <a href='time.duration.literals'>[time.duration.literals]</a>, suffixes for duration literals
</span>constexpr chrono::hours                                 operator "" h(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, ratio&lt;3600,1&gt;&gt; operator "" h(long double);
constexpr chrono::minutes                               operator "" min(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, ratio&lt;60,1&gt;&gt;   operator "" min(long double);
constexpr chrono::seconds                               operator "" s(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>&gt;                operator "" s(long double);
constexpr chrono::milliseconds                          operator "" ms(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, milli&gt;         operator "" ms(long double);
constexpr chrono::microseconds                          operator "" us(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, micro&gt;         operator "" us(long double);
constexpr chrono::nanoseconds                           operator "" ns(unsigned long long);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, nano&gt;          operator "" ns(long double);

}  <span class='comment'>// namespace chrono_literals
</span>}  <span class='comment'>// namespace literals
</span>
namespace chrono {

using namespace literals::chrono_literals;

} <span class='comment'>// namespace chrono
</span>
}  <span class='comment'>// namespace std
</span></pre></div><div id='time.clock.req'><h3 ><a class='secnum' href='#time.clock.req' style='min-width:103pt'>20.12.3</a> Clock requirements <a class='abbr_ref' href='time.clock.req'>[time.clock.req]</a></h3><div class='para' id='time.clock.req-1'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.req-1'>1</a></div><p >A clock is a bundle consisting of a <span class='texttt'>duration</span>, a
<span class='texttt'>time_point</span>, and a function <span class='texttt'>now()</span> to get the current <span class='texttt'>time_point</span>.
The origin of the clock's <span class='texttt'>time_point</span> is referred to as the clock's <a class='hidden_link' href='#def:epoch' id='def:epoch'><i>epoch</i></a>.
 A clock shall meet the requirements in Table <a href='#tab:time.clock'>[tab:time.clock]</a>.</p></div><div class='para' id='time.clock.req-2'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.req-2'>2</a></div><p >In Table <a href='#tab:time.clock'>[tab:time.clock]</a> <span class='texttt'>C1</span> and <span class='texttt'>C2</span> denote clock types. <span class='texttt'>t1</span> and
<span class='texttt'>t2</span> are values returned by <span class='texttt'>C1::now()</span> where the call returning <span class='texttt'>t1</span> happens
before (<a href='intro.multithread'>[intro.multithread]</a>) the call returning <span class='texttt'>t2</span> and both of these calls
occur
before <span class='texttt'>C1::time_point::max()</span>.
[&nbsp;<i>Note:</i> this means <span class='texttt'>C1</span> did not wrap around between <span class='texttt'>t1</span> and
<span class='texttt'>t2</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:time.clock'>Table <a href='#tab:time.clock'>59</a> — Clock requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Operational semantics</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>C1::rep</span> </td><td class='left'>
  An arithmetic type or a class emulating an arithmetic type </td><td class='left'>
  The representation type of <span class='texttt'>C1::duration</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>C1::period</span>  </td><td class='left'>
  a specialization of <span class='texttt'>ratio</span>     </td><td class='left'>
  The tick period of the clock in seconds.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>C1::duration</span>  </td><td class='left'>
  <span class='texttt'>chrono::duration&lt;C1::rep, C1::period&gt;</span> </td><td class='left'>
  The <span class='texttt'>duration</span> type of the clock. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>C1::time_point</span>  </td><td class='left'>
  <span class='texttt'>chrono::time_point&lt;C1&gt;</span> or <span class='texttt'>chrono::time_point&lt;C2, C1::duration&gt;</span>  </td><td class='left'>
  The <span class='texttt'>time_point</span> type of the clock. <span class='texttt'>C1</span> and <span class='texttt'>C2</span> shall
  refer to the same epoch. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>C1::is_steady</span>  </td><td class='left'>
  <span class='texttt'>const bool</span>      </td><td class='left'>
  <span class='texttt'>true</span> if <span class='texttt'>t1 &lt;= t2</span> is always <span class='texttt'>true</span> and the time between clock
  ticks is constant, otherwise <span class='texttt'>false</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>C1::now()</span> </td><td class='left'>
  <span class='texttt'>C1::time_point</span>  </td><td class='left'>
  Returns a <span class='texttt'>time_point</span> object representing the current point in time. </td></tr></table></div></div><div class='para' id='time.clock.req-3'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.req-3'>3</a></div><p >[&nbsp;<i>Note:</i> The relative difference in durations between those reported by a given clock and the
SI definition is a measure of the quality of implementation. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='time.clock.req-4'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.req-4'>4</a></div><p >A type <span class='texttt'>TC</span> meets the <span class='texttt'>TrivialClock</span> requirements if:</p><ul class='itemize'><li id='time.clock.req-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.clock.req-4.1'>(4.1)</a></div><p ><span class='texttt'>TC</span> satisfies the <span class='texttt'>Clock</span> requirements (<a href='time.clock.req'>[time.clock.req]</a>),</p></li><li id='time.clock.req-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.clock.req-4.2'>(4.2)</a></div><p >the types <span class='texttt'>TC::rep</span>, <span class='texttt'>TC::duration</span>, and <span class='texttt'>TC::time_point</span>
satisfy the requirements of <span class='texttt'>EqualityComparable</span> (Table <a href='equalitycomparable'>[equalitycomparable]</a>),
<span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>),
<span class='texttt'>DefaultConstructible</span> (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
<span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>),
<span class='texttt'>CopyAssignable</span> (Table <a href='copyassignable'>[copyassignable]</a>),
<span class='texttt'>Destructible</span> (Table <a href='destructible'>[destructible]</a>), and the requirements of
numeric types (<a href='numeric.requirements'>[numeric.requirements]</a>). [&nbsp;<i>Note:</i> this means, in particular,
that operations on these types will not throw exceptions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='time.clock.req-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.clock.req-4.3'>(4.3)</a></div><p >lvalues of the types <span class='texttt'>TC::rep</span>, <span class='texttt'>TC::duration</span>, and
<span class='texttt'>TC::time_point</span> are swappable (<a href='swappable.requirements'>[swappable.requirements]</a>),</p></li><li id='time.clock.req-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.clock.req-4.4'>(4.4)</a></div><p >the function <span class='texttt'>TC::now()</span> does not throw exceptions, and</p></li><li id='time.clock.req-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.clock.req-4.5'>(4.5)</a></div><p >the type <span class='texttt'>TC::time_point::clock</span> meets the <span class='texttt'>TrivialClock</span>
requirements, recursively.
</p></li></ul></div></div><div id='time.traits'><h3 ><a class='secnum' href='#time.traits' style='min-width:103pt'>20.12.4</a> Time-related traits <a class='abbr_ref' href='time.traits'>[time.traits]</a></h3><div id='time.traits.is_fp'><h4 ><a class='secnum' href='#time.traits.is_fp' style='min-width:118pt'>20.12.4.1</a> <span class='texttt'>treat_as_floating_point</span> <a class='abbr_ref' href='time.traits.is_fp'>[time.traits.is_fp]</a></h4><p ><span class='indexparent'><a class='index' id='treat_as_floating_point'></a></span><code class='itemdecl'>
template &lt;class Rep&gt; struct treat_as_floating_point
  : is_floating_point&lt;Rep&gt; { };
</code></p><div class='para' id='time.traits.is_fp-1'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.is_fp-1'>1</a></div><p >The <span class='texttt'>duration</span> template uses the <span class='texttt'>treat_as_floating_point</span> trait to
help determine if a <span class='texttt'>duration</span> object can be converted to another
<span class='texttt'>duration</span> with a different tick <span class='texttt'>period</span>. If
<span class='texttt'>treat_as_floating_point&lt;Rep&gt;::value</span> is true, then implicit conversions
are allowed among <span class='texttt'>duration</span>s. Otherwise, the implicit convertibility
depends on the tick <span class='texttt'>period</span>s of the <span class='texttt'>duration</span>s.
[&nbsp;<i>Note:</i>
The intention of this trait is to indicate whether a given class behaves like a floating-point
type, and thus allows division of one value by another with acceptable loss of precision. If
<span class='texttt'>treat_as_floating_point&lt;Rep&gt;::value</span> is <span class='texttt'>false</span>, <span class='texttt'>Rep</span> will be treated as
if it behaved like an integral type for the purpose of these conversions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='time.traits.duration_values'><h4 ><a class='secnum' href='#time.traits.duration_values' style='min-width:118pt'>20.12.4.2</a> <span class='texttt'>duration_values</span> <a class='abbr_ref' href='time.traits.duration_values'>[time.traits.duration_values]</a></h4><p ><span class='indexparent'><a class='index' id='duration_values'></a></span><code class='itemdecl'>
template &lt;class Rep&gt;
struct duration_values {
public:
  static constexpr Rep zero();
  static constexpr Rep min();
  static constexpr Rep max();
};
</code></p><div class='para' id='time.traits.duration_values-1'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-1'>1</a></div><p >The <span class='texttt'>duration</span> template uses the <span class='texttt'>duration_values</span> trait to
construct special values of the durations representation (<span class='texttt'>Rep</span>). This is
done because the representation might be a class type with behavior which
requires some other implementation to return these special values. In that case,
the author of that class type should specialize <span class='texttt'>duration_values</span> to
return the indicated values.</p><p ><span class='indexparent'><a class='index' id='zero,duration_values'></a></span><span class='indexparent'><a class='index' id='duration_values,zero'></a></span><code class='itemdecl'>
static constexpr Rep zero();
</code></p></div><div class='itemdescr'></div><div class='para' id='time.traits.duration_values-2'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>Rep(0)</span>. [&nbsp;<i>Note:</i> <span class='texttt'>Rep(0)</span> is specified instead of
<span class='texttt'>Rep()</span> because <span class='texttt'>Rep()</span> may have some other meaning, such as an
uninitialized value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='time.traits.duration_values-3'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-3'>3</a></div><div class='itemdescr'><p ><i>Remark:</i> The value returned shall be the additive identity.
</p></div></div><p ><span class='indexparent'><a class='index' id='min,duration_values'></a></span><span class='indexparent'><a class='index' id='duration_values,min'></a></span><code class='itemdecl'>
static constexpr Rep min();
</code></p><div class='itemdescr'></div><div class='para' id='time.traits.duration_values-4'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>numeric_limits&lt;Rep&gt;::lowest()</span>.</p></div></div><div class='para' id='time.traits.duration_values-5'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-5'>5</a></div><div class='itemdescr'><p ><i>Remark:</i> The value returned shall compare less than or equal to <span class='texttt'>zero()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max,duration_values'></a></span><span class='indexparent'><a class='index' id='duration_values,max'></a></span><code class='itemdecl'>
static constexpr Rep max();
</code></p><div class='itemdescr'></div><div class='para' id='time.traits.duration_values-6'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>numeric_limits&lt;Rep&gt;::max()</span>.</p></div></div><div class='para' id='time.traits.duration_values-7'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.duration_values-7'>7</a></div><div class='itemdescr'><p ><i>Remark:</i> The value returned shall compare greater than <span class='texttt'>zero()</span>.
</p></div></div></div><div id='time.traits.specializations'><h4 ><a class='secnum' href='#time.traits.specializations' style='min-width:118pt'>20.12.4.3</a> Specializations of <span class='texttt'>common_type</span> <a class='abbr_ref' href='time.traits.specializations'>[time.traits.specializations]</a></h4><p ><span class='indexparent'><a class='index' id='common_type'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
struct common_type&lt;chrono::duration&lt;Rep1, Period1&gt;, chrono::duration&lt;Rep2, Period2&gt;&gt; {
  typedef chrono::duration&lt;common_type_t&lt;Rep1, Rep2&gt;, <i><span class='texttt'>see below</span></i>&gt; type;
};
</code></p><div class='para' id='time.traits.specializations-1'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.specializations-1'>1</a></div><p >The <span class='texttt'>period</span> of the <span class='texttt'>duration</span> indicated by this specialization of
<span class='texttt'>common_type</span> shall be the greatest common divisor of <span class='texttt'>Period1</span> and
<span class='texttt'>Period2</span>. [&nbsp;<i>Note:</i> This can be computed by forming a ratio of the
greatest common divisor of <span class='texttt'>Period1::num</span> and <span class='texttt'>Period2::num</span> and the
least common multiple of <span class='texttt'>Period1::den</span> and <span class='texttt'>Period2::den</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='time.traits.specializations-2'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.specializations-2'>2</a></div><p >[&nbsp;<i>Note:</i> The <span class='texttt'>typedef</span> name <span class='texttt'>type</span> is a synonym for the
<span class='texttt'>duration</span> with the largest tick <span class='texttt'>period</span> possible where both
<span class='texttt'>duration</span> arguments will convert to it without requiring a division
operation. The representation of this type is intended to be able to hold any
value resulting from this conversion with no truncation error, although
floating-point durations may have round-off errors. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='common_type'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
struct common_type&lt;chrono::time_point&lt;Clock, Duration1&gt;, chrono::time_point&lt;Clock, Duration2&gt;&gt; {
  typedef chrono::time_point&lt;Clock, common_type_t&lt;Duration1, Duration2&gt;&gt; type;
};
</code></p></div><div class='para' id='time.traits.specializations-3'><div class='marginalizedparent'><a class='marginalized' href='#time.traits.specializations-3'>3</a></div><p >The common type of two <span class='texttt'>time_point</span> types is a <span class='texttt'>time_point</span> with the same
clock as the two types and the common type of their two <span class='texttt'>duration</span>s.</p></div></div></div><div id='time.duration'><h3 ><a class='secnum' href='#time.duration' style='min-width:103pt'>20.12.5</a> Class template <span class='texttt'>duration</span> <a class='abbr_ref' href='time.duration'>[time.duration]</a></h3><div class='para' id='time.duration-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-1'>1</a></div><p >A <span class='texttt'>duration</span> type measures time between two points in time (<span class='texttt'>time_point</span>s).
A <span class='texttt'>duration</span> has a representation which holds a count of ticks and a tick period.
The tick period is the amount of time which occurs from one tick to the next, in units
of seconds. It is expressed as a rational constant using the template <span class='texttt'>ratio</span>.</p><pre class='codeblock'>
template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration {
public:
  typedef Rep    rep;
  typedef Period period;
private:
  rep rep_;  <span class='comment'>// <i>exposition only</i>
</span>public:
  <span class='comment'>// <a href='time.duration.cons'>[time.duration.cons]</a>, construct/copy/destroy:
</span>  constexpr duration() = default;
  template &lt;class Rep2&gt;
      constexpr explicit duration(const Rep2&amp; r);
  template &lt;class Rep2, class Period2&gt;
     constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
  ~duration() = default;
  duration(const duration&amp;) = default;
  duration&amp; operator=(const duration&amp;) = default;

  <span class='comment'>// <a href='time.duration.observer'>[time.duration.observer]</a>, observer:
</span>  constexpr rep count() const;

  <span class='comment'>// <a href='time.duration.arithmetic'>[time.duration.arithmetic]</a>, arithmetic:
</span>  constexpr duration  operator+() const;
  constexpr duration  operator-() const;
  duration&amp; operator++();
  duration  operator++(int);
  duration&amp; operator--();
  duration  operator--(int);

  duration&amp; operator+=(const duration&amp; d);
  duration&amp; operator-=(const duration&amp; d);

  duration&amp; operator*=(const rep&amp; rhs);
  duration&amp; operator/=(const rep&amp; rhs);
  duration&amp; operator%=(const rep&amp; rhs);
  duration&amp; operator%=(const duration&amp; rhs);

  <span class='comment'>// <a href='time.duration.special'>[time.duration.special]</a>, special values:
</span>  static constexpr duration zero();
  static constexpr duration min();
  static constexpr duration max();
};
</pre></div><div class='itemdescr'></div><div class='para' id='time.duration-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Rep</span> shall be an arithmetic type or a class emulating an arithmetic type.</p></div></div><div class='para' id='time.duration-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>duration</span> is instantiated with a <span class='texttt'>duration</span> type for the template
argument <span class='texttt'>Rep</span>, the program is ill-formed.</p></div></div><div class='para' id='time.duration-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>Period</span> is not a specialization of <span class='texttt'>ratio</span>, the program is ill-formed.</p></div></div><div class='para' id='time.duration-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>Period::num</span> is not positive, the program is ill-formed.</p></div></div><div class='para' id='time.duration-6'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> Members of <span class='texttt'>duration</span> shall not throw exceptions other than
those thrown by the indicated operations on their representations.</p></div></div><div class='para' id='time.duration-7'><div class='marginalizedparent'><a class='marginalized' href='#time.duration-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> The defaulted copy constructor of duration shall be a
<span class='texttt'>constexpr</span> function if and only if the required initialization
of the member <span class='texttt'>rep_</span> for copy and move, respectively, would
satisfy the requirements for a <span class='texttt'>constexpr</span> function.
</p></div></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
duration&lt;long, ratio&lt;60&gt;&gt; d0;       <span class='comment'>// holds a count of minutes using a <span class='texttt'>long</span>
</span>duration&lt;long long, milli&gt; d1;      <span class='comment'>// holds a count of milliseconds using a <span class='texttt'>long long</span>
</span>duration&lt;double, ratio&lt;1, 30&gt;&gt;  d2; <span class='comment'>// holds a count with a tick period of <img src='math/1063258799813875788.png' class='mathinlineimg' alt='$\frac{1}{30}$'/> of a second
</span>                                    <span class='comment'>// (30 Hz) using a <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><div id='time.duration.cons'><h4 ><a class='secnum' href='#time.duration.cons' style='min-width:118pt'>20.12.5.1</a> <span class='texttt'>duration</span> constructors <a class='abbr_ref' href='time.duration.cons'>[time.duration.cons]</a></h4><p ><span class='indexparent'><a class='index' id='duration,constructor'></a></span><code class='itemdecl'>
template &lt;class Rep2&gt;
  constexpr explicit duration(const Rep2&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cons-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload
resolution unless
<span class='texttt'>Rep2</span> is implicitly convertible to <span class='texttt'>rep</span> and
</p><ul class='itemize'><li id='time.duration.cons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cons-1.1'>(1.1)</a></div><p ><span class='texttt'>treat_as_floating_point&lt;rep&gt;::value</span> is <span class='texttt'>true</span> or
</p></li><li id='time.duration.cons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cons-1.2'>(1.2)</a></div><p ><span class='texttt'>treat_as_floating_point&lt;Rep2&gt;::value</span> is <span class='texttt'>false</span>.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
duration&lt;int, milli&gt; d(3);          <span class='comment'>// OK
</span>duration&lt;int, milli&gt; d(3.5);        <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='time.duration.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.duration.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>count() == static_cast&lt;rep&gt;(r)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='duration,constructor'></a></span><code class='itemdecl'>
template &lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cons-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless
no overflow is induced in the conversion and
<span class='texttt'>treat_as_floating_point&lt;rep&gt;::value</span> is <span class='texttt'>true</span> or both
<span class='texttt'>ratio_divide&lt;Period2, period&gt;::den</span> is <span class='texttt'>1</span> and
<span class='texttt'>treat_as_floating_point&lt;Rep2&gt;::value</span> is <span class='texttt'>false</span>. [&nbsp;<i>Note:</i> This
requirement prevents implicit truncation error when converting between
integral-based <span class='texttt'>duration</span> types. Such a construction could easily lead to
confusion about the value of the <span class='texttt'>duration</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
duration&lt;int, milli&gt; ms(3);
duration&lt;int, micro&gt; us = ms;       <span class='comment'>// OK
</span>duration&lt;int, milli&gt; ms2 = us;      <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='time.duration.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>duration</span>, constructing <span class='texttt'>rep_</span> from<br/>
<span class='texttt'>duration_cast&lt;duration&gt;(d).count()</span>.
</p></div></div></div><div id='time.duration.observer'><h4 ><a class='secnum' href='#time.duration.observer' style='min-width:118pt'>20.12.5.2</a> <span class='texttt'>duration</span> observer <a class='abbr_ref' href='time.duration.observer'>[time.duration.observer]</a></h4><p ><span class='indexparent'><a class='index' id='count,duration'></a></span><span class='indexparent'><a class='index' id='duration,count'></a></span><code class='itemdecl'>
constexpr rep count() const;
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.observer-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.observer-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rep_</span>.
</p></div></div></div><div id='time.duration.arithmetic'><h4 ><a class='secnum' href='#time.duration.arithmetic' style='min-width:118pt'>20.12.5.3</a> <span class='texttt'>duration</span> arithmetic <a class='abbr_ref' href='time.duration.arithmetic'>[time.duration.arithmetic]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator+'></a></span><code class='itemdecl'>
constexpr duration operator+() const;
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator-'></a></span><code class='itemdecl'>
constexpr duration operator-() const;
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(-rep_);</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator++'></a></span><code class='itemdecl'>
duration&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>++rep_</span>.</p></div></div><div class='para' id='time.duration.arithmetic-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator++'></a></span><code class='itemdecl'>
duration operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(rep_++);</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator--'></a></span><code class='itemdecl'>
duration&amp; operator--();
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-6'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>--rep_</span>.</p></div></div><div class='para' id='time.duration.arithmetic-7'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator--'></a></span><code class='itemdecl'>
duration operator--(int);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-8'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(rep_--);</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator+='></a></span><code class='itemdecl'>
duration&amp; operator+=(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-9'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ += d.count()</span>.</p></div></div><div class='para' id='time.duration.arithmetic-10'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator-='></a></span><code class='itemdecl'>
duration&amp; operator-=(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-11'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ -= d.count()</span>.</p></div></div><div class='para' id='time.duration.arithmetic-12'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator*='></a></span><code class='itemdecl'>
duration&amp; operator*=(const rep&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-13'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ *= rhs</span>.</p></div></div><div class='para' id='time.duration.arithmetic-14'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator/='></a></span><code class='itemdecl'>
duration&amp; operator/=(const rep&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-15'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ /= rhs</span>.</p></div></div><div class='para' id='time.duration.arithmetic-16'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator%=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator%='></a></span><code class='itemdecl'>
duration&amp; operator%=(const rep&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-17'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ %= rhs</span>.</p></div></div><div class='para' id='time.duration.arithmetic-18'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator%=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator%='></a></span><code class='itemdecl'>
duration&amp; operator%=(const duration&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.arithmetic-19'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>rep_ %= rhs.count()</span>.</p></div></div><div class='para' id='time.duration.arithmetic-20'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.arithmetic-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='time.duration.special'><h4 ><a class='secnum' href='#time.duration.special' style='min-width:118pt'>20.12.5.4</a> <span class='texttt'>duration</span> special values <a class='abbr_ref' href='time.duration.special'>[time.duration.special]</a></h4><p ><span class='indexparent'><a class='index' id='zero,duration'></a></span><span class='indexparent'><a class='index' id='duration,zero'></a></span><code class='itemdecl'>
static constexpr duration zero();
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.special-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.special-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(duration_values&lt;rep&gt;::zero())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='min,duration'></a></span><span class='indexparent'><a class='index' id='duration,min'></a></span><code class='itemdecl'>
static constexpr duration min();
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.special-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.special-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(duration_values&lt;rep&gt;::min())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max,duration'></a></span><span class='indexparent'><a class='index' id='duration,max'></a></span><code class='itemdecl'>
static constexpr duration max();
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.special-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.special-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>duration(duration_values&lt;rep&gt;::max())</span>.
</p></div></div></div><div id='time.duration.nonmember'><h4 ><a class='secnum' href='#time.duration.nonmember' style='min-width:118pt'>20.12.5.5</a> <span class='texttt'>duration</span> non-member arithmetic <a class='abbr_ref' href='time.duration.nonmember'>[time.duration.nonmember]</a></h4><div class='para' id='time.duration.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-1'>1</a></div><p >In the function descriptions that follow, <span class='texttt'>CD</span> represents the return type
of the function. <span class='texttt'>CR(A,B)</span> represents <span class='texttt'>common_type_t&lt;A, B&gt;</span>.</p><p ><span class='indexparent'><a class='index' id='common_type'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p></div><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(lhs).count() + CD(rhs).count()).
</p></div></div><p ><span class='indexparent'><a class='index' id='common_type'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  operator-(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(lhs).count() - CD(rhs).count()).
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator*'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period, class Rep2&gt;
  constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload
resolution unless <span class='texttt'>Rep2</span> is implicitly convertible to <span class='texttt'>CR(Rep1, Rep2)</span>.</p></div></div><div class='para' id='time.duration.nonmember-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(d).count() * s).
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator*'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Rep2, class Period&gt;
  constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-6'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload
resolution unless <span class='texttt'>Rep1</span> is implicitly convertible to <span class='texttt'>CR(Rep1, Rep2)</span>.</p></div></div><div class='para' id='time.duration.nonmember-7'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>d * s</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator/'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period, class Rep2&gt;
  constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-8'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload
resolution unless <span class='texttt'>Rep2</span> is implicitly convertible to <span class='texttt'>CR(Rep1, Rep2)</span>
and <span class='texttt'>Rep2</span> is not an instantiation of <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.duration.nonmember-9'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(d).count() / s).
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator/'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr common_type_t&lt;Rep1, Rep2&gt;
  operator/(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-10'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>CD(lhs).count() / CD(rhs).count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator%,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator%'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period, class Rep2&gt;
  constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-11'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload
resolution unless <span class='texttt'>Rep2</span> is implicitly convertible to <span class='texttt'>CR(Rep1, Rep2)</span> and
<span class='texttt'>Rep2</span> is not an instantiation of <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.duration.nonmember-12'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(d).count() % s).
</p></div></div><p ><span class='indexparent'><a class='index' id='operator%,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator%'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;
  operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.nonmember-13'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.nonmember-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> CD(CD(lhs).count() % CD(rhs).count()).
</p></div></div></div><div id='time.duration.comparisons'><h4 ><a class='secnum' href='#time.duration.comparisons' style='min-width:118pt'>20.12.5.6</a> <span class='texttt'>duration</span> comparisons <a class='abbr_ref' href='time.duration.comparisons'>[time.duration.comparisons]</a></h4><div class='para' id='time.duration.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-1'>1</a></div><p >In the function descriptions that follow, <span class='texttt'>CT</span> represents
<span class='texttt'>common_type_t&lt;A, B&gt;</span>, where <span class='texttt'>A</span> and <span class='texttt'>B</span> are the types of
the two arguments to the function.</p><p ><span class='indexparent'><a class='index' id='operator==,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator=='></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator==(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p></div><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>CT(lhs).count() == CT(rhs).count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator!='></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator!=(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator<'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&lt;(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>CT(lhs).count() &lt; CT(rhs).count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator<='></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&lt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,idxl'></a></span><span class='indexparent'><a class='index' id='idxl,operator>'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&gt;(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator>='></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  constexpr bool operator&gt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.comparisons-7'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.comparisons-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div></div><div id='time.duration.cast'><h4 ><a class='secnum' href='#time.duration.cast' style='min-width:118pt'>20.12.5.7</a> <span class='texttt'>duration_cast</span> <a class='abbr_ref' href='time.duration.cast'>[time.duration.cast]</a></h4><p ><span class='indexparent'><a class='index' id='duration_cast'></a></span><code class='itemdecl'>
template &lt;class ToDuration, class Rep, class Period&gt;
  constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.cast-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cast-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload
resolution unless <span class='texttt'>ToDuration</span> is an instantiation of <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.duration.cast-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.cast-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> Let <span class='texttt'>CF</span> be <span class='texttt'>ratio_divide&lt;Period, typename
ToDuration::period&gt;</span>, and <span class='texttt'>CR</span> be <span class='texttt'>common_type&lt;</span> <span class='texttt'>typename
ToDuration::rep, Rep, intmax_t&gt;::type.</span>
</p><ul class='itemize'><li id='time.duration.cast-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cast-2.1'>(2.1)</a></div><p >If <span class='texttt'>CF::num == 1</span> and <span class='texttt'>CF::den == 1</span>, returns
</p><pre class='codeblock'>
ToDuration(static_cast&lt;typename ToDuration::rep&gt;(d.count()))
</pre></li><li id='time.duration.cast-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cast-2.2'>(2.2)</a></div><p >otherwise, if <span class='texttt'>CF::num != 1</span> and <span class='texttt'>CF::den == 1</span>, returns
</p><pre class='codeblock'>
ToDuration(static_cast&lt;typename ToDuration::rep&gt;(
  static_cast&lt;CR&gt;(d.count()) * static_cast&lt;CR&gt;(CF::num)))
</pre></li><li id='time.duration.cast-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cast-2.3'>(2.3)</a></div><p >otherwise, if <span class='texttt'>CF::num == 1</span> and <span class='texttt'>CF::den != 1</span>, returns
</p><pre class='codeblock'>
ToDuration(static_cast&lt;typename ToDuration::rep&gt;(
  static_cast&lt;CR&gt;(d.count()) / static_cast&lt;CR&gt;(CF::den)))
</pre></li><li id='time.duration.cast-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#time.duration.cast-2.4'>(2.4)</a></div><p >otherwise, returns
</p><pre class='codeblock'>
ToDuration(static_cast&lt;typename ToDuration::rep&gt;(
  static_cast&lt;CR&gt;(d.count()) * static_cast&lt;CR&gt;(CF::num) / static_cast&lt;CR&gt;(CF::den)))
</pre></li></ul><p ><i>Notes:</i> This function does not use any implicit conversions; all conversions
are done with <span class='texttt'>static_cast</span>. It avoids multiplications and divisions when
it is known at compile time that one or more arguments is 1. Intermediate
computations are carried out in the widest representation and only converted to
the destination representation at the final step.
</p></div></div></div><div id='time.duration.literals'><h4 ><a class='secnum' href='#time.duration.literals' style='min-width:118pt'>20.12.5.8</a> Suffixes for duration literals <a class='abbr_ref' href='time.duration.literals'>[time.duration.literals]</a></h4><div class='para' id='time.duration.literals-1'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-1'>1</a></div><p >This section describes literal suffixes for constructing duration literals. The
suffixes <span class='texttt'>h</span>, <span class='texttt'>min</span>, <span class='texttt'>s</span>, <span class='texttt'>ms</span>, <span class='texttt'>us</span>, <span class='texttt'>ns</span>
denote duration values of the corresponding types <span class='texttt'>hours</span>, <span class='texttt'>minutes</span>,
<span class='texttt'>seconds</span>, <span class='texttt'>milliseconds</span>, <span class='texttt'>microseconds</span>, and <span class='texttt'>nanoseconds</span>
respectively if they are applied to integral literals.</p></div><div class='para' id='time.duration.literals-2'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-2'>2</a></div><p >If any of these suffixes are applied to a floating point literal the result is a
<span class='texttt'>chrono::duration</span> literal with an unspecified floating point representation.</p></div><div class='para' id='time.duration.literals-3'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-3'>3</a></div><p >If any of these suffixes are applied to an integer literal and the resulting
<span class='texttt'>chrono::duration</span> value cannot be represented in the result type because
of overflow, the program is ill-formed.</p></div><div class='para' id='time.duration.literals-4'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-4'>4</a></div><p >[&nbsp;<i>Example:</i>
The following code shows some duration literals.
</p><pre class='codeblock'>
using namespace std::chrono_literals;
auto constexpr aday=24h;
auto constexpr lesson=45min;
auto constexpr halfanhour=0.5h;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><code class='itemdecl'>
constexpr chrono::hours                                 operator "" h(unsigned long long hours);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, ratio&lt;3600,1&gt;&gt; operator "" h(long double hours);
</code></p></div><div class='itemdescr'></div><div class='para' id='time.duration.literals-5'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>hours</span> hours.
</p></div></div><p ><code class='itemdecl'>
constexpr chrono::minutes                             operator "" min(unsigned long long minutes);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, ratio&lt;60,1&gt;&gt; operator "" min(long double minutes);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.literals-6'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>minutes</span> minutes.
</p></div></div><p ><code class='itemdecl'>
constexpr chrono::seconds                operator "" s(unsigned long long sec);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>&gt; operator "" s(long double sec);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.literals-7'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>sec</span> seconds.</p></div></div><div class='para' id='time.duration.literals-8'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
The same suffix <span class='texttt'>s</span> is used for <span class='texttt'>basic_string</span> but there is no
conflict, since duration suffixes apply to numbers and string literal suffixes
apply to character array literals.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
constexpr chrono::milliseconds                  operator "" ms(unsigned long long msec);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, milli&gt; operator "" ms(long double msec);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.literals-9'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>msec</span> milliseconds.
</p></div></div><p ><code class='itemdecl'>
constexpr chrono::microseconds                  operator "" us(unsigned long long usec);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, micro&gt; operator "" us(long double usec);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.literals-10'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>usec</span> microseconds.
</p></div></div><p ><code class='itemdecl'>
constexpr chrono::nanoseconds                  operator "" ns(unsigned long long nsec);
constexpr chrono::duration&lt;<i><span class='texttt'>unspecified</span></i>, nano&gt; operator "" ns(long double nsec);
</code></p><div class='itemdescr'></div><div class='para' id='time.duration.literals-11'><div class='marginalizedparent'><a class='marginalized' href='#time.duration.literals-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
A <span class='texttt'>duration</span> literal representing <span class='texttt'>nsec</span> nanoseconds.
</p></div></div></div></div><div id='time.point'><h3 ><a class='secnum' href='#time.point' style='min-width:103pt'>20.12.6</a> Class template <span class='texttt'>time_point</span> <a class='abbr_ref' href='time.point'>[time.point]</a></h3><pre class='codeblock'>
template &lt;class Clock, class Duration = typename Clock::duration&gt;
class time_point {
public:
  typedef Clock                     clock;
  typedef Duration                  duration;
  typedef typename duration::rep    rep;
  typedef typename duration::period period;
private:
  duration d_;  <span class='comment'>// <i>exposition only</i>
</span>
public:
  <span class='comment'>// <a href='time.point.cons'>[time.point.cons]</a>, construct:
</span>  constexpr time_point();  <span class='comment'>// has value epoch
</span>  constexpr explicit time_point(const duration&amp; d);  <span class='comment'>// same as time_point() + d
</span>  template &lt;class Duration2&gt;
    constexpr time_point(const time_point&lt;clock, Duration2&gt;&amp; t);

  <span class='comment'>// <a href='time.point.observer'>[time.point.observer]</a>, observer:
</span>  constexpr duration time_since_epoch() const;

  <span class='comment'>// <a href='time.point.arithmetic'>[time.point.arithmetic]</a>, arithmetic:
</span>  time_point&amp; operator+=(const duration&amp; d);
  time_point&amp; operator-=(const duration&amp; d);

  <span class='comment'>// <a href='time.point.special'>[time.point.special]</a>, special values:
</span>  static constexpr time_point min();
  static constexpr time_point max();
};
</pre><div class='para' id='time.point-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point-1'>1</a></div><p ><span class='texttt'>Clock</span> shall meet the Clock requirements (<a href='time.clock'>[time.clock]</a>).</p></div><div class='para' id='time.point-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point-2'>2</a></div><p >If <span class='texttt'>Duration</span> is not an instance of <span class='texttt'>duration</span>,
the program is ill-formed.</p></div><div id='time.point.cons'><h4 ><a class='secnum' href='#time.point.cons' style='min-width:118pt'>20.12.6.1</a> <span class='texttt'>time_point</span> constructors <a class='abbr_ref' href='time.point.cons'>[time.point.cons]</a></h4><p ><span class='indexparent'><a class='index' id='time_point,constructor'></a></span><code class='itemdecl'>
constexpr time_point();
</code></p><div class='itemdescr'></div><div class='para' id='time.point.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>time_point</span>, initializing
<span class='texttt'>d_</span> with <span class='texttt'>duration::zero()</span>. Such a <span class='texttt'>time_point</span> object
represents the epoch.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_point,constructor'></a></span><code class='itemdecl'>
constexpr explicit time_point(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>time_point</span>, initializing
<span class='texttt'>d_</span> with <span class='texttt'>d</span>. Such a <span class='texttt'>time_point</span> object represents the epoch
<span class='texttt'>+ d</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_point,constructor'></a></span><code class='itemdecl'>
template &lt;class Duration2&gt;
  constexpr time_point(const time_point&lt;clock, Duration2&gt;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cons-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless <span class='texttt'>Duration2</span>
is implicitly convertible to <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.point.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>time_point</span>, initializing
<span class='texttt'>d_</span> with <span class='texttt'>t.time_since_epoch()</span>.
</p></div></div></div><div id='time.point.observer'><h4 ><a class='secnum' href='#time.point.observer' style='min-width:118pt'>20.12.6.2</a> <span class='texttt'>time_point</span> observer <a class='abbr_ref' href='time.point.observer'>[time.point.observer]</a></h4><p ><span class='indexparent'><a class='index' id='time_point,time_since_epoch'></a></span><span class='indexparent'><a class='index' id='time_since_epoch,time_point'></a></span><code class='itemdecl'>
constexpr duration time_since_epoch() const;
</code></p><div class='itemdescr'></div><div class='para' id='time.point.observer-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.observer-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>d_</span>.
</p></div></div></div><div id='time.point.arithmetic'><h4 ><a class='secnum' href='#time.point.arithmetic' style='min-width:118pt'>20.12.6.3</a> <span class='texttt'>time_point</span> arithmetic <a class='abbr_ref' href='time.point.arithmetic'>[time.point.arithmetic]</a></h4><p ><span class='indexparent'><a class='index' id='operator+=,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator+='></a></span><code class='itemdecl'>
time_point&amp; operator+=(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.arithmetic-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.arithmetic-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>d_ += d</span>.</p></div></div><div class='para' id='time.point.arithmetic-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.arithmetic-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-=,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator-='></a></span><code class='itemdecl'>
time_point&amp; operator-=(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.arithmetic-3'><div class='marginalizedparent'><a class='marginalized' href='#time.point.arithmetic-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>d_ -= d</span>.</p></div></div><div class='para' id='time.point.arithmetic-4'><div class='marginalizedparent'><a class='marginalized' href='#time.point.arithmetic-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='time.point.special'><h4 ><a class='secnum' href='#time.point.special' style='min-width:118pt'>20.12.6.4</a> <span class='texttt'>time_point</span> special values <a class='abbr_ref' href='time.point.special'>[time.point.special]</a></h4><p ><span class='indexparent'><a class='index' id='min,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,min'></a></span><code class='itemdecl'>
static constexpr time_point min();
</code></p><div class='itemdescr'></div><div class='para' id='time.point.special-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.special-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>time_point(duration::min())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,max'></a></span><code class='itemdecl'>
static constexpr time_point max();
</code></p><div class='itemdescr'></div><div class='para' id='time.point.special-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.special-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>time_point(duration::max())</span>.
</p></div></div></div><div id='time.point.nonmember'><h4 ><a class='secnum' href='#time.point.nonmember' style='min-width:118pt'>20.12.6.5</a> <span class='texttt'>time_point</span> non-member arithmetic <a class='abbr_ref' href='time.point.nonmember'>[time.point.nonmember]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator+'></a></span><span class='indexparent'><a class='index' id='operator+,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator+'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.nonmember-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>CT(lhs.time_since_epoch() + rhs)</span>, where <span class='texttt'>CT</span> is the type of the return value.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator+'></a></span><span class='indexparent'><a class='index' id='operator+,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator+'></a></span><code class='itemdecl'>
template &lt;class Rep1, class Period1, class Clock, class Duration2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;duration&lt;Rep1, Period1&gt;, Duration2&gt;&gt;
  operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs + lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator-'></a></span><span class='indexparent'><a class='index' id='operator-,duration'></a></span><span class='indexparent'><a class='index' id='duration,operator-'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.nonmember-3'><div class='marginalizedparent'><a class='marginalized' href='#time.point.nonmember-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs + (-rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator-'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr common_type_t&lt;Duration1, Duration2&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.nonmember-4'><div class='marginalizedparent'><a class='marginalized' href='#time.point.nonmember-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.time_since_epoch() - rhs.time_since_epoch()</span>.
</p></div></div></div><div id='time.point.comparisons'><h4 ><a class='secnum' href='#time.point.comparisons' style='min-width:118pt'>20.12.6.6</a> <span class='texttt'>time_point</span> comparisons <a class='abbr_ref' href='time.point.comparisons'>[time.point.comparisons]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator=='></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator==(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.time_since_epoch() == rhs.time_since_epoch()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator!='></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator!=(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator<'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator&lt;(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.time_since_epoch() &lt; rhs.time_since_epoch()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator<='></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator&lt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator>'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator&gt;(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,time_point'></a></span><span class='indexparent'><a class='index' id='time_point,operator>='></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration1, class Duration2&gt;
  constexpr bool operator&gt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#time.point.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div></div><div id='time.point.cast'><h4 ><a class='secnum' href='#time.point.cast' style='min-width:118pt'>20.12.6.7</a> <span class='texttt'>time_point_cast</span> <a class='abbr_ref' href='time.point.cast'>[time.point.cast]</a></h4><p ><span class='indexparent'><a class='index' id='time_point_cast'></a></span><code class='itemdecl'>
template &lt;class ToDuration, class Clock, class Duration&gt;
  constexpr time_point&lt;Clock, ToDuration&gt;
  time_point_cast(const time_point&lt;Clock, Duration&gt;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='time.point.cast-1'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cast-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload
resolution unless <span class='texttt'>ToDuration</span> is an
instantiation of <span class='texttt'>duration</span>.</p></div></div><div class='para' id='time.point.cast-2'><div class='marginalizedparent'><a class='marginalized' href='#time.point.cast-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>time_point&lt;Clock, ToDuration&gt;(duration_cast&lt;ToDuration&gt;(t.time_since_epoch()))</span>.
</p></div></div></div></div><div id='time.clock'><h3 ><a class='secnum' href='#time.clock' style='min-width:103pt'>20.12.7</a> Clocks <a class='abbr_ref' href='time.clock'>[time.clock]</a></h3><div class='para' id='time.clock-1'><div class='marginalizedparent'><a class='marginalized' href='#time.clock-1'>1</a></div><p >The types defined in this subclause shall satisfy the
<span class='texttt'>TrivialClock</span>
requirements (<a href='time.clock.req'>[time.clock.req]</a>).</p></div><div id='time.clock.system'><h4 ><a class='secnum' href='#time.clock.system' style='min-width:118pt'>20.12.7.1</a> Class <span class='texttt'>system_clock</span> <a class='abbr_ref' href='time.clock.system'>[time.clock.system]</a></h4><div class='para' id='time.clock.system-1'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.system-1'>1</a></div><p >Objects of class <span class='texttt'>system_clock</span> represent wall clock time from the system-wide
realtime clock.</p><pre class='codeblock'>
class system_clock {
public:
  typedef <i><span class='texttt'>see below</span></i>                           rep;
  typedef ratio&lt;<i><span class='texttt'>unspecified</span></i>, <i><span class='texttt'>unspecified</span></i>&gt;   period;
  typedef chrono::duration&lt;rep, period&gt;       duration;
  typedef chrono::time_point&lt;system_clock&gt;    time_point;
  static constexpr bool is_steady =        <i><span class='texttt'>unspecified</span></i>;

  static time_point now() noexcept;

  <span class='comment'>// Map to C API
</span>  static time_t      to_time_t  (const time_point&amp; t) noexcept;
  static time_point  from_time_t(time_t t) noexcept;
};
</pre><p ><span class='indexparent'><a class='index' id='rep,system_clock'></a></span><span class='indexparent'><a class='index' id='system_clock,rep'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>unspecified</span></i> system_clock::rep;
</code></p></div><div class='itemdescr'></div><div class='para' id='time.clock.system-2'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.system-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>system_clock::duration::min() &lt; system_clock::duration::zero()</span> shall
be <span class='texttt'>true</span>. [&nbsp;<i>Note:</i> This implies that <span class='texttt'>rep</span> is a signed type. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='to_time_t'></a></span><code class='itemdecl'>
static time_t to_time_t(const time_point&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='time.clock.system-3'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.system-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>time_t</span> object that represents the same point in time as <span class='texttt'>t</span>
when both values are restricted to the coarser of the precisions of <span class='texttt'>time_t</span> and
<span class='texttt'>time_point</span>.
It is implementation defined whether values are rounded or truncated to the
required precision.<span class='indexparent'><a class='index' id='whether_values_are_rounded_or_truncated_to_the_required_precision_when_converting_between_time_t_values_and_time_point_objects.'></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='from_time_t'></a></span><code class='itemdecl'>
static time_point from_time_t(time_t t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='time.clock.system-4'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.system-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>time_point</span> object that represents the same point in time as <span class='texttt'>t</span>
when both values are restricted to the coarser of the precisions of <span class='texttt'>time_t</span> and
<span class='texttt'>time_point</span>.
It is implementation defined whether values are rounded or truncated to the
required precision.<span class='indexparent'><a class='index' id='whether_values_are_rounded_or_truncated_to_the_required_precision_when_converting_between_time_t_values_and_time_point_objects.'></a></span>
</p></div></div></div><div id='time.clock.steady'><h4 ><a class='secnum' href='#time.clock.steady' style='min-width:118pt'>20.12.7.2</a> Class <span class='texttt'>steady_clock</span> <a class='abbr_ref' href='time.clock.steady'>[time.clock.steady]</a></h4><div class='para' id='time.clock.steady-1'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.steady-1'>1</a></div><p >Objects of class <span class='texttt'>steady_clock</span> represent clocks for which values of <span class='texttt'>time_point</span>
never decrease as physical time advances and for which values of <span class='texttt'>time_point</span> advance at
a steady rate relative to real time. That is, the clock may not be adjusted.</p><pre class='codeblock'>
class steady_clock {
public:
  typedef <i><span class='texttt'>unspecified</span></i>                               rep;
  typedef ratio&lt;<i><span class='texttt'>unspecified</span></i>, <i><span class='texttt'>unspecified</span></i>&gt;          period;
  typedef chrono::duration&lt;rep, period&gt;              duration;
  typedef chrono::time_point&lt;<i><span class='texttt'>unspecified</span></i>, duration&gt;  time_point;
  static constexpr bool is_steady =               true;

  static time_point now() noexcept;
};
</pre></div></div><div id='time.clock.hires'><h4 ><a class='secnum' href='#time.clock.hires' style='min-width:118pt'>20.12.7.3</a> Class <span class='texttt'>high_resolution_clock</span> <a class='abbr_ref' href='time.clock.hires'>[time.clock.hires]</a></h4><div class='para' id='time.clock.hires-1'><div class='marginalizedparent'><a class='marginalized' href='#time.clock.hires-1'>1</a></div><p >Objects of class <span class='texttt'>high_resolution_clock</span> represent clocks with the
shortest tick period. <span class='texttt'>high_resolution_clock</span> may be a synonym for
<span class='texttt'>system_clock</span> or <span class='texttt'>steady_clock</span>.</p><pre class='codeblock'>
class high_resolution_clock {
public:
  typedef <i><span class='texttt'>unspecified</span></i>                               rep;
  typedef ratio&lt;<i><span class='texttt'>unspecified</span></i>, <i><span class='texttt'>unspecified</span></i>&gt;          period;
  typedef chrono::duration&lt;rep, period&gt;              duration;
  typedef chrono::time_point&lt;<i><span class='texttt'>unspecified</span></i>, duration&gt; time_point;
  static constexpr bool is_steady =               <i><span class='texttt'>unspecified</span></i>;

  static time_point now() noexcept;
};
</pre></div></div></div><div id='date.time'><h3 ><a class='secnum' href='#date.time' style='min-width:103pt'>20.12.8</a> Date and time functions <a class='abbr_ref' href='date.time'>[date.time]</a></h3><div class='para' id='date.time-1'><div class='marginalizedparent'><a class='marginalized' href='#date.time-1'>1</a></div><p >Table <a href='#tab:util.hdr.ctime'>[tab:util.hdr.ctime]</a> describes the header
<span class='texttt'>&lt;ctime&gt;</span>.</p><div class='numberedTable' id='tab:util.hdr.ctime'>Table <a href='#tab:util.hdr.ctime'>60</a> — Header <span class='texttt'>&lt;ctime&gt;</span> synopsis<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='4' class='center'><b>Name(s)</b></td></tr><tr class='capsep'><td class='left'> 


<b>Macros</b>:             </td><td class='left'>
 <span class='texttt'>NULL</span>       </td><td class='left'>
 <span class='texttt'>CLOCKS_PER_SEC</span>     </td><td class='left'>
                    </td><td class='left'>
                    </td></tr><tr class='rowsep'><td class='left'> 
<b>Types</b>:              </td><td class='left'>
 <span class='texttt'>size_t</span>     </td><td class='left'>
 <span class='texttt'>clock_t</span>    </td><td class='left'>
 <span class='texttt'>time_t</span>     </td><td class='left'>
                    </td></tr><tr class='rowsep'><td class='left'> 
<b>Struct</b>:             </td><td class='left'>
 <span class='texttt'>tm</span>         </td><td class='left'>
                    </td><td class='left'>
                    </td><td class='left'>
                    </td></tr><tr class='rowsep'><td colspan='5' class='left'><b>Functions</b>:</td></tr><tr ><td class='left'>
<span class='texttt'>asctime</span>     </td><td class='left'>
 <span class='texttt'>clock</span>      </td><td class='left'>
 <span class='texttt'>difftime</span>   </td><td class='left'>
 <span class='texttt'>localtime</span>  </td><td class='left'>
 <span class='texttt'>strftime</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>ctime</span>       </td><td class='left'>
 <span class='texttt'>gmtime</span>     </td><td class='left'>
 <span class='texttt'>mktime</span>     </td><td class='left'>
 <span class='texttt'>time</span>       </td><td class='left'>
                    </td></tr></table></div></div><div class='para' id='date.time-2'><div class='marginalizedparent'><a class='marginalized' href='#date.time-2'>2</a></div><p >The contents are the same as the Standard C library header
<span class='texttt'>&lt;time.h&gt;.</span><a class='footnotenum' href='#footnote-232'>232</a>
The functions <span class='texttt'>asctime</span>, <span class='texttt'>ctime</span>, <span class='texttt'>gmtime</span>, and
<span class='texttt'>localtime</span> are not required to avoid data
races (<a href='res.on.data.races'>[res.on.data.races]</a>).</p><p ><span class='textsc'>See also:</span>
ISO C Clause 7.12, Amendment 1 Clause 4.6.4.</p></div><div class='footnote' id='footnote-231'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-231'>231)</a></div><p ><span class='texttt'>strftime</span> supports the C conversion specifiers
<span class='texttt'>C</span>, <span class='texttt'>D</span>, <span class='texttt'>e</span>, <span class='texttt'>F</span>, <span class='texttt'>g</span>, <span class='texttt'>G</span>, <span class='texttt'>h</span>,
<span class='texttt'>r</span>, <span class='texttt'>R</span>, <span class='texttt'>t</span>, <span class='texttt'>T</span>, <span class='texttt'>u</span>, <span class='texttt'>V</span>, and
<span class='texttt'>z</span>, and the modifiers <span class='texttt'>E</span> and <span class='texttt'>O</span>.</p></div></div></div><div id='allocator.adaptor'><h2 ><a class='secnum' href='#allocator.adaptor' style='min-width:88pt'>20.13</a> Class template <span class='texttt'>scoped_allocator_adaptor</span> <a class='abbr_ref' href='allocator.adaptor'>[allocator.adaptor]</a></h2><div id='allocator.adaptor.syn'><h3 ><a class='secnum' href='#allocator.adaptor.syn' style='min-width:103pt'>20.13.1</a> Header <span class='texttt'>&lt;scoped_allocator&gt;</span> synopsis <a class='abbr_ref' href='allocator.adaptor.syn'>[allocator.adaptor.syn]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator'></a></span></p><pre class='codeblock'>
  <span class='comment'>// scoped allocator adaptor
</span>  template &lt;class OuterAlloc, class... InnerAlloc&gt;
    class scoped_allocator_adaptor;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</pre><div class='para' id='allocator.adaptor.syn-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.syn-1'>1</a></div><p >The class template <span class='texttt'>scoped_allocator_adaptor</span> is an allocator template that
specifies the memory resource (the outer allocator) to be used by a container (as any
other allocator does) and also specifies an inner allocator resource to be passed to the
constructor of every element within the container. This adaptor is instantiated with one
outer and zero or more inner allocator types. If instantiated with only one allocator
type, the inner allocator becomes the <span class='texttt'>scoped_allocator_adaptor</span> itself, thus
using the same allocator resource for the container and every element within the
container and, if the elements themselves are containers, each of their elements
recursively. If instantiated with more than one allocator, the first allocator is the
outer allocator for use by the container, the second allocator is passed to the
constructors of the container's elements, and, if the elements themselves are
containers, the third allocator is passed to the elements' elements, and so on. If
containers are nested to a depth greater than the number of allocators, the last
allocator is used repeatedly, as in the single-allocator case, for any remaining
recursions. [&nbsp;<i>Note:</i> The <span class='texttt'>scoped_allocator_adaptor</span> is derived from the outer
allocator type so it can be substituted for the outer allocator type in most
expressions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  template &lt;class OuterAlloc, class... InnerAllocs&gt;
    class scoped_allocator_adaptor : public OuterAlloc {
  private:
    typedef allocator_traits&lt;OuterAlloc&gt; OuterTraits; <span class='comment'>// <i>exposition only</i>
</span>    scoped_allocator_adaptor&lt;InnerAllocs...&gt; inner;   <span class='comment'>// <i>exposition only</i>
</span>  public:
    typedef OuterAlloc outer_allocator_type;
    typedef <i><span class='texttt'>see below</span></i> inner_allocator_type;

    typedef typename OuterTraits::value_type value_type;
    typedef typename OuterTraits::size_type size_type;
    typedef typename OuterTraits::difference_type difference_type;
    typedef typename OuterTraits::pointer pointer;
    typedef typename OuterTraits::const_pointer const_pointer;
    typedef typename OuterTraits::void_pointer void_pointer;
    typedef typename OuterTraits::const_void_pointer const_void_pointer;

    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_copy_assignment;
    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_move_assignment;
    typedef <i><span class='texttt'>see below</span></i> propagate_on_container_swap;

    template &lt;class Tp&gt;
      struct rebind {
        typedef scoped_allocator_adaptor&lt;
          OuterTraits::template rebind_alloc&lt;Tp&gt;, InnerAllocs...&gt; other;
      };

    scoped_allocator_adaptor();
    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                               const InnerAllocs&amp;... innerAllocs) noexcept;

    scoped_allocator_adaptor(const scoped_allocator_adaptor&amp; other) noexcept;
    scoped_allocator_adaptor(scoped_allocator_adaptor&amp;&amp; other) noexcept;

    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(
        const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; other) noexcept;
    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(
        scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp;&amp; other) noexcept;

    ~scoped_allocator_adaptor();

    inner_allocator_type&amp; inner_allocator() noexcept;
    const inner_allocator_type&amp; inner_allocator() const noexcept;
    outer_allocator_type&amp; outer_allocator() noexcept;
    const outer_allocator_type&amp; outer_allocator() const noexcept;

    pointer allocate(size_type n);
    pointer allocate(size_type n, const_void_pointer hint);
    void deallocate(pointer p, size_type n);
    size_type max_size() const;

    template &lt;class T, class... Args&gt;
      void construct(T* p, Args&amp;&amp;... args);
    template &lt;class T1, class T2, class... Args1, class... Args2&gt;
      void construct(pair&lt;T1, T2&gt;* p, piecewise_construct_t,
                     tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
    template &lt;class T1, class T2&gt;
      void construct(pair&lt;T1, T2&gt;* p);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, const pair&lt;U, V&gt;&amp; x);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);

    template &lt;class T&gt;
      void destroy(T* p);

    scoped_allocator_adaptor select_on_container_copy_construction() const;
  };

  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
}
</pre></div></div><div id='allocator.adaptor.types'><h3 ><a class='secnum' href='#allocator.adaptor.types' style='min-width:103pt'>20.13.2</a> Scoped allocator adaptor member types <a class='abbr_ref' href='allocator.adaptor.types'>[allocator.adaptor.types]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,inner_allocator_type'></a></span><span class='indexparent'><a class='index' id='inner_allocator_type,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> inner_allocator_type;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.types-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.types-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>scoped_allocator_adaptor&lt;OuterAlloc&gt;</span> if <span class='texttt'>sizeof...(InnerAllocs)</span> is
zero; otherwise,<br/> <span class='texttt'>scoped_allocator_adaptor&lt;InnerAllocs...&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,propagate_on_container_copy_assignment'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_copy_assignment,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_copy_assignment;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.types-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.types-2'>2</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_copy_assignment::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,propagate_on_container_move_assignment'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_move_assignment,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_move_assignment;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.types-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.types-3'>3</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,propagate_on_container_swap'></a></span><span class='indexparent'><a class='index' id='propagate_on_container_swap,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
typedef <i><span class='texttt'>see below</span></i> propagate_on_container_swap;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.types-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.types-4'>4</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_swap::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div></div><div id='allocator.adaptor.cnstr'><h3 ><a class='secnum' href='#allocator.adaptor.cnstr' style='min-width:103pt'>20.13.3</a> Scoped allocator adaptor constructors <a class='abbr_ref' href='allocator.adaptor.cnstr'>[allocator.adaptor.cnstr]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor();
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> value-initializes the <span class='texttt'>OuterAlloc</span> base class and the <span class='texttt'>inner</span> allocator
object.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                           const InnerAllocs&amp;... innerAllocs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='allocator.adaptor.cnstr-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> initializes the <span class='texttt'>OuterAlloc</span> base class with
<span class='texttt'>std::forward&lt;OuterA2&gt;(outerAlloc)</span> and <span class='texttt'>inner</span> with <span class='texttt'>innerAllocs...</span>
(hence recursively initializing each allocator within the adaptor with the corresponding
allocator from the argument list).
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor(const scoped_allocator_adaptor&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> initializes each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor(scoped_allocator_adaptor&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> move constructs each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(const scoped_allocator_adaptor&lt;OuterA2,
                                                          InnerAllocs...&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='allocator.adaptor.cnstr-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> initializes each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(scoped_allocator_adaptor&lt;OuterA2,
                                                    InnerAllocs...&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.cnstr-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='allocator.adaptor.cnstr-9'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.cnstr-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> initializes each allocator within the adaptor with the corresponding allocator rvalue
from <span class='texttt'>other</span>.
</p></div></div></div><div id='allocator.adaptor.members'><h3 ><a class='secnum' href='#allocator.adaptor.members' style='min-width:103pt'>20.13.4</a> Scoped allocator adaptor members <a class='abbr_ref' href='allocator.adaptor.members'>[allocator.adaptor.members]</a></h3><div class='para' id='allocator.adaptor.members-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-1'>1</a></div><p >In the <span class='texttt'>construct</span> member functions,
<i>OUTERMOST(x)</i> is <span class='texttt'>x</span> if <span class='texttt'>x</span> does not have an
<span class='texttt'>outer_allocator()</span> member function and <br/>
<i>OUTERMOST(x.outer_allocator())</i>
otherwise;
<i>OUTERMOST_ALLOC_TRAITS(x)</i> is <br/>
<span class='texttt'>allocator_traits&lt;decltype(<i>OUTERMOST</i>(x))&gt;</span>.
[&nbsp;<i>Note:</i> <i>OUTERMOST</i>(x) and <br/>
<i>OUTERMOST_ALLOC_TRAITS</i>(x) are recursive operations. It
is incumbent upon the definition of <span class='texttt'>outer_allocator()</span> to ensure that the
recursion terminates. It will terminate for all instantiations of <br/>
<span class='texttt'>scoped_allocator_adaptor</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,inner_allocator'></a></span><span class='indexparent'><a class='index' id='inner_allocator,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
inner_allocator_type&amp; inner_allocator() noexcept;
const inner_allocator_type&amp; inner_allocator() const noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span> if <span class='texttt'>sizeof...(InnerAllocs)</span> is zero; otherwise,
<span class='texttt'>inner</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,outer_allocator'></a></span><span class='indexparent'><a class='index' id='outer_allocator,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
outer_allocator_type&amp; outer_allocator() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;OuterAlloc&amp;&gt;(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,outer_allocator'></a></span><span class='indexparent'><a class='index' id='outer_allocator,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
const outer_allocator_type&amp; outer_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;const OuterAlloc&amp;&gt;(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,allocate'></a></span><span class='indexparent'><a class='index' id='allocate,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
pointer allocate(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,allocate'></a></span><span class='indexparent'><a class='index' id='allocate,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
pointer allocate(size_type n, const_void_pointer hint);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n, hint)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,deallocate'></a></span><span class='indexparent'><a class='index' id='deallocate,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
void deallocate(pointer p, size_type n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::deallocate(outer_allocator(), p, n)</span>;
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,max_size'></a></span><span class='indexparent'><a class='index' id='max_size,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
size_type max_size() const;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::max_size(outer_allocator())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-9'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul class='itemize'><li id='allocator.adaptor.members-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-9.1'>(9.1)</a></div><p >If <span class='texttt'>uses_allocator&lt;T, inner_allocator_type&gt;::value</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible&lt;T, Args...&gt;::value</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(<span class='texttt'>*this</span>)<span class='texttt'>::construct(<br/>
<i>OUTERMOST</i>(*this), p, std::forward&lt;Args&gt;(args)...)</span>.</p></li><li id='allocator.adaptor.members-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-9.2'>(9.2)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T, inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T, allocator_arg_t, inner_allocator_type, Args...&gt;::value</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(<span class='texttt'>*this</span>)<span class='texttt'>::construct(<i>OUTERMOST</i>(*this),
p, allocator_arg,<br/>inner_allocator(), std::forward&lt;Args&gt;(args)...)</span>.</p></li><li id='allocator.adaptor.members-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-9.3'>(9.3)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T, inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T, Args..., inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(*this)::
<span class='texttt'>construct(<i>OUTERMOST</i>(*this), p, std::forward&lt;Args&gt;(args)...,<br/>inner_allocator())</span>.</p></li><li id='allocator.adaptor.members-9.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-9.4'>(9.4)</a></div><p >Otherwise, the program is ill-formed. [&nbsp;<i>Note:</i> An error will result if
<span class='texttt'>uses_allocator</span> evaluates to true but the specific constructor does not take an
allocator. This definition prevents a silent failure to pass an inner allocator to a
contained element. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class... Args1, class... Args2&gt;
  void construct(pair&lt;T1, T2&gt;* p,piecewise_construct_t,
                 tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-10'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> all of the types in <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span> shall be
<span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>).</p></div></div><div class='para' id='allocator.adaptor.members-11'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>tuple</span> object <span class='texttt'>xprime</span> from <span class='texttt'>x</span> by the
following rules:</p><ul class='itemize'><li id='allocator.adaptor.members-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.1'>(11.1)</a></div><p >If <span class='texttt'>uses_allocator&lt;T1, inner_allocator_type&gt;::value</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible&lt;T1,
Args1...&gt;::value</span> is <span class='texttt'>true</span>, then <span class='texttt'>xprime</span> is <span class='texttt'>x</span>.</p></li><li id='allocator.adaptor.members-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.2'>(11.2)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T1, inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span>
and
<span class='texttt'>is_constructible&lt;T1, allocator_arg_t, inner_allocator_type, Args1...&gt;::value</span>
is
<span class='texttt'>true</span>, then <span class='texttt'>xprime</span> is
<span class='texttt'>tuple_cat(tuple&lt;allocator_arg_t, inner_allocator_type&amp;&gt;(
allocator_arg, inner_allocator()), std::move(x))</span>.</p></li><li id='allocator.adaptor.members-11.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.3'>(11.3)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T1, inner_allocator_type&gt;::value</span> is
<span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T1, Args1..., inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span>,
then <span class='texttt'>xprime</span> is
<span class='texttt'>tuple_cat(std::move(x), tuple&lt;inner_allocator_type&amp;&gt;(inner_allocator()))</span>.</p></li><li id='allocator.adaptor.members-11.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.4'>(11.4)</a></div><p >Otherwise, the program is ill-formed.
</p></li></ul><p >and constructs a <span class='texttt'>tuple</span> object <span class='texttt'>yprime</span> from <span class='texttt'>y</span> by the following rules:</p><ul class='itemize'><li id='allocator.adaptor.members-11.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.5'>(11.5)</a></div><p >If <span class='texttt'>uses_allocator&lt;T2, inner_allocator_type&gt;::value</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible&lt;T2,
Args2...&gt;::value</span> is <span class='texttt'>true</span>, then <span class='texttt'>yprime</span> is <span class='texttt'>y</span>.</p></li><li id='allocator.adaptor.members-11.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.6'>(11.6)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T2, inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span>
and
<span class='texttt'>is_constructible&lt;T2, allocator_arg_t, inner_allocator_type, Args2...&gt;::value</span>
is
<span class='texttt'>true</span>, then <span class='texttt'>yprime</span> is
<span class='texttt'>tuple_cat(tuple&lt;allocator_arg_t, inner_allocator_type&amp;&gt;(
allocator_arg, inner_allocator()), std::move(y))</span>.</p></li><li id='allocator.adaptor.members-11.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.7'>(11.7)</a></div><p >Otherwise, if <span class='texttt'>uses_allocator&lt;T2, inner_allocator_type&gt;::value</span> is
<span class='texttt'>true</span> and
<span class='texttt'>is_constructible&lt;T2, Args2..., inner_allocator_type&gt;::value</span> is <span class='texttt'>true</span>,
then <span class='texttt'>yprime</span> is
<span class='texttt'>tuple_cat(std::move(y), tuple&lt;inner_allocator_type&amp;&gt;(inner_allocator()))</span>.</p></li><li id='allocator.adaptor.members-11.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.adaptor.members-11.8'>(11.8)</a></div><p >Otherwise, the program is ill-formed.
</p></li></ul><p >then calls <span class='texttt'><i>OUTERMOST_ALLOC_TRAITS</i>(*this)::construct(<i>OUTERMOST</i>(*this), p,<br/>
piecewise_construct, std::move(xprime), std::move(yprime))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  void construct(pair&lt;T1, T2&gt;* p);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-12'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>this-&gt;construct(p, piecewise_construct, tuple&lt;&gt;(), tuple&lt;&gt;())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-13'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>this-&gt;construct(p, piecewise_construct, forward_as_tuple(std::forward&lt;U&gt;(x)), forward_as_tuple(std::forward&lt;V&gt;(y)))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, const pair&lt;U, V&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-14'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>this-&gt;construct(p, piecewise_construct, forward_as_tuple(x.first), forward_as_tuple(x.second))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,construct'></a></span><span class='indexparent'><a class='index' id='construct,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-15'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>this-&gt;construct(p, piecewise_construct, forward_as_tuple(std::forward&lt;U&gt;(x.first)), forward_as_tuple(std::forward&lt;V&gt;(x.second)))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,destructor'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  void destroy(T* p);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-16'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'><i>OUTERMOST_ALLOC_TRAITS</i>(*this)::destroy(<i>OUTERMOST</i>(*this), p)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,select_on_container_copy_construction'></a></span><span class='indexparent'><a class='index' id='select_on_container_copy_construction,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor select_on_container_copy_construction() const;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.adaptor.members-17'><div class='marginalizedparent'><a class='marginalized' href='#allocator.adaptor.members-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> A new scoped_allocator_adaptor object where each allocator <span class='texttt'>A</span> in the
adaptor is initialized from the result of calling
<span class='texttt'>allocator_traits&lt;A&gt;::select_on_container_copy_construction()</span> on the
corresponding allocator in <span class='texttt'>*this</span>.
</p></div></div></div><div id='scoped.adaptor.operators'><h3 ><a class='secnum' href='#scoped.adaptor.operators' style='min-width:103pt'>20.13.5</a> Scoped allocator operators <a class='abbr_ref' href='scoped.adaptor.operators'>[scoped.adaptor.operators]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='scoped.adaptor.operators-1'><div class='marginalizedparent'><a class='marginalized' href='#scoped.adaptor.operators-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.outer_allocator() == b.outer_allocator()</span> if
<span class='texttt'>sizeof...(InnerAllocs)</span> is zero;
otherwise, <span class='texttt'>a.outer_allocator() == b.outer_allocator()</span>
<span class='texttt'>&amp;&amp;</span> <span class='texttt'>a.inner_allocator() == b.inner_allocator()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,scoped_allocator_adaptor'></a></span><code class='itemdecl'>
template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='scoped.adaptor.operators-2'><div class='marginalizedparent'><a class='marginalized' href='#scoped.adaptor.operators-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div><div id='type.index'><h2 ><a class='secnum' href='#type.index' style='min-width:88pt'>20.14</a> Class <span class='texttt'>type_index</span> <a class='abbr_ref' href='type.index'>[type.index]</a></h2><p ><span class='indexparent'><a class='index' id='typeinfo'></a></span></p><div id='type.index.synopsis'><h3 ><a class='secnum' href='#type.index.synopsis' style='min-width:103pt'>20.14.1</a> Header <span class='texttt'>&lt;typeindex&gt;</span> synopsis <a class='abbr_ref' href='type.index.synopsis'>[type.index.synopsis]</a></h3><pre class='codeblock'>
namespace std {
  class type_index;
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;type_index&gt;;
}
</pre></div><div id='type.index.overview'><h3 ><a class='secnum' href='#type.index.overview' style='min-width:103pt'>20.14.2</a> <span class='texttt'>type_index</span> overview <a class='abbr_ref' href='type.index.overview'>[type.index.overview]</a></h3><pre class='codeblock'>
namespace std {
  class type_index {
  public:
    type_index(const type_info&amp; rhs) noexcept;
    bool operator==(const type_index&amp; rhs) const noexcept;
    bool operator!=(const type_index&amp; rhs) const noexcept;
    bool operator&lt; (const type_index&amp; rhs) const noexcept;
    bool operator&lt;= (const type_index&amp; rhs) const noexcept;
    bool operator&gt; (const type_index&amp; rhs) const noexcept;
    bool operator&gt;= (const type_index&amp; rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;
  private:
    const type_info* target;    <span class='comment'>// <i>exposition only</i>
</span>    <span class='comment'>// Note that the use of a pointer here, rather than a reference,
</span>    <span class='comment'>// means that the default copy/move constructor and assignment
</span>    <span class='comment'>// operators will be provided and work as expected.
</span>  };
}
</pre><div class='para' id='type.index.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#type.index.overview-1'>1</a></div><p >The class <span class='texttt'>type_index</span> provides a simple wrapper for
<span class='texttt'>type_info</span> which can be used as an index type in associative
containers (<a href='associative'>[associative]</a>) and in unordered associative
containers (<a href='unord'>[unord]</a>).</p></div></div><div id='type.index.members'><h3 ><a class='secnum' href='#type.index.members' style='min-width:103pt'>20.14.3</a> <span class='texttt'>type_index</span> members <a class='abbr_ref' href='type.index.members'>[type.index.members]</a></h3><p ><span class='indexparent'><a class='index' id='type_index,constructor'></a></span><code class='itemdecl'>
type_index(const type_info&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-1'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>type_index</span> object, the equivalent of <span class='texttt'>target = &amp;rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator=='></a></span><code class='itemdecl'>
bool operator==(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-2'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*target == *rhs.target</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator!='></a></span><code class='itemdecl'>
bool operator!=(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-3'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*target != *rhs.target</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator<'></a></span><code class='itemdecl'>
bool operator&lt;(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-4'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target-&gt;before(*rhs.target)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator<='></a></span><code class='itemdecl'>
bool operator&lt;=(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-5'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!rhs.target-&gt;before(*target)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator>'></a></span><code class='itemdecl'>
bool operator&gt;(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-6'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.target-&gt;before(*target)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,operator>='></a></span><code class='itemdecl'>
bool operator&gt;=(const type_index&amp; rhs) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-7'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!target-&gt;before(*rhs.target)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='hash_code,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,hash_code'></a></span><code class='itemdecl'>
size_t hash_code() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-8'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target-&gt;hash_code()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='name,type_index'></a></span><span class='indexparent'><a class='index' id='type_index,name'></a></span><code class='itemdecl'>
const char* name() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.members-9'><div class='marginalizedparent'><a class='marginalized' href='#type.index.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target-&gt;name()</span>
</p></div></div></div><div id='type.index.hash'><h3 ><a class='secnum' href='#type.index.hash' style='min-width:103pt'>20.14.4</a> Hash support <a class='abbr_ref' href='type.index.hash'>[type.index.hash]</a></h3><p ><span class='indexparent'><a class='index' id='hash'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;type_index&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='type.index.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#type.index.hash-1'>1</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>). For an object <span class='texttt'>index</span> of type <span class='texttt'>type_index</span>,
<span class='texttt'>hash&lt;type_index&gt;()(index)</span> shall evaluate to the same result as <span class='texttt'>index.hash_code()</span>.
</p></div></div></div></div></div></div></body></html>