<!DOCTYPE html><html lang='en'><head><title>[complex.numbers]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Numerics library <a class='abbr_ref' href='./#numerics'>[numerics]</a></h1><div id='complex.numbers'><h2 ><a class='secnum' style='min-width:88pt'>26.4</a> Complex numbers <a class='abbr_ref'>[complex.numbers]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The header
<span class='indexparent'><a class='index' id='complex'></a></span><span class='texttt'>&lt;complex&gt;</span>
defines a
class template,
and numerous functions for representing and manipulating complex numbers.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The effect of instantiating the template
<span class='texttt'>complex</span>
for any type other than <span class='texttt'>float</span>, <span class='texttt'>double</span>, or <span class='texttt'>long double</span> is unspecified.
The specializations
<span class='texttt'>complex&lt;float&gt;</span>,
<span class='texttt'>complex&lt;double&gt;</span>, and
<span class='texttt'>complex&lt;long double&gt;</span> are literal types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the result of a function is not mathematically defined or not in
the range of representable values for its type, the behavior is
undefined.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If <span class='texttt'>z</span> is an lvalue expression of type <span class='emph'>cv</span> <span class='texttt'>std::complex&lt;T&gt;</span> then:</p><ul ><li ><p >the expression <span class='texttt'>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</span> shall be well-formed,
</p></li><li ><p ><span class='texttt'>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</span> shall designate the real part of <span class='texttt'>z</span>, and
</p></li><li ><p ><span class='texttt'>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</span> shall designate the imaginary part of <span class='texttt'>z</span>.
</p></li></ul><p >Moreover, if <span class='texttt'>a</span> is an expression of type <span class='texttt'>cv std::complex&lt;T&gt;*</span> and the expression <span class='texttt'>a[i]</span> is well-defined for an integer expression <span class='texttt'>i</span>, then:</p><ul ><li ><p ><span class='texttt'>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</span> shall designate the real part of <span class='texttt'>a[i]</span>, and
</p></li><li ><p ><span class='texttt'>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</span> shall designate the imaginary part of <span class='texttt'>a[i]</span>.
</p></li></ul></div><div id='complex.syn'><h3 ><a class='secnum' href='#complex.syn' style='min-width:103pt'>26.4.1</a> Header <span class='texttt'>&lt;complex&gt;</span> synopsis <a class='abbr_ref' href='complex.syn'>[complex.syn]</a></h3><p ><span class='indexparent'><a class='index' id='complex'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class complex;
  template&lt;&gt; class complex&lt;float&gt;;
  template&lt;&gt; class complex&lt;double&gt;;
  template&lt;&gt; class complex&lt;long double&gt;;

  <span class='comment'>// <a href='complex.ops'>[complex.ops]</a>, operators:
</span>  template&lt;class T&gt;
    complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator+(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; operator-(
    const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator-(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; operator*(
    const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator*(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; operator/(
    const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator/(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator/(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; constexpr bool operator==(
    const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; constexpr bool operator==(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; constexpr bool operator==(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; constexpr bool operator!=(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T, class charT, class traits&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;, complex&lt;T&gt;&amp;);

  template&lt;class T, class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;, const complex&lt;T&gt;&amp;);

  <span class='comment'>// <a href='complex.value.ops'>[complex.value.ops]</a>, values:
</span>  template&lt;class T&gt; constexpr T real(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; constexpr T imag(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; T arg(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; T norm(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; conj(const complex&lt;T&gt;&amp;);
  template &lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp; = 0);

  <span class='comment'>// <a href='complex.transcendentals'>[complex.transcendentals]</a>, transcendentals:
</span>  template&lt;class T&gt; complex&lt;T&gt; acos(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; asin(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; atan(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; acosh(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; asinh(const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; atanh(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; cos  (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; cosh (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; exp  (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; log  (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; log10(const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; pow(const complex&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; complex&lt;T&gt; pow(const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; pow(const T&amp;, const complex&lt;T&gt;&amp;);

  template&lt;class T&gt; complex&lt;T&gt; sin  (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; sinh (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; sqrt (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; tan  (const complex&lt;T&gt;&amp;);
  template&lt;class T&gt; complex&lt;T&gt; tanh (const complex&lt;T&gt;&amp;);

  <span class='comment'>// <a href='complex.literals'>[complex.literals]</a>, complex literals:
</span>  inline namespace literals {
    inline namespace complex_literals {
      constexpr complex&lt;long double&gt; operator""il(long double);
      constexpr complex&lt;long double&gt; operator""il(unsigned long long);
      constexpr complex&lt;double&gt; operator""i(long double);
      constexpr complex&lt;double&gt; operator""i(unsigned long long);
      constexpr complex&lt;float&gt; operator""if(long double);
      constexpr complex&lt;float&gt; operator""if(unsigned long long);
    }
  }
}
</pre></div><div id='complex'><h3 ><a class='secnum' href='#complex' style='min-width:103pt'>26.4.2</a> Class template <span class='texttt'>complex</span> <a class='abbr_ref' href='complex'>[complex]</a></h3><p ><span class='indexparent'><a class='index' id='complex'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt;
  class complex {
  public:
    typedef T value_type;

    constexpr complex(const T&amp; re = T(), const T&amp; im = T());
    constexpr complex(const complex&amp;);
    template&lt;class X&gt; constexpr complex(const complex&lt;X&gt;&amp;);

    constexpr T real() const;
    void real(T);
    constexpr T imag() const;
    void imag(T);

    complex&lt;T&gt;&amp; operator= (const T&amp;);
    complex&lt;T&gt;&amp; operator+=(const T&amp;);
    complex&lt;T&gt;&amp; operator-=(const T&amp;);
    complex&lt;T&gt;&amp; operator*=(const T&amp;);
    complex&lt;T&gt;&amp; operator/=(const T&amp;);

    complex&amp; operator=(const complex&amp;);
    template&lt;class X&gt; complex&lt;T&gt;&amp; operator= (const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;T&gt;&amp; operator+=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;T&gt;&amp; operator-=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;T&gt;&amp; operator*=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;T&gt;&amp; operator/=(const complex&lt;X&gt;&amp;);
  };
}
</pre><div class='para' id='complex-1'><div class='marginalizedparent'><a class='marginalized' href='#complex-1'>1</a></div><p >The class
<span class='texttt'>complex</span>
describes an object that can
store the Cartesian components,
<span class='texttt'>real()</span>
and
<span class='texttt'>imag()</span>,
of a complex
number.</p></div></div><div id='complex.special'><h3 ><a class='secnum' href='#complex.special' style='min-width:103pt'>26.4.3</a> <span class='texttt'>complex</span> specializations <a class='abbr_ref' href='complex.special'>[complex.special]</a></h3><pre class='codeblock'>
namespace std {
  template&lt;&gt; class complex&lt;float&gt; {
  public:
    typedef float value_type;

    constexpr complex(float re = 0.0f, float im = 0.0f);
    constexpr explicit complex(const complex&lt;double&gt;&amp;);
    constexpr explicit complex(const complex&lt;long double&gt;&amp;);

    constexpr float real() const;
    void real(float);
    constexpr float imag() const;
    void imag(float);

    complex&lt;float&gt;&amp; operator= (float);
    complex&lt;float&gt;&amp; operator+=(float);
    complex&lt;float&gt;&amp; operator-=(float);
    complex&lt;float&gt;&amp; operator*=(float);
    complex&lt;float&gt;&amp; operator/=(float);

    complex&lt;float&gt;&amp; operator=(const complex&lt;float&gt;&amp;);
    template&lt;class X&gt; complex&lt;float&gt;&amp; operator= (const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;float&gt;&amp; operator+=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;float&gt;&amp; operator-=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;float&gt;&amp; operator*=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;float&gt;&amp; operator/=(const complex&lt;X&gt;&amp;);
  };

  template&lt;&gt; class complex&lt;double&gt; {
  public:
    typedef double value_type;

    constexpr complex(double re = 0.0, double im = 0.0);
    constexpr complex(const complex&lt;float&gt;&amp;);
    constexpr explicit complex(const complex&lt;long double&gt;&amp;);

    constexpr double real() const;
    void real(double);
    constexpr double imag() const;
    void imag(double);

    complex&lt;double&gt;&amp; operator= (double);
    complex&lt;double&gt;&amp; operator+=(double);
    complex&lt;double&gt;&amp; operator-=(double);
    complex&lt;double&gt;&amp; operator*=(double);
    complex&lt;double&gt;&amp; operator/=(double);

    complex&lt;double&gt;&amp; operator=(const complex&lt;double&gt;&amp;);
    template&lt;class X&gt; complex&lt;double&gt;&amp; operator= (const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;double&gt;&amp; operator+=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;double&gt;&amp; operator-=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;double&gt;&amp; operator*=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;double&gt;&amp; operator/=(const complex&lt;X&gt;&amp;);
  };

  template&lt;&gt; class complex&lt;long double&gt; {
  public:
    typedef long double value_type;

    constexpr complex(long double re = 0.0L, long double im = 0.0L);
    constexpr complex(const complex&lt;float&gt;&amp;);
    constexpr complex(const complex&lt;double&gt;&amp;);

    constexpr long double real() const;
    void real(long double);
    constexpr long double imag() const;
    void imag(long double);

    complex&lt;long double&gt;&amp; operator=(const complex&lt;long double&gt;&amp;);
    complex&lt;long double&gt;&amp; operator= (long double);
    complex&lt;long double&gt;&amp; operator+=(long double);
    complex&lt;long double&gt;&amp; operator-=(long double);
    complex&lt;long double&gt;&amp; operator*=(long double);
    complex&lt;long double&gt;&amp; operator/=(long double);

    template&lt;class X&gt; complex&lt;long double&gt;&amp; operator= (const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;long double&gt;&amp; operator+=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;long double&gt;&amp; operator-=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;long double&gt;&amp; operator*=(const complex&lt;X&gt;&amp;);
    template&lt;class X&gt; complex&lt;long double&gt;&amp; operator/=(const complex&lt;X&gt;&amp;);
  };
}
</pre></div><div id='complex.members'><h3 ><a class='secnum' href='#complex.members' style='min-width:103pt'>26.4.4</a> <span class='texttt'>complex</span> member functions <a class='abbr_ref' href='complex.members'>[complex.members]</a></h3><p ><span class='indexparent'><a class='index' id='complex,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; constexpr complex(const T&amp; re = T(), const T&amp; im = T());
</code></p><div class='itemdescr'></div><div class='para' id='complex.members-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>complex</span>.</p></div></div><div class='para' id='complex.members-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.members-2'>2</a></div><div class='itemdescr'><p ><i>Postcondition:</i>
<span class='texttt'>real() == re &amp;&amp; imag() == im</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='real,complex'></a></span><span class='indexparent'><a class='index' id='complex,real'></a></span><code class='itemdecl'>
constexpr T real() const;
</code></p><div class='itemdescr'><p ><i>Returns:</i> The value of the real component.
</p></div><p ><span class='indexparent'><a class='index' id='real,complex'></a></span><span class='indexparent'><a class='index' id='complex,real'></a></span><code class='itemdecl'>
void real(T val);
</code></p><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>val</span> to the real component.
</p></div><p ><span class='indexparent'><a class='index' id='imag,complex'></a></span><span class='indexparent'><a class='index' id='complex,imag'></a></span><code class='itemdecl'>
constexpr T imag() const;
</code></p><div class='itemdescr'><p ><i>Returns:</i> The value of the imaginary component.
</p></div><p ><span class='indexparent'><a class='index' id='imag,complex'></a></span><span class='indexparent'><a class='index' id='complex,imag'></a></span><code class='itemdecl'>
void imag(T val);
</code></p><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>val</span> to the imaginary component.
</p></div></div><div id='complex.member.ops'><h3 ><a class='secnum' href='#complex.member.ops' style='min-width:103pt'>26.4.5</a> <span class='texttt'>complex</span> member operators <a class='abbr_ref' href='complex.member.ops'>[complex.member.ops]</a></h3><p ><span class='indexparent'><a class='index' id='operator+=,complex'></a></span><code class='itemdecl'>
complex&lt;T&gt;&amp; operator+=(const T&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Adds the scalar value <span class='texttt'>rhs</span> to the real part of the complex value
<span class='texttt'>*this</span>
and stores the result in the real part of
<span class='texttt'>*this</span>,
leaving the imaginary part unchanged.</p></div></div><div class='para' id='complex.member.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-=,complex'></a></span><code class='itemdecl'>
complex&lt;T&gt;&amp; operator-=(const T&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Subtracts the scalar value <span class='texttt'>rhs</span> from the real part of the complex value
<span class='texttt'>*this</span>
and stores the result in the real part of
<span class='texttt'>*this</span>,
leaving the imaginary part unchanged.</p></div></div><div class='para' id='complex.member.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*=,complex'></a></span><code class='itemdecl'>
complex&lt;T&gt;&amp; operator*=(const T&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Multiplies the scalar value <span class='texttt'>rhs</span> by the complex value
<span class='texttt'>*this</span>
and stores the result in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='complex.member.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/=,complex'></a></span><code class='itemdecl'>
complex&lt;T&gt;&amp; operator/=(const T&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Divides the scalar value <span class='texttt'>rhs</span> into the complex value
<span class='texttt'>*this</span>
and stores the result in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='complex.member.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+=,complex'></a></span><code class='itemdecl'>
template&lt;class X&gt; complex&lt;T&gt;&amp; operator+=(const complex&lt;X&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Adds the complex value <span class='texttt'>rhs</span> to the complex value
<span class='texttt'>*this</span>
and stores the sum in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='complex.member.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-=,complex'></a></span><code class='itemdecl'>
template&lt;class X&gt; complex&lt;T&gt;&amp; operator-=(const complex&lt;X&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Subtracts the complex value <span class='texttt'>rhs</span> from the complex value
<span class='texttt'>*this</span>
and stores the difference in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='complex.member.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*=,complex'></a></span><code class='itemdecl'>
template&lt;class X&gt; complex&lt;T&gt;&amp; operator*=(const complex&lt;X&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Multiplies the complex value <span class='texttt'>rhs</span> by the complex value
<span class='texttt'>*this</span>
and stores the product in
<span class='texttt'>*this</span>.</p><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/=,complex'></a></span><code class='itemdecl'>
template&lt;class X&gt; complex&lt;T&gt;&amp; operator/=(const complex&lt;X&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.member.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
Divides the complex value <span class='texttt'>rhs</span> into the complex value
<span class='texttt'>*this</span>
and stores the quotient in
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='complex.member.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#complex.member.ops-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='complex.ops'><h3 ><a class='secnum' href='#complex.ops' style='min-width:103pt'>26.4.6</a> <span class='texttt'>complex</span> non-member operations <a class='abbr_ref' href='complex.ops'>[complex.ops]</a></h3><p ><span class='indexparent'><a class='index' id='operator+,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp; lhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
unary operator.</p></div></div><div class='para' id='complex.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(lhs)</span>.
</p></div></div><pre class='codeblock'>
template&lt;class T&gt;
  complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator+(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</pre><div class='itemdescr'></div><div class='para' id='complex.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(lhs) += rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt;&amp; lhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
unary operator.</p></div></div><div class='para' id='complex.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(-lhs.real(),-lhs.imag())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,complex'></a></span><span class='indexparent'><a class='index' id='complex,operator-'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  complex&lt;T&gt; operator-(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator-(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(lhs) -= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  complex&lt;T&gt; operator*(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator*(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(lhs) *= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator/,complex'></a></span><span class='indexparent'><a class='index' id='complex,operator/'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  complex&lt;T&gt; operator/(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator/(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; complex&lt;T&gt; operator/(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;T&gt;(lhs) /= rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  constexpr bool operator==(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; constexpr bool operator==(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; constexpr bool operator==(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>lhs.real() == rhs.real() &amp;&amp; lhs.imag() == rhs.imag()</span>.</p></div></div><div class='para' id='complex.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The imaginary part is assumed to be
<span class='texttt'>T()</span>,
or 0.0, for the
<span class='texttt'>T</span>
arguments.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  constexpr bool operator!=(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; constexpr bool operator!=(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>rhs.real() != lhs.real() || rhs.imag() != lhs.imag()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>>,complex'></a></span><code class='itemdecl'>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
Extracts a complex number <span class='texttt'>x</span> of the form:
<span class='texttt'>u</span>,
<span class='texttt'>(u)</span>,
or
<span class='texttt'>(u,v)</span>,
where
<span class='texttt'>u</span>
is the real part and
<span class='texttt'>v</span>
is the imaginary part (<a href='istream.formatted'>[istream.formatted]</a>).</p></div></div><div class='para' id='complex.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
The input values shall be convertible to
<span class='texttt'>T</span>.</p><p >If bad input is encountered, calls
<span class='texttt'>is.setstate(ios_base::failbit)</span>
(which may throw
<span class='texttt'>ios::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).</p></div></div><div class='para' id='complex.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>is</span>.</p></div></div><div class='para' id='complex.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-15'>15</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This extraction is performed as a series of simpler
extractions.
Therefore, the skipping of whitespace is specified to be
the same for each of the simpler extractions.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<,complex'></a></span><code class='itemdecl'>
template&lt;class T, class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; o, const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>
inserts the complex number <span class='texttt'>x</span>
onto the stream <span class='texttt'>o</span> as if it were implemented as follows:</p><pre class='codeblock'>
template&lt;class T, class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; o, const complex&lt;T&gt;&amp; x) {
  basic_ostringstream&lt;charT, traits&gt; s;
  s.flags(o.flags());
  s.imbue(o.getloc());
  s.precision(o.precision());
  s &lt;&lt; '(' &lt;&lt; x.real() &lt;&lt; "," &lt;&lt; x.imag() &lt;&lt; ')';
  return o &lt;&lt; s.str();
}
</pre></div></div><div class='para' id='complex.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#complex.ops-17'>17</a></div><div class='itemdescr'><p ><i>Note:</i> In a locale in which comma is used as a decimal point character, the
use of comma as a field separator can be ambiguous. Inserting
<span class='texttt'>std::showpoint</span> into the output stream forces all outputs to
show an explicit decimal point character; as a result, all inserted sequences of
complex numbers can be extracted unambiguously.</p></div></div></div><div id='complex.value.ops'><h3 ><a class='secnum' href='#complex.value.ops' style='min-width:103pt'>26.4.7</a> <span class='texttt'>complex</span> value operations <a class='abbr_ref' href='complex.value.ops'>[complex.value.ops]</a></h3><p ><span class='indexparent'><a class='index' id='real,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; constexpr T real(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.real()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='imag,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; constexpr T imag(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.imag()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='abs,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
The magnitude of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='arg,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; T arg(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
The phase angle of <span class='texttt'>x</span>, or <span class='texttt'>atan2(imag(x), real(x))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='norm,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; T norm(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
The squared magnitude of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='conj,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; conj(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex conjugate of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='proj,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> The projection of <span class='texttt'>x</span> onto the Riemann sphere.</p></div></div><div class='para' id='complex.value.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as the C function <span class='texttt'>cproj</span>, defined in 7.3.9.4.
</p></div></div><p ><span class='indexparent'><a class='index' id='polar,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0);
</code></p><div class='itemdescr'></div><div class='para' id='complex.value.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#complex.value.ops-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
The
<span class='texttt'>complex</span>
value corresponding
to a complex number whose magnitude is <span class='texttt'>rho</span> and whose phase angle
is <span class='texttt'>theta</span>.
</p></div></div></div><div id='complex.transcendentals'><h3 ><a class='secnum' href='#complex.transcendentals' style='min-width:103pt'>26.4.8</a> <span class='texttt'>complex</span> transcendentals <a class='abbr_ref' href='complex.transcendentals'>[complex.transcendentals]</a></h3><p ><span class='indexparent'><a class='index' id='acos,complex'></a></span><span class='indexparent'><a class='index' id='cacos,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; acos(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc cosine of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>cacos</span>,
defined in 7.3.5.1.
</p></div></div><p ><span class='indexparent'><a class='index' id='asin,complex'></a></span><span class='indexparent'><a class='index' id='casin,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; asin(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-3'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc sine of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-4'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>casin</span>,
defined in 7.3.5.2.
</p></div></div><p ><span class='indexparent'><a class='index' id='atan,complex'></a></span><span class='indexparent'><a class='index' id='catan,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; atan(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-5'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc tangent of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-6'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>catan</span>,
defined in 7.3.5.3.
</p></div></div><p ><span class='indexparent'><a class='index' id='acosh,complex'></a></span><span class='indexparent'><a class='index' id='cacosh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; acosh(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-7'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc hyperbolic cosine of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-8'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>cacosh</span>,
defined in 7.3.6.1.
</p></div></div><p ><span class='indexparent'><a class='index' id='asinh,complex'></a></span><span class='indexparent'><a class='index' id='casinh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; asinh(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-9'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc hyperbolic sine of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-10'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>casinh</span>,
defined in 7.3.6.2.
</p></div></div><p ><span class='indexparent'><a class='index' id='atanh,complex'></a></span><span class='indexparent'><a class='index' id='catanh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; atanh(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-11'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> The complex arc hyperbolic tangent of <span class='texttt'>x</span>.</p></div></div><div class='para' id='complex.transcendentals-12'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-12'>12</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Behaves the same as C function <span class='texttt'>catanh</span>,
defined in 7.3.6.3.
</p></div></div><p ><span class='indexparent'><a class='index' id='cos,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; cos(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-13'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex cosine of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='cosh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; cosh(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-14'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex hyperbolic cosine of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='exp,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; exp(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-15'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex base e exponential of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='log,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; log(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-16'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
the branch cuts are along the negative real axis.</p></div></div><div class='para' id='complex.transcendentals-17'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex natural (base e) logarithm of <span class='texttt'>x</span>,
in the range of a strip mathematically unbounded along the
real axis and in the interval <span class='texttt'>[<span class='discretionary'></span>-i times pi,<span class='discretionary'></span>i times pi<span class='discretionary'></span>]</span>
along the imaginary axis.
When <span class='texttt'>x</span> is a negative real
number,
<span class='texttt'>imag(log(x))</span>
is pi.
</p></div></div><p ><span class='indexparent'><a class='index' id='log10,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; log10(const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-18'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-18'>18</a></div><div class='itemdescr'><p ><i>Remarks:</i>
the branch cuts are along the negative real axis.</p></div></div><div class='para' id='complex.transcendentals-19'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-19'>19</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex common (base 10) logarithm of <span class='texttt'>x</span>, defined as
<span class='texttt'>log(x)/log(10)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pow,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  complex&lt;T&gt; pow(const complex&lt;T&gt;&amp; x, const complex&lt;T&gt;&amp; y);
template&lt;class T&gt; complex&lt;T&gt; pow  (const complex&lt;T&gt;&amp; x, const T&amp; y);
template&lt;class T&gt; complex&lt;T&gt; pow  (const T&amp; x, const complex&lt;T&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-20'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-20'>20</a></div><div class='itemdescr'><p ><i>Remarks:</i>
the branch cuts are along the negative real axis.</p></div></div><div class='para' id='complex.transcendentals-21'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex power of base <span class='texttt'>x</span> raised to the <span class='texttt'>y</span>-th power,
defined as
<span class='texttt'>exp(y*log(x))</span>.
The value returned for
<span class='texttt'>pow(0,0)</span>
is implementation-defined.
</p></div></div><p ><span class='indexparent'><a class='index' id='sin,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; sin  (const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-22'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex sine of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sinh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; sinh (const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-23'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex hyperbolic sine of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sqrt,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; sqrt (const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-24'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-24'>24</a></div><div class='itemdescr'><p ><i>Remarks:</i>
the branch cuts are along the negative real axis.</p></div></div><div class='para' id='complex.transcendentals-25'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex square root of <span class='texttt'>x</span>, in the range of the right
half-plane.
If the argument is a negative real number, the
value returned lies on the positive imaginary axis.
</p></div></div><p ><span class='indexparent'><a class='index' id='tan,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; tan  (const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-26'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-26'>26</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex tangent of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tanh,complex'></a></span><code class='itemdecl'>
template&lt;class T&gt; complex&lt;T&gt; tanh (const complex&lt;T&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='complex.transcendentals-27'><div class='marginalizedparent'><a class='marginalized' href='#complex.transcendentals-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i>
The complex hyperbolic tangent of <span class='texttt'>x</span>.
</p></div></div></div><div id='cmplx.over'><h3 ><a class='secnum' href='#cmplx.over' style='min-width:103pt'>26.4.9</a> Additional overloads <a class='abbr_ref' href='cmplx.over'>[cmplx.over]</a></h3><div class='para' id='cmplx.over-1'><div class='marginalizedparent'><a class='marginalized' href='#cmplx.over-1'>1</a></div><p ><span class='indexparent'><a class='index' id='arg'></a></span><span class='indexparent'><a class='index' id='conj'></a></span><span class='indexparent'><a class='index' id='imag'></a></span><span class='indexparent'><a class='index' id='norm'></a></span><span class='indexparent'><a class='index' id='real'></a></span>The following function templates shall have additional overloads:
</p><pre class='codeblock'>
arg                   norm 
conj                  proj
imag                  real 
</pre></div><div class='para' id='cmplx.over-2'><div class='marginalizedparent'><a class='marginalized' href='#cmplx.over-2'>2</a></div><p ><span class='indexparent'><a class='index' id='overloads,floating_point'></a></span>The additional overloads shall be sufficient to ensure:</p><ol ><li ><p >If the argument has type <span class='texttt'>long double</span>, then it is effectively 
              cast to <span class='texttt'>complex&lt;long double&gt;</span>.
        </p></li><li ><p >Otherwise, if the argument has type <span class='texttt'>double</span> or an integer type,
              then it is effectively cast to <span class='texttt'>complex&lt;<span class='discretionary'></span>double&gt;</span>.
        </p></li><li ><p >Otherwise, if the argument has type <span class='texttt'>float</span>, then it is 
              effectively cast to <span class='texttt'>complex&lt;float&gt;</span>.
</p></li></ol></div><div class='para' id='cmplx.over-3'><div class='marginalizedparent'><a class='marginalized' href='#cmplx.over-3'>3</a></div><p ><span class='indexparent'><a class='index' id='pow'></a></span>Function template <span class='texttt'>pow</span> shall have additional overloads sufficient to
ensure, for a call with at least one argument of type <span class='texttt'>complex&lt;T&gt;</span>:</p><ol ><li ><p >If either argument has type <span class='texttt'>complex&lt;long double&gt;</span> or type <span class='texttt'>long
        double</span>, then both arguments are effectively cast to
        <span class='texttt'>complex&lt;long double&gt;</span>.
  </p></li><li ><p >Otherwise, if either argument has type <span class='texttt'>complex&lt;double&gt;</span>, <span class='texttt'>double</span>,
        or an integer type, then both arguments are effectively cast to
        <span class='texttt'>complex&lt;double&gt;</span>.
  </p></li><li ><p >Otherwise, if either argument has type <span class='texttt'>complex&lt;float&gt;</span> or <span class='texttt'>float</span>,
        then both arguments are effectively cast to <span class='texttt'>complex&lt;float&gt;</span>.
</p></li></ol></div></div><div id='complex.literals'><h3 ><a class='secnum' href='#complex.literals' style='min-width:103pt'>26.4.10</a> Suffixes for complex number literals <a class='abbr_ref' href='complex.literals'>[complex.literals]</a></h3><p ><span class='indexparent'><a class='index' id='complex,literals'></a></span><span class='indexparent'><a class='index' id='literals,complex'></a></span></p><div class='para' id='complex.literals-1'><div class='marginalizedparent'><a class='marginalized' href='#complex.literals-1'>1</a></div><p >This section describes literal suffixes for constructing complex number literals.
The suffixes <span class='texttt'>i</span>, <span class='texttt'>il</span>, and <span class='texttt'>if</span> create complex numbers of
the types <span class='texttt'>complex&lt;double&gt;</span>, <span class='texttt'>complex&lt;long double&gt;</span>, and
<span class='texttt'>complex&lt;float&gt;</span> respectively, with their imaginary part denoted by the
given literal number and the real part being zero.</p><p ><code class='itemdecl'>
constexpr complex&lt;long double&gt; operator""il(long double d);
constexpr complex&lt;long double&gt; operator""il(unsigned long long d);
</code></p></div><div class='itemdescr'></div><div class='para' id='complex.literals-2'><div class='marginalizedparent'><a class='marginalized' href='#complex.literals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;long double&gt;{0.0L, static_cast&lt;long double&gt;(d)}</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr complex&lt;double&gt; operator""i(long double d);
constexpr complex&lt;double&gt; operator""i(unsigned long long d);
</code></p><div class='itemdescr'></div><div class='para' id='complex.literals-3'><div class='marginalizedparent'><a class='marginalized' href='#complex.literals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;double&gt;{0.0, static_cast&lt;double&gt;(d)}</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr complex&lt;float&gt; operator""if(long double d);
constexpr complex&lt;float&gt; operator""if(unsigned long long d);
</code></p><div class='itemdescr'></div><div class='para' id='complex.literals-4'><div class='marginalizedparent'><a class='marginalized' href='#complex.literals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>complex&lt;float&gt;{0.0f, static_cast&lt;float&gt;(d)}</span>.
</p></div></div></div><div id='ccmplx'><h3 ><a class='secnum' href='#ccmplx' style='min-width:103pt'>26.4.11</a> Header <span class='texttt'>&lt;ccomplex&gt;</span> <a class='abbr_ref' href='ccmplx'>[ccmplx]</a></h3><div class='para' id='ccmplx-1'><div class='marginalizedparent'><a class='marginalized' href='#ccmplx-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ccomplex'></a></span>The header behaves as if it simply includes the header <span class='texttt'>&lt;complex&gt;</span>.</p></div></div></div></div></body></html>