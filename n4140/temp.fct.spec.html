<!DOCTYPE html><html lang='en'><head><title>[temp.fct.spec]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><div id='temp.fct.spec'><h2 ><a class='secnum' style='min-width:88pt'>14.8</a> Function template specializations <a class='abbr_ref'>[temp.fct.spec]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='template,function'></a></span>A function instantiated from a function template is called a function template
specialization; so is an explicit specialization of a function template.
Template arguments can be explicitly specified when naming the function
template specialization, deduced from the context (e.g.,
deduced from the function arguments in a call to the function template
specialization, see <a href='temp.deduct'>[temp.deduct]</a>), or obtained from default template arguments.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each function template specialization instantiated from a template
has its own copy of any static variable.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; void f(T* p) {
  static T s;
};

void g(int a, char* b) {
  f(&amp;a);            <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int*)</span>
</span>  f(&amp;b);            <span class='comment'>// calls <span class='texttt'>f&lt;char*&gt;(char**)</span>
</span>}
</pre><p >Here
<span class='texttt'>f&lt;int&gt;(int*)</span>
has a static variable
<span class='texttt'>s</span>
of type
<span class='texttt'>int</span>
and
<span class='texttt'>f&lt;char*&gt;(char**)</span>
has a static variable
<span class='texttt'>s</span>
of type
<span class='texttt'>char*</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='temp.arg.explicit'><h3 ><a class='secnum' href='#temp.arg.explicit' style='min-width:103pt'>14.8.1</a> Explicit template argument specification <a class='abbr_ref' href='temp.arg.explicit'>[temp.arg.explicit]</a></h3><div class='para' id='temp.arg.explicit-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specification,template_argument'></a></span>Template arguments can be specified when referring to a function
template specialization by qualifying the function template
name with the list of
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
in the same way as
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
are specified in uses of a class template specialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);
void f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {
  sort&lt;dcomplex&gt;(cv);           <span class='comment'>// <span class='texttt'>sort(Array&lt;dcomplex&gt;&amp;)</span>
</span>  sort&lt;int&gt;(ci);                <span class='comment'>// <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span>}
</pre><p >and</p><pre class='codeblock'>
template&lt;class U, class V&gt; U convert(V v);

void g(double d) {
  int i = convert&lt;int,double&gt;(d);       <span class='comment'>// <span class='texttt'>int convert(double)</span>
</span>  char c = convert&lt;char,double&gt;(d);     <span class='comment'>// <span class='texttt'>char convert(double)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-2'>2</a></div><p >A template argument list may be specified when referring to a specialization
of a function template</p><ul class='itemize'><li id='temp.arg.explicit-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.arg.explicit-2.1'>(2.1)</a></div><p >when a function is called,
</p></li><li id='temp.arg.explicit-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.arg.explicit-2.2'>(2.2)</a></div><p >when the address of a function is taken, when a function initializes a
reference to function, or when a pointer to member function is formed,
</p></li><li id='temp.arg.explicit-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.arg.explicit-2.3'>(2.3)</a></div><p >in an explicit specialization,
</p></li><li id='temp.arg.explicit-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.arg.explicit-2.4'>(2.4)</a></div><p >in an explicit instantiation, or
</p></li><li id='temp.arg.explicit-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.arg.explicit-2.5'>(2.5)</a></div><p >in a friend declaration.
</p></li></ul></div><div class='para' id='temp.arg.explicit-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-3'>3</a></div><p >Trailing template arguments that can be deduced (<a href='temp.deduct'>[temp.deduct]</a>) or
obtained from default
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
may be omitted from the list of explicit
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>.
A trailing template parameter pack (<a href='temp.variadic'>[temp.variadic]</a>) not otherwise deduced will be
deduced to an empty sequence of template arguments.
If all of the template arguments can be deduced, they may all be omitted;
in this case, the empty template argument list
<span class='texttt'>&lt;&gt;</span>
itself may also be omitted.
In contexts where deduction is done and fails, or in contexts where
deduction is not done, if a template argument list is specified and it,
along with any default template arguments, identifies a single function
template specialization, then the
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
is an lvalue for the function template specialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class X, class Y&gt; X f(Y);
template&lt;class X, class Y, class ... Z&gt; X g(Y);
void h() {
  int i = f&lt;int&gt;(5.6);          <span class='comment'>// <span class='texttt'>Y</span> is deduced to be <span class='texttt'>double</span>
</span>  int j = f(5.6);               <span class='comment'>// ill-formed: <span class='texttt'>X</span> cannot be deduced
</span>  f&lt;void&gt;(f&lt;int, bool&gt;);        <span class='comment'>// <span class='texttt'>Y</span> for outer <span class='texttt'>f</span> deduced to be
</span>                                <span class='comment'>// <span class='texttt'>int (*)(bool)</span>
</span>  f&lt;void&gt;(f&lt;int&gt;);              <span class='comment'>// ill-formed: <span class='texttt'>f&lt;int&gt;</span> does not denote a
</span>                                <span class='comment'>// single function template specialization
</span>  int k = g&lt;int&gt;(5.6);          <span class='comment'>// <span class='texttt'>Y</span> is deduced to be double, <span class='texttt'>Z</span> is deduced to an empty sequence
</span>  f&lt;void&gt;(g&lt;int, bool&gt;);        <span class='comment'>// <span class='texttt'>Y</span> for outer <span class='texttt'>f</span> is deduced to be
</span>                                <span class='comment'>// <span class='texttt'>int (*)(bool)</span>, <span class='texttt'>Z</span> is deduced to an empty sequence
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-4'>4</a></div><p >[&nbsp;<i>Note:</i>
An empty template argument list can be used to indicate that a given
use refers to a specialization of a function template even when a
non-template function (<a href='dcl.fct'>[dcl.fct]</a>) is visible that would otherwise be used.
For example:</p><pre class='codeblock'>
template &lt;class T&gt; int f(T);    <span class='comment'>// #1
</span>int f(int);                     <span class='comment'>// #2
</span>int k = f(1);                   <span class='comment'>// uses #2
</span>int l = f&lt;&gt;(1);                 <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-5'>5</a></div><p >Template arguments that are present shall be specified in the declaration
order of their corresponding
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>.
The template argument list shall not specify more
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
than there are corresponding
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
unless one of the <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i> is a template
parameter pack.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class X, class Y, class Z&gt; X f(Y,Z);
template&lt;class ... Args&gt; void f2();
void g() {
  f&lt;int,const char*,double&gt;("aa",3.0);
  f&lt;int,const char*&gt;("aa",3.0);       <span class='comment'>// <span class='texttt'>Z</span> is deduced to be <span class='texttt'>double</span>
</span>  f&lt;int&gt;("aa",3.0);             <span class='comment'>// <span class='texttt'>Y</span> is deduced to be <span class='texttt'>const char*</span>, and
</span>                                <span class='comment'>// <span class='texttt'>Z</span> is deduced to be <span class='texttt'>double</span>
</span>  f("aa",3.0);                  <span class='comment'>// error: <span class='texttt'>X</span> cannot be deduced
</span>  f2&lt;char, short, int, long&gt;(); <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-6'>6</a></div><p >Implicit conversions (Clause <a href='conv'>[conv]</a>) will be performed on a function argument
to convert it to the type of the corresponding function parameter if
the parameter type contains no
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
that participate in template argument deduction.
[&nbsp;<i>Note:</i>
Template parameters do not participate in template argument deduction if
they are explicitly specified.
For example,</p><pre class='codeblock'>
template&lt;class T&gt; void f(T);

class Complex {
  Complex(double);
};

void g() {
  f&lt;Complex&gt;(1);                <span class='comment'>// OK, means <span class='texttt'>f&lt;Complex&gt;(Complex(1))</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-7'>7</a></div><p >[&nbsp;<i>Note:</i>
Because the explicit template argument list follows the function
template name, and because conversion member function templates and
constructor member function templates are called without using a
function name, there is no way to provide an explicit template
argument list for these function templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]

</p></div><div class='para' id='temp.arg.explicit-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-8'>8</a></div><p >[&nbsp;<i>Note:</i>
For simple function names, argument dependent lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)
applies even when the function name is not visible within the scope of the call.
This is because the call still has the syntactic form of a function call (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>).
But when a function template with explicit template arguments is used,
the call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call.
If no such name is visible,
the call is not syntactically well-formed and argument-dependent lookup
does not apply.
If some such name is visible,
argument dependent lookup applies and additional function templates
may be found in other namespaces.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  struct B { };
  template&lt;int X&gt; void f(B);
}
namespace C {
  template&lt;class T&gt; void f(T t);
}
void g(A::B b) {
  f&lt;3&gt;(b);                      <span class='comment'>// ill-formed: not a function call
</span>  A::f&lt;3&gt;(b);                   <span class='comment'>// well-formed
</span>  C::f&lt;3&gt;(b);                   <span class='comment'>// ill-formed; argument dependent lookup
</span>                                <span class='comment'>// applies only to unqualified names
</span>  using C::f;
  f&lt;3&gt;(b);                      <span class='comment'>// well-formed because <span class='texttt'>C::f</span> is visible; then
</span>                                <span class='comment'>// <span class='texttt'>A::f</span> is found by argument dependent lookup
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.arg.explicit-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.arg.explicit-9'>9</a></div><p >Template argument deduction can extend the sequence of template
arguments corresponding to a template parameter pack, even when the
sequence contains explicitly specified template arguments.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... values);

void g() {
  f&lt;int*, float*&gt;(0, 0, 0);     <span class='comment'>// <span class='texttt'>Types</span> is deduced to the sequence <span class='texttt'>int*</span>, <span class='texttt'>float*</span>, <span class='texttt'>int</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.deduct'><h3 ><a class='secnum' href='#temp.deduct' style='min-width:103pt'>14.8.2</a> Template argument deduction <a class='abbr_ref' href='temp.deduct'>[temp.deduct]</a></h3><div class='para' id='temp.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-1'>1</a></div><p >When a
function template
specialization is referenced, all of the
template arguments shall have values.
The values can be
explicitly specified or, in some cases, be deduced from the use
or obtained from default
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {
  sort(cv);                     <span class='comment'>// calls <span class='texttt'>sort(Array&lt;dcomplex&gt;&amp;)</span>
</span>  sort(ci);                     <span class='comment'>// calls <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span>}
</pre><p >and</p><pre class='codeblock'>
void g(double d) {
  int i = convert&lt;int&gt;(d);      <span class='comment'>// calls <span class='texttt'>convert&lt;int,double&gt;(double)</span>
</span>  int c = convert&lt;char&gt;(d);     <span class='comment'>// calls <span class='texttt'>convert&lt;char,double&gt;(double)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-2'>2</a></div><p >When an explicit template argument list is specified, the template
arguments must be compatible with the template parameter list and must
result in a valid function type as described below; otherwise type
deduction fails.  Specifically, the following steps are performed when
evaluating an explicitly specified template argument list with respect
to a given function template:</p><ul class='itemize'><li id='temp.deduct-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-2.1'>(2.1)</a></div><p >The specified template arguments must match the template parameters in
kind (i.e., type, non-type, template). There
must not be more arguments than there are parameters
unless at least one parameter is a template parameter pack, and there shall be
an argument for each non-pack parameter.
Otherwise, type deduction fails.</p></li><li id='temp.deduct-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-2.2'>(2.2)</a></div><p >Non-type arguments must match the types of the corresponding non-type
template parameters, or must be convertible to the types of the
corresponding non-type parameters as specified in <a href='temp.arg.nontype'>[temp.arg.nontype]</a>, otherwise type deduction fails.</p></li><li id='temp.deduct-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-2.3'>(2.3)</a></div><p >The specified template argument values are substituted for the
corresponding template parameters as specified below.
</p></li></ul></div><div class='para' id='temp.deduct-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-3'>3</a></div><p >After this substitution is performed, the function parameter type
adjustments described in <a href='dcl.fct'>[dcl.fct]</a> are performed.
[&nbsp;<i>Example:</i>
A parameter type of “<span class='texttt'>void ()(const int, int[5])</span>” becomes
“<span class='texttt'>void(*)(int,int*)</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
A top-level qualifier in a function parameter declaration does not affect
the function type but still affects the type of the function parameter
variable within the function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; void f(T t);
template &lt;class X&gt; void g(const X x);
template &lt;class Z&gt; void h(Z, Z*);

int main() {
  <span class='comment'>// #1: function type is <span class='texttt'>f(int)</span>, <span class='texttt'>t</span> is non <span class='texttt'>const</span>
</span>  f&lt;int&gt;(1);

  <span class='comment'>// #2: function type is <span class='texttt'>f(int)</span>, <span class='texttt'>t</span> is <span class='texttt'>const</span>
</span>  f&lt;const int&gt;(1);

  <span class='comment'>// #3: function type is <span class='texttt'>g(int)</span>, <span class='texttt'>x</span> is <span class='texttt'>const</span>
</span>  g&lt;int&gt;(1);

  <span class='comment'>// #4: function type is <span class='texttt'>g(int)</span>, <span class='texttt'>x</span> is <span class='texttt'>const</span>
</span>  g&lt;const int&gt;(1);

  <span class='comment'>// #5: function type is <span class='texttt'>h(int, const int*)</span>
</span>  h&lt;const int&gt;(1,0);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-4'>4</a></div><p >[&nbsp;<i>Note:</i>
<span class='texttt'>f&lt;int&gt;(1)</span> and <span class='texttt'>f&lt;const int&gt;(1)</span> call distinct functions
even though both of the functions called have the same function type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.deduct-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-5'>5</a></div><p >The resulting substituted and adjusted function type is used as
the type of the function template for template argument
deduction.  If a template argument has not been deduced and its
corresponding template parameter has a default argument, the
template argument is determined by substituting the template 
arguments determined for preceding template parameters into the
default argument. If the substitution results in an invalid type,
as described above, type deduction fails.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class U = double&gt;
void f(T t = 0, U u = 0);

void g() {
  f(1, 'c');        <span class='comment'>// <span class='texttt'>f&lt;int,char&gt;(1,'c')</span>
</span>  f(1);             <span class='comment'>// <span class='texttt'>f&lt;int,double&gt;(1,0)</span>
</span>  f();              <span class='comment'>// error: <span class='texttt'>T</span> cannot be deduced
</span>  f&lt;int&gt;();         <span class='comment'>// <span class='texttt'>f&lt;int,double&gt;(0,0)</span>
</span>  f&lt;int,char&gt;();    <span class='comment'>// <span class='texttt'>f&lt;int,char&gt;(0,0)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >When all template arguments have been deduced or obtained from
default template arguments, all uses of template parameters in
the template parameter list of the template and the function type
are replaced with the corresponding deduced
or default argument values. If the substitution results in an
invalid type, as described above, type deduction fails.</p></div><div class='para' id='temp.deduct-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-6'>6</a></div><p >At certain points in the template argument deduction process it is necessary
to take a function type that makes use of template parameters and replace those
template parameters with the corresponding template arguments. This is done at
the beginning of template argument deduction when any explicitly specified
template arguments are substituted into the function type, and again at the end
of template argument deduction when any template arguments that were deduced or
obtained from default arguments are substituted.</p></div><div class='para' id='temp.deduct-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-7'>7</a></div><p >The substitution occurs in all types and expressions that are used in the function
type and in template parameter declarations. The expressions include not only
constant expressions such as those that appear in array bounds or as nontype
template arguments but also general expressions (i.e., non-constant expressions)
inside <span class='texttt'>sizeof</span>, <span class='texttt'>decltype</span>, and other contexts that allow non-constant
expressions. The substitution proceeds in lexical order and stops when
a condition that causes deduction to fail is encountered. [&nbsp;<i>Note:</i> The equivalent substitution in exception specifications is
done only when the <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is instantiated, at which point a program is ill-formed
if the substitution results in an invalid type or
expression. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A { using X = typename T::X; };
template &lt;class T&gt; typename T::X f(typename A&lt;T&gt;::X);
template &lt;class T&gt; void f(...) { }
template &lt;class T&gt; auto g(typename A&lt;T&gt;::X) -&gt; typename T::X;
template &lt;class T&gt; void g(...) { }

void h() {
  f&lt;int&gt;(0); <span class='comment'>// OK, substituting return type causes deduction to fail
</span>  g&lt;int&gt;(0); <span class='comment'>// error, substituting parameter type instantiates <span class='texttt'>A&lt;int&gt;</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-8'>8</a></div><p >If a substitution results in an invalid type or expression, type deduction fails. An
invalid type or expression is one that would be ill-formed, with a diagnostic
required, if written using the substituted arguments. [&nbsp;<i>Note:</i> If no
diagnostic is required, the program is still ill-formed. Access checking is done
as part of the substitution
process. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Only invalid types and expressions in the immediate
context of the function type and its template parameter types can result in a deduction
failure. [&nbsp;<i>Note:</i> The evaluation of the substituted types and expressions can result
in side effects such as the instantiation of class template specializations and/or
function template specializations, the generation of implicitly-defined functions,
etc. Such side effects are not in the “immediate context” and can result in the
program being ill-formed.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct X { };
struct Y {
  Y(X){}
};

template &lt;class T&gt; auto f(T t1, T t2) -&gt; decltype(t1 + t2); <span class='comment'>// #1
</span>X f(Y, Y);  <span class='comment'>// #2
</span>
X x1, x2;
X x3 = f(x1, x2);  <span class='comment'>// deduction fails on #1 (cannot add <span class='texttt'>X+X</span>), calls #2</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i> Type deduction may fail for
the following reasons:</p><ul class='itemize'><li id='temp.deduct-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.1'>(8.1)</a></div><p >Attempting to instantiate a pack expansion containing multiple parameter packs of differing lengths.
</p></li><li id='temp.deduct-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.2'>(8.2)</a></div><p >Attempting to create an array with an element type that is <span class='texttt'>void</span>, a
function type, a reference type, or an abstract class type, or attempting
to create an array with a size that is zero or negative.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; int f(T[5]);
int I = f&lt;int&gt;(0);
int j = f&lt;void&gt;(0);             <span class='comment'>// invalid array
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.deduct-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.3'>(8.3)</a></div><p >Attempting to use a type that is not a class or enumeration type in a qualified name.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; int f(typename T::B*);
int i = f&lt;int&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.deduct-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.4'>(8.4)</a></div><p >Attempting to use a type in a <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> of a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> when
that type does not contain the specified member, or
</p><ul class='itemize'><li id='temp.deduct-8.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct-8.4.1'>(8.4.1)</a></div><p >the specified member is not a type where a type is required, or
</p></li><li id='temp.deduct-8.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct-8.4.2'>(8.4.2)</a></div><p >the specified member is not a template where a template is required, or
</p></li><li id='temp.deduct-8.4.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct-8.4.3'>(8.4.3)</a></div><p >the specified member is not a non-type where a non-type is required.
</p></li></ul><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;int I&gt; struct X { };
template &lt;template &lt;class T&gt; class&gt; struct Z { };
template &lt;class T&gt; void f(typename T::Y*){}
template &lt;class T&gt; void g(X&lt;T::N&gt;*){}
template &lt;class T&gt; void h(Z&lt;T::template TT&gt;*){}
struct A {};
struct B { int Y; };
struct C {
  typedef int N;
};
struct D {
  typedef int TT;
};

int main() {
  <span class='comment'>// Deduction fails in each of these cases:
</span>  f&lt;A&gt;(0);  <span class='comment'>// <span class='texttt'>A</span> does not contain a member <span class='texttt'>Y</span>
</span>  f&lt;B&gt;(0);  <span class='comment'>// The <span class='texttt'>Y</span> member of <span class='texttt'>B</span> is not a type
</span>  g&lt;C&gt;(0);  <span class='comment'>// The <span class='texttt'>N</span> member of <span class='texttt'>C</span> is not a non-type
</span>  h&lt;D&gt;(0);  <span class='comment'>// The <span class='texttt'>TT</span> member of <span class='texttt'>D</span> is not a template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.deduct-8.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.5'>(8.5)</a></div><p >Attempting to create a pointer to reference type.
</p></li><li id='temp.deduct-8.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.6'>(8.6)</a></div><p >Attempting to create a reference to <span class='texttt'>void</span>.
</p></li><li id='temp.deduct-8.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.7'>(8.7)</a></div><p >Attempting to create “pointer to member of <span class='texttt'>T</span>” when <span class='texttt'>T</span> is not a
class type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; int f(int T::*);
int i = f&lt;int&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.deduct-8.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.8'>(8.8)</a></div><p >Attempting to give an invalid type to a non-type template parameter.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, T&gt; struct S {};
template &lt;class T&gt; int f(S&lt;T, T()&gt;*);
struct X {};
int i0 = f&lt;X&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li id='temp.deduct-8.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.9'>(8.9)</a></div><p >Attempting to perform an invalid conversion in either a template
argument expression, or an expression used in the function
declaration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T, T*&gt; int f(int);
int i2 = f&lt;int,1&gt;(0);           <span class='comment'>// can't conv <span class='texttt'>1</span> to <span class='texttt'>int*</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li id='temp.deduct-8.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.10'>(8.10)</a></div><p >Attempting to create a function type in which a parameter has a type
of <span class='texttt'>void</span>, or in which the return type is a function type
or array type.</p></li><li id='temp.deduct-8.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct-8.11'>(8.11)</a></div><p >Attempting to create a function type in which a parameter type or the return type is an
abstract class type (<a href='class.abstract'>[class.abstract]</a>).
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.deduct-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct-9'>9</a></div><p >Except as described above, the use of an invalid value shall not cause
type deduction to fail.
[&nbsp;<i>Example:</i>
In the following example 1000 is converted to <span class='texttt'>signed char</span> and results
in an implementation-defined value as specified in (<a href='conv.integral'>[conv.integral]</a>).
In other words, both templates are considered even though 1000,
when converted to <span class='texttt'>signed char</span>, results in an implementation-defined
value.</p><pre class='codeblock'>
template &lt;int&gt; int f(int);
template &lt;signed char&gt; int f(int);
int i1 = f&lt;1&gt;(0);               <span class='comment'>// ambiguous
</span>int i2 = f&lt;1000&gt;(0);            <span class='comment'>// ambiguous
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='temp.deduct.call'><h4 ><a class='secnum' href='#temp.deduct.call' style='min-width:118pt'>14.8.2.1</a> Deducing template arguments from a function call <a class='abbr_ref' href='temp.deduct.call'>[temp.deduct.call]</a></h4><div class='para' id='temp.deduct.call-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-1'>1</a></div><p >Template argument deduction is done by comparing each function
template parameter type (call it
<span class='texttt'>P</span>)
with the type of the corresponding argument of the call (call it
<span class='texttt'>A</span>)
as described below.
If removing references and cv-qualifiers from <span class='texttt'>P</span> gives
<span class='texttt'>std::initializer_list&lt;<span class='math'><span class='mathalpha'>P</span><sup >'</sup></span>&gt;</span> for some <span class='texttt'><span class='math'><span class='mathalpha'>P</span><sup >'</sup></span></span> and the
argument is an initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), then deduction is
performed instead for each element of the initializer list, taking
<span class='texttt'><span class='math'><span class='mathalpha'>P</span><sup >'</sup></span></span> as a function template parameter type and the initializer
element as its argument. Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context (<a href='temp.deduct.type'>[temp.deduct.type]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);
f({1,2,3});                 <span class='comment'>// <span class='texttt'>T</span> deduced to <span class='texttt'>int</span>
</span>f({1,"asdf"});              <span class='comment'>// error: <span class='texttt'>T</span> deduced to both <span class='texttt'>int</span> and <span class='texttt'>const char*</span>
</span>
template&lt;class T&gt; void g(T);
g({1,2,3});                 <span class='comment'>// error: no argument deduced for <span class='texttt'>T</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
For a function parameter pack that occurs at the end of the <i ><a href='dcl.fct#nt:parameter-declaration-list'>parameter-declaration-list</a></i>,
the type <span class='texttt'>A</span> of each
remaining argument of the call is compared with the type <span class='texttt'>P</span>
of the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of the function parameter pack.
Each comparison deduces template arguments for subsequent positions in
the template parameter packs expanded by the function parameter pack.
When a function parameter pack appears in a non-deduced
context (<a href='temp.deduct.type'>[temp.deduct.type]</a>), the type of that parameter pack is
never deduced.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types&amp; ...);
template&lt;class T1, class ... Types&gt; void g(T1, Types ...);
template&lt;class T1, class ... Types&gt; void g1(Types ..., T1);

void h(int x, float&amp; y) {
  const int z = x;
  f(x, y, z);                  <span class='comment'>// <span class='texttt'>Types</span> is deduced to <span class='texttt'>int</span>, <span class='texttt'>float</span>, <span class='texttt'>const int</span>
</span>  g(x, y, z);                  <span class='comment'>// <span class='texttt'>T1</span> is deduced to <span class='texttt'>int</span>; <span class='texttt'>Types</span> is deduced to <span class='texttt'>float</span>, <span class='texttt'>int</span>
</span>  g1(x, y, z);                 <span class='comment'>// error: <span class='texttt'>Types</span> is not deduced
</span>  g1&lt;int, int, int&gt;(x, y, z);  <span class='comment'>// OK, no deduction occurs
</span>
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.call-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-2'>2</a></div><p >If
<span class='texttt'>P</span>
is not a reference type:</p><ul class='itemize'><li id='temp.deduct.call-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-2.1'>(2.1)</a></div><p >If
<span class='texttt'>A</span>
is an array type, the pointer type produced by the array-to-pointer
standard conversion (<a href='conv.array'>[conv.array]</a>) is used in place of
<span class='texttt'>A</span>
for type deduction;
otherwise,
</p></li><li id='temp.deduct.call-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-2.2'>(2.2)</a></div><p >If
<span class='texttt'>A</span>
is a function type, the pointer type produced by the
function-to-pointer standard conversion (<a href='conv.func'>[conv.func]</a>) is used in place
of
<span class='texttt'>A</span>
for type
deduction; otherwise,
</p></li><li id='temp.deduct.call-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-2.3'>(2.3)</a></div><p >If
<span class='texttt'>A</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction.
</p></li></ul></div><div class='para' id='temp.deduct.call-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-3'>3</a></div><p >If
<span class='texttt'>P</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction.
If
<span class='texttt'>P</span>
is a reference type, the type
referred to by
<span class='texttt'>P</span>
is used for type deduction.
If <span class='texttt'>P</span> is an rvalue reference to a cv-unqualified template parameter and the argument is an
lvalue, the type “lvalue reference to <span class='texttt'>A</span>” is used in place of <span class='texttt'>A</span> for type
deduction. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; int f(T&amp;&amp;);
template &lt;class T&gt; int g(const T&amp;&amp;);
int i;
int n1 = f(i);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&amp;&gt;(int&amp;)</span>
</span>int n2 = f(0);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int&amp;&amp;)</span>
</span>int n3 = g(i);                  <span class='comment'>// error: would call <span class='texttt'>g&lt;int&gt;(const int&amp;&amp;)</span>, which
</span>                                <span class='comment'>// would bind an rvalue reference to an lvalue
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.call-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-4'>4</a></div><p >In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>
(after
the type
<span class='texttt'>A</span>
is transformed as described above).
However, there are
three cases that allow a difference:</p><ul class='itemize'><li id='temp.deduct.call-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-4.1'>(4.1)</a></div><p >If the original
<span class='texttt'>P</span>
is a reference type, the deduced
<span class='texttt'>A</span>
(i.e.,
the type referred to by the reference) can be more cv-qualified than
the transformed <span class='texttt'>A</span>.
</p></li><li id='temp.deduct.call-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-4.2'>(4.2)</a></div><p >The transformed <span class='texttt'>A</span>
can be another pointer or pointer to member type that can be converted
to the deduced
<span class='texttt'>A</span>
via a qualification conversion (<a href='conv.qual'>[conv.qual]</a>).</p></li><li id='temp.deduct.call-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-4.3'>(4.3)</a></div><p >If
<span class='texttt'>P</span>
is a class and
<span class='texttt'>P</span>
has the form
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>,
then
the transformed <span class='texttt'>A</span>
can be a derived class of the
deduced
<span class='texttt'>A</span>.
Likewise, if
<span class='texttt'>P</span>
is a pointer to a class of the form
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>,
the transformed <span class='texttt'>A</span>
can be a pointer to a
derived class pointed to by the deduced
<span class='texttt'>A</span>.
</p></li></ul><p >[&nbsp;<i>Note:</i> as specified in <a href='temp.arg.explicit'>[temp.arg.explicit]</a>, implicit conversions will be
performed on a function argument to convert it to the type of the corresponding
function parameter if the parameter contains no <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
that participate in template argument deduction. Such conversions are also
allowed, in addition to the ones described in the preceding list. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.deduct.call-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-5'>5</a></div><p >These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails.
[&nbsp;<i>Note:</i>
If a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is not used in any of the function parameters of a function template,
or is used only in a non-deduced context, its corresponding
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
cannot be deduced from a function call and the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
must be explicitly specified.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.deduct.call-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.call-6'>6</a></div><p >When P is a function type, pointer to function type, or pointer to member
function type:
</p><ul class='itemize'><li id='temp.deduct.call-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-6.1'>(6.1)</a></div><p >If the argument is an overload set containing one or more function templates,
the parameter is treated as a non-deduced context.
</p></li><li id='temp.deduct.call-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.call-6.2'>(6.2)</a></div><p >If the argument is an overload set (not containing function templates), trial
argument deduction is attempted using each of the members of the set. If
deduction succeeds for only one of the overload set members, that member is
used as the argument value for the deduction. If deduction succeeds for more than
one member of the overload set the parameter is treated as a non-deduced context.</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Only one function of an overload set matches the call so the function
</span><span class='comment'>// parameter is a deduced context.
</span>template &lt;class T&gt; int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g);       <span class='comment'>// calls <span class='texttt'>f(int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Ambiguous deduction causes the second function parameter to be a
</span><span class='comment'>// non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// The overload set contains a template, causing the second function
</span><span class='comment'>// parameter to be a non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
char g(char);
template &lt;class T&gt; T g(T);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></div></div><div id='temp.deduct.funcaddr'><h4 ><a class='secnum' href='#temp.deduct.funcaddr' style='min-width:118pt'>14.8.2.2</a> Deducing template arguments taking the address of a function template <a class='abbr_ref' href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a></h4><div class='para' id='temp.deduct.funcaddr-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.funcaddr-1'>1</a></div><p >Template arguments can be deduced from the type specified when taking
the address of an overloaded function (<a href='over.over'>[over.over]</a>).
The function template's function type and the specified type
are used as the types of
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
and the deduction is done as
described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='temp.deduct.funcaddr-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.funcaddr-2'>2</a></div><p >A placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>) in the return type of a
function template is a non-deduced context. If template argument
deduction succeeds for such a function, the return type is determined
from instantiation of the function body.</p></div></div><div id='temp.deduct.conv'><h4 ><a class='secnum' href='#temp.deduct.conv' style='min-width:118pt'>14.8.2.3</a> Deducing conversion function template arguments <a class='abbr_ref' href='temp.deduct.conv'>[temp.deduct.conv]</a></h4><div class='para' id='temp.deduct.conv-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-1'>1</a></div><p >Template argument deduction is done by comparing the return type of
the
conversion function template
(call it
<span class='texttt'>P</span>)
with the type that is
required as the result of the conversion (call it
<span class='texttt'>A</span>; see <a href='dcl.init'>[dcl.init]</a>, <a href='over.match.conv'>[over.match.conv]</a>, and <a href='over.match.ref'>[over.match.ref]</a>
for the determination of that type)
as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='temp.deduct.conv-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-2'>2</a></div><p >If <span class='texttt'>P</span> is a reference type, the type referred to by <span class='texttt'>P</span> is used in place
of <span class='texttt'>P</span> for type deduction and for any further references to or transformations of
<span class='texttt'>P</span> in the remainder of this section.</p></div><div class='para' id='temp.deduct.conv-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-3'>3</a></div><p >If
<span class='texttt'>A</span>
is not a reference type:</p><ul class='itemize'><li id='temp.deduct.conv-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.conv-3.1'>(3.1)</a></div><p >If
<span class='texttt'>P</span>
is an array type, the pointer type produced by the
array-to-pointer standard conversion (<a href='conv.array'>[conv.array]</a>) is used in place of
<span class='texttt'>P</span>
for type
deduction; otherwise,
</p></li><li id='temp.deduct.conv-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.conv-3.2'>(3.2)</a></div><p >If
<span class='texttt'>P</span>
is a function type, the pointer type produced by the
function-to-pointer standard conversion (<a href='conv.func'>[conv.func]</a>) is used in place of
<span class='texttt'>P</span>
for
type deduction; otherwise,
</p></li><li id='temp.deduct.conv-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.conv-3.3'>(3.3)</a></div><p >If
<span class='texttt'>P</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction.
</p></li></ul></div><div class='para' id='temp.deduct.conv-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-4'>4</a></div><p >If
<span class='texttt'>A</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction.
If
<span class='texttt'>A</span>
is a
reference type, the type referred to by
<span class='texttt'>A</span>
is used for type deduction.</p></div><div class='para' id='temp.deduct.conv-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-5'>5</a></div><p >In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>.
However, there are two cases that allow a difference:</p><ul class='itemize'><li id='temp.deduct.conv-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.conv-5.1'>(5.1)</a></div><p >If the original
<span class='texttt'>A</span>
is a reference type,
<span class='texttt'>A</span>
can be more cv-qualified
than the deduced
<span class='texttt'>A</span>
(i.e., the type referred to by the reference)
</p></li><li id='temp.deduct.conv-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.conv-5.2'>(5.2)</a></div><p >The deduced
<span class='texttt'>A</span>
can be another pointer or pointer to member type that
can be converted to
<span class='texttt'>A</span>
via a qualification conversion.
</p></li></ul></div><div class='para' id='temp.deduct.conv-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-6'>6</a></div><p >These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails.</p></div><div class='para' id='temp.deduct.conv-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.conv-7'>7</a></div><p >When the deduction process requires a qualification conversion for a
pointer or pointer to member type as described above, the following
process is used to determine the deduced template argument values:</p><p >If
<span class='texttt'>A</span>
is a type
<div class='indented'>
<span class='math'><span class='mathit'>cv</span><sub >1,0</sub></span> “pointer to <span class='math'>&hellip;</span>” <span class='math'><span class='mathit'>cv</span><sub >1,<span class='mathalpha'>n</span>-1</sub></span> “pointer to”
<span class='math'><span class='mathit'>cv</span><sub >1,<span class='mathalpha'>n</span></sub><span class='mathit'>T1</span></span>
</div>
and
<span class='texttt'>P</span>
is a type
<div class='indented'>
<span class='math'><span class='mathit'>cv</span><sub >2,0</sub></span> “pointer to <span class='math'>&hellip;</span>” <span class='math'><span class='mathit'>cv</span><sub >2,<span class='mathalpha'>n</span>-1</sub></span> “pointer to”
<span class='math'><span class='mathit'>cv</span><sub >2,<span class='mathalpha'>n</span></sub><span class='mathit'>T2</span></span>
</div>
The cv-unqualified
<span class='texttt'>T1</span>
and
<span class='texttt'>T2</span>
are used as the types of
<span class='texttt'>A</span>
and
<span class='texttt'>P</span>
respectively for type deduction.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T***();
};
A a;
const int * const * const * p1 = a;     <span class='comment'>// <span class='texttt'>T</span> is deduced as <span class='texttt'>int</span>, not <span class='texttt'>const int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.deduct.partial'><h4 ><a class='secnum' href='#temp.deduct.partial' style='min-width:118pt'>14.8.2.4</a> Deducing template arguments during partial ordering <a class='abbr_ref' href='temp.deduct.partial'>[temp.deduct.partial]</a></h4><div class='para' id='temp.deduct.partial-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-1'>1</a></div><p >Template argument deduction is done by comparing certain types associated with
the two function templates being compared.</p></div><div class='para' id='temp.deduct.partial-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-2'>2</a></div><p >Two sets of types are used to determine the partial ordering.  For each of
the templates involved there is the original function type and the
transformed function type.
[&nbsp;<i>Note:</i>
The creation of the transformed type is described in <a href='temp.func.order'>[temp.func.order]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The deduction process uses the
transformed type as the argument template and the original type of the
other template as the parameter template.  This process is done twice
for each type involved in the partial ordering comparison: once using
the transformed template-1 as the argument template and template-2 as
the parameter template and again using the transformed template-2 as
the argument template and template-1 as the parameter template.</p></div><div class='para' id='temp.deduct.partial-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-3'>3</a></div><p >The types used to determine the ordering depend on the context in which
the partial ordering is done:</p><ul class='itemize'><li id='temp.deduct.partial-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-3.1'>(3.1)</a></div><p >In the context of a function call, the types used are those function parameter types
for which the function call has arguments.<a class='footnotenum' href='#footnote-143'>143</a>
</p></li><li id='temp.deduct.partial-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-3.2'>(3.2)</a></div><p >In the context of a call to a conversion function, the return types of
the conversion function templates are used.
</p></li><li id='temp.deduct.partial-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-3.3'>(3.3)</a></div><p >In other contexts (<a href='temp.func.order'>[temp.func.order]</a>) the function template's function
type is used.
</p></li></ul></div><div class='para' id='temp.deduct.partial-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-4'>4</a></div><p >Each type nominated above from the parameter template and the corresponding type from the
argument template are used as the types of
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>.</p></div><div class='para' id='temp.deduct.partial-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-5'>5</a></div><p >Before the partial ordering is done, certain transformations are performed
on the types used for partial ordering:</p><ul class='itemize'><li id='temp.deduct.partial-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-5.1'>(5.1)</a></div><p >If
<span class='texttt'>P</span>
is a reference type,
<span class='texttt'>P</span>
is replaced by the type referred to.
</p></li><li id='temp.deduct.partial-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-5.2'>(5.2)</a></div><p >If
<span class='texttt'>A</span>
is a reference type,
<span class='texttt'>A</span>
is replaced by the type referred to.
</p></li></ul></div><div class='para' id='temp.deduct.partial-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-6'>6</a></div><p >If both
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>
were reference types (before being replaced with the type referred to
above), determine which of the two types (if any) is more cv-qualified
than the other; otherwise the types are considered to be equally
cv-qualified for partial ordering purposes. The result of this
determination will be used below.</p></div><div class='para' id='temp.deduct.partial-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-7'>7</a></div><p >Remove any top-level cv-qualifiers:
</p><ul class='itemize'><li id='temp.deduct.partial-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-7.1'>(7.1)</a></div><p >If
<span class='texttt'>P</span>
is a cv-qualified type,
<span class='texttt'>P</span>
is replaced by the cv-unqualified version of
<span class='texttt'>P</span>.
</p></li><li id='temp.deduct.partial-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-7.2'>(7.2)</a></div><p >If
<span class='texttt'>A</span>
is a cv-qualified type,
<span class='texttt'>A</span>
is replaced by the cv-unqualified version of
<span class='texttt'>A</span>.
</p></li></ul></div><div class='para' id='temp.deduct.partial-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-8'>8</a></div><p >If <span class='texttt'>A</span> was transformed from a function parameter pack and <span class='texttt'>P</span> is not
a parameter pack, type deduction fails. Otherwise, using
the resulting types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
the deduction is then done as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.
If <span class='texttt'>P</span> is a function parameter pack, the type <span class='texttt'>A</span> of each remaining
parameter type of the argument template is compared with the type <span class='texttt'>P</span> of
the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of the function parameter pack. Each comparison
deduces template arguments for subsequent positions in the template parameter
packs expanded by the function parameter pack.
If deduction succeeds for a given type,
the type from the argument template is considered to be at least as specialized
as the type from the parameter template.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class... Args&gt;           void f(Args... args);           <span class='comment'>// #1
</span>template&lt;class T1, class... Args&gt; void f(T1 a1, Args... args);    <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;      void f(T1 a1, T2 a2);           <span class='comment'>// #3
</span>
f();                  <span class='comment'>// calls #1
</span>f(1, 2, 3);           <span class='comment'>// calls #2
</span>f(1, 2);              <span class='comment'>// calls #3; non-variadic template #3 is more
</span>                      <span class='comment'>// specialized than the variadic templates #1 and #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.partial-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-9'>9</a></div><p >If, for a given type, deduction succeeds in both directions (i.e., the
types are identical after the transformations above)
and both <span class='texttt'>P</span> and <span class='texttt'>A</span> were reference types (before being replaced with the
type referred to above):</p><ul class='itemize'><li id='temp.deduct.partial-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-9.1'>(9.1)</a></div><p >if the type from the argument template was an lvalue reference and the type
from the parameter template was not, the argument type is considered to be
more specialized than the other; otherwise,</p></li><li id='temp.deduct.partial-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-9.2'>(9.2)</a></div><p >if the type from
the argument template is more cv-qualified than the type from the
parameter template (as described above), the argument type is considered to be
more specialized than the other; otherwise,</p></li><li id='temp.deduct.partial-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.partial-9.3'>(9.3)</a></div><p >neither type is more specialized than the other.
</p></li></ul></div><div class='para' id='temp.deduct.partial-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-10'>10</a></div><p >If for each type being considered a given template is at least as specialized
for all types and more specialized for some set of types and the
other template is not more specialized for any types or is not
at least as specialized for any types, then
the given template is more specialized than the other template.
Otherwise, neither template is more specialized than the other.</p></div><div class='para' id='temp.deduct.partial-11'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-11'>11</a></div><p >In most cases, all template parameters must have values in order for
deduction to succeed, but for partial ordering purposes a template
parameter may remain without a value provided it is not used in the
types being used for partial ordering.
[&nbsp;<i>Note:</i>
A template parameter used in a non-deduced context is considered used.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; T f(int);        <span class='comment'>// #1
</span>template &lt;class T, class U&gt; T f(U); <span class='comment'>// #2
</span>void g() {
  f&lt;int&gt;(1);        <span class='comment'>// calls #1
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.partial-12'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.partial-12'>12</a></div><p >[&nbsp;<i>Note:</i> Partial ordering of function templates containing
template parameter packs is independent of the number of deduced arguments
for those template parameter packs. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ...&gt; struct Tuple { };
template&lt;class ... Types&gt; void g(Tuple&lt;Types ...&gt;);                 <span class='comment'>// #1
</span>template&lt;class T1, class ... Types&gt; void g(Tuple&lt;T1, Types ...&gt;);   <span class='comment'>// #2
</span>template&lt;class T1, class ... Types&gt; void g(Tuple&lt;T1, Types&amp; ...&gt;);  <span class='comment'>// #3
</span>
g(Tuple&lt;&gt;());                   <span class='comment'>// calls #1
</span>g(Tuple&lt;int, float&gt;());         <span class='comment'>// calls #2
</span>g(Tuple&lt;int, float&amp;&gt;());        <span class='comment'>// calls #3
</span>g(Tuple&lt;int&gt;());                <span class='comment'>// calls #3
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-143'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-143'>143)</a></div><p >Default arguments
are not considered to be arguments in this context; they only become arguments
after a function has been selected.</p></div></div><div id='temp.deduct.type'><h4 ><a class='secnum' href='#temp.deduct.type' style='min-width:118pt'>14.8.2.5</a> Deducing template arguments from a type <a class='abbr_ref' href='temp.deduct.type'>[temp.deduct.type]</a></h4><div class='para' id='temp.deduct.type-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-1'>1</a></div><p >Template arguments can be deduced in several different contexts, but
in each case a type that is specified in terms of template parameters
(call it
<span class='texttt'>P</span>)
is compared with an actual type (call it
<span class='texttt'>A</span>),
and an attempt is made to find template argument values (a type for a type
parameter, a value for a non-type parameter, or a template for a
template parameter) that will make
<span class='texttt'>P</span>,
after substitution of the deduced values (call it the deduced
<span class='texttt'>A</span>),
compatible with
<span class='texttt'>A</span>.</p></div><div class='para' id='temp.deduct.type-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-2'>2</a></div><p >In some cases, the deduction is done using a single set of types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
in other cases, there will be a set of corresponding types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>.
Type deduction is done
independently for each
<span class='texttt'>P/A</span>
pair, and the deduced template
argument values are then combined.
If type deduction cannot be done
for any
<span class='texttt'>P/A</span>
pair, or if for any pair the deduction leads to more than
one possible set of deduced values, or if different pairs yield
different deduced values, or if any template argument remains neither
deduced nor explicitly specified, template argument deduction fails.</p></div><div class='para' id='temp.deduct.type-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-3'>3</a></div><p >A given type
<span class='texttt'>P</span>
can be composed from a number of other
types, templates, and non-type values:</p><ul class='itemize'><li id='temp.deduct.type-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-3.1'>(3.1)</a></div><p >A function type includes the types of each of the function parameters
and the return type.
</p></li><li id='temp.deduct.type-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-3.2'>(3.2)</a></div><p >A pointer to member type includes the type of the class object pointed to
and the type of the member pointed to.
</p></li><li id='temp.deduct.type-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-3.3'>(3.3)</a></div><p >A type that is a specialization of a class template (e.g.,
<span class='texttt'>A&lt;int&gt;</span>)
includes the types, templates, and non-type values referenced by the
template argument list of the specialization.
</p></li><li id='temp.deduct.type-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-3.4'>(3.4)</a></div><p >An array type includes the array element type and the value of the
array bound.
</p></li></ul></div><div class='para' id='temp.deduct.type-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-4'>4</a></div><p >In most cases, the types, templates, and non-type values that are used
to compose
<span class='texttt'>P</span>
participate in template argument deduction.
That is,
they may be used to determine the value of a template argument, and
the value so determined must be consistent with the values determined
elsewhere.
In certain contexts, however, the value does not
participate in type deduction, but instead uses the values of template
arguments that were either deduced elsewhere or explicitly specified.
If a template parameter is used only in non-deduced contexts and is not
explicitly specified, template argument deduction fails.</p></div><div class='para' id='temp.deduct.type-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-5'>5</a></div><p >The non-deduced contexts are:</p><p ><span class='indexparent'><a class='index' id='context,non-deduced'></a></span></p><ul class='itemize'><li id='temp.deduct.type-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.1'>(5.1)</a></div><p >The
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
of a type that was specified using a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>.
</p></li><li id='temp.deduct.type-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.2'>(5.2)</a></div><p >The <i ><a href='expr.comma#nt:expression'>expression</a></i> of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.
</p></li><li id='temp.deduct.type-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.3'>(5.3)</a></div><p >A non-type template argument or an array bound in which a subexpression
references a template parameter.
</p></li><li id='temp.deduct.type-5.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.4'>(5.4)</a></div><p >A template parameter used in the parameter type of a function parameter that
has a default argument that is being used in the call for which argument
deduction is being done.
</p></li><li id='temp.deduct.type-5.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.5'>(5.5)</a></div><p >A function parameter for which argument deduction cannot be done because the
associated function argument is a function, or a set of overloaded
functions (<a href='over.over'>[over.over]</a>), and one or more of the following apply:
</p><ul class='itemize'><li id='temp.deduct.type-5.5.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct.type-5.5.1'>(5.5.1)</a></div><p >more than one function matches the function parameter type (resulting in
an ambiguous deduction), or
</p></li><li id='temp.deduct.type-5.5.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct.type-5.5.2'>(5.5.2)</a></div><p >no function matches the function parameter type, or
</p></li><li id='temp.deduct.type-5.5.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.deduct.type-5.5.3'>(5.5.3)</a></div><p >the set of functions supplied as an argument contains one or more function templates.
</p></li></ul></li><li id='temp.deduct.type-5.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.6'>(5.6)</a></div><p >A function parameter for which the associated argument is an initializer
list (<a href='dcl.init.list'>[dcl.init.list]</a>) but the parameter does not have
<span class='texttt'>std::initializer_list</span> or reference to possibly cv-qualified
<span class='texttt'>std::initializer_list</span> type. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; void g(T);
g({1,2,3});                 <span class='comment'>// error: no argument deduced for <span class='texttt'>T</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.deduct.type-5.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-5.7'>(5.7)</a></div><p >A function parameter pack that does not occur at the end of the 
<i ><a href='dcl.fct#nt:parameter-declaration-list'>parameter-declaration-list</a></i>.
</p></li></ul></div><div class='para' id='temp.deduct.type-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-6'>6</a></div><p >When a type name is specified in a way that includes a non-deduced
context, all of the types that comprise that type name are also
non-deduced.
However, a compound type can include both deduced and non-deduced types.
[&nbsp;<i>Example:</i>
If a type is specified as
<span class='texttt'>A&lt;T&gt;::B&lt;T2&gt;</span>,
both
<span class='texttt'>T</span>
and
<span class='texttt'>T2</span>
are non-deduced.
Likewise, if a type is specified as
<span class='texttt'>A&lt;I+J&gt;::X&lt;T&gt;</span>,
<span class='texttt'>I</span>,
<span class='texttt'>J</span>,
and
<span class='texttt'>T</span>
are non-deduced.
If a type is specified as
<span class='texttt'>void</span>
<span class='texttt'>f(typename</span>
<span class='texttt'>A&lt;T&gt;::B,</span>
<span class='texttt'>A&lt;T&gt;)</span>,
the
<span class='texttt'>T</span>
in
<span class='texttt'>A&lt;T&gt;::B</span>
is non-deduced but
the
<span class='texttt'>T</span>
in
<span class='texttt'>A&lt;T&gt;</span>
is deduced.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-7'>7</a></div><p >[&nbsp;<i>Example:</i>
Here is an example in which different parameter/argument pairs produce
inconsistent template argument deductions:</p><pre class='codeblock'>
template&lt;class T&gt; void f(T x, T y) { <span class='comment'>/* ... */</span> }
struct A { <span class='comment'>/* ... */</span> };
struct B : A { <span class='comment'>/* ... */</span> };
void g(A a, B b) {
  f(a,b);           <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>A</span> or <span class='texttt'>B</span>
</span>  f(b,a);           <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>A</span> or <span class='texttt'>B</span>
</span>  f(a,a);           <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>A</span>
</span>  f(b,b);           <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>B</span>
</span>}
</pre><p >Here is an example where two template arguments are deduced from a
single function parameter/argument pair.
This can lead to conflicts
that cause type deduction to fail:</p><pre class='codeblock'>
template &lt;class T, class U&gt; void f(  T (*)( T, U, U )  );

int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);

void r() {
  f(g1);            <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>int</span> and <span class='texttt'>U</span> is <span class='texttt'>float</span>
</span>  f(g2);            <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>char</span> or <span class='texttt'>int</span>
</span>  f(g3);            <span class='comment'>// error: <span class='texttt'>U</span> could be <span class='texttt'>char</span> or <span class='texttt'>float</span>
</span>}
</pre><p >Here is an example where a qualification conversion applies between the
argument type on the function call and the deduced template argument type:</p><pre class='codeblock'>
template&lt;class T&gt; void f(const T*) { }
int* p;
void s() {
  f(p);             <span class='comment'>// <span class='texttt'>f(const int*)</span>
</span>}
</pre><p >Here is an example where the template argument is used to instantiate
a derived class type of the corresponding function parameter type:</p><pre class='codeblock'>
template &lt;class T&gt; struct B { };
template &lt;class T&gt; struct D : public B&lt;T&gt; {};
struct D2 : public B&lt;int&gt; {};
template &lt;class T&gt; void f(B&lt;T&gt;&amp;){}
void t() {
  D&lt;int&gt; d;
  D2     d2;
  f(d);             <span class='comment'>// calls <span class='texttt'>f(B&lt;int&gt;&amp;)</span>
</span>  f(d2);            <span class='comment'>// calls <span class='texttt'>f(B&lt;int&gt;&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-8'>8</a></div><p >A template type argument
<span class='texttt'>T</span>,
a template template argument
<span class='texttt'>TT</span>
or a template non-type argument
<span class='texttt'>i</span>
can be deduced if
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>
have one of the following forms:</p><pre class='codeblock'>
T
<span class='grammarterm'>cv-list</span> T
T*
T&amp;
T&amp;&amp;
T[<span class='grammarterm'>integer-constant</span>]
<span class='grammarterm'>template-name</span>&lt;T&gt;  (where <span class='grammarterm'>template-name</span> refers to a class template)
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>(T)
T()
T(T)
T <a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>::*
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a> T::*
T T::*
T (<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>::*)()
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a> (T::*)()
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a> (<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>::*)(T)
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a> (T::*)(T)
T (<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>::*)(T)
T (T::*)()
T (T::*)(T)
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>[i]
<span class='grammarterm'>template-name</span>&lt;i&gt;  (where <span class='grammarterm'>template-name</span> refers to a class template)
TT&lt;T&gt;
TT&lt;i&gt;
TT&lt;&gt;
</pre><p >where
<span class='texttt'>(T)</span>
represents
a <span class='grammarterm'>parameter-type-list</span>
where at least one parameter type contains a
<span class='texttt'>T</span>,
and
<span class='texttt'>()</span>
represents
a <span class='grammarterm'>parameter-type-list</span>
where no parameter type contains a
<span class='texttt'>T</span>.
Similarly,
<span class='texttt'>&lt;T&gt;</span>
represents template argument lists where at least one argument contains a
<span class='texttt'>T</span>,
<span class='texttt'>&lt;i&gt;</span>
represents template argument lists where at least one argument contains an
<span class='texttt'>i</span>
and
<span class='texttt'>&lt;&gt;</span>
represents template argument lists where no argument contains a
<span class='texttt'>T</span>
or an
<span class='texttt'>i</span>.</p></div><div class='para' id='temp.deduct.type-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-9'>9</a></div><p >If <span class='texttt'>P</span> has a form that contains <span class='texttt'>&lt;T&gt;</span>
or <span class='texttt'>&lt;i&gt;</span>, then each argument <span class='math'><span class='mathtt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> of the
respective template argument list <span class='texttt'>P</span> is compared with the
corresponding argument <span class='math'><span class='mathtt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> of the corresponding
template argument list of <span class='texttt'>A</span>. If the template argument list
of <span class='texttt'>P</span> contains a pack expansion that is not the last
template argument, the entire template argument list is a non-deduced
context. If <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is a pack expansion, then the pattern
of <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is compared with each remaining argument in the
template argument list of <span class='texttt'>A</span>. Each comparison deduces
template arguments for subsequent positions in the template parameter
packs expanded by <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span>.
During partial ordering (<a href='temp.deduct.partial'>[temp.deduct.partial]</a>), if <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> was
originally a pack expansion:</p><ul class='itemize'><li id='temp.deduct.type-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-9.1'>(9.1)</a></div><p >if <span class='texttt'>P</span> does not contain a template argument corresponding to
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> then <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is ignored;</p></li><li id='temp.deduct.type-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-9.2'>(9.2)</a></div><p >otherwise, if <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is not a pack expansion, template argument
deduction fails.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T1, class... Z&gt; class S;                               <span class='comment'>// #1
</span>template&lt;class T1, class... Z&gt; class S&lt;T1, const Z&amp;...&gt; { };          <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;   class S&lt;T1, const T2&amp;&gt; { };            <span class='comment'>// #3
</span>S&lt;int, const int&amp;&gt; s;         <span class='comment'>// both #2 and #3 match; #3 is more specialized
</span>
template&lt;class T, class... U&gt;            struct A { };                <span class='comment'>// #1
</span>template&lt;class T1, class T2, class... U&gt; struct A&lt;T1, T2*, U...&gt; { }; <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;             struct A&lt;T1, T2&gt; { };        <span class='comment'>// #3
</span>template struct A&lt;int, int*&gt;; <span class='comment'>// selects #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-10'>10</a></div><p >Similarly, if <span class='texttt'>P</span> has a form that contains
<span class='texttt'>(T)</span>, then each parameter type <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span>
of the respective <span class='grammarterm'>parameter-type-list</span> of
<span class='texttt'>P</span> is compared with the corresponding parameter type
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> of the corresponding <span class='grammarterm'>parameter-type-list</span>
of <span class='texttt'>A</span>.
If <span class='texttt'>P</span> and <span class='texttt'>A</span> are function types that originated from deduction when
taking the address of a function template (<a href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a>) or when
deducing template arguments from a function declaration (<a href='temp.deduct.decl'>[temp.deduct.decl]</a>)
and <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> are parameters of the top-level
<span class='grammarterm'>parameter-type-list</span> of <span class='texttt'>P</span> and <span class='texttt'>A</span>, respectively,
<span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is adjusted if it is an rvalue reference to a cv-unqualified template
parameter and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is an lvalue reference, in which case the type of
<span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is changed to be the template parameter type (i.e., <span class='texttt'>T&amp;&amp;</span> is
changed to simply <span class='texttt'>T</span>). [&nbsp;<i>Note:</i> As a result, when <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='texttt'>T&amp;&amp;</span>
and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='texttt'>X&amp;</span>, the adjusted <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> will be <span class='texttt'>T</span>,
causing <span class='texttt'>T</span> to be deduced as <span class='texttt'>X&amp;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; void f(T&amp;&amp;);
template &lt;&gt; void f(int&amp;) { }  <span class='comment'>// #1
</span>template &lt;&gt; void f(int&amp;&amp;) { } <span class='comment'>// #2
</span>void g(int i) {
  f(i);                       <span class='comment'>// calls <span class='texttt'>f&lt;int&amp;&gt;(int&amp;)</span>, i.e., #1
</span>  f(0);                       <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int&amp;&amp;)</span>, i.e., #2
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >If the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i>
corresponding to <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is a function parameter pack,
then the type of its <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is compared with
each remaining parameter type in the <span class='grammarterm'>parameter-type-list</span>
of <span class='texttt'>A</span>. Each comparison deduces template arguments for
subsequent positions in the template parameter packs expanded by the
function parameter pack.
During partial ordering (<a href='temp.deduct.partial'>[temp.deduct.partial]</a>), if <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> was
originally a function parameter pack:</p><ul class='itemize'><li id='temp.deduct.type-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-10.1'>(10.1)</a></div><p >if <span class='texttt'>P</span> does not contain a function parameter type corresponding to
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> then <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is ignored;</p></li><li id='temp.deduct.type-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.deduct.type-10.2'>(10.2)</a></div><p >otherwise, if <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is not a function parameter pack, template
argument deduction fails.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T*, U...) { }    <span class='comment'>// #1
</span>template&lt;class T&gt;             void f(T) { }           <span class='comment'>// #2
</span>template void f(int*);      <span class='comment'>// selects #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-11'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-11'>11</a></div><p >These forms can be used in the same way as
<span class='texttt'>T</span>
is for further composition of types.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
X&lt;int&gt; (*)(char[6])
</pre><p >is of the form</p><pre class='codeblock'>
<span class='grammarterm'>template-name</span>&lt;T&gt; (*)(<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a>[i])
</pre><p >which is a variant of</p><pre class='codeblock'>
<a class='hidden_link' href='#def:type' id='def:type'><i>type</i></a> (*)(T)
</pre><p >where type is
<span class='texttt'>X&lt;int&gt;</span>
and
<span class='texttt'>T</span>
is
<span class='texttt'>char[6]</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-12'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-12'>12</a></div><p >Template arguments cannot be deduced from function arguments involving
constructs other than the ones specified above.</p></div><div class='para' id='temp.deduct.type-13'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-13'>13</a></div><p >A template type argument cannot be deduced from the type of a non-type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>.</p></div><div class='para' id='temp.deduct.type-14'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-14'>14</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T, T i&gt; void f(double a[10][i]);
int v[10][20];
f(v);               <span class='comment'>// error: argument for template-parameter <span class='texttt'>T</span> cannot be deduced
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-15'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-15'>15</a></div><p >[&nbsp;<i>Note:</i>
Except for reference and pointer types, a major array bound is not part of a
function parameter type and cannot be deduced from an argument:</p><pre class='codeblock'>
template&lt;int i&gt; void f1(int a[10][i]);
template&lt;int i&gt; void f2(int a[i][20]);
template&lt;int i&gt; void f3(int (&amp;a)[i][20]);

void g() {
  int v[10][20];
  f1(v);            <span class='comment'>// OK: <span class='texttt'>i</span> deduced to be <span class='texttt'>20</span>
</span>  f1&lt;20&gt;(v);        <span class='comment'>// OK
</span>  f2(v);            <span class='comment'>// error: cannot deduce template-argument <span class='texttt'>i</span>
</span>  f2&lt;10&gt;(v);        <span class='comment'>// OK
</span>  f3(v);            <span class='comment'>// OK: <span class='texttt'>i</span> deduced to be <span class='texttt'>10</span>
</span>}
</pre></div><div class='para' id='temp.deduct.type-16'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-16'>16</a></div><p >If, in the declaration of a function template with a non-type
template parameter, the non-type template parameter
is used in a subexpression in the function parameter list,
the expression is a non-deduced context as specified above.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;int i&gt; class A { <span class='comment'>/* ... */</span> };
template &lt;int i&gt; void g(A&lt;i+1&gt;);
template &lt;int i&gt; void f(A&lt;i&gt;, A&lt;i+1&gt;);
void k() {
  A&lt;1&gt; a1;
  A&lt;2&gt; a2;
  g(a1);            <span class='comment'>// error: deduction fails for expression <span class='texttt'>i+1</span>
</span>  g&lt;0&gt;(a1);         <span class='comment'>// OK
</span>  f(a1, a2);        <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i>
Template parameters do not participate in template argument deduction if
they are used only in non-deduced contexts.
For example,</p><pre class='codeblock'>
template&lt;int i, typename T&gt;
T deduce(typename A&lt;T&gt;::X x,    <span class='comment'>// <span class='texttt'>T</span> is not deduced here
</span>  T t,                          <span class='comment'>// but <span class='texttt'>T</span> is deduced here
</span>  typename B&lt;i&gt;::Y y);          <span class='comment'>// <span class='texttt'>i</span> is not deduced here
</span>A&lt;int&gt; a;
B&lt;77&gt;  b;

int    x = deduce&lt;77&gt;(a.xm, 62, b.ym);
<span class='comment'>// <span class='texttt'>T</span> is deduced to be <span class='texttt'>int</span>, <span class='texttt'>a.xm</span> must be convertible to
</span><span class='comment'>// <span class='texttt'>A&lt;int&gt;::X</span>
</span><span class='comment'>// <span class='texttt'>i</span> is explicitly specified to be <span class='texttt'>77</span>, <span class='texttt'>b.ym</span> must be convertible
</span><span class='comment'>// to <span class='texttt'>B&lt;77&gt;::Y</span>
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-17'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-17'>17</a></div><p >If <span class='texttt'>P</span> has a form that contains <span class='texttt'>&lt;i&gt;</span>, and if the type of the
corresponding value of <span class='texttt'>A</span> differs from the type of <span class='texttt'>i</span>, deduction
fails. If <span class='texttt'>P</span> has a form that contains <span class='texttt'>[i]</span>, and if the type of
<span class='texttt'>i</span> is not an integral type, deduction fails.<a class='footnotenum' href='#footnote-144'>144</a>
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;int i&gt; class A { <span class='comment'>/* ... */</span> };
template&lt;short s&gt; void f(A&lt;s&gt;);
void k1() {
  A&lt;1&gt; a;
  f(a);             <span class='comment'>// error: deduction fails for conversion from <span class='texttt'>int</span> to <span class='texttt'>short</span>
</span>  f&lt;1&gt;(a);          <span class='comment'>// OK
</span>}

template&lt;const short cs&gt; class B { };
template&lt;short s&gt; void g(B&lt;s&gt;);
void k2() {
  B&lt;1&gt; b;
  g(b);             <span class='comment'>// OK: cv-qualifiers are ignored on template parameter types
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-18'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-18'>18</a></div><p >A
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
can be deduced from a function, pointer to function, or pointer to
member function type.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; void f(void(*)(T,int));
template&lt;class T&gt; void foo(T,int);
void g(int,int);
void g(char,int);

void h(int,int,int);
void h(char,int);
int m() {
  f(&amp;g);            <span class='comment'>// error: ambiguous
</span>  f(&amp;h);            <span class='comment'>// OK: void <span class='texttt'>h(char,int)</span> is a unique match
</span>  f(&amp;foo);          <span class='comment'>// error: type deduction fails because <span class='texttt'>foo</span> is a template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-19'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-19'>19</a></div><p >A template
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i>
cannot be deduced from the type of a function default argument.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; void f(T = 5, T = 7);
void g() {
  f(1);             <span class='comment'>// OK: call <span class='texttt'>f&lt;int&gt;(1,7)</span>
</span>  f();              <span class='comment'>// error: cannot deduce <span class='texttt'>T</span>
</span>  f&lt;int&gt;();         <span class='comment'>// OK: call <span class='texttt'>f&lt;int&gt;(5,7)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-20'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-20'>20</a></div><p >The
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
corresponding to a template
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is deduced from the type of the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
of a class template specialization used in the argument list of a function call.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;template &lt;class T&gt; class X&gt; struct A { };
template &lt;template &lt;class T&gt; class X&gt; void f(A&lt;X&gt;) { }
template&lt;class T&gt; struct B { };
A&lt;B&gt; ab;
f(ab);              <span class='comment'>// calls <span class='texttt'>f(A&lt;B&gt;)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.deduct.type-21'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.type-21'>21</a></div><p >[&nbsp;<i>Note:</i> Template argument deduction involving parameter
packs (<a href='temp.variadic'>[temp.variadic]</a>) can deduce zero or more arguments for
each parameter pack. <i>&nbsp;—&nbsp;end note</i>&nbsp;][&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class&gt; struct X { };
template&lt;class R, class ... ArgTypes&gt; struct X&lt;R(int, ArgTypes ...)&gt; { };
template&lt;class ... Types&gt; struct Y { };
template&lt;class T, class ... Types&gt; struct Y&lt;T, Types&amp; ...&gt; { };

template&lt;class ... Types&gt; int f(void (*)(Types ...));
void g(int, float);

X&lt;int&gt; x1;                      <span class='comment'>// uses primary template
</span>X&lt;int(int, float, double)&gt; x2;  <span class='comment'>// uses partial specialization; <span class='texttt'>ArgTypes</span> contains <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>X&lt;int(float, int)&gt; x3;          <span class='comment'>// uses primary template
</span>Y&lt;&gt; y1;                         <span class='comment'>// use primary template; <span class='texttt'>Types</span> is empty
</span>Y&lt;int&amp;, float&amp;, double&amp;&gt; y2;    <span class='comment'>// uses partial specialization; <span class='texttt'>T</span> is <span class='texttt'>int&amp;</span>, <span class='texttt'>Types</span> contains <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>Y&lt;int, float, double&gt; y3;       <span class='comment'>// uses primary template; <span class='texttt'>Types</span> contains <span class='texttt'>int</span>, <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>int fv = f(g);                  <span class='comment'>// OK; <span class='texttt'>Types</span> contains <span class='texttt'>int</span>, <span class='texttt'>float</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-144'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-144'>144)</a></div><p >Although the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
corresponding to a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
of type
<span class='texttt'>bool</span>
may be deduced from an array bound, the resulting value will always be
<span class='texttt'>true</span>
because the array bound will be non-zero.</p></div></div><div id='temp.deduct.decl'><h4 ><a class='secnum' href='#temp.deduct.decl' style='min-width:118pt'>14.8.2.6</a> Deducing template arguments from a function declaration <a class='abbr_ref' href='temp.deduct.decl'>[temp.deduct.decl]</a></h4><div class='para' id='temp.deduct.decl-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.decl-1'>1</a></div><p >In a declaration whose <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> refers to a specialization
of a function template, template argument deduction is performed to identify
the specialization to which the declaration refers. Specifically, this is done
for explicit instantiations (<a href='temp.explicit'>[temp.explicit]</a>), explicit specializations (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
and certain friend declarations (<a href='temp.friend'>[temp.friend]</a>). This is also done to
determine whether a deallocation function template specialization matches a placement
<span class='texttt'>operator new</span> (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>).
In all these cases, <span class='texttt'>P</span> is the type of the function template being considered
as a potential match and <span class='texttt'>A</span> is either the function type from the
declaration
or the type of the deallocation function that would match the placement
<span class='texttt'>operator new</span> as described in <a href='expr.new'>[expr.new]</a>. The
deduction is done as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='temp.deduct.decl-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.deduct.decl-2'>2</a></div><p >If, for the set of function templates so considered, there is either no match or
more than one match after partial ordering has been considered (<a href='temp.func.order'>[temp.func.order]</a>),
deduction fails and, in the declaration cases, the
program is ill-formed.</p></div></div></div><div id='temp.over'><h3 ><a class='secnum' href='#temp.over' style='min-width:103pt'>14.8.3</a> Overload resolution <a class='abbr_ref' href='temp.over'>[temp.over]</a></h3><div class='para' id='temp.over-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,function_template'></a></span>A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name.
When a call to that name is written (explicitly, or implicitly using the
operator notation), template argument deduction (<a href='temp.deduct'>[temp.deduct]</a>)
and checking of any explicit template arguments (<a href='temp.arg'>[temp.arg]</a>) are performed
for each function template to find the template argument values (if any) that
can be used with that function template to instantiate a function template
specialization that can be invoked with the call arguments.
For each function template, if the argument deduction and checking succeeds,
the
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
(deduced and/or explicit)
are used to synthesize the declaration of
a single function template specialization which is
added to the candidate functions set to be used in overload resolution.
If, for a given function template, argument deduction fails, no such function
is added to the set of candidate functions for that template.
The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of
the same name.
The synthesized declarations are
treated like any other functions in
the remainder of overload resolution, except as explicitly noted
in <a href='over.match.best'>[over.match.best]</a>.<a class='footnotenum' href='#footnote-145'>145</a></p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            <span class='comment'>// <span class='texttt'>max(int a, int b)</span>
</span>  char m2 = max(c,d);           <span class='comment'>// <span class='texttt'>max(char a, char b)</span>
</span>  int m3 = max(a,c);            <span class='comment'>// error: cannot generate <span class='texttt'>max(int,char)</span>
</span>}
</pre></div><div class='para' id='temp.over-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-2'>2</a></div><p >Adding the non-template function</p><pre class='codeblock'>
int max(int,int);
</pre><p >to the example above would resolve the third call, by providing a function that
could be called for
<span class='texttt'>max(a,c)</span>
after using the standard conversion of
<span class='texttt'>char</span>
to
<span class='texttt'>int</span>
for
<span class='texttt'>c</span>.</p></div><div class='para' id='temp.over-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-3'>3</a></div><p >Here is an example involving conversions on a function argument involved in
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; struct B { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; struct D : public B&lt;T&gt; { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void f(B&lt;T&gt;&amp;);

void g(B&lt;int&gt;&amp; bi, D&lt;int&gt;&amp; di) {
  f(bi);            <span class='comment'>// <span class='texttt'>f(bi)</span>
</span>  f(di);            <span class='comment'>// <span class='texttt'>f((B&lt;int&gt;&amp;)di)</span>
</span>}
</pre></div><div class='para' id='temp.over-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-4'>4</a></div><p >Here is an example involving conversions on a function argument not involved in
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; void f(T*,int);       <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T,char);       <span class='comment'>// #2
</span>
void h(int* pi, int i, char c) {
  f(pi,i);          <span class='comment'>// #1: <span class='texttt'>f&lt;int&gt;(pi,i)</span>
</span>  f(pi,c);          <span class='comment'>// #2: <span class='texttt'>f&lt;int*&gt;(pi,c)</span>
</span>
  f(i,c);           <span class='comment'>// #2: <span class='texttt'>f&lt;int&gt;(i,c);</span>
</span>  f(i,i);           <span class='comment'>// #2: <span class='texttt'>f&lt;int&gt;(i,char(i))</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.over-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-5'>5</a></div><p >Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions.
Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);    <span class='comment'>// declaration
</span>
void g() {
  f("Annemarie");               <span class='comment'>// call of <span class='texttt'>f&lt;const char*&gt;</span>
</span>}
</pre></div><div class='para' id='temp.over-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.over-6'>6</a></div><p >The call of
<span class='texttt'>f</span>
is well-formed even if the template
<span class='texttt'>f</span>
is only declared and not defined at the point of the call.
The program will be ill-formed unless a specialization for
<span class='texttt'>f&lt;const char*&gt;</span>,
either implicitly or explicitly generated,
is present in some translation unit.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='template'></a></span>
</p></div><div class='footnote' id='footnote-145'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-145'>145)</a></div><p >The parameters of function template
specializations contain no
template parameter types.
The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions.
Non-deduced arguments allow the full range of conversions.
Note also that <a href='over.match.best'>[over.match.best]</a> specifies that a non-template function will
be given preference over a template specialization if the two functions
are otherwise equally good candidates for an overload match.</p></div></div></div></div></body></html>