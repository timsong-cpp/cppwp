<!DOCTYPE html><html lang='en'><head><title>[iterator.primitives]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>24</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><div id='iterator.primitives'><h2 ><a class='secnum' style='min-width:88pt'>24.4</a> Iterator primitives <a class='abbr_ref'>[iterator.primitives]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >To simplify the task of defining iterators, the library provides
several classes and functions:</p></div><div id='iterator.traits'><h3 ><a class='secnum' href='#iterator.traits' style='min-width:103pt'>24.4.1</a> Iterator traits <a class='abbr_ref' href='iterator.traits'>[iterator.traits]</a></h3><div class='para' id='iterator.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-1'>1</a></div><p >To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
<span class='texttt'>Iterator</span>
is the type of an iterator,
the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::iterator_category
</pre><p >be defined as the iterator's difference type, value type and iterator category, respectively.
In addition, the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre><p >shall be defined as the iterator's reference and pointer types, that is, for an
iterator object <span class='texttt'>a</span>, the same type as the type of <span class='texttt'>*a</span> and <span class='texttt'>a-&gt;</span>,
respectively. In the case of an output iterator, the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre><p >may be defined as <span class='texttt'>void</span>.</p></div><div class='para' id='iterator.traits-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-2'>2</a></div><p >The template
<span class='texttt'>iterator_traits&lt;Iterator&gt;</span>
is defined as</p><pre class='codeblock'>
namespace std {
  template&lt;class Iterator&gt; struct iterator_traits {
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
  };
}
</pre></div><div class='para' id='iterator.traits-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-3'>3</a></div><p >It is specialized for pointers as</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct iterator_traits&lt;T*&gt; {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T&amp; reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
</pre><p >and for pointers to const as</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct iterator_traits&lt;const T*&gt; {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef const T* pointer;
    typedef const T&amp; reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
</pre></div><div class='para' id='iterator.traits-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-4'>4</a></div><p >[&nbsp;<i>Example:</i>
To implement a generic
<span class='texttt'>reverse</span>
function, a C++ program can do the following:</p><pre class='codeblock'>
template &lt;class BidirectionalIterator&gt;
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
  typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type n =
    distance(first, last);
  --n;
  while(n &gt; 0) {
    typename iterator_traits&lt;BidirectionalIterator&gt;::value_type
     tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='iterator.basic'><h3 ><a class='secnum' href='#iterator.basic' style='min-width:103pt'>24.4.2</a> Basic iterator <a class='abbr_ref' href='iterator.basic'>[iterator.basic]</a></h3><div class='para' id='iterator.basic-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.basic-1'>1</a></div><p >The
<span class='texttt'>iterator</span>
template may be used as a base class to ease the definition of required types
for new iterators.</p><pre class='codeblock'>
namespace std {
  template&lt;class Category, class T, class Distance = ptrdiff_t,
    class Pointer = T*, class Reference = T&amp;&gt;
  struct iterator {
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
  };
}
</pre></div></div><div id='std.iterator.tags'><h3 ><a class='secnum' href='#std.iterator.tags' style='min-width:103pt'>24.4.3</a> Standard iterator tags <a class='abbr_ref' href='std.iterator.tags'>[std.iterator.tags]</a></h3><div class='para' id='std.iterator.tags-1'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-1'>1</a></div><p ><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
<i>category tag</i>
classes which are used as compile time tags for algorithm selection.
They are:
<span class='texttt'>input_iterator_tag</span>,
<span class='texttt'>output_iterator_tag</span>,
<span class='texttt'>forward_iterator_tag</span>,
<span class='texttt'>bidirectional_iterator_tag</span>
and
<span class='texttt'>random_access_iterator_tag</span>.
For every iterator of type
<span class='texttt'>Iterator</span>,
<span class='texttt'>iterator_traits&lt;Iterator&gt;::iterator_category</span>
shall be defined to be the most specific category tag that describes the
iterator's behavior.</p><pre class='codeblock'>
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
}
</pre></div><div class='para' id='std.iterator.tags-2'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-2'>2</a></div><p ><span class='indexparent'><a class='index' id='empty'></a></span><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>[&nbsp;<i>Example:</i>
For a program-defined iterator
<span class='texttt'>BinaryTreeIterator</span>,
it could be included
into the bidirectional iterator category by specializing the
<span class='texttt'>iterator_traits</span>
template:</p><pre class='codeblock'>
template&lt;class T&gt; struct iterator_traits&lt;BinaryTreeIterator&lt;T&gt; &gt; {
  typedef std::ptrdiff_t difference_type;
  typedef T value_type;
  typedef T* pointer;
  typedef T&amp; reference;
  typedef bidirectional_iterator_tag iterator_category;
};
</pre><p >Typically, however, it would be easier to derive
<span class='texttt'>BinaryTreeIterator&lt;T&gt;</span>
from
<span class='texttt'>iterator&lt;bidirectional_iterator_tag,T,ptrdiff_t,T*,T&amp;&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='std.iterator.tags-3'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-3'>3</a></div><p >[&nbsp;<i>Example:</i>
If
<span class='texttt'>evolve()</span>
is well defined for bidirectional iterators, but can be implemented more
efficiently for random access iterators, then the implementation is as follows:</p><pre class='codeblock'>
template &lt;class BidirectionalIterator&gt;
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits&lt;BidirectionalIterator&gt;::iterator_category());
}

template &lt;class BidirectionalIterator&gt;
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  <span class='comment'>// more generic, but less efficient algorithm
</span>}

template &lt;class RandomAccessIterator&gt;
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  <span class='comment'>// more efficient, but less generic algorithm
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='std.iterator.tags-4'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-4'>4</a></div><p >[&nbsp;<i>Example:</i>
If a C++ program wants to define a bidirectional iterator for some data structure containing
<span class='texttt'>double</span>
and such that it
works on a large memory model of the implementation, it can do so with:</p><pre class='codeblock'>
class MyIterator :
  public iterator&lt;bidirectional_iterator_tag, double, long, T*, T&amp;&gt; {
  <span class='comment'>// code implementing <span class='texttt'>++</span>, etc.
</span>};
</pre></div><div class='para' id='std.iterator.tags-5'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-5'>5</a></div><p >Then there is no need to specialize the
<span class='texttt'>iterator_traits</span>
template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='iterator.operations'><h3 ><a class='secnum' href='#iterator.operations' style='min-width:103pt'>24.4.4</a> Iterator operations <a class='abbr_ref' href='iterator.operations'>[iterator.operations]</a></h3><div class='para' id='iterator.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-1'>1</a></div><p >Since only random access iterators provide
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
operators, the library provides two
function templates
<span class='texttt'>advance</span>
and
<span class='texttt'>distance</span>.
These
function templates
use
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
for random access iterators (and are, therefore, constant
time for them); for input, forward and bidirectional iterators they use
<span class='texttt'>++</span>
to provide linear time
implementations.</p><p ><span class='indexparent'><a class='index' id='advance'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class Distance&gt;
  void advance(InputIterator&amp; i, Distance n);
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>n</span>
shall be negative only for bidirectional and random access iterators.</p></div></div><div class='para' id='iterator.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Increments (or decrements for negative
<span class='texttt'>n</span>)
iterator reference
<span class='texttt'>i</span>
by
<span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='distance'></a></span><code class='itemdecl'>
  template&lt;class InputIterator&gt;
      typename iterator_traits&lt;InputIterator&gt;::difference_type
         distance(InputIterator first, InputIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>InputIterator</span> meets the requirements of random access iterator,
returns <span class='texttt'>(last - first)</span>; otherwise, returns
the number of increments needed to get from
<span class='texttt'>first</span>
to
<span class='texttt'>last</span>.</p></div></div><div class='para' id='iterator.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
If <span class='texttt'>InputIterator</span> meets the requirements of random access iterator,
<span class='texttt'>last</span> shall be reachable from <span class='texttt'>first</span> or <span class='texttt'>first</span> shall be
reachable from <span class='texttt'>last</span>; otherwise,
<span class='texttt'>last</span>
shall be reachable from
<span class='texttt'>first</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='next'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  ForwardIterator next(ForwardIterator x,
    typename std::iterator_traits&lt;ForwardIterator&gt;::difference_type n = 1);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>advance(x, n); return x;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='prev'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator&gt;
  BidirectionalIterator prev(BidirectionalIterator x,
    typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>advance(x, -n); return x;</span>
</p></div></div></div></div></div></body></html>