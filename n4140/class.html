<!DOCTYPE html><html lang='en'><head><title>[class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='class'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><p ><span class='indexparent'><a class='index' id='class'></a></span></p><p ><span class='indexparent'><a class='index' id='class,member_function'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='{},class_declaration'></a></span><span class='indexparent'><a class='index' id='{},class_definition'></a></span><span class='indexparent'><a class='index' id='type,class_and'></a></span><span class='indexparent'><a class='index' id='object_class'></a></span>A class is a type.
<span class='indexparent'><a class='index' id='name_class'></a></span>Its name becomes a <i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>) within its
scope.</p><pre class='bnf'><a id='nt:class-name'>class-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><p ><i ><a href='class#nt:class-specifier'>Class-specifiers</a></i> and
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifiers</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) are used to
make <i ><a href='class#nt:class-name'>class-names</a></i>. An object of a class consists of a
(possibly empty) sequence of members and base class objects.</p><pre class='bnf'><a id='nt:class-specifier'>class-specifier:</a>
    <i ><a href='class#nt:class-head'>class-head</a></i> <span class='terminal'>{</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:class-head'>class-head:</a>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-head-name'>class-head-name</a></i> <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.derived#nt:base-clause'>base-clause</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.derived#nt:base-clause'>base-clause</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:class-head-name'>class-head-name:</a>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-name'>class-name</a></i></pre><pre class='bnf'><a id='nt:class-virt-specifier'>class-virt-specifier:</a>
    <span class='terminal'>final</span></pre><pre class='bnf'><a id='nt:class-key'>class-key:</a>
    <span class='terminal'>class</span>
    <span class='terminal'>struct</span>
    <span class='terminal'>union</span></pre><p >A <i ><a href='class#nt:class-specifier'>class-specifier</a></i> whose
<i ><a href='class#nt:class-head'>class-head</a></i> omits the
<i ><a href='class#nt:class-head-name'>class-head-name</a></i> defines an unnamed class. [&nbsp;<i>Note:</i> An unnamed class thus can't
be <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='class#nt:class-name'>class-name</a></i> is inserted into the scope in which it is
declared immediately after the <i ><a href='class#nt:class-name'>class-name</a></i> is seen. The
<i ><a href='class#nt:class-name'>class-name</a></i> is also inserted into the scope of the class
itself; this is known as the <span class='grammarterm'>injected-class-name</span>.
<span class='indexparent'><a class='index' id='injected-class-name'></a></span>For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
<span class='indexparent'><a class='index' id='definition,class'></a></span>A <i ><a href='class#nt:class-specifier'>class-specifier</a></i> is commonly referred to as a class
definition.
<span class='indexparent'><a class='index' id='definition,class'></a></span>A class is considered defined after the closing brace of its
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> has been seen even though its member
functions are in general not yet defined.
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the class; the attributes in
the <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of the class
whenever it is named.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If a class is marked with the <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i> <span class='texttt'>final</span> and it appears
as a <i ><a href='class.derived#nt:base-type-specifier'>base-type-specifier</a></i> in a <i ><a href='class.derived#nt:base-clause'>base-clause</a></i>
(Clause <a href='class.derived'>[class.derived]</a>), the program is ill-formed. Whenever a
<i ><a href='class#nt:class-key'>class-key</a></i> is followed by a <i ><a href='class#nt:class-head-name'>class-head-name</a></i>, the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='texttt'>final</span>, and a colon or left brace, <span class='texttt'>final</span> is
interpreted as a <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i>. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A;
struct A final {};      <span class='comment'>// OK: definition of <span class='texttt'>struct A</span>,
</span>                        <span class='comment'>// not value-initialization of variable <span class='texttt'>final</span>
</span>
struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B final : C{};  <span class='comment'>// OK: definition of nested class <span class='texttt'>B</span>,
</span>                        <span class='comment'>// not declaration of a bit-field member <span class='texttt'>final</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Complete objects and member subobjects of class type shall have nonzero
size.<a class='footnotenum' href='#footnote-108'>108</a>
[&nbsp;<i>Note:</i>
Class objects can be assigned, passed as arguments to functions, and
returned by functions (except objects of classes for which copying or moving has
been restricted; see <a href='class.copy'>[class.copy]</a>). Other plausible operators, such
as equality comparison, can be defined by the user; see <a href='over.oper'>[over.oper]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='struct,class_versus'></a></span><span class='indexparent'><a class='index' id='structure'></a></span><span class='indexparent'><a class='index' id='union,class_versus'></a></span>A <a class='hidden_link' href='#def:union' id='def:union'><i>union</i></a> is a class defined with the <i ><a href='class#nt:class-key'>class-key</a></i>
<span class='texttt'>union</span>;
<span class='indexparent'><a class='index' id='access_control,union'></a></span>it holds at most one data member at a time (<a href='class.union'>[class.union]</a>).
[&nbsp;<i>Note:</i>
Aggregates of class type are described in <a href='dcl.init.aggr'>[dcl.init.aggr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='class,trivial'></a></span><span class='indexparent'><a class='index' id='trivial_class'></a></span></p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A <a class='hidden_link' href='#def:trivially_copyable_class' id='def:trivially_copyable_class'><i>trivially copyable class</i></a> is a class that:</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >has no non-trivial copy constructors (<a href='class.copy'>[class.copy]</a>),
</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >has no non-trivial move constructors (<a href='class.copy'>[class.copy]</a>),
</p></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div><p >has no non-trivial copy assignment operators (<a href='over.ass'>[over.ass]</a>, <a href='class.copy'>[class.copy]</a>),
</p></li><li id='6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.4'>(6.4)</a></div><p >has no non-trivial move assignment operators (<a href='over.ass'>[over.ass]</a>, <a href='class.copy'>[class.copy]</a>), and
</p></li><li id='6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.5'>(6.5)</a></div><p >has a trivial destructor (<a href='class.dtor'>[class.dtor]</a>).
</p></li></ul><p >A <a class='hidden_link' href='#def:trivial_class' id='def:trivial_class'><i>trivial class</i></a> is a class that has a default
constructor (<a href='class.ctor'>[class.ctor]</a>), has no non-trivial default constructors, and is trivially copyable.
[&nbsp;<i>Note:</i> In particular, a trivially copyable or trivial class does not have
virtual functions or virtual base classes.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='class,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_class'></a></span></p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A <span class='grammarterm'>standard-layout class</span> is a class that:</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >has no non-static data members of type non-standard-layout class
(or array of such types) or reference,</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >has no virtual functions (<a href='class.virtual'>[class.virtual]</a>) and no
virtual base classes (<a href='class.mi'>[class.mi]</a>),</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >has the same access control (Clause <a href='class.access'>[class.access]</a>)
for all non-static data members,</p></li><li id='7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.4'>(7.4)</a></div><p >has no non-standard-layout base classes,</p></li><li id='7.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.5'>(7.5)</a></div><p >either has no non-static data members in the most derived class
and at most one base class with non-static data members, or has no base
classes with non-static data members, and</p></li><li id='7.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.6'>(7.6)</a></div><p >has no base classes of the same type as the first non-static
data member.<a class='footnotenum' href='#footnote-109'>109</a>
</p></li></ul><p ><span class='indexparent'><a class='index' id='struct,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_struct'></a></span><span class='indexparent'><a class='index' id='union,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_union'></a></span></p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A <span class='grammarterm'>standard-layout struct</span> is a standard-layout class
defined with the <i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>struct</span> or the
<i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>class</span>.
A <span class='grammarterm'>standard-layout union</span> is a standard-layout class
defined with the
<i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>union</span>.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i> Standard-layout classes are useful for communicating with
code written in other programming languages. Their layout is specified
in <a href='class.mem'>[class.mem]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='POD_struct'></a></span><span class='indexparent'><a class='index' id='POD_class'></a></span><span class='indexparent'><a class='index' id='POD_union'></a></span>A <a class='hidden_link' href='#def:POD_struct' id='def:POD_struct'><i>POD struct</i></a><a class='footnotenum' href='#footnote-110'>110</a>
is a non-union class that is both a trivial class and a
standard-layout class, and has no non-static data members of type non-POD struct,
non-POD union (or array of such types). Similarly, a
<a class='hidden_link' href='#def:POD_union' id='def:POD_union'><i>POD union</i></a> is a union that is both a trivial class and a standard-layout
class, and has no non-static data members of type non-POD struct, non-POD
union (or array of such types). A <a class='hidden_link' href='#def:POD_class' id='def:POD_class'><i>POD class</i></a> is a
class that is either a POD struct or a POD union.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct N {          <span class='comment'>// neither trivial nor standard-layout
</span>  int i;
  int j;
  virtual ~N();
};

struct T {          <span class='comment'>// trivial but not standard-layout
</span>  int i;
private: 
  int j;
};

struct SL {         <span class='comment'>// standard-layout but not trivial
</span>  int i;
  int j;
  ~SL();
};

struct POD {        <span class='comment'>// both trivial and standard-layout
</span>  int i;
  int j;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >If a <i ><a href='class#nt:class-head-name'>class-head-name</a></i> contains a <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>,
the <i ><a href='class#nt:class-specifier'>class-specifier</a></i> shall refer to a class that was
previously declared directly in the class or namespace to which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> refers,
or in an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>) of that namespace
(i.e., not merely inherited or
introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>), and the
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> shall appear in a namespace enclosing the
previous declaration.
In such cases, the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> of the
<i ><a href='class#nt:class-head-name'>class-head-name</a></i> of the
definition shall not begin with a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.</p></div><div class='footnote' id='footnote-108'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-108'>108)</a></div><p >Base class subobjects are not so constrained.</p></div><div class='footnote' id='footnote-109'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-109'>109)</a></div><p >This ensures that two subobjects that have the
same class type and that
belong to the same most derived object are not allocated at the same
address (<a href='expr.eq'>[expr.eq]</a>).</p></div><div class='footnote' id='footnote-110'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-110'>110)</a></div><p >The acronym POD stands for “plain old data”.</p></div><div id='name'><h2 ><a class='secnum' href='#name' style='min-width:88pt'>9.1</a> Class names <a class='abbr_ref' href='class.name'>[class.name]</a></h2><p ><span class='indexparent'><a class='index' id='definition,class_name_as_type'></a></span><span class='indexparent'><a class='index' id='structure_tag'></a></span><span class='indexparent'><a class='index' id='equivalence,type'></a></span>
</p><div class='para' id='name-1'><div class='marginalizedparent'><a class='marginalized' href='#name-1'>1</a></div><p >A class definition introduces a new type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
</pre><p >declares three variables of three different types. This implies that</p><pre class='codeblock'>
a1 = a2;                        <span class='comment'>// error: <span class='texttt'>Y</span> assigned to <span class='texttt'>X</span>
</span>a1 = a3;                        <span class='comment'>// error: <span class='texttt'>int</span> assigned to <span class='texttt'>X</span>
</span></pre><p >are type mismatches, and that</p><pre class='codeblock'>
int f(X);
int f(Y);
</pre><p ><span class='indexparent'><a class='index' id='overloading'></a></span>declare an overloaded (Clause <a href='over'>[over]</a>) function <span class='texttt'>f()</span> and not
simply a single function <span class='texttt'>f()</span> twice. For the same reason,</p><pre class='codeblock'>
struct S { int a; };
struct S { int a; };            <span class='comment'>// error, double definition
</span></pre><p >is ill-formed because it defines <span class='texttt'>S</span> twice.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='name-2'><div class='marginalizedparent'><a class='marginalized' href='#name-2'>2</a></div><p ><span class='indexparent'><a class='index' id='definition,scope_of_class'></a></span><span class='indexparent'><a class='index' id='class_name,scope_of'></a></span>A class declaration introduces the class name into the scope where
<span class='indexparent'><a class='index' id='name_hiding,class_definition'></a></span>it is declared and hides any
class, variable, function, or other declaration of that name in an
enclosing scope (<a href='basic.scope'>[basic.scope]</a>). If a class name is declared in a
scope where a variable, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='basic.lookup.elab'>[basic.lookup.elab]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct stat {
  <span class='comment'>// ...
</span>};

stat gstat;                     <span class='comment'>// use plain <span class='texttt'>stat</span> to
</span>                                <span class='comment'>// define variable
</span>
int stat(struct stat*);         <span class='comment'>// redeclare <span class='texttt'>stat</span> as function
</span>
void f() {
  struct stat* ps;              <span class='comment'>// <span class='texttt'>struct</span> prefix needed
</span>                                <span class='comment'>// to name <span class='texttt'>struct stat</span>
</span>  stat(ps);                     <span class='comment'>// call <span class='texttt'>stat()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='declaration,forward_class'></a></span>A <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> consisting solely of <span class='grammarterm'>class-key
identifier;</span> is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct s { int a; };

void g() {
  struct s;                     <span class='comment'>// hide global <span class='texttt'>struct s</span>
</span>                                <span class='comment'>// with a block-scope declaration
</span>  s* p;                         <span class='comment'>// refer to local <span class='texttt'>struct s</span>
</span>  struct s { char* p; };        <span class='comment'>// define local <span class='texttt'>struct s</span>
</span>  struct s;                     <span class='comment'>// redeclaration, has no effect
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Such declarations allow definition of classes that refer to each other.
<span class='indexparent'><a class='index' id='example,friend'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class Vector;

class Matrix {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};

class Vector {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};
</pre><p >Declaration of <span class='texttt'>friend</span>s is described in <a href='class.friend'>[class.friend]</a>,
operator functions in <a href='over.oper'>[over.oper]</a>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='name-3'><div class='marginalizedparent'><a class='marginalized' href='#name-3'>3</a></div><p ><span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='elaborated_type_specifier'></a></span>[&nbsp;<i>Note:</i>
An <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) can also
be used as a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   <span class='comment'>// global <span class='texttt'>s</span>
</span>  p-&gt;a = s;                     <span class='comment'>// parameter <span class='texttt'>s</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='name-4'><div class='marginalizedparent'><a class='marginalized' href='#name-4'>4</a></div><p ><span class='indexparent'><a class='index' id='class_name,point_of_declaration'></a></span>[&nbsp;<i>Note:</i>
The declaration of a class name takes effect immediately after the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is seen in the class definition or
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. For example,</p><pre class='codeblock'>
class A * A;
</pre><p >first specifies <span class='texttt'>A</span> to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form <span class='texttt'>class</span> <span class='texttt'>A</span> must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='name-5'><div class='marginalizedparent'><a class='marginalized' href='#name-5'>5</a></div><p ><span class='indexparent'><a class='index' id='class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>) that names a class type,
or a cv-qualified version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i>. If a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a cv-qualified class type is used
where a <i ><a href='class#nt:class-name'>class-name</a></i> is required, the cv-qualifiers are
ignored. A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> shall not be used as the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='class#nt:class-head'>class-head</a></i>.</p></div></div><div id='mem'><h2 ><a class='secnum' href='#mem' style='min-width:88pt'>9.2</a> Class members <a class='abbr_ref' href='class.mem'>[class.mem]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,member'></a></span><span class='indexparent'><a class='index' id='data_member'></a></span></p><pre class='bnf'><a id='nt:member-specification'>member-specification:</a>
    <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class.derived#nt:access-specifier'>access-specifier</a></i> <span class='terminal'>:</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:member-declaration'>member-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
    <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
    <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>
    <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>
    <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
    <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i></pre><pre class='bnf'><a id='nt:member-declarator-list'>member-declarator-list:</a>
    <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>
    <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> <span class='terminal'>,</span> <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i></pre><pre class='bnf'><a id='nt:member-declarator'>member-declarator:</a>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><pre class='bnf'><a id='nt:virt-specifier-seq'>virt-specifier-seq:</a>
    <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>
    <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i></pre><pre class='bnf'><a id='nt:virt-specifier'>virt-specifier:</a>
    <span class='terminal'>override</span>
    <span class='terminal'>final</span></pre><pre class='bnf'><a id='nt:pure-specifier'>pure-specifier:</a>
    <span class='terminal'>= 0</span></pre><div class='para' id='mem-1'><div class='marginalizedparent'><a class='marginalized' href='#mem-1'>1</a></div><p ><span class='indexparent'><a class='index' id='definition,class'></a></span>The <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> in a class definition declares the
full set of members of the class; no member can be added elsewhere.
Members of a class are data members, member
functions (<a href='class.mfct'>[class.mfct]</a>), nested types, and enumerators. Data
members and member functions are static or non-static;
see <a href='class.static'>[class.static]</a>. Nested types are
classes (<a href='class.name'>[class.name]</a>, <a href='class.nest'>[class.nest]</a>) and
enumerations (<a href='dcl.enum'>[dcl.enum]</a>) defined in the class, and arbitrary types
declared as members by use of a typedef declaration (<a href='dcl.typedef'>[dcl.typedef]</a>).
The enumerators of an unscoped enumeration (<a href='dcl.enum'>[dcl.enum]</a>) defined in the class
are members of the class. Except when used to declare
friends (<a href='class.friend'>[class.friend]</a>), to declare an unnamed bit-field (<a href='class.bit'>[class.bit]</a>),
or to introduce the name of a member of a
base class into a derived
class (<a href='namespace.udecl'>[namespace.udecl]</a>), or when the declaration is an
<i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i>,
<i ><a href='class.mem#nt:member-declaration'>member-declarations</a></i> declare members of the class, and each
such <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> shall declare at least one member
name of the class. A member shall not be declared twice in the
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, except that a nested class or member
class template can be declared and then later defined, and except that an
enumeration can be introduced with an <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> and later
redeclared with an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.</p></div><div class='para' id='mem-2'><div class='marginalizedparent'><a class='marginalized' href='#mem-2'>2</a></div><p ><span class='indexparent'><a class='index' id='completely_defined'></a></span>A class is considered a completely-defined object
type (<a href='basic.types'>[basic.types]</a>) (or complete type) at the closing <span class='texttt'>}</span> of
the <i ><a href='class#nt:class-specifier'>class-specifier</a></i>.
Within the class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, the class is regarded as complete
within function bodies, default arguments,
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> introducing inheriting
constructors (<a href='class.inhctor'>[class.inhctor]</a>),
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i>, and
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> for non-static data members
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>.</p></div><div class='para' id='mem-3'><div class='marginalizedparent'><a class='marginalized' href='#mem-3'>3</a></div><p >[&nbsp;<i>Note:</i>
A single name can denote several function members provided their types
are sufficiently different (Clause <a href='over'>[over]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-4'><div class='marginalizedparent'><a class='marginalized' href='#mem-4'>4</a></div><p >A <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> shall appear only in the
declaration of a data member. (For static data members,
see <a href='class.static.data'>[class.static.data]</a>; for non-static data members,
see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='mem-5'><div class='marginalizedparent'><a class='marginalized' href='#mem-5'>5</a></div><p >A member shall not be declared with the <span class='texttt'>extern</span>
or <span class='texttt'>register</span>
<span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i>. Within a class definition, a member shall not be declared with the <span class='texttt'>thread_local</span> <span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i> unless also declared <span class='texttt'>static</span>.</p></div><div class='para' id='mem-6'><div class='marginalizedparent'><a class='marginalized' href='#mem-6'>6</a></div><p >The <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall contain a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that is not a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i>.
The
<i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> can be omitted only after a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> or an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> or in a
<span class='texttt'>friend</span> declaration (<a href='class.friend'>[class.friend]</a>). A
<i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i> shall be used only in the declaration of a
virtual function (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='mem-7'><div class='marginalizedparent'><a class='marginalized' href='#mem-7'>7</a></div><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>
appertains to each of the entities declared by the <i ><a href='class.mem#nt:member-declarator'>member-declarators</a></i>;
it shall not appear if the optional <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> is omitted.</p></div><div class='para' id='mem-8'><div class='marginalizedparent'><a class='marginalized' href='#mem-8'>8</a></div><p >A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> shall contain at most one of each
<i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>.
A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i>
shall appear only in the declaration of a virtual member
function (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='mem-9'><div class='marginalizedparent'><a class='marginalized' href='#mem-9'>9</a></div><p ><span class='indexparent'><a class='index' id='class_object,member'></a></span>Non-<span class='texttt'>static</span> (<a href='class.static'>[class.static]</a>) data members shall not have
incomplete types. In particular, a class <span class='texttt'>C</span> shall not contain a
non-static member of class <span class='texttt'>C</span>, but it can contain a pointer or
reference to an object of class <span class='texttt'>C</span>.</p></div><div class='para' id='mem-10'><div class='marginalizedparent'><a class='marginalized' href='#mem-10'>10</a></div><p >[&nbsp;<i>Note:</i>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-11'><div class='marginalizedparent'><a class='marginalized' href='#mem-11'>11</a></div><p >[&nbsp;<i>Note:</i>
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-12'><div class='marginalizedparent'><a class='marginalized' href='#mem-12'>12</a></div><p ><span class='indexparent'><a class='index' id='example,class_definition'></a></span>[&nbsp;<i>Example:</i>
A simple example of a class definition is</p><pre class='codeblock'>
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
</pre><p >which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration</p><pre class='codeblock'>
tnode s, *sp;
</pre><p >declares <span class='texttt'>s</span> to be a <span class='texttt'>tnode</span> and <span class='texttt'>sp</span> to be a pointer
to a <span class='texttt'>tnode</span>. With these declarations, <span class='texttt'>sp-&gt;count</span> refers to
the <span class='texttt'>count</span> member of the object to which <span class='texttt'>sp</span> points;
<span class='texttt'>s.left</span> refers to the <span class='texttt'>left</span> subtree pointer of the object
<span class='texttt'>s</span>; and <span class='texttt'>s.right-&gt;tword[0]</span> refers to the initial character
of the <span class='texttt'>tword</span> member of the <span class='texttt'>right</span> subtree of <span class='texttt'>s</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-13'><div class='marginalizedparent'><a class='marginalized' href='#mem-13'>13</a></div><p ><span class='indexparent'><a class='index' id='layout,class_object'></a></span>Nonstatic data members of a (non-union) class
with the same access control (Clause <a href='class.access'>[class.access]</a>)
are allocated so that later
members have higher addresses within a class object.
<span class='indexparent'><a class='index' id='allocation,unspecified'></a></span>The order of allocation of non-static data members
with different access control
is unspecified (Clause <a href='class.access'>[class.access]</a>).
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions (<a href='class.virtual'>[class.virtual]</a>) and
virtual base classes (<a href='class.mi'>[class.mi]</a>).</p></div><div class='para' id='mem-14'><div class='marginalizedparent'><a class='marginalized' href='#mem-14'>14</a></div><p >If <span class='texttt'>T</span> is the name of a class, then each of the following shall
have a name different from <span class='texttt'>T</span>:</p><ul class='itemize'><li id='mem-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-14.1'>(14.1)</a></div><p >every static data member of class <span class='texttt'>T</span>;</p></li><li id='mem-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-14.2'>(14.2)</a></div><p >every member function of class <span class='texttt'>T</span>
[&nbsp;<i>Note:</i>
This restriction does not apply to constructors, which do not have
names (<a href='class.ctor'>[class.ctor]</a>)
<i>&nbsp;—&nbsp;end note</i>&nbsp;];</p></li><li id='mem-14.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-14.3'>(14.3)</a></div><p >every member of class <span class='texttt'>T</span> that is itself a type;</p></li><li id='mem-14.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-14.4'>(14.4)</a></div><p >every enumerator of every member of class <span class='texttt'>T</span> that is an
unscoped enumerated type; and</p></li><li id='mem-14.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-14.5'>(14.5)</a></div><p >every member of every anonymous union that is a member of class
<span class='texttt'>T</span>.
</p></li></ul></div><div class='para' id='mem-15'><div class='marginalizedparent'><a class='marginalized' href='#mem-15'>15</a></div><p >In addition, if class <span class='texttt'>T</span> has a user-declared
constructor (<a href='class.ctor'>[class.ctor]</a>), every non-static data member of class
<span class='texttt'>T</span> shall have a name different from <span class='texttt'>T</span>.</p></div><div class='para' id='mem-16'><div class='marginalizedparent'><a class='marginalized' href='#mem-16'>16</a></div><p >Two standard-layout struct (Clause <a href='class'>[class]</a>) types are <a class='hidden_link' href='#def:layout-compatible' id='def:layout-compatible'><i>layout-compatible</i></a> if they
have the same number of non-static data members and corresponding
non-static data members (in declaration order) have layout-compatible
types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='mem-17'><div class='marginalizedparent'><a class='marginalized' href='#mem-17'>17</a></div><p >Two standard-layout union (Clause <a href='class'>[class]</a>) types are <a class='hidden_link' href='#def:layout-compatible' id='def:layout-compatible'><i>layout-compatible</i></a> if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='mem-18'><div class='marginalizedparent'><a class='marginalized' href='#mem-18'>18</a></div><p >If a standard-layout union contains two or more
standard-layout structs that share a common
initial sequence, and if the standard-layout union object currently contains one of
these standard-layout structs, it is permitted to inspect the common initial part of
any of them. Two standard-layout structs share a common initial sequence if
corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.</p></div><div class='para' id='mem-19'><div class='marginalizedparent'><a class='marginalized' href='#mem-19'>19</a></div><p >If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member. Otherwise, its
address is the same as the address of its first base class subobject (if any).
[&nbsp;<i>Note:</i>
There might therefore be unnamed padding within a standard-layout struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='mfct'><h2 ><a class='secnum' href='#mfct' style='min-width:88pt'>9.3</a> Member functions <a class='abbr_ref' href='class.mfct'>[class.mfct]</a></h2><p ><span class='indexparent'><a class='index' id='member_function,class'></a></span></p><div class='para' id='mfct-1'><div class='marginalizedparent'><a class='marginalized' href='#mfct-1'>1</a></div><p >Functions declared in the definition of a class, excluding those
declared with a <span class='texttt'>friend</span> specifier (<a href='class.friend'>[class.friend]</a>), are
called member functions of that class. A member function may be declared
<span class='texttt'>static</span> in which case it is a <a class='hidden_link' href='#def:static' id='def:static'><i>static</i></a> member function
of its class (<a href='class.static'>[class.static]</a>); otherwise it is a
<span class='grammarterm'>non-static</span> member function of its
class (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>, <a href='class.this'>[class.this]</a>).</p></div><div class='para' id='mfct-2'><div class='marginalizedparent'><a class='marginalized' href='#mfct-2'>2</a></div><p ><span class='indexparent'><a class='index' id='member_function,inline'></a></span><span class='indexparent'><a class='index' id='definition,member_function'></a></span>A member function may be defined (<a href='dcl.fct.def'>[dcl.fct.def]</a>) in its class
definition, in which case it is an <a class='hidden_link' href='#def:inline' id='def:inline'><i>inline</i></a> member
function (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>), or it may be defined outside of its class
definition if it has already been declared but not defined in its class
definition. A member function definition that appears outside of the
class definition shall appear in a namespace scope enclosing the class
definition. Except for member function definitions that appear outside
of a class definition, and except for explicit specializations of member
functions of class templates and member function
templates (<a href='temp.spec'>[temp.spec]</a>) appearing outside of the class definition, a
member function shall not be redeclared.</p></div><div class='para' id='mfct-3'><div class='marginalizedparent'><a class='marginalized' href='#mfct-3'>3</a></div><p >An <span class='texttt'>inline</span> member function (whether static or non-static) may
also be defined outside of its class definition provided either its
declaration in the class definition or its definition outside of the
class definition declares the function as <span class='texttt'>inline</span>.
[&nbsp;<i>Note:</i>
Member functions of a class in namespace scope have external linkage.
Member functions of a local class (<a href='class.local'>[class.local]</a>) have no linkage.
See <a href='basic.link'>[basic.link]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mfct-4'><div class='marginalizedparent'><a class='marginalized' href='#mfct-4'>4</a></div><p >There shall be at most one definition of a non-inline member function in
a program; no diagnostic is required. There may be more than one
<span class='texttt'>inline</span> member function definition in a program.
See <a href='basic.def.odr'>[basic.def.odr]</a> and <a href='dcl.fct.spec'>[dcl.fct.spec]</a>.</p></div><div class='para' id='mfct-5'><div class='marginalizedparent'><a class='marginalized' href='#mfct-5'>5</a></div><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span>If the definition of a member function is lexically outside its class
definition, the member function name shall be qualified by its class
name using the <span class='texttt'>::</span> operator.
[&nbsp;<i>Note:</i>
A name used in a member function definition (that is, in the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> including the default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>) or in the member function body) is looked up
as described in <a href='basic.lookup'>[basic.lookup]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X {
  typedef int T;
  static T count;
  void f(T);
};
void X::f(T t = count) { }
</pre><p >The member function <span class='texttt'>f</span> of class <span class='texttt'>X</span> is defined in global
scope; the notation <span class='texttt'>X::f</span> specifies that the function <span class='texttt'>f</span>
is a member of class <span class='texttt'>X</span> and in the scope of class <span class='texttt'>X</span>. In
the function definition, the parameter type <span class='texttt'>T</span> refers to the
typedef member <span class='texttt'>T</span> declared in class <span class='texttt'>X</span> and the default
argument <span class='texttt'>count</span> refers to the static data member <span class='texttt'>count</span>
declared in class <span class='texttt'>X</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct-6'><div class='marginalizedparent'><a class='marginalized' href='#mfct-6'>6</a></div><p >A <span class='texttt'>static</span> local variable in a member function always refers to
the same object, whether or not the member function is <span class='texttt'>inline</span>.</p></div><div class='para' id='mfct-7'><div class='marginalizedparent'><a class='marginalized' href='#mfct-7'>7</a></div><p >Previously declared member functions may be mentioned in <span class='texttt'>friend</span> declarations.</p></div><div class='para' id='mfct-8'><div class='marginalizedparent'><a class='marginalized' href='#mfct-8'>8</a></div><p ><span class='indexparent'><a class='index' id='local_class,member_function_in'></a></span>Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.</p></div><div class='para' id='mfct-9'><div class='marginalizedparent'><a class='marginalized' href='#mfct-9'>9</a></div><p >[&nbsp;<i>Note:</i>
A member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see <a href='dcl.fct'>[dcl.fct]</a>. For example,</p><pre class='codeblock'>
typedef void fv(void);
typedef void fvc(void) const;
struct S {
  fv memfunc1;      <span class='comment'>// equivalent to: <span class='texttt'>void memfunc1(void);</span>
</span>  void memfunc2();
  fvc memfunc3;     <span class='comment'>// equivalent to: <span class='texttt'>void memfunc3(void) const;</span>
</span>};
fv  S::* pmfv1 = &amp;S::memfunc1;
fv  S::* pmfv2 = &amp;S::memfunc2;
fvc S::* pmfv3 = &amp;S::memfunc3;
</pre><p >Also see <a href='temp.arg'>[temp.arg]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='mfct.non-static'><h3 ><a class='secnum' href='#mfct.non-static' style='min-width:103pt'>9.3.1</a> Nonstatic member functions <a class='abbr_ref' href='class.mfct.non-static'>[class.mfct.non-static]</a></h3><p ><span class='indexparent'><a class='index' id='member_function,nonstatic'></a></span></p><div class='para' id='mfct.non-static-1'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-1'>1</a></div><p >A <span class='grammarterm'>non-static</span> member function may be called for an object of
its class type, or for an object of a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from its class type, using the class member
access syntax (<a href='expr.ref'>[expr.ref]</a>, <a href='over.match.call'>[over.match.call]</a>). A non-static
member function may also be called directly using the function call
syntax (<a href='expr.call'>[expr.call]</a>, <a href='over.match.call'>[over.match.call]</a>) from within
the body of a member function of its class or of a class derived from
its class.</p></div><div class='para' id='mfct.non-static-2'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-2'>2</a></div><p ><span class='indexparent'><a class='index' id='member_function,call_undefined'></a></span>If a non-static member function of a class <span class='texttt'>X</span> is called for an
object that is not of type <span class='texttt'>X</span>, or of a type derived from
<span class='texttt'>X</span>, the behavior is undefined.</p></div><div class='para' id='mfct.non-static-3'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-3'>3</a></div><p >When an <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> (<a href='expr.prim'>[expr.prim]</a>) that is not part of a
class member access syntax (<a href='expr.ref'>[expr.ref]</a>) and not used to form a
pointer to member (<a href='expr.unary.op'>[expr.unary.op]</a>) is used in
a member of class <span class='texttt'>X</span> in a context where <span class='texttt'>this</span> can be
used (<a href='expr.prim.general'>[expr.prim.general]</a>),
if name
lookup (<a href='basic.lookup'>[basic.lookup]</a>) resolves the name in the
<i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> to a non-static non-type member of some class
<span class='texttt'>C</span>,
and if either the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is potentially evaluated or
<span class='texttt'>C</span> is <span class='texttt'>X</span> or a base class of <span class='texttt'>X</span>,
the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is transformed into a class
member access expression (<a href='expr.ref'>[expr.ref]</a>) using
<span class='texttt'>(*this)</span> (<a href='class.this'>[class.this]</a>) as the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
to the left of the <span class='texttt'>.</span> operator.
[&nbsp;<i>Note:</i>
If <span class='texttt'>C</span> is not <span class='texttt'>X</span> or a base class of <span class='texttt'>X</span>, the class
member access expression is ill-formed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Similarly during name lookup, when an
<i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) used in the definition of a
member function for class <span class='texttt'>X</span> resolves to a <span class='texttt'>static</span> member,
an enumerator or a nested type of class <span class='texttt'>X</span> or of a base class of
<span class='texttt'>X</span>, the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> is transformed into a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> names the class of the member function.
<span class='indexparent'><a class='index' id='example,member_function'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
  void set(const char*, tnode* l, tnode* r);
};

void tnode::set(const char* w, tnode* l, tnode* r) {
  count = strlen(w)+1;
  if (sizeof(tword)&lt;=count)
      perror("tnode string too long");
  strcpy(tword,w);
  left = l;
  right = r;
}

void f(tnode n1, tnode n2) {
  n1.set("abc",&amp;n2,0);
  n2.set("def",0,0);
}
</pre><p >In the body of the member function <span class='texttt'>tnode::set</span>, the member names
<span class='texttt'>tword</span>, <span class='texttt'>count</span>, <span class='texttt'>left</span>, and <span class='texttt'>right</span> refer to
members of the object for which the function is called. Thus, in the
call <span class='texttt'>n1.set("abc",&amp;n2,0)</span>, <span class='texttt'>tword</span> refers to
<span class='texttt'>n1.tword</span>, and in the call <span class='texttt'>n2.set("def",0,0)</span>, it refers
to <span class='texttt'>n2.tword</span>. The functions <span class='texttt'>strlen</span>, <span class='texttt'>perror</span>, and
<span class='texttt'>strcpy</span> are not members of the class <span class='texttt'>tnode</span> and should be
declared elsewhere.<a class='footnotenum' href='#footnote-111'>111</a>
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct.non-static-4'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-4'>4</a></div><p >A non-static member function may be declared <span class='texttt'>const</span>,
<span class='texttt'>volatile</span>, or <span class='texttt'>const</span> <span class='texttt'>volatile</span>. These
<span class='grammarterm'>cv-qualifiers</span> affect the type of the <span class='texttt'>this</span>
pointer (<a href='class.this'>[class.this]</a>). They also affect the function
type (<a href='dcl.fct'>[dcl.fct]</a>) of the member function; a member function declared
<span class='texttt'>const</span> is a <a class='hidden_link' href='#def:const' id='def:const'><i>const</i></a> member function, a member function
declared <span class='texttt'>volatile</span> is a <a class='hidden_link' href='#def:volatile' id='def:volatile'><i>volatile</i></a> member function and a
member function declared <span class='texttt'>const</span> <span class='texttt'>volatile</span> is a
<a class='hidden_link' href='#def:const_volatile' id='def:const_volatile'><i>const volatile</i></a> member function.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X {
  void g() const;
  void h() const volatile;
};
</pre><p ><span class='texttt'>X::g</span> is a <span class='texttt'>const</span> member function and <span class='texttt'>X::h</span> is a
<span class='texttt'>const</span> <span class='texttt'>volatile</span> member function.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct.non-static-5'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-5'>5</a></div><p >A non-static member function may be declared with a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (<a href='dcl.fct'>[dcl.fct]</a>); see <a href='over.match.funcs'>[over.match.funcs]</a>.</p></div><div class='para' id='mfct.non-static-6'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-6'>6</a></div><p >A non-static member function may be declared
<a class='hidden_link' href='#def:virtual' id='def:virtual'><i>virtual</i></a> (<a href='class.virtual'>[class.virtual]</a>) or <a class='hidden_link' href='#def:pure_virtual' id='def:pure_virtual'><i>pure virtual</i></a> (<a href='class.abstract'>[class.abstract]</a>).</p></div><div class='footnote' id='footnote-111'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-111'>111)</a></div><p >See, for example, <span class='texttt'>&lt;cstring&gt;</span> (<a href='c.strings'>[c.strings]</a>).</p></div></div><div id='this'><h3 ><a class='secnum' href='#this' style='min-width:103pt'>9.3.2</a> The <span class='texttt'>this</span> pointer <a class='abbr_ref' href='class.this'>[class.this]</a></h3><p ><span class='indexparent'><a class='index' id='this'></a></span>
<span class='indexparent'><a class='index' id='member_function,this'></a></span></p><div class='para' id='this-1'><div class='marginalizedparent'><a class='marginalized' href='#this-1'>1</a></div><p ><span class='indexparent'><a class='index' id='this_pointer'></a></span>In the body of a non-static (<a href='class.mfct'>[class.mfct]</a>) member function, the
keyword <span class='texttt'>this</span> is a prvalue expression whose value is the
address of the object for which the function is called.
<span class='indexparent'><a class='index' id='this,type_of'></a></span>The type of <span class='texttt'>this</span> in a member function of a class <span class='texttt'>X</span> is
<span class='texttt'>X*</span>.
<span class='indexparent'><a class='index' id='member_function,const'></a></span>If the member function is declared <span class='texttt'>const</span>, the type of
<span class='texttt'>this</span> is <span class='texttt'>const</span> <span class='texttt'>X*</span>,
<span class='indexparent'><a class='index' id='member_function,volatile'></a></span>if the member function is declared <span class='texttt'>volatile</span>, the type of
<span class='texttt'>this</span> is <span class='texttt'>volatile</span> <span class='texttt'>X*</span>, and if the member function
is declared <span class='texttt'>const</span> <span class='texttt'>volatile</span>, the type of <span class='texttt'>this</span> is
<span class='texttt'>const</span> <span class='texttt'>volatile</span> <span class='texttt'>X*</span>.
<span class='indexparent'><a class='index' id='member_function,const'></a></span>[&nbsp;<i>Note:</i> thus in a <span class='texttt'>const</span> member function, the object for which the function is
called is accessed through a <span class='texttt'>const</span> access path. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct s {
  int a;
  int f() const;
  int g() { return a++; }
  int h() const { return a++; } <span class='comment'>// error
</span>};

int s::f() const { return a; }
</pre><p >The <span class='texttt'>a++</span> in the body of <span class='texttt'>s::h</span> is ill-formed because it
tries to modify (a part of) the object for which <span class='texttt'>s::h()</span> is
called. This is not allowed in a <span class='texttt'>const</span> member function because
<span class='texttt'>this</span> is a pointer to <span class='texttt'>const</span>; that is, <span class='texttt'>*this</span> has
<span class='texttt'>const</span> type.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='this-2'><div class='marginalizedparent'><a class='marginalized' href='#this-2'>2</a></div><p >Similarly, <span class='texttt'>volatile</span> semantics (<a href='dcl.type.cv'>[dcl.type.cv]</a>) apply in
<span class='texttt'>volatile</span> member functions when accessing the object and its
non-static data members.</p></div><div class='para' id='this-3'><div class='marginalizedparent'><a class='marginalized' href='#this-3'>3</a></div><p >A <span class='grammarterm'>cv-qualified</span> member function can be called on an
object-expression (<a href='expr.ref'>[expr.ref]</a>) only if the object-expression is as
cv-qualified or less-cv-qualified than the member function.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void k(s&amp; x, const s&amp; y) {
  x.f();
  x.g();
  y.f();
  y.g();                        <span class='comment'>// error
</span>}
</pre><p >The call <span class='texttt'>y.g()</span> is ill-formed because <span class='texttt'>y</span> is <span class='texttt'>const</span>
and <span class='texttt'>s::g()</span> is a non-<span class='texttt'>const</span> member function, that is,
<span class='texttt'>s::g()</span> is less-qualified than the object-expression <span class='texttt'>y</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='this-4'><div class='marginalizedparent'><a class='marginalized' href='#this-4'>4</a></div><p ><span class='indexparent'><a class='index' id='const,constructor_and'></a></span><span class='indexparent'><a class='index' id='const,destructor_and'></a></span><span class='indexparent'><a class='index' id='volatile,constructor_and'></a></span><span class='indexparent'><a class='index' id='volatile,destructor_and'></a></span>Constructors (<a href='class.ctor'>[class.ctor]</a>) and destructors (<a href='class.dtor'>[class.dtor]</a>) shall
not be declared <span class='texttt'>const</span>, <span class='texttt'>volatile</span> or <span class='texttt'>const</span>
<span class='texttt'>volatile</span>. [&nbsp;<i>Note:</i> However, these functions can be invoked to
create and destroy objects with cv-qualified types,
see (<a href='class.ctor'>[class.ctor]</a>) and (<a href='class.dtor'>[class.dtor]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='static'><h2 ><a class='secnum' href='#static' style='min-width:88pt'>9.4</a> Static members <a class='abbr_ref' href='class.static'>[class.static]</a></h2><p ><span class='indexparent'><a class='index' id='member,static'></a></span><span class='indexparent'><a class='index' id='member_function,static'></a></span>
</p><div class='para' id='static-1'><div class='marginalizedparent'><a class='marginalized' href='#static-1'>1</a></div><p >A data or function member of a class may be declared <span class='texttt'>static</span> in a
class definition, in which case it is a <a class='hidden_link' href='#def:static_member' id='def:static_member'><i>static member</i></a> of the class.</p></div><div class='para' id='static-2'><div class='marginalizedparent'><a class='marginalized' href='#static-2'>2</a></div><p >A <span class='texttt'>static</span> member <span class='texttt'>s</span> of class <span class='texttt'>X</span> may be referred to
using the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> expression <span class='texttt'>X::s</span>; it is not
necessary to use the class member access syntax (<a href='expr.ref'>[expr.ref]</a>) to
refer to a <span class='texttt'>static</span> member. A <span class='texttt'>static</span> member may be
referred to using the class member access syntax, in which case the
object expression is evaluated.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct process {
  static void reschedule();
};
process&amp; g();

void f() {
  process::reschedule();        <span class='comment'>// OK: no object necessary
</span>  g().reschedule();             <span class='comment'>// <span class='texttt'>g()</span> is called
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='static-3'><div class='marginalizedparent'><a class='marginalized' href='#static-3'>3</a></div><p >A <span class='texttt'>static</span> member may be referred to directly in the scope of its
class or in the scope of a class derived (Clause <a href='class.derived'>[class.derived]</a>)
from its class; in this case, the <span class='texttt'>static</span> member is referred to
as if a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> expression was used, with the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> of the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> naming
the class scope from which the static member is referenced.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int g();
struct X {
  static int g();
};
struct Y : X {
  static int i;
};
int Y::i = g();                 <span class='comment'>// equivalent to <span class='texttt'>Y::g();</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='static-4'><div class='marginalizedparent'><a class='marginalized' href='#static-4'>4</a></div><p >If an <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) is used in the
definition of a <span class='texttt'>static</span> member following the member's
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>, and name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>)
finds that the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> refers to a <span class='texttt'>static</span>
member, enumerator, or nested type of the member's class (or of a base
class of the member's class), the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> is
transformed into a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> expression in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> names the class scope from which the
member is referenced.
[&nbsp;<i>Note:</i>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static-5'><div class='marginalizedparent'><a class='marginalized' href='#static-5'>5</a></div><p >Static members obey the usual class member access rules
(Clause <a href='class.access'>[class.access]</a>). When used in the declaration of a class
member, the <span class='texttt'>static</span> specifier shall only be used in the member
declarations that appear within the <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> of
the class definition.
[&nbsp;<i>Note:</i>
It cannot be specified in member declarations that appear in namespace scope.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='static.mfct'><h3 ><a class='secnum' href='#static.mfct' style='min-width:103pt'>9.4.1</a> Static member functions <a class='abbr_ref' href='class.static.mfct'>[class.static.mfct]</a></h3><p ><span class='indexparent'><a class='index' id='member_function,static'></a></span>
</p><div class='para' id='static.mfct-1'><div class='marginalizedparent'><a class='marginalized' href='#static.mfct-1'>1</a></div><p >[&nbsp;<i>Note:</i>
The rules described in <a href='class.mfct'>[class.mfct]</a> apply to <span class='texttt'>static</span> member
functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static.mfct-2'><div class='marginalizedparent'><a class='marginalized' href='#static.mfct-2'>2</a></div><p >[&nbsp;<i>Note:</i>
A <span class='texttt'>static</span> member function does not have a <span class='texttt'>this</span>
pointer (<a href='class.this'>[class.this]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
A <span class='texttt'>static</span> member function shall not be <span class='texttt'>virtual</span>. There
shall not be a <span class='texttt'>static</span> and a non-static member function with the
same name and the same parameter types (<a href='over.load'>[over.load]</a>). A
<span class='texttt'>static</span> member function shall not be declared <span class='texttt'>const</span>,
<span class='texttt'>volatile</span>, or <span class='texttt'>const volatile</span>.</p></div></div><div id='static.data'><h3 ><a class='secnum' href='#static.data' style='min-width:103pt'>9.4.2</a> Static data members <a class='abbr_ref' href='class.static.data'>[class.static.data]</a></h3><p ><span class='indexparent'><a class='index' id='member_data,static'></a></span>
</p><div class='para' id='static.data-1'><div class='marginalizedparent'><a class='marginalized' href='#static.data-1'>1</a></div><p >A <span class='texttt'>static</span> data member is not part of the subobjects of a class. If a
<span class='texttt'>static</span> data member is declared <span class='texttt'>thread_local</span> there is one copy of
the member per thread. If a <span class='texttt'>static</span> data member is not declared
<span class='texttt'>thread_local</span> there is one copy of the data member that is shared by all
the objects of the class.</p></div><div class='para' id='static.data-2'><div class='marginalizedparent'><a class='marginalized' href='#static.data-2'>2</a></div><p ><span class='indexparent'><a class='index' id='initialization,static_member'></a></span><span class='indexparent'><a class='index' id='definition,static_member'></a></span>The declaration of a <span class='texttt'>static</span> data member in its class definition
is not a definition and may be of an incomplete type other than
cv-qualified <span class='texttt'>void</span>. The definition for a <span class='texttt'>static</span> data
member shall appear in a namespace scope enclosing the member's class
definition.
<span class='indexparent'><a class='index' id='operator_use,scope_resolution'></a></span>In the definition at namespace scope, the name of the <span class='texttt'>static</span>
data member shall be qualified by its class name using the <span class='texttt'>::</span>
operator. The <i ><a href='dcl.init#nt:initializer'>initializer</a></i> expression in the definition of a
<span class='texttt'>static</span> data member is in the scope of its
class (<a href='basic.scope.class'>[basic.scope.class]</a>).
<span class='indexparent'><a class='index' id='example,static'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class process {
  static process* run_chain;
  static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
</pre><p >The <span class='texttt'>static</span> data member <span class='texttt'>run_chain</span> of class
<span class='texttt'>process</span> is defined in global scope; the notation
<span class='texttt'>process<span class='discretionary'></span>::<span class='discretionary'></span>run_chain</span> specifies that the member <span class='texttt'>run_chain</span>
is a member of class <span class='texttt'>process</span> and in the scope of class
<span class='texttt'>process</span>. In the <span class='texttt'>static</span> data member definition, the
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> expression refers to the <span class='texttt'>static</span> data
member <span class='texttt'>running</span> of class <span class='texttt'>process</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i>
Once the <span class='texttt'>static</span> data member has been defined, it exists even if
no objects of its class have been created.
[&nbsp;<i>Example:</i>
in the example above, <span class='texttt'>run_chain</span> and <span class='texttt'>running</span> exist even
if no objects of class <span class='texttt'>process</span> are created by the program.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static.data-3'><div class='marginalizedparent'><a class='marginalized' href='#static.data-3'>3</a></div><p >If a non-volatile <span class='texttt'>const</span> <span class='texttt'>static</span> data member is
of integral or enumeration type,
its declaration in the class definition can specify a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> in which every
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> that is an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is a constant expression (<a href='expr.const'>[expr.const]</a>). A <span class='texttt'>static</span> data member of
literal type can be declared in the class definition with the
<span class='texttt'>constexpr</span> specifier; if so, its declaration shall specify a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> in which every
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> that is an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is a constant expression. [&nbsp;<i>Note:</i> In both these cases,
the member may appear in constant expressions. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The
member shall still be defined in a namespace scope if
it is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in the program and the
namespace scope definition shall not contain an <i ><a href='dcl.init#nt:initializer'>initializer</a></i>.</p></div><div class='para' id='static.data-4'><div class='marginalizedparent'><a class='marginalized' href='#static.data-4'>4</a></div><p >[&nbsp;<i>Note:</i>
There shall be exactly one definition of a <span class='texttt'>static</span> data member
that is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in a program; no diagnostic is required.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Unnamed classes and classes contained directly
or indirectly within unnamed classes shall not contain <span class='texttt'>static</span>
data members.</p></div><div class='para' id='static.data-5'><div class='marginalizedparent'><a class='marginalized' href='#static.data-5'>5</a></div><p ><span class='indexparent'><a class='index' id='restriction,static'></a></span><span class='texttt'>Static</span> data members of a class in namespace scope have external
linkage (<a href='basic.link'>[basic.link]</a>). A local class shall not have <span class='texttt'>static</span>
data members.</p></div><div class='para' id='static.data-6'><div class='marginalizedparent'><a class='marginalized' href='#static.data-6'>6</a></div><p ><span class='texttt'>Static</span> data members are initialized and destroyed exactly like
non-local variables (<a href='basic.start.init'>[basic.start.init]</a>, <a href='basic.start.term'>[basic.start.term]</a>).</p></div><div class='para' id='static.data-7'><div class='marginalizedparent'><a class='marginalized' href='#static.data-7'>7</a></div><p >A <span class='texttt'>static</span> data member shall not be
<span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>).</p></div></div></div><div id='union'><h2 ><a class='secnum' href='#union' style='min-width:88pt'>9.5</a> Unions <a class='abbr_ref' href='class.union'>[class.union]</a></h2><p ><span class='indexparent'><a class='index' id='union'></a></span></p><div class='para' id='union-1'><div class='marginalizedparent'><a class='marginalized' href='#union-1'>1</a></div><p >In a union, at most one of the non-static data members can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. [&nbsp;<i>Note:</i> One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (<a href='class.mem'>[class.mem]</a>), and if an object of this
standard-layout union type contains one of the standard-layout structs, it is permitted
to inspect the common initial sequence of any of standard-layout struct members;
see <a href='class.mem'>[class.mem]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct. All non-static data members of a
union object have the same address.</p></div><div class='para' id='union-2'><div class='marginalizedparent'><a class='marginalized' href='#union-2'>2</a></div><p ><span class='indexparent'><a class='index' id='member_function,union'></a></span><span class='indexparent'><a class='index' id='constructor,union'></a></span><span class='indexparent'><a class='index' id='destructor,union'></a></span>A union can have member functions (including constructors and destructors),
<span class='indexparent'><a class='index' id='restriction,union'></a></span>but not virtual (<a href='class.virtual'>[class.virtual]</a>) functions. A union shall not have
base classes. A union shall not be used as a base class.
<span class='indexparent'><a class='index' id='restriction,union'></a></span>If a union contains a non-static data member of
reference type the program is ill-formed.
[&nbsp;<i>Note:</i> If any non-static data member of a union has a non-trivial
default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy constructor (<a href='class.copy'>[class.copy]</a>),
move constructor (<a href='class.copy'>[class.copy]</a>),
copy assignment operator (<a href='class.copy'>[class.copy]</a>),
move assignment operator (<a href='class.copy'>[class.copy]</a>),
or destructor (<a href='class.dtor'>[class.dtor]</a>), the corresponding member function
of the union must be user-provided or it will
be implicitly deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>) for the union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union-3'><div class='marginalizedparent'><a class='marginalized' href='#union-3'>3</a></div><p >[&nbsp;<i>Example:</i> Consider the following union:</p><pre class='codeblock'>
union U {
  int i;
  float f;
  std::string s;
};
</pre><p >Since <span class='texttt'>std::string</span> (<a href='string.classes'>[string.classes]</a>) declares non-trivial versions of all of the special
member functions, <span class='texttt'>U</span> will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use <span class='texttt'>U</span>, some or all of these member functions
must be user-provided.<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union-4'><div class='marginalizedparent'><a class='marginalized' href='#union-4'>4</a></div><p >[&nbsp;<i>Note:</i> In general, one must use explicit destructor calls and placement
new operators to change the active member of a union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
Consider an object <span class='texttt'>u</span> of a <span class='texttt'>union</span> type <span class='texttt'>U</span> having non-static data members
<span class='texttt'>m</span> of type <span class='texttt'>M</span> and <span class='texttt'>n</span> of type <span class='texttt'>N</span>. If <span class='texttt'>M</span> has a non-trivial
destructor and <span class='texttt'>N</span> has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of <span class='texttt'>u</span> can be safely switched from <span class='texttt'>m</span> to
<span class='texttt'>n</span> using the destructor and placement new operator as follows:</p><pre class='codeblock'>
u.m.~M();
new (&amp;u.n) N;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union-5'><div class='marginalizedparent'><a class='marginalized' href='#union-5'>5</a></div><p ><span class='indexparent'><a class='index' id='union,anonymous'></a></span>A union of the form</p><pre class='bnf'><span class='terminal'>union</span> <span class='terminal'>{</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> <span class='terminal'>}</span> <span class='terminal'>;</span></pre><p >is called an <a class='hidden_link' href='#def:anonymous_union' id='def:anonymous_union'><i>anonymous union</i></a>; it defines an unnamed object of unnamed
type. The <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> of an anonymous union shall
only define non-static data members.
[&nbsp;<i>Note:</i>
Nested types, anonymous unions, and functions cannot be declared within an anonymous
union.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
<span class='indexparent'><a class='index' id='initialization,union'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
</pre><p >Here <span class='texttt'>a</span> and <span class='texttt'>p</span> are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union-6'><div class='marginalizedparent'><a class='marginalized' href='#union-6'>6</a></div><p ><span class='indexparent'><a class='index' id='union,global_anonymous'></a></span><span class='indexparent'><a class='index' id='scope,anonymous_union_at_namespace'></a></span>Anonymous unions declared in a named namespace or in the global
namespace shall be declared <span class='texttt'>static</span>. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
<span class='indexparent'><a class='index' id='access_control,anonymous_union'></a></span><span class='indexparent'><a class='index' id='restriction,anonymous_union'></a></span>An anonymous union shall not have <span class='texttt'>private</span> or <span class='texttt'>protected</span>
members (Clause <a href='class.access'>[class.access]</a>). An anonymous union shall not have
function members.</p></div><div class='para' id='union-7'><div class='marginalizedparent'><a class='marginalized' href='#union-7'>7</a></div><p >A union for which objects, pointers, or references are declared is not an anonymous union.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f() {
  union { int aa; char* p; } obj, *ptr = &amp;obj;
  aa = 1;                         <span class='comment'>// error
</span>  ptr-&gt;aa = 1;                    <span class='comment'>// OK
</span>}
</pre><p >The assignment to plain <span class='texttt'>aa</span> is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Initialization of unions with no user-declared constructors is described
in (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union-8'><div class='marginalizedparent'><a class='marginalized' href='#union-8'>8</a></div><p >A <a class='hidden_link' href='#def:union-like_class' id='def:union-like_class'><i>union-like class</i></a> is a union or a class that has an anonymous union as a direct
member. A union-like class <span class='texttt'>X</span> has a set of <a class='hidden_link' href='#def:variant_members' id='def:variant_members'><i>variant members</i></a>.
If <span class='texttt'>X</span> is a union, a non-static data member of <span class='texttt'>X</span> that is not an anonymous
union is a variant member of <span class='texttt'>X</span>. In addition, a non-static data member of an
anonymous union that is a member of <span class='texttt'>X</span> is also a variant member of <span class='texttt'>X</span>.
At most one variant member of a union may have a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
union U {
  int x = 0;
  union { };
  union {
    int z;
    int y = 1; <span class='comment'>// error: initialization for second variant member of <span class='texttt'>U</span>
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='bit'><h2 ><a class='secnum' href='#bit' style='min-width:88pt'>9.6</a> Bit-fields <a class='abbr_ref' href='class.bit'>[class.bit]</a></h2><p ><span class='indexparent'><a class='index' id='bit-field'></a></span></p><div class='para' id='bit-1'><div class='marginalizedparent'><a class='marginalized' href='#bit-1'>1</a></div><p >A <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i> of the form</p><pre class='bnf'><i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>  <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><p ><span class='indexparent'><a class='index' id=':,field_declaration'></a></span><span class='indexparent'><a class='index' id='declaration,bit-field'></a></span>specifies a bit-field;
its length is set off from the bit-field name by a colon. The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the entity being declared. The bit-field
attribute is not part of the type of the class member. The
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be an integral constant expression
with a value greater than or equal to zero. The
value of the integral constant expression may
be larger than the number of bits in the object
representation (<a href='basic.types'>[basic.types]</a>) of the bit-field's type; in such
cases the extra bits are used as padding bits and do not participate in
the value representation (<a href='basic.types'>[basic.types]</a>) of the bit-field.
<span class='indexparent'><a class='index' id='allocation,implementation_defined_bit-field'></a></span>Allocation of bit-fields within a class object is
<span class='indexparent'><a class='index' id='allocation_of_bit-fields_within_a_class_object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='bit-field,implementation_defined_alignment_of'></a></span>Alignment of bit-fields is <span class='indexparent'><a class='index' id='alignment_of_bit-fields_within_a_class_object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='layout,bit-field'></a></span>Bit-fields are packed into some addressable allocation unit.
[&nbsp;<i>Note:</i>
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='bit-2'><div class='marginalizedparent'><a class='marginalized' href='#bit-2'>2</a></div><p ><span class='indexparent'><a class='index' id='bit-field,unnamed'></a></span>A declaration for a bit-field that omits the <i ><a href='lex.name#nt:identifier'>identifier</a></i>
declares an <span class='grammarterm'>unnamed</span> bit-field. Unnamed bit-fields are not
members and cannot be initialized.
[&nbsp;<i>Note:</i>
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='bit-field,zero_width_of'></a></span><span class='indexparent'><a class='index' id='bit-field,alignment_of'></a></span>As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the value of the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> be equal to zero.</p></div><div class='para' id='bit-3'><div class='marginalizedparent'><a class='marginalized' href='#bit-3'>3</a></div><p ><span class='indexparent'><a class='index' id='bit-field,type_of'></a></span>A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type (<a href='basic.fundamental'>[basic.fundamental]</a>).
<span class='indexparent'><a class='index' id='Boolean'></a></span>A <span class='texttt'>bool</span> value can successfully be stored in a bit-field of any
nonzero size.
<span class='indexparent'><a class='index' id='bit-field,address_of'></a></span>The address-of operator <span class='texttt'>&amp;</span> shall not be applied to a bit-field,
so there are no pointers to bit-fields.
<span class='indexparent'><a class='index' id='restriction,bit-field'></a></span><span class='indexparent'><a class='index' id='restriction,address_of_bit-field'></a></span><span class='indexparent'><a class='index' id='restriction,pointer_to_bit-field'></a></span>A non-const reference shall not be bound to a
bit-field (<a href='dcl.init.ref'>[dcl.init.ref]</a>).
[&nbsp;<i>Note:</i>
If the initializer for a reference of type <span class='texttt'>const</span> <span class='texttt'>T&amp;</span> is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See <a href='dcl.init.ref'>[dcl.init.ref]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='bit-4'><div class='marginalizedparent'><a class='marginalized' href='#bit-4'>4</a></div><p >If the value <span class='texttt'>true</span> or <span class='texttt'>false</span> is stored into a bit-field of
type <span class='texttt'>bool</span> of any size (including a one bit bit-field), the
original <span class='texttt'>bool</span> value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type (<a href='dcl.enum'>[dcl.enum]</a>),
the original enumerator value and the value of the bit-field shall
compare equal.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              <span class='comment'>// yields <span class='texttt'>true</span>
</span>    { <span class='comment'>/* ... */</span> }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='nest'><h2 ><a class='secnum' href='#nest' style='min-width:88pt'>9.7</a> Nested class declarations <a class='abbr_ref' href='class.nest'>[class.nest]</a></h2><p ><span class='indexparent'><a class='index' id='definition,nested_class'></a></span><span class='indexparent'><a class='index' id='class_local'></a></span><span class='indexparent'><a class='index' id='class_nested'></a></span></p><div class='para' id='nest-1'><div class='marginalizedparent'><a class='marginalized' href='#nest-1'>1</a></div><p >A class can be declared within another class. A class declared within
another is called a <span class='grammarterm'>nested</span> class. The name of a nested class
is local to its enclosing class.
<span class='indexparent'><a class='index' id='nested_class,scope_of'></a></span>The nested class is in the scope of its enclosing class.
[&nbsp;<i>Note:</i>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='example,nested_class'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x;
int y;

struct enclose {
  int x;
  static int s;

  struct inner {
    void f(int i) {
      int a = sizeof(x);        <span class='comment'>// OK: operand of sizeof is an unevaluated operand
</span>      x = i;                    <span class='comment'>// error: assign to <span class='texttt'>enclose::x</span>
</span>      s = i;                    <span class='comment'>// OK: assign to <span class='texttt'>enclose::s</span>
</span>      ::x = i;                  <span class='comment'>// OK: assign to global <span class='texttt'>x</span>
</span>      y = i;                    <span class='comment'>// OK: assign to global <span class='texttt'>y</span>
</span>    }
    void g(enclose* p, int i) {
      p-&gt;x = i;                 <span class='comment'>// OK: assign to <span class='texttt'>enclose::x</span>
</span>    }
  };
};

inner* p = 0;                   <span class='comment'>// error: <span class='texttt'>inner</span> not in scope
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-2'><div class='marginalizedparent'><a class='marginalized' href='#nest-2'>2</a></div><p >Member functions and static data members of a nested class can be
defined in a namespace scope enclosing the definition of their class.
<span class='indexparent'><a class='index' id='example,nested_class_definition'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct enclose {
  struct inner {
    static int x;
    void f(int i);
  };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { <span class='comment'>/* ... */</span> }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-3'><div class='marginalizedparent'><a class='marginalized' href='#nest-3'>3</a></div><p >If class <span class='texttt'>X</span> is defined in a namespace scope, a nested class
<span class='texttt'>Y</span> may be declared in class <span class='texttt'>X</span> and later defined in the
definition of class <span class='texttt'>X</span> or be later defined in a namespace scope
enclosing the definition of class <span class='texttt'>X</span>.
<span class='indexparent'><a class='index' id='example,nested_class_forward_declaration'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class E {
  class I1;                     <span class='comment'>// forward declaration of nested class
</span>  class I2;
  class I1 { };                 <span class='comment'>// definition of nested class
</span>};
class E::I2 { };                <span class='comment'>// definition of nested class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-4'><div class='marginalizedparent'><a class='marginalized' href='#nest-4'>4</a></div><p ><span class='indexparent'><a class='index' id='friend_function,nested_class'></a></span>Like a member function, a friend function (<a href='class.friend'>[class.friend]</a>) defined
within a nested class is in the lexical scope of that class; it obeys
the same rules for name binding as a static member function of that
class (<a href='class.static'>[class.static]</a>), but it has no special access rights to
members of an enclosing class.</p></div></div><div id='local'><h2 ><a class='secnum' href='#local' style='min-width:88pt'>9.8</a> Local class declarations <a class='abbr_ref' href='class.local'>[class.local]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,local_class'></a></span><span class='indexparent'><a class='index' id='definition,local_class'></a></span>
</p><div class='para' id='local-1'><div class='marginalizedparent'><a class='marginalized' href='#local-1'>1</a></div><p >A class can be declared within a function definition; such a class is
called a <span class='grammarterm'>local</span> class. The name of a local class is local to
its enclosing scope.
<span class='indexparent'><a class='index' id='local_class,scope_of'></a></span>The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function.
Declarations in a local class
shall not odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) a variable with automatic storage
duration from an
enclosing scope.
[&nbsp;<i>Example:</i>
<span class='indexparent'><a class='index' id='example,local_class'></a></span></p><pre class='codeblock'>
int x;
void f() {
  static int s ;
  int x;
  const int N = 5;
  extern int q();

  struct local {
    int g() { return x; }       <span class='comment'>// error: odr-use of automatic variable <span class='texttt'>x</span>
</span>    int h() { return s; }       <span class='comment'>// OK
</span>    int k() { return ::x; }     <span class='comment'>// OK
</span>    int l() { return q(); }     <span class='comment'>// OK
</span>    int m() { return N; }       <span class='comment'>// OK: not an odr-use
</span>    int* n() { return &amp;N; }     <span class='comment'>// error: odr-use of automatic variable <span class='texttt'>N</span>
</span>  };
}

local* p = 0;                   <span class='comment'>// error: <span class='texttt'>local</span> not in scope
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-2'><div class='marginalizedparent'><a class='marginalized' href='#local-2'>2</a></div><p >An enclosing function has no special access to members of the local
class; it obeys the usual access rules (Clause <a href='class.access'>[class.access]</a>).
<span class='indexparent'><a class='index' id='member_function,local_class'></a></span>Member functions of a local class shall be defined within their class
definition, if they are defined at all.</p></div><div class='para' id='local-3'><div class='marginalizedparent'><a class='marginalized' href='#local-3'>3</a></div><p ><span class='indexparent'><a class='index' id='nested_class,local_class'></a></span>If class <span class='texttt'>X</span> is a local class a nested class <span class='texttt'>Y</span> may be
declared in class <span class='texttt'>X</span> and later defined in the definition of class
<span class='texttt'>X</span> or be later defined in the same scope as the definition of
class <span class='texttt'>X</span>.
<span class='indexparent'><a class='index' id='restriction,local_class'></a></span>A class nested within
a local class is a local class.</p></div><div class='para' id='local-4'><div class='marginalizedparent'><a class='marginalized' href='#local-4'>4</a></div><p >A local class shall not have static data members.</p></div></div><div id='nested.type'><h2 ><a class='secnum' href='#nested.type' style='min-width:88pt'>9.9</a> Nested type names <a class='abbr_ref' href='class.nested.type'>[class.nested.type]</a></h2><p ><span class='indexparent'><a class='index' id='type_name,nested'></a></span><span class='indexparent'><a class='index' id='type_name,nested,scope_of'></a></span>
</p><div class='para' id='nested.type-1'><div class='marginalizedparent'><a class='marginalized' href='#nested.type-1'>1</a></div><p >Type names obey exactly the same scope rules as other names. In
particular, type names defined within a class definition cannot be used
outside their class without qualification.
[&nbsp;<i>Example:</i></p><p ><span class='indexparent'><a class='index' id='example,nested_type_name'></a></span></p><pre class='codeblock'>
struct X {
  typedef int I;
  class Y { <span class='comment'>/* ... */</span> };
  I a;
};

I b;                            <span class='comment'>// error
</span>Y c;                            <span class='comment'>// error
</span>X::Y d;                         <span class='comment'>// OK
</span>X::I e;                         <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='class'></a></span>
</p></div></div></div></div></body></html>