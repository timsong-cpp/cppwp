<!DOCTYPE html><html lang='en'><head><title>[temp.decls]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><div id='temp.decls'><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref'>[temp.decls]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A
<i ><a href='temp.names#nt:template-id'>template-id</a></i>,
that is, the
<i ><a href='temp.names#nt:template-name'>template-name</a></i>
followed by a
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>
shall not be specified in the declaration of a primary template declaration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2, I&gt; { };     <span class='comment'>// error
</span>template&lt;class T1, int I&gt; void sort&lt;T1, I&gt;(T1 data[I]);         <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
However, this syntax is allowed in class template partial specializations (<a href='temp.class.spec'>[temp.class.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For purposes of name lookup and instantiation,
default arguments and <i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> of function
templates and default arguments and <i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> of
member functions of class templates are considered definitions;
each default argument or <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is a separate
definition which is unrelated to
the function template definition or to any other default arguments or
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Because an <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i> cannot declare a
<i ><a href='temp.names#nt:template-id'>template-id</a></i>, it is not possible to partially or
explicitly specialize an alias template.</p></div><div id='temp.class'><h3 ><a class='secnum' href='#temp.class' style='min-width:103pt'>14.5.1</a> Class templates <a class='abbr_ref' href='temp.class'>[temp.class]</a></h3><div class='para' id='temp.class-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class-1'>1</a></div><p >A class
<a class='hidden_link' href='#def:template' id='def:template'><i>template</i></a>
defines the layout and operations
for an unbounded set of related types.
[&nbsp;<i>Example:</i>
a single class template
<span class='texttt'>List</span>
might provide a common definition for
list of
<span class='texttt'>int</span>,
list of
<span class='texttt'>float</span>,
and list of pointers to
<span class='texttt'>Shape</span>s.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
An array class template might be declared like this:</p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};
</pre></div><div class='para' id='temp.class-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class-2'>2</a></div><p >The prefix
<span class='texttt'>template</span>
<span class='texttt'>&lt;class</span>
<span class='texttt'>T&gt;</span>
specifies that a template is being declared and that a
<i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
<span class='texttt'>T</span>
will be used in the declaration.
In other words,
<span class='texttt'>Array</span>
is a parameterized type with
<span class='texttt'>T</span>
as its parameter.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.class-3'>3</a></div><p >When a member function, a member class, a member enumeration, a static data member or
a member template of a class
template is defined outside of the class template definition,
the member definition is defined as a template definition in which the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
are those of the class template.
The names of the template parameters used in the definition of the member may
be different from the template parameter names used in the class
template definition.
The template argument list following the class template name in the member
definition shall name the parameters in the same order as the one used in
the template parameter list of the member. Each template
parameter pack shall be expanded with an ellipsis in the template
argument list.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T1, class T2&gt; struct A {
  void f1();
  void f2();
};

template&lt;class T2, class T1&gt; void A&lt;T2,T1&gt;::f1() { }    <span class='comment'>// OK
</span>template&lt;class T2, class T1&gt; void A&lt;T1,T2&gt;::f2() { }    <span class='comment'>// error
</span></pre><pre class='codeblock'>
template&lt;class ... Types&gt; struct B {
  void f3();
  void f4();
};

template&lt;class ... Types&gt; void B&lt;Types ...&gt;::f3() { }    <span class='comment'>// OK
</span>template&lt;class ... Types&gt; void B&lt;Types&gt;::f4() { }        <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.class-4'>4</a></div><p >In a redeclaration, partial
specialization,
explicit specialization or explicit
instantiation of a class template, the
<i ><a href='class#nt:class-key'>class-key</a></i>
shall agree in kind with the original class template declaration (<a href='dcl.type.elab'>[dcl.type.elab]</a>).</p></div><div id='temp.mem.func'><h4 ><a class='secnum' href='#temp.mem.func' style='min-width:118pt'>14.5.1.1</a> Member functions of class templates <a class='abbr_ref' href='temp.mem.func'>[temp.mem.func]</a></h4><div class='para' id='temp.mem.func-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.func-1'>1</a></div><p ><span class='indexparent'><a class='index' id='template,member_function'></a></span>A member function
of a class template
may be defined outside of the class
template definition in which it is declared.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};
</pre><p >declares three function templates.
The subscript function might be defined like this:</p><pre class='codeblock'>
template&lt;class T&gt; T&amp; Array&lt;T&gt;::operator[](int i) {
  if (i&lt;0 || sz&lt;=i) error("Array: range error");
  return v[i];
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.mem.func-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.func-2'>2</a></div><p >The
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
for a member function of a class template are determined by the
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
of the type of the object for which the member function is called.
[&nbsp;<i>Example:</i>
the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
for
<span class='texttt'>Array&lt;T&gt;&nbsp;::&nbsp;operator&nbsp;[]&nbsp;()</span>
will be determined by the
<span class='texttt'>Array</span>
to which the subscripting operation is applied.</p><pre class='codeblock'>
Array&lt;int&gt; v1(20);
Array&lt;dcomplex&gt; v2(30);

v1[3] = 7;                      <span class='comment'>// <span class='texttt'>Array&lt;int&gt;::operator[]()</span>
</span>v2[3] = dcomplex(7,8);          <span class='comment'>// <span class='texttt'>Array&lt;dcomplex&gt;::operator[]()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.mem.class'><h4 ><a class='secnum' href='#temp.mem.class' style='min-width:118pt'>14.5.1.2</a> Member classes of class templates <a class='abbr_ref' href='temp.mem.class'>[temp.mem.class]</a></h4><div class='para' id='temp.mem.class-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.class-1'>1</a></div><p >A member class of a class template may be defined outside the class template
definition in which it is declared.
[&nbsp;<i>Note:</i>
The member class must be defined before its first use that requires
an instantiation (<a href='temp.inst'>[temp.inst]</a>).
For example,</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  class B;
};
A&lt;int&gt;::B* b1;                  <span class='comment'>// OK: requires <span class='texttt'>A</span> to be defined but not <span class='texttt'>A::B</span>
</span>template&lt;class T&gt; class A&lt;T&gt;::B { };
A&lt;int&gt;::B  b2;                  <span class='comment'>// OK: requires <span class='texttt'>A::B</span> to be defined
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='temp.static'><h4 ><a class='secnum' href='#temp.static' style='min-width:118pt'>14.5.1.3</a> Static data members of class templates <a class='abbr_ref' href='temp.static'>[temp.static]</a></h4><div class='para' id='temp.static-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.static-1'>1</a></div><p ><span class='indexparent'><a class='index' id='member,template_and_static'></a></span>A definition for a static data member or static data member template may be
provided in a namespace scope enclosing the definition of the static member's
class template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T s;
};
template&lt;class T&gt; T X&lt;T&gt;::s = 0;

struct limits {
  template&lt;class T&gt;
    static const T min;           <span class='comment'>// declaration
</span>};

template&lt;class T&gt;
  const T limits::min = { };      <span class='comment'>// definition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.static-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.static-2'>2</a></div><p >An explicit specialization of a static data member declared as an array of unknown
bound can have a different bound from its definition, if any. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  static int i[];
};
template &lt;class T&gt; int A&lt;T&gt;::i[4];    <span class='comment'>// 4 elements
</span>template &lt;&gt; int A&lt;int&gt;::i[] = { 1 };  <span class='comment'>// OK: 1 element
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.mem.enum'><h4 ><a class='secnum' href='#temp.mem.enum' style='min-width:118pt'>14.5.1.4</a> Enumeration members of class templates <a class='abbr_ref' href='temp.mem.enum'>[temp.mem.enum]</a></h4><div class='para' id='temp.mem.enum-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.enum-1'>1</a></div><p >An enumeration member of a class template may be defined outside the class
template definition. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  enum E : T;
};
A&lt;int&gt; a;
template&lt;class T&gt; enum A&lt;T&gt;::E : T { e1, e2 };
A&lt;int&gt;::E e = A&lt;int&gt;::e1;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='temp.mem'><h3 ><a class='secnum' href='#temp.mem' style='min-width:103pt'>14.5.2</a> Member templates <a class='abbr_ref' href='temp.mem'>[temp.mem]</a></h3><div class='para' id='temp.mem-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-1'>1</a></div><p >A template can be declared within a class or class template; such a template
is called a member template.
A member template can be defined within or outside its class definition or
class template definition.
A member template of a class template that is defined outside of its class
template definition shall be specified with the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
of the class template followed by the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
of the member template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct string {
  template&lt;class T2&gt; int compare(const T2&amp;);
  template&lt;class T2&gt; string(const string&lt;T2&gt;&amp; s) { <span class='comment'>/* ... */</span> }
};

template&lt;class T&gt; template&lt;class T2&gt; int string&lt;T&gt;::compare(const T2&amp; s) {
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.mem-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-2'>2</a></div><p >A local class of non-closure type shall not have member templates.
Access control rules (Clause <a href='class.access'>[class.access]</a>)
apply to member template names.
A destructor shall not be a member
template.
A non-template member function (<a href='dcl.fct'>[dcl.fct]</a>) with a given name
and type and a member function template of the same name, which could be
used to generate a specialization of the same type, can both be
declared in a class.
When both exist, a use of that name and type refers to the
non-template member unless an explicit template argument list is supplied.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class T2&gt; void f(T2);
};

template &lt;&gt; void A&lt;int&gt;::f(int) { }                     <span class='comment'>// non-template member function
</span>template &lt;&gt; template &lt;&gt; void A&lt;int&gt;::f&lt;&gt;(int) { }       <span class='comment'>// member function template specialization
</span>
int main() {
  A&lt;char&gt; ac;
  ac.f(1);          <span class='comment'>// non-template
</span>  ac.f('c');        <span class='comment'>// template
</span>  ac.f&lt;&gt;(1);        <span class='comment'>// template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.mem-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-3'>3</a></div><p >A member function template shall not be virtual.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct AA {
  template &lt;class C&gt; virtual void g(C);   <span class='comment'>// error
</span>  virtual void f();                       <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.mem-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-4'>4</a></div><p >A specialization of
a member function template does not override a virtual function from a
base class.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class B {
  virtual void f(int);
};

class D : public B {
  template &lt;class T&gt; void f(T); <span class='comment'>// does not override <span class='texttt'>B::f(int)</span>
</span>  void f(int i) { f&lt;&gt;(i); }     <span class='comment'>// overriding function that calls
</span>                                <span class='comment'>// the template instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.mem-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-5'>5</a></div><p >A specialization of a
conversion function template
is referenced in
the same way as a non-template conversion function that converts to
the same type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T*();
};
template &lt;class T&gt; A::operator T*(){ return 0; }
template &lt;&gt; A::operator char*(){ return 0; }    <span class='comment'>// specialization
</span>template A::operator void*();                   <span class='comment'>// explicit instantiation
</span>
int main() {
  A a;
  int* ip;
  ip = a.operator int*();       <span class='comment'>// explicit call to template operator
</span>                                <span class='comment'>// <span class='texttt'>A::operator int*()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Because the explicit template argument list follows the function template
name, and because conversion member function templates and constructor
member function templates are called without using a function name,
there is no way to provide an explicit template argument list for these
function templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.mem-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-6'>6</a></div><p >A specialization of a
conversion function template
is not found by name
lookup.
Instead, any
conversion function templates
visible in the
context of the use are considered.
For each such operator, if argument
deduction succeeds (<a href='temp.deduct.conv'>[temp.deduct.conv]</a>), the resulting specialization is
used as if found by name lookup.</p></div><div class='para' id='temp.mem-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-7'>7</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> in a derived class cannot refer to a specialization
of a
conversion function template
in a base class.</p></div><div class='para' id='temp.mem-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem-8'>8</a></div><p >Overload resolution (<a href='over.ics.rank'>[over.ics.rank]</a>) and partial
ordering (<a href='temp.func.order'>[temp.func.order]</a>) are used to select the best conversion function
among multiple
specializations of conversion function templates
and/or non-template
conversion functions.</p></div></div><div id='temp.variadic'><h3 ><a class='secnum' href='#temp.variadic' style='min-width:103pt'>14.5.3</a> Variadic templates <a class='abbr_ref' href='temp.variadic'>[temp.variadic]</a></h3><div class='para' id='temp.variadic-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-1'>1</a></div><p >A <a class='hidden_link' href='#def:template_parameter_pack' id='def:template_parameter_pack'><i>template parameter pack</i></a> is a template parameter
that accepts zero or more template arguments. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; struct Tuple { };

Tuple&lt;&gt; t0;                     <span class='comment'>// <span class='texttt'>Types</span> contains no arguments
</span>Tuple&lt;int&gt; t1;                  <span class='comment'>// <span class='texttt'>Types</span> contains one argument: <span class='texttt'>int</span>
</span>Tuple&lt;int, float&gt; t2;           <span class='comment'>// <span class='texttt'>Types</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>float</span>
</span>Tuple&lt;0&gt; error;                 <span class='comment'>// error: 0 is not a type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.variadic-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-2'>2</a></div><p >A <a class='hidden_link' href='#def:function_parameter_pack' id='def:function_parameter_pack'><i>function parameter pack</i></a> is a function parameter
that accepts zero or more function arguments. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... args);

f();                <span class='comment'>// OK: <span class='texttt'>args</span> contains no arguments
</span>f(1);               <span class='comment'>// OK: <span class='texttt'>args</span> contains one argument: <span class='texttt'>int</span>
</span>f(2, 1.0);          <span class='comment'>// OK: <span class='texttt'>args</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.variadic-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-3'>3</a></div><p >A <a class='hidden_link' href='#def:parameter_pack' id='def:parameter_pack'><i>parameter pack</i></a> is either a template parameter
pack or a function parameter pack.</p></div><div class='para' id='temp.variadic-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-4'>4</a></div><p >A <a class='hidden_link' href='#def:pack_expansion' id='def:pack_expansion'><i>pack expansion</i></a>
consists of a <a class='hidden_link' href='#def:pattern' id='def:pattern'><i>pattern</i></a> and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:</p><ul ><li id='temp.variadic-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.1'>(4.1)</a></div><p >In a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>); the pattern is the
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis.</p></li><li id='temp.variadic-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.2'>(4.2)</a></div><p >In a template parameter pack that is a pack expansion (<a href='temp.param'>[temp.param]</a>):</p><ul ><li id='temp.variadic-4.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.variadic-4.2.1'>(4.2.1)</a></div><p >if the template parameter pack is a <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i>;
the pattern is the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis;</p></li><li id='temp.variadic-4.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.variadic-4.2.2'>(4.2.2)</a></div><p >if the template parameter pack is a <i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> with a
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>; the pattern is the corresponding
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> without the ellipsis.
</p></li></ul></li><li id='temp.variadic-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.3'>(4.3)</a></div><p >In an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> (<a href='dcl.init'>[dcl.init]</a>);
the pattern is an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>.</p></li><li id='temp.variadic-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.4'>(4.4)</a></div><p >In a <i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i> (Clause <a href='class.derived'>[class.derived]</a>);
the pattern is a <i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>.</p></li><li id='temp.variadic-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.5'>(4.5)</a></div><p >In a <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> (<a href='class.base.init'>[class.base.init]</a>) for a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> whose <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> denotes a
base class; the pattern is the <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>.</p></li><li id='temp.variadic-4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.6'>(4.6)</a></div><p >In a <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i> (<a href='temp.arg'>[temp.arg]</a>);
the pattern is a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>.</p></li><li id='temp.variadic-4.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.7'>(4.7)</a></div><p >In a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>);
the pattern is a <i ><a href='dcl.name#nt:type-id'>type-id</a></i>.</p></li><li id='temp.variadic-4.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.8'>(4.8)</a></div><p >In an <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> (<a href='dcl.attr.grammar'>[dcl.attr.grammar]</a>); the pattern is
an <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i>.</p></li><li id='temp.variadic-4.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.9'>(4.9)</a></div><p >In an <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> (<a href='dcl.align'>[dcl.align]</a>); the pattern is
the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> without the ellipsis.</p></li><li id='temp.variadic-4.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.10'>(4.10)</a></div><p >In a <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>); the pattern is
a <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i>.</p></li><li id='temp.variadic-4.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-4.11'>(4.11)</a></div><p >In a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>); the pattern is an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>.
</p></li></ul></div><div class='para' id='temp.variadic-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-5'>5</a></div><p >For the purpose of determining whether a parameter pack satisfies a rule
regarding entities other than parameter packs, the parameter pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... rest);
template&lt;class ... Types&gt; void g(Types ... rest) {
  f(&amp;rest ...);     <span class='comment'>// “<span class='texttt'>&amp;rest ...</span>” is a pack expansion; “<span class='texttt'>&amp;rest</span>” is its pattern
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.variadic-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-6'>6</a></div><p >A parameter pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a parameter pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more parameter packs that
are not expanded by a nested pack expansion; such parameter packs are called
<a class='hidden_link' href='#def:unexpanded' id='def:unexpanded'><i>unexpanded</i></a> parameter packs in the pattern. All of the parameter packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a parameter pack that is not expanded is
ill-formed. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;typename...&gt; struct Tuple {};
template&lt;typename T1, typename T2&gt; struct Pair {};

template&lt;class ... Args1&gt; struct zip {
  template&lt;class ... Args2&gt; struct with {
    typedef Tuple&lt;Pair&lt;Args1, Args2&gt; ... &gt; type;
  };
};

typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;
    <span class='comment'>// <span class='texttt'>T1</span> is <span class='texttt'>Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</span>
</span>typedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;
    <span class='comment'>// error: different number of arguments specified for <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span>
</span>
template&lt;class ... Args&gt;
  void g(Args ... args) {               <span class='comment'>// OK: <span class='texttt'>Args</span> is expanded by the function parameter pack <span class='texttt'>args</span>
</span>    f(const_cast&lt;const Args*&gt;(&amp;args)...); <span class='comment'>// OK: “<span class='texttt'>Args</span>” and “<span class='texttt'>args</span>” are expanded
</span>    f(5 ...);                             <span class='comment'>// error: pattern does not contain any parameter packs
</span>    f(args);                              <span class='comment'>// error: parameter pack “<span class='texttt'>args</span>” is not expanded
</span>    f(h(args ...) + args ...);            <span class='comment'>// OK: first “<span class='texttt'>args</span>” expanded within <span class='texttt'>h</span>, second
</span>                                          <span class='comment'>// “<span class='texttt'>args</span>” expanded within <span class='texttt'>f</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.variadic-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-7'>7</a></div><p >The instantiation of a pack expansion
that is not a <span class='texttt'>sizeof...</span> expression
produces a
list
<span class='math'><span class='mathtt'>E</span><sub >1</sub>, <span class='mathtt'>E</span><sub >2</sub>, ..., <span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>,
where
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters. Each
<span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern and
replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
Such an element, in the context of the instantiation, is interpreted as
follows:</p><ul ><li id='temp.variadic-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-7.1'>(7.1)</a></div><p >if the pack is a template parameter pack, the element is a template
parameter (<a href='temp.param'>[temp.param]</a>) of the corresponding kind (type or
non-type) designating the type or value from the template
argument; otherwise,</p></li><li id='temp.variadic-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.variadic-7.2'>(7.2)</a></div><p >if the pack is a function parameter pack, the element is an
<i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
designating the function parameter that resulted from
the instantiation of the pattern where the pack is declared.
</p></li></ul><p >All of the <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> become elements in the enclosing list.
[&nbsp;<i>Note:</i> The variety of list varies with the context:
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>,
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>, etc.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
When <span class='math'><span class='mathalpha'>N</span></span> is zero, the instantiation of the expansion produces an empty list.
Such an instantiation does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the list entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class... T&gt; struct X : T... { };
template&lt;class... T&gt; void f(T... values) {
  X&lt;T...&gt; x(values...);
}

template void f&lt;&gt;();  <span class='comment'>// OK: <span class='texttt'>X&lt;&gt;</span> has no base classes
</span>                      <span class='comment'>// <span class='texttt'>x</span> is a variable of type <span class='texttt'>X&lt;&gt;</span> that is value-initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.variadic-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.variadic-8'>8</a></div><p >The instantiation of a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>) produces
an integral constant containing the number of elements in the parameter pack
it expands.</p></div></div><div id='temp.friend'><h3 ><a class='secnum' href='#temp.friend' style='min-width:103pt'>14.5.4</a> Friends <a class='abbr_ref' href='temp.friend'>[temp.friend]</a></h3><div class='para' id='temp.friend-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-1'>1</a></div><p ><span class='indexparent'><a class='index' id='friend,template_and'></a></span>A friend of a class or class template can be a function template or
class template, a specialization of a function template or class
template, or a non-template function or class.
For a friend function declaration that is not a template declaration:</p><ul ><li id='temp.friend-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.friend-1.1'>(1.1)</a></div><p >if the name of the friend is a qualified or unqualified <i ><a href='temp.names#nt:template-id'>template-id</a></i>,
the friend declaration refers to a specialization of a function
template, otherwise,
</p></li><li id='temp.friend-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.friend-1.2'>(1.2)</a></div><p >if the name of the friend is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> and a matching non-template
function is found in the specified class or namespace, the friend
declaration refers to that function, otherwise,
</p></li><li id='temp.friend-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.friend-1.3'>(1.3)</a></div><p >if the name of the friend is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> and a matching
function template
is found in the specified class
or namespace, the friend declaration refers to
the deduced specialization of that function template (<a href='temp.deduct.decl'>[temp.deduct.decl]</a>), otherwise,
</p></li><li id='temp.friend-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.friend-1.4'>(1.4)</a></div><p >the name shall be an <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> that declares (or redeclares) a
non-template function.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; class task;
template&lt;class T&gt; task&lt;T&gt;* preempt(task&lt;T&gt;*);

template&lt;class T&gt; class task {
  friend void next_time();
  friend void process(task&lt;T&gt;*);
  friend task&lt;T&gt;* preempt&lt;T&gt;(task&lt;T&gt;*);
  template&lt;class C&gt; friend int func(C);

  friend class task&lt;int&gt;;
  template&lt;class P&gt; friend class frd;
};
</pre><p >Here,
each specialization of the
<span class='texttt'>task</span>
class template has the function
<span class='texttt'>next_time</span>
as a friend;
because
<span class='texttt'>process</span>
does not have explicit
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>,
each specialization of the
<span class='texttt'>task</span>
class template has an appropriately typed function
<span class='texttt'>process</span>
as a friend, and this friend is not a function template specialization;
because the friend
<span class='texttt'>preempt</span>
has an explicit
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
<span class='texttt'>T</span>,
each specialization of the
<span class='texttt'>task</span>
class template has the appropriate specialization of the function
template
<span class='texttt'>preempt</span>
as a friend;
and each specialization of the
<span class='texttt'>task</span>
class template has all specializations of the function template
<span class='texttt'>func</span>
as friends.
Similarly,
each specialization of the
<span class='texttt'>task</span>
class template has the class template specialization
<span class='texttt'>task&lt;int&gt;</span>
as a friend, and has all specializations of the class template
<span class='texttt'>frd</span>
as friends.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.friend-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-2'>2</a></div><p >A friend template may be declared within a class or class template.
A friend function template may be defined within a class or class
template, but a friend class template may not be defined in a class
or class template.
In these cases, all specializations of the friend class or friend function
template are friends of the class or class template granting friendship.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
  template&lt;class T&gt; friend class B;                 <span class='comment'>// OK
</span>  template&lt;class T&gt; friend void f(T)<span class='texttt'>{ /* ... */ }</span>  <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.friend-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-3'>3</a></div><p >A template friend declaration specifies that all specializations of that
template, whether they are implicitly instantiated (<a href='temp.inst'>[temp.inst]</a>), partially
specialized (<a href='temp.class.spec'>[temp.class.spec]</a>) or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
are friends of the class containing the template friend declaration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class X {
  template&lt;class T&gt; friend struct A;
  class Y { };
};

template&lt;class T&gt; struct A { X::Y ab; };            <span class='comment'>// OK
</span>template&lt;class T&gt; struct A&lt;T*&gt; { X::Y ab; };        <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.friend-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-4'>4</a></div><p >When a function is defined in a friend function declaration in a class
template, the function is instantiated when the function is
odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>). The
same restrictions on multiple declarations and definitions that apply
to non-template function declarations and definitions also apply to
these implicit definitions.</p></div><div class='para' id='temp.friend-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-5'>5</a></div><p >A member of a class template may be declared to be a friend of a
non-template class.
In this case, the corresponding member of every specialization of
the class template is a friend of the class granting friendship.
For explicit specializations the corresponding member is the member (if any)
that has the same name, kind (type, function, class template, or function
template), template parameters, and signature as the member of the class
template instantiation that would otherwise have been generated.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B { };
  void f();
  struct D {
    void g();
  };
};
template&lt;&gt; struct A&lt;int&gt; {
  struct B { };
  int f();
  struct D {
    void g();
  };
};

class C {
  template&lt;class T&gt; friend struct A&lt;T&gt;::B;    <span class='comment'>// grants friendship to <span class='texttt'>A&lt;int&gt;::B</span> even though
</span>                                              <span class='comment'>// it is not a specialization of <span class='texttt'>A&lt;T&gt;::B</span>
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::f();    <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::f()</span>
</span>                                              <span class='comment'>// because its return type does not match
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::D::g(); <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::D::g()</span>
</span>                                              <span class='comment'>// because <span class='texttt'>A&lt;int&gt;::D</span> is not a specialization of <span class='texttt'>A&lt;T&gt;::D</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.friend-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-6'>6</a></div><p >[&nbsp;<i>Note:</i>
A friend declaration may first declare a member of an enclosing namespace scope (<a href='temp.inject'>[temp.inject]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.friend-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-7'>7</a></div><p >A friend template shall not be declared in a local class.</p></div><div class='para' id='temp.friend-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-8'>8</a></div><p >Friend declarations shall not declare partial specializations.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class A { };
class X {
  template&lt;class T&gt; friend class A&lt;T*&gt;; <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.friend-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.friend-9'>9</a></div><p >When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, nor shall the inline specifier be used in such a
declaration.</p></div></div><div id='temp.class.spec'><h3 ><a class='secnum' href='#temp.class.spec' style='min-width:103pt'>14.5.5</a> Class template partial specializations <a class='abbr_ref' href='temp.class.spec'>[temp.class.spec]</a></h3><div class='para' id='temp.class.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization,class_template_partial'></a></span><span class='indexparent'><a class='index' id='template,primary'></a></span>A
<a class='hidden_link' href='#def:primary' id='def:primary'><i>primary</i></a>
class template declaration is one in which the class template name is an
identifier.
A template declaration in which the class template name is a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
is a
<a class='hidden_link' href='#def:partial_specialization' id='def:partial_specialization'><i>partial specialization</i></a>
of the class template named in the
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>.
A partial specialization of a class template provides an alternative definition
of the template that is used instead of the primary definition when the
arguments in a specialization match those given in the partial
specialization (<a href='temp.class.spec.match'>[temp.class.spec.match]</a>).
The primary template shall be declared before any specializations of
that template.
A partial specialization shall be declared before the first use of a class template
specialization that would make use of the partial specialization as the result of
an implicit or explicit instantiation in every translation unit in which such a use
occurs; no diagnostic is required.</p></div><div class='para' id='temp.class.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-2'>2</a></div><p >Each class template partial specialization is a distinct template and
definitions shall be provided for the members of a template partial
specialization (<a href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a>).</p></div><div class='para' id='temp.class.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A             { };    <span class='comment'>// #1
</span>template&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { };    <span class='comment'>// #2
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { };    <span class='comment'>// #3
</span>template&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { };    <span class='comment'>// #4
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { };    <span class='comment'>// #5
</span></pre><p >The first declaration declares the primary (unspecialized) class template.
The second and subsequent declarations declare partial specializations of
the primary template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-4'>4</a></div><p >The template parameters are specified in the angle bracket enclosed list
that immediately follows the keyword
<span class='texttt'>template</span>.
For partial specializations, the template argument list is explicitly
written immediately following the class template name.
For primary templates, this list is implicitly described by the
template parameter list.
Specifically, the order of the template arguments is the sequence in
which they appear in the template parameter list.
[&nbsp;<i>Example:</i>
the template argument list for the primary template in the example
above is
<span class='texttt'>&lt;T1,</span>
<span class='texttt'>T2,</span>
<span class='texttt'>I&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
The template argument list shall not be specified in the primary template
declaration.
For example,</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2, I&gt;  { };    <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.class.spec-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-5'>5</a></div><p >A class template partial specialization may be declared or redeclared in any
namespace scope in which its definition may be defined (<a href='temp.class'>[temp.class]</a> and <a href='temp.mem'>[temp.mem]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct C {
    template&lt;class T2&gt; struct B { };
  };
};

<span class='comment'>// partial specialization of <span class='texttt'>A&lt;T&gt;::C::B&lt;T2&gt;</span>
</span>template&lt;class T&gt; template&lt;class T2&gt;
  struct A&lt;T&gt;::C::B&lt;T2*&gt; { };

A&lt;short&gt;::C::B&lt;int*&gt; absip;     <span class='comment'>// uses partial specialization
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-6'>6</a></div><p >Partial specialization declarations themselves are not found by name lookup.
Rather, when the primary template name is used, any previously-declared partial
specializations of the primary template are also considered.
One consequence is
that a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
which refers to a class template does not restrict the set of partial specializations
which may be found through the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace N {
  template&lt;class T1, class T2&gt; class A { };         <span class='comment'>// primary template
</span>}

using N::A;                             <span class='comment'>// refers to the primary template
</span>
namespace N {
  template&lt;class T&gt; class A&lt;T, T*&gt; { }; <span class='comment'>// partial specialization
</span>}

A&lt;int,int*&gt; a;                  <span class='comment'>// uses the partial specialization, which is found through
</span>                                <span class='comment'>// the using declaration which refers to the primary template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-7'>7</a></div><p >A non-type argument is non-specialized if it is the name of a non-type
parameter.
All other non-type arguments are specialized.</p></div><div class='para' id='temp.class.spec-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec-8'>8</a></div><p >Within the argument list of a class template partial specialization,
the following restrictions apply:</p><ul ><li id='temp.class.spec-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.1'>(8.1)</a></div><p >A partially specialized non-type argument expression shall not involve
a template parameter of the partial specialization except when the argument
expression is a simple
<i ><a href='lex.name#nt:identifier'>identifier</a></i>.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;int I, int J&gt; struct A {};
template &lt;int I&gt; struct A&lt;I+5, I*2&gt; {}; <span class='comment'>// error
</span>
template &lt;int I, int J&gt; struct B {};
template &lt;int I&gt; struct B&lt;I, I&gt; {};     <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.class.spec-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.2'>(8.2)</a></div><p >The type of a template parameter corresponding to a specialized non-type argument
shall not be dependent on a parameter of the specialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T, T t&gt; struct C {};
template &lt;class T&gt; struct C&lt;T, 1&gt;;                  <span class='comment'>// error
</span>
template&lt; int X, int (*array_ptr)[X] &gt; class A {};
int array[5];
template&lt; int X &gt; class A&lt;X,&amp;array&gt; { };            <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='temp.class.spec-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.3'>(8.3)</a></div><p >The argument list of the specialization shall not be identical to the
implicit argument list of the primary template.</p></li><li id='temp.class.spec-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.4'>(8.4)</a></div><p >The specialization shall be more specialized than the primary
template (<a href='temp.class.order'>[temp.class.order]</a>).</p></li><li id='temp.class.spec-8.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.5'>(8.5)</a></div><p >The template parameter list of a specialization shall not contain default
template argument values.<a class='footnotenum' href='#footnote-140'>140</a>
</p></li><li id='temp.class.spec-8.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec-8.6'>(8.6)</a></div><p >An argument shall not contain an unexpanded parameter pack. If
an argument is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>), it shall be
the last argument in the template argument list.
</p></li></ul></div><div class='footnote' id='footnote-140'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-140'>140)</a></div><p >There is no way in which they could be used.</p></div><div id='temp.class.spec.match'><h4 ><a class='secnum' href='#temp.class.spec.match' style='min-width:118pt'>14.5.5.1</a> Matching of class template partial specializations <a class='abbr_ref' href='temp.class.spec.match'>[temp.class.spec.match]</a></h4><div class='para' id='temp.class.spec.match-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.match-1'>1</a></div><p >When a class template is used in a context that requires an instantiation of
the class,
it is necessary to determine whether the instantiation is to be generated
using the primary template or one of the partial specializations.
This is done by matching the template arguments of the class template
specialization with the template argument lists of the partial
specializations.</p><ul ><li id='temp.class.spec.match-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec.match-1.1'>(1.1)</a></div><p >If exactly one matching specialization is found, the instantiation is
generated from that specialization.
</p></li><li id='temp.class.spec.match-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec.match-1.2'>(1.2)</a></div><p >If more than one matching specialization is found,
the partial order rules (<a href='temp.class.order'>[temp.class.order]</a>) are used to determine
whether one of the specializations is more specialized than the
others.
If none of the specializations is more specialized than all of the
other matching specializations, then the use of the class template
is ambiguous and the program is ill-formed.
</p></li><li id='temp.class.spec.match-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.spec.match-1.3'>(1.3)</a></div><p >If no matches are found, the instantiation is generated from the
primary template.
</p></li></ul></div><div class='para' id='temp.class.spec.match-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.match-2'>2</a></div><p >A partial specialization matches a given actual template argument
list if the template arguments of the partial specialization can be
deduced from the actual template argument list (<a href='temp.deduct'>[temp.deduct]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
A&lt;int, int, 1&gt;   a1;            <span class='comment'>// uses #1
</span>A&lt;int, int*, 1&gt;  a2;            <span class='comment'>// uses #2, <span class='texttt'>T</span> is <span class='texttt'>int</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int, char*, 5&gt; a3;            <span class='comment'>// uses #4, <span class='texttt'>T</span> is <span class='texttt'>char</span>
</span>A&lt;int, char*, 1&gt; a4;            <span class='comment'>// uses #5, <span class='texttt'>T1</span> is <span class='texttt'>int</span>, <span class='texttt'>T2</span> is <span class='texttt'>char</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int*, int*, 2&gt; a5;            <span class='comment'>// ambiguous: matches #3 and #5
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec.match-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.match-3'>3</a></div><p >A non-type template argument can also be deduced from the value of an actual
template argument of a non-type parameter of the primary template.
[&nbsp;<i>Example:</i>
the declaration of
<span class='texttt'>a2</span>
above.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec.match-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.match-4'>4</a></div><p >In a type name that refers to a class template specialization, (e.g.,
<span class='texttt'>A&lt;int, int, 1&gt;</span>)
the argument list shall match the template parameter list of the primary
template.
The template arguments of a specialization are deduced from the arguments
of the primary template.</p></div></div><div id='temp.class.order'><h4 ><a class='secnum' href='#temp.class.order' style='min-width:118pt'>14.5.5.2</a> Partial ordering of class template specializations <a class='abbr_ref' href='temp.class.order'>[temp.class.order]</a></h4><div class='para' id='temp.class.order-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.order-1'>1</a></div><p >For two class template partial specializations,
the first is at least as specialized as the second if, given the following
rewrite to two function templates, the first function template is at least
as specialized as the second according to the ordering rules for function
templates (<a href='temp.func.order'>[temp.func.order]</a>):</p><ul ><li id='temp.class.order-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.order-1.1'>(1.1)</a></div><p >the first function template has the same template parameters as
the first partial specialization and has a single function parameter
whose type is a class template specialization with the template arguments of
the first partial specialization, and
</p></li><li id='temp.class.order-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.order-1.2'>(1.2)</a></div><p >the second function template has the same template parameters as
the second partial specialization and has a single function parameter
whose type is a class template specialization with the template arguments of
the second partial specialization.
</p></li></ul></div><div class='para' id='temp.class.order-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.order-2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;int I, int J, class T&gt; class X { };
template&lt;int I, int J&gt;          class X&lt;I, J, int&gt; { }; <span class='comment'>// #1
</span>template&lt;int I&gt;                 class X&lt;I, I, int&gt; { }; <span class='comment'>// #2
</span>
template&lt;int I, int J&gt; void f(X&lt;I, J, int&gt;);            <span class='comment'>// A
</span>template&lt;int I&gt;        void f(X&lt;I, I, int&gt;);            <span class='comment'>// B
</span></pre><p >The partial specialization
<span class='texttt'>#2</span>
is more specialized than the partial specialization
<span class='texttt'>#1</span>
because the function template
<span class='texttt'>B</span>
is more specialized than the function template
<span class='texttt'>A</span>
according to the ordering rules for function templates.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.class.spec.mfunc'><h4 ><a class='secnum' href='#temp.class.spec.mfunc' style='min-width:118pt'>14.5.5.3</a> Members of class template specializations <a class='abbr_ref' href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a></h4><div class='para' id='temp.class.spec.mfunc-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.mfunc-1'>1</a></div><p >The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.
A class template specialization is a distinct template.
The members of the class template partial specialization are
unrelated to the members of the primary template.
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class
template partial specialization.
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
<span class='comment'>// primary template
</span>template&lt;class T, int I&gt; struct A {
  void f();
};

template&lt;class T, int I&gt; void A&lt;T,I&gt;::f() { }

<span class='comment'>// class template partial specialization
</span>template&lt;class T&gt; struct A&lt;T,2&gt; {
  void f();
  void g();
  void h();
};

<span class='comment'>// member of class template partial specialization
</span>template&lt;class T&gt; void A&lt;T,2&gt;::g() { }

<span class='comment'>// explicit specialization
</span>template&lt;&gt; void A&lt;char,2&gt;::h() { }

int main() {
  A&lt;char,0&gt; a0;
  A&lt;char,2&gt; a2;
  a0.f();                       <span class='comment'>// OK, uses definition of primary template's member
</span>  a2.g();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// partial specialization's member
</span>  a2.h();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// explicit specialization's member
</span>  a2.f();                       <span class='comment'>// ill-formed, no definition of <span class='texttt'>f</span> for <span class='texttt'>A&lt;T,2&gt;</span>
</span>                                <span class='comment'>// the primary template is not used here
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.class.spec.mfunc-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.spec.mfunc-2'>2</a></div><p >If a member template of a class template is partially specialized,
the member template partial specializations are member templates of
the enclosing class template;
if the enclosing class template is instantiated (<a href='temp.inst'>[temp.inst]</a>, <a href='temp.explicit'>[temp.explicit]</a>),
a declaration for every member template partial specialization is also
instantiated as part of creating the members of the class template
specialization.
If the primary member template is explicitly specialized for a given
(implicit) specialization of the enclosing class template,
the partial specializations of the member template are ignored for this
specialization of the enclosing class template.
If a partial specialization of the member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are
still considered for this specialization of the enclosing class template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  template&lt;class T2&gt; struct B {};                     <span class='comment'>// #1
</span>  template&lt;class T2&gt; struct B&lt;T2*&gt; {};                <span class='comment'>// #2
</span>};

template&lt;&gt; template&lt;class T2&gt; struct A&lt;short&gt;::B {};  <span class='comment'>// #3
</span>
A&lt;char&gt;::B&lt;int*&gt;  abcip;  <span class='comment'>// uses #2
</span>A&lt;short&gt;::B&lt;int*&gt; absip;  <span class='comment'>// uses #3
</span>A&lt;char&gt;::B&lt;int&gt;  abci;    <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='temp.fct'><h3 ><a class='secnum' href='#temp.fct' style='min-width:103pt'>14.5.6</a> Function templates <a class='abbr_ref' href='temp.fct'>[temp.fct]</a></h3><div class='para' id='temp.fct-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.fct-1'>1</a></div><p >A function template defines an unbounded set of related functions.
[&nbsp;<i>Example:</i>
a family of sort functions might be declared like this:</p><pre class='codeblock'>
template&lt;class T&gt; class Array { };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.fct-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.fct-2'>2</a></div><p >A function template can be overloaded with other function templates
and with non-template functions (<a href='dcl.fct'>[dcl.fct]</a>).
A non-template function is not
related to a function template
(i.e., it is never considered to be a specialization),
even if it has the same name and type
as a potentially generated function template specialization.<a class='footnotenum' href='#footnote-141'>141</a></p></div><div class='footnote' id='footnote-141'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-141'>141)</a></div><p >That is,
declarations of non-template functions do not merely guide
overload resolution of
function template specializations
with the same name.
If such a non-template function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in a program, it must be defined;
it will not be implicitly instantiated using the function template definition.</p></div><div id='temp.over.link'><h4 ><a class='secnum' href='#temp.over.link' style='min-width:118pt'>14.5.6.1</a> Function template overloading <a class='abbr_ref' href='temp.over.link'>[temp.over.link]</a></h4><div class='para' id='temp.over.link-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading'></a></span>It is possible to overload function templates so that two different
function template specializations have the same type.
[&nbsp;<i>Example:</i></p><div class='minipage'><pre class='codeblock'>
<span class='comment'>// file1.c
</span>template&lt;class T&gt;
  void f(T*);
void g(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int*)</span>
</span>}
</pre></div><div class='minipage'><pre class='codeblock'>
<span class='comment'>// file2.c
</span>template&lt;class T&gt;
  void f(T);
void h(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int*&gt;(int*)</span>
</span>}
</pre></div><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.over.link-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-2'>2</a></div><p >Such specializations are distinct functions and do not violate the one
definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>).</p></div><div class='para' id='temp.over.link-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-3'>3</a></div><p >The signature of a function template
is defined in <a href='intro.defs'>[intro.defs]</a>.
The names of the template parameters are significant only for establishing
the relationship between the template parameters and the rest of the
signature.
[&nbsp;<i>Note:</i>
Two distinct function templates may have identical function return types and
function parameter lists, even if overload resolution alone cannot distinguish
them.</p><pre class='codeblock'>
template&lt;class T&gt; void f();
template&lt;int I&gt; void f();       <span class='comment'>// OK: overloads the first template
</span>                                <span class='comment'>// distinguishable with an explicit template argument list
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.over.link-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-4'>4</a></div><p >When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template.
This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;int I, int J&gt; A&lt;I+J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// #1
</span>template &lt;int K, int L&gt; A&lt;K+L&gt; f(A&lt;K&gt;, A&lt;L&gt;);   <span class='comment'>// same as #1
</span>template &lt;int I, int J&gt; A&lt;I-J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// different from #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Most expressions that use template parameters use non-type template
parameters, but it is possible for an expression to reference a type
parameter.
For example, a template type parameter can be used in the
<span class='texttt'>sizeof</span> operator.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.over.link-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-5'>5</a></div><p >Two expressions involving template parameters are considered
<a class='hidden_link' href='#def:equivalent' id='def:equivalent'><i>equivalent</i></a>
if two function definitions containing the expressions would satisfy
the one definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>), except that the tokens used
to name the template parameters may differ as long as a token used to
name a template parameter in one expression is replaced by another token
that names the same template parameter in the other expression. For
determining whether two dependent names (<a href='temp.dep'>[temp.dep]</a>) are
equivalent, only the name itself is considered, not the result of name
lookup in the context of the template. If multiple declarations of the
same function template differ in the result of this name lookup, the
result for the first declaration is used.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;int I, int J&gt; void f(A&lt;I+J&gt;);         <span class='comment'>// #1
</span>template &lt;int K, int L&gt; void f(A&lt;K+L&gt;);         <span class='comment'>// same as #1
</span>
template &lt;class T&gt; decltype(g(T())) h();
int g(int);
template &lt;class T&gt; decltype(g(T())) h()         <span class='comment'>// redeclaration of <span class='texttt'>h()</span> uses the earlier lookup
</span>  { return g(T()); }                            <span class='comment'>// ...although the lookup here does find <span class='texttt'>g(int)</span>
</span>int i = h&lt;int&gt;();                               <span class='comment'>// template argument substitution fails; <span class='texttt'>g(int)</span>
</span>                                                <span class='comment'>// was not in scope at the first declaration of <span class='texttt'>h()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
Two expressions involving template parameters that are not equivalent are
<a class='hidden_link' href='#def:functionally_equivalent' id='def:functionally_equivalent'><i>functionally equivalent</i></a>
if, for any given set of template arguments, the evaluation of the
expression results in the same value.</p></div><div class='para' id='temp.over.link-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-6'>6</a></div><p >Two function templates are
<a class='hidden_link' href='#def:equivalent' id='def:equivalent'><i>equivalent</i></a>
if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter
lists that are equivalent using the rules described above to compare
expressions involving
template parameters.
Two function templates are
<a class='hidden_link' href='#def:functionally_equivalent' id='def:functionally_equivalent'><i>functionally equivalent</i></a>
if they are equivalent except that one or more
expressions
that involve template parameters in the return types and parameter
lists are functionally equivalent using the rules described above to
compare expressions involving
template parameters.
If a program contains declarations of function templates that are
functionally equivalent but not equivalent, the program is ill-formed;
no diagnostic is required.</p></div><div class='para' id='temp.over.link-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-7'>7</a></div><p >[&nbsp;<i>Note:</i>
This rule guarantees that equivalent declarations will be linked with
one another, while not requiring implementations to use heroic efforts
to guarantee that functionally equivalent declarations will be treated
as distinct.
For example, the last two declarations are functionally
equivalent and would cause a program to be ill-formed:</p><pre class='codeblock'>
<span class='comment'>// Guaranteed to be the same
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);

<span class='comment'>// Guaranteed to be different
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+11&gt;);

<span class='comment'>// Ill-formed, no diagnostic required
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='temp.func.order'><h4 ><a class='secnum' href='#temp.func.order' style='min-width:118pt'>14.5.6.2</a> Partial ordering of function templates <a class='abbr_ref' href='temp.func.order'>[temp.func.order]</a></h4><div class='para' id='temp.func.order-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,template'></a></span><span class='indexparent'><a class='index' id='ordering,function_template_partial'></a></span>If a function template is overloaded,
the use of a function template specialization might be ambiguous because
template argument deduction (<a href='temp.deduct'>[temp.deduct]</a>) may associate the function
template specialization with more than one function template declaration.
<a class='hidden_link' href='#def:Partial_ordering' id='def:Partial_ordering'><i>Partial ordering</i></a>
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:</p><ul ><li id='temp.func.order-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.1'>(1.1)</a></div><p >during overload resolution for a call to a function template specialization (<a href='over.match.best'>[over.match.best]</a>);
</p></li><li id='temp.func.order-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.2'>(1.2)</a></div><p >when the address of a function template specialization is taken;
</p></li><li id='temp.func.order-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.3'>(1.3)</a></div><p >when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>);
</p></li><li id='temp.func.order-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.4'>(1.4)</a></div><p >when a friend function declaration (<a href='temp.friend'>[temp.friend]</a>), an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) refers to
a function template specialization.
</p></li></ul></div><div class='para' id='temp.func.order-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-2'>2</a></div><p >Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type.
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.</p></div><div class='para' id='temp.func.order-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-3'>3</a></div><p >To produce the transformed template, for each type, non-type, or template
template parameter (including template parameter packs (<a href='temp.variadic'>[temp.variadic]</a>)
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template.
If only one of the function templates is a non-static member of some
class <span class='texttt'>A</span>, that function
template is considered to have a new first parameter inserted in its function
parameter list. Given <i>cv</i> as the cv-qualifiers of the function
template (if any), the new parameter is of type “rvalue reference to
<i>cv</i> <span class='texttt'>A</span>” if the optional <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> of the
function template is <span class='texttt'>&amp;&amp;</span>, or of type “lvalue reference to
<i>cv</i> <span class='texttt'>A</span>” otherwise. [&nbsp;<i>Note:</i> This allows a non-static
member to be ordered with respect to a nonmember function and for the results
to be equivalent to the ordering of two equivalent nonmembers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A { };
template&lt;class T&gt; struct B {
  template&lt;class R&gt; int operator*(R&amp;);              <span class='comment'>// #1
</span>};

template&lt;class T, class R&gt; int operator*(T&amp;, R&amp;);   <span class='comment'>// #2
</span>
<span class='comment'>// The declaration of <span class='texttt'>B::operator*</span> is transformed into the equivalent of
</span><span class='comment'>// <span class='texttt'>template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;// #1a
</span>
int main() {
  A a;
  B&lt;A&gt; b;
  b * a;                                            <span class='comment'>// calls #1a
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.func.order-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-4'>4</a></div><p >Using the transformed function template's function type,
perform type deduction against the other template as described in <a href='temp.deduct.partial'>[temp.deduct.partial]</a>.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A { A(); };

template&lt;class T&gt; void f(T);
template&lt;class T&gt; void f(T*);
template&lt;class T&gt; void f(const T*);

template&lt;class T&gt; void g(T);
template&lt;class T&gt; void g(T&amp;);

template&lt;class T&gt; void h(const T&amp;);
template&lt;class T&gt; void h(A&lt;T&gt;&amp;);

void m() {
  const int* p;
  f(p);             <span class='comment'>// <span class='texttt'>f(const T*)</span> is more specialized than <span class='texttt'>f(T)</span> or <span class='texttt'>f(T*)</span>
</span>  float x;
  g(x);             <span class='comment'>// Ambiguous: <span class='texttt'>g(T)</span> or <span class='texttt'>g(T&amp;)</span>
</span>  A&lt;int&gt; z;
  h(z);             <span class='comment'>// overload resolution selects <span class='texttt'>h(A&lt;T&gt;&amp;)</span>
</span>  const A&lt;int&gt; z2;
  h(z2);            <span class='comment'>// <span class='texttt'>h(const T&amp;)</span> is called because <span class='texttt'>h(A&lt;T&gt;&amp;)</span> is not callable
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.func.order-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-5'>5</a></div><p >[&nbsp;<i>Note:</i> Since partial ordering in a call context considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);            <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T*, int=1);    <span class='comment'>// #2
</span>template&lt;class T&gt; void g(T);            <span class='comment'>// #3
</span>template&lt;class T&gt; void g(T*, ...);      <span class='comment'>// #4
</span>
</pre><pre class='codeblock'>
int main() {
  int* ip;
  f(ip);            <span class='comment'>// calls #2
</span>  g(ip);            <span class='comment'>// calls #4
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T, class U&gt; struct A { };

template&lt;class T, class U&gt; void f(U, A&lt;U, T&gt;* p = 0); <span class='comment'>// #1
</span>template&lt;         class U&gt; void f(U, A&lt;U, U&gt;* p = 0); <span class='comment'>// #2
</span>template&lt;class T         &gt; void g(T, T = T());        <span class='comment'>// #3
</span>template&lt;class T, class... U&gt; void g(T, U ...);       <span class='comment'>// #4
</span>
void h() {
  f&lt;int&gt;(42, (A&lt;int, int&gt;*)0);                        <span class='comment'>// calls #2
</span>  f&lt;int&gt;(42);                                         <span class='comment'>// error: ambiguous
</span>  g(42);                                              <span class='comment'>// error: ambiguous
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T, U...);        <span class='comment'>// #1
</span>template&lt;class T            &gt; void f(T);              <span class='comment'>// #2
</span>template&lt;class T, class... U&gt; void g(T*, U...);       <span class='comment'>// #3
</span>template&lt;class T            &gt; void g(T);              <span class='comment'>// #4
</span>
void h(int i) {
  f(&amp;i);                                              <span class='comment'>// error: ambiguous
</span>  g(&amp;i);                                              <span class='comment'>// OK: calls #3
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='temp.alias'><h3 ><a class='secnum' href='#temp.alias' style='min-width:103pt'>14.5.7</a> Alias templates <a class='abbr_ref' href='temp.alias'>[temp.alias]</a></h3><div class='para' id='temp.alias-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.alias-1'>1</a></div><p >A <i ><a href='temp#nt:template-declaration'>template-declaration</a></i> in which the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> is an
<i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i> (Clause <a href='dcl.dcl'>[dcl.dcl]</a>) declares the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> to be a <a class='hidden_link' href='#def:alias_template' id='def:alias_template'><i>alias template</i></a>.
An alias template is a name for a family of
types. The name of the alias template is a <i ><a href='temp.names#nt:template-name'>template-name</a></i>.</p></div><div class='para' id='temp.alias-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.alias-2'>2</a></div><p >When a <i ><a href='temp.names#nt:template-id'>template-id</a></i> refers to the specialization of
an alias template, it is equivalent to the associated type obtained by
substitution of its <i ><a href='temp.names#nt:template-argument'>template-arguments</a></i> for the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i> in the <i ><a href='dcl.name#nt:type-id'>type-id</a></i> of
the alias template.
[&nbsp;<i>Note:</i> An alias template name is never deduced.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct Alloc { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; using Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;
Vec&lt;int&gt; v;         <span class='comment'>// same as <span class='texttt'>vector&lt;int, Alloc&lt;int&gt;&gt; v;</span>
</span>
template&lt;class T&gt;
  void process(Vec&lt;T&gt;&amp; v)
  { <span class='comment'>/* ... */</span> }

template&lt;class T&gt;
  void process(vector&lt;T, Alloc&lt;T&gt;&gt;&amp; w)
  { <span class='comment'>/* ... */</span> }     <span class='comment'>// error: redefinition
</span>
template&lt;template&lt;class&gt; class TT&gt;
  void f(TT&lt;int&gt;);

f(v);               <span class='comment'>// error: <span class='texttt'>Vec</span> not deduced
</span>
template&lt;template&lt;class,class&gt; class TT&gt;
  void g(TT&lt;int, Alloc&lt;int&gt;&gt;);
g(v);               <span class='comment'>// OK: <span class='texttt'>TT</span> = <span class='texttt'>vector</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.alias-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.alias-3'>3</a></div><p >The <i ><a href='dcl.name#nt:type-id'>type-id</a></i> in an alias template declaration shall not refer to
the alias template being declared. The type produced by an alias template
specialization shall not directly or indirectly make use of that specialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A;
template &lt;class T&gt; using B = typename A&lt;T&gt;::U;
template &lt;class T&gt; struct A {
  typedef B&lt;T&gt; U;
};
B&lt;short&gt; b;         <span class='comment'>// error: instantiation of <span class='texttt'>B&lt;short&gt;</span> uses own type via <span class='texttt'>A&lt;short&gt;::U</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></body></html>