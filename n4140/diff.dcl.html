<!DOCTYPE html><html lang='en'><head><title>[diff.dcl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.dcl'>[diff.iso]</a></h2><div id='diff.dcl'><h3 ><a class='secnum' style='min-width:103pt'>C.1.6</a> Clause <a href='dcl.dcl'>[dcl.dcl]</a>: declarations <a class='abbr_ref'>[diff.dcl]</a></h3><p ><a href='dcl.stc'>[dcl.stc]</a>
<br/><b>Change:</b> In C++, the <span class='texttt'>static</span> or <span class='texttt'>extern</span> specifiers can only be applied to names of objects or functions
Using these specifiers with type declarations is illegal in C++.
In C, these specifiers are ignored when used on type declarations.</p><p >Example:</p><pre class='codeblock'>
static struct S {               <span class='comment'>// valid C, invalid in C++
</span>  int i;
};
</pre><p ><br/><b>Rationale:</b>
Storage class specifiers don't have any meaning when associated
with a type.
In C++, class members can be declared with the <span class='texttt'>static</span> storage
class specifier.
Allowing storage class specifiers on type
declarations could render the code confusing for users.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.typedef'>[dcl.typedef]</a>
<br/><b>Change:</b> A C++ typedef name must be different from any class type name declared
in the same scope (except if the typedef is a synonym of the class name with the
same name). In C, a typedef name and a struct tag name declared in the same scope
can have the same name (because they have different name spaces)</p><p >Example:
</p><pre class='codeblock'>
typedef struct name1 { <span class='comment'>/*...*/</span> } name1;         <span class='comment'>// valid C and C++
</span>struct name { <span class='comment'>/*...*/</span> };
typedef int name;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
For ease of use, C++ doesn't require that a type name be prefixed
with the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span> or <span class='texttt'>union</span> when used in object
declarations or type casts.</p><p >Example:
</p><pre class='codeblock'>
class name { <span class='comment'>/*...*/</span> };
name i;                         <span class='comment'>// <span class='texttt'>i</span> has type <span class='texttt'>class name</span>
</span></pre><p ><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
One of the 2 types has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a> [see also <a href='basic.link'>[basic.link]</a>]
<br/><b>Change:</b> const objects must be initialized in C++ but can be left uninitialized in C
<br/><b>Rationale:</b>
A const object cannot be assigned to so it must be initialized
to hold a useful value.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a>
<br/><b>Change:</b> Banning implicit int</p><p >In C++ a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
must contain a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, unless
it is followed by a declarator for a constructor, a destructor, or a
conversion function.
In the following example, the
left-hand column presents valid C;
the right-hand column presents
equivalent C++ :</p><pre class='codeblock'>
void f(const parm);            void f(const int parm);
const n = 3;                   const int n = 3;
main()                         int main()
    <span class='comment'>/* ... */</span>                      <span class='comment'>/* ... */</span>
</pre><p ><br/><b>Rationale:</b>
In C++, implicit int creates several opportunities for
ambiguity between expressions involving function-like
casts and declarations.
Explicit declaration is increasingly considered
to be proper style.
Liaison with WG14 (C) indicated support for (at least)
deprecating implicit int in the next revision of C.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
Could be automated.
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.spec.auto'>[dcl.spec.auto]</a>
<br/><b>Change:</b>
The keyword <span class='texttt'>auto</span> cannot be used as a storage class specifier.</p><pre class='codeblock'>
void f() {
  auto int x;     <span class='comment'>// valid C, invalid C++
</span>}
</pre><p ><br/><b>Rationale:</b> Allowing the use of <span class='texttt'>auto</span> to deduce the type
of a variable from its initializer results in undesired interpretations of
<span class='texttt'>auto</span> as a storage class specifier in certain contexts.
<br/><b>Effect on original feature:</b> Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b> Syntactic transformation.
<br/><b>How widely used:</b> Rare.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<br/><b>Change:</b> C++ objects of enumeration type can only be assigned values of the same enumeration type.
In C, objects of enumeration type can be assigned values of any integral type</p><p >Example:
</p><pre class='codeblock'>
enum color { red, blue, green };
enum color c = 1;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
The type-safe nature of C++.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
(The type error produced by the assignment can be automatically
corrected by applying an explicit cast.)
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<br/><b>Change:</b> In C++, the type of an enumerator is its enumeration. In C, the type of an enumerator is <span class='texttt'>int</span>.</p><p >Example:</p><pre class='codeblock'>
enum e { A };
sizeof(A) == sizeof(int)        <span class='comment'>// in C
</span>sizeof(A) == sizeof(e)          <span class='comment'>// in C++
</span><span class='comment'>/* <i><span class='textrm'>and <span class='texttt'>sizeof(int)</span> is not necessarily equal to <span class='texttt'>sizeof(e)</span></span></i> */</span>
</pre><p ><br/><b>Rationale:</b>
In C++, an enumeration is a distinct type.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.
The only time this affects existing C code is when the size of an
enumerator is taken.
Taking the size of an enumerator is not a
common C coding practice.</p></div></div></body></html>