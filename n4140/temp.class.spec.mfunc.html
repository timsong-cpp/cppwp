<!DOCTYPE html><html lang='en'><head><title>[temp.class.spec.mfunc]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.class.spec.mfunc'>[temp.decls]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.5.5</a> Class template partial specializations <a class='abbr_ref' href='temp.class.spec#mfunc'>[temp.class.spec]</a></h3><div id='temp.class.spec.mfunc'><h4 ><a class='secnum' style='min-width:118pt'>14.5.5.3</a> Members of class template specializations <a class='abbr_ref'>[temp.class.spec.mfunc]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.
A class template specialization is a distinct template.
The members of the class template partial specialization are
unrelated to the members of the primary template.
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class
template partial specialization.
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
<span class='comment'>// primary template
</span>template&lt;class T, int I&gt; struct A {
  void f();
};

template&lt;class T, int I&gt; void A&lt;T,I&gt;::f() { }

<span class='comment'>// class template partial specialization
</span>template&lt;class T&gt; struct A&lt;T,2&gt; {
  void f();
  void g();
  void h();
};

<span class='comment'>// member of class template partial specialization
</span>template&lt;class T&gt; void A&lt;T,2&gt;::g() { }

<span class='comment'>// explicit specialization
</span>template&lt;&gt; void A&lt;char,2&gt;::h() { }

int main() {
  A&lt;char,0&gt; a0;
  A&lt;char,2&gt; a2;
  a0.f();                       <span class='comment'>// OK, uses definition of primary template's member
</span>  a2.g();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// partial specialization's member
</span>  a2.h();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// explicit specialization's member
</span>  a2.f();                       <span class='comment'>// ill-formed, no definition of <span class='texttt'>f</span> for <span class='texttt'>A&lt;T,2&gt;</span>
</span>                                <span class='comment'>// the primary template is not used here
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If a member template of a class template is partially specialized,
the member template partial specializations are member templates of
the enclosing class template;
if the enclosing class template is instantiated (<a href='temp.inst'>[temp.inst]</a>, <a href='temp.explicit'>[temp.explicit]</a>),
a declaration for every member template partial specialization is also
instantiated as part of creating the members of the class template
specialization.
If the primary member template is explicitly specialized for a given
(implicit) specialization of the enclosing class template,
the partial specializations of the member template are ignored for this
specialization of the enclosing class template.
If a partial specialization of the member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are
still considered for this specialization of the enclosing class template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  template&lt;class T2&gt; struct B {};                     <span class='comment'>// #1
</span>  template&lt;class T2&gt; struct B&lt;T2*&gt; {};                <span class='comment'>// #2
</span>};

template&lt;&gt; template&lt;class T2&gt; struct A&lt;short&gt;::B {};  <span class='comment'>// #3
</span>
A&lt;char&gt;::B&lt;int*&gt;  abcip;  <span class='comment'>// uses #2
</span>A&lt;short&gt;::B&lt;int*&gt; absip;  <span class='comment'>// uses #3
</span>A&lt;char&gt;::B&lt;int&gt;  abci;    <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>