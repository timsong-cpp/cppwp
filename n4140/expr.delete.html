<!DOCTYPE html><html lang='en'><head><title>[expr.delete]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.3</a> Unary expressions <a class='abbr_ref' href='expr.unary#expr.delete'>[expr.unary]</a></h2><div id='expr.delete'><h3 ><a class='secnum' style='min-width:103pt'>5.3.5</a> Delete <a class='abbr_ref'>[expr.delete]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,delete'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> operator destroys a most derived
object (<a href='intro.object'>[intro.object]</a>) or array created by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.</p><pre class='bnf'><a id='nt:delete-expression'>delete-expression:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre><p >The first alternative is for non-array objects, and the second is for arrays. Whenever
the <span class='texttt'>delete</span> keyword is immediately followed by empty square brackets, it shall be
interpreted as the second alternative.<a class='footnotenum' href='#footnote-79'>79</a>
The operand shall be of pointer to object type or of class type. If of
class type, the operand is contextually implicitly converted
(Clause <a href='conv'>[conv]</a>) to a pointer to object
type.<a class='footnotenum' href='#footnote-80'>80</a>
The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>'s result has type
<span class='texttt'>void</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,object'></a></span>
If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section.
<span class='indexparent'><a class='index' id='object,delete'></a></span>In the first alternative
(<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), the value of the operand of <span class='texttt'>delete</span> may
be a null pointer value, a pointer to a non-array object
created by a previous <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a pointer to a
subobject (<a href='intro.object'>[intro.object]</a>) representing a base class of such an
object (Clause <a href='class.derived'>[class.derived]</a>). If not, the behavior is undefined.
<span class='indexparent'><a class='index' id='array,delete'></a></span><span class='indexparent'><a class='index' id='delete,array'></a></span>In the second alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>), the value of the
operand of <span class='texttt'>delete</span>
may be a null pointer value or a pointer value
that resulted from
a previous array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.<a class='footnotenum' href='#footnote-81'>81</a>
If not, the behavior is undefined.
[&nbsp;<i>Note:</i> 
this means that the syntax of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> must
match the type of the object allocated by <span class='texttt'>new</span>, not the syntax of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
a pointer to a <span class='texttt'>const</span> type can be the operand of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>; it is not necessary to cast away the
constness (<a href='expr.const.cast'>[expr.const.cast]</a>) of the pointer expression before it is
used as the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='delete,undefined'></a></span>In the first alternative (<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), if the static type of
the object to be deleted is different from its dynamic type, the static type shall be
a base class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall
be evaluated exactly once.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,incomplete'></a></span>If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='delete,destructor_and'></a></span>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, then:</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >If the allocation call for the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> for the object to
be deleted was not omitted and the allocation was not extended (<a href='expr.new'>[expr.new]</a>), the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a deallocation
function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>). The value returned from the
allocation call of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> shall be passed as the
first argument to the deallocation function.</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >Otherwise, if the allocation was extended or was provided by extending the
allocation of another <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>, and the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> for every other pointer value produced by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that had storage provided by the extended
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> has been evaluated, the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a deallocation function. The value
returned from the allocation call of the extended <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
shall be passed as the first argument to the deallocation function.</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >Otherwise, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will not call a
<span class='indexparent'><a class='index' id='function,deallocation'></a></span><span class='indexparent'><a class='index' id='deallocation'></a></span><span class='indexparent'><a class='index' id='delete'></a></span><a class='hidden_link' href='#def:deallocation_function' id='def:deallocation_function'><i>deallocation function</i></a> (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>).
</p></li></ul><p >Otherwise, it is unspecified whether the deallocation function will be
called.
[&nbsp;<i>Note:</i>
The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i> 
An implementation provides default definitions of the global
deallocation functions <span class='texttt'>operator delete()</span> for
non-arrays (<a href='new.delete.single'>[new.delete.single]</a>) and
<span class='indexparent'><a class='index' id='operator_'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator delete[]()</span> for arrays (<a href='new.delete.array'>[new.delete.array]</a>). A C++
program can provide alternative definitions of these
functions (<a href='replacement.functions'>[replacement.functions]</a>), and/or class-specific
versions (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >When the keyword <span class='texttt'>delete</span> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is
preceded by the unary <span class='texttt'>::</span> operator, the deallocation function's name is looked
up in global scope. Otherwise, the lookup considers class-specific deallocation
functions (<a href='class.free'>[class.free]</a>). If no class-specific deallocation function is found,
the deallocation function's name is looked up in global scope.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If the type is complete and if deallocation function lookup finds both a usual
deallocation function with only a pointer parameter and a usual deallocation
function with both a pointer parameter and a size parameter, then the selected
deallocation function shall be the one with two parameters. Otherwise, the selected
deallocation function shall be the function with one parameter.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >When a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
is executed, the selected deallocation function shall be called with
the address of the block of storage to be reclaimed as its first argument and
(if the two-parameter deallocation function is used) the size of the block as its
second argument.<a class='footnotenum' href='#footnote-82'>82</a></p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Access and ambiguity control are done for both the deallocation function
and the destructor (<a href='class.dtor'>[class.dtor]</a>, <a href='class.free'>[class.free]</a>).</p></div><div class='footnote' id='footnote-79'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-79'>79)</a></div><p >A lambda expression with a
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> that consists of
empty square brackets can follow the <span class='texttt'>delete</span> keyword if the lambda expression is
enclosed in parentheses.</p></div><div class='footnote' id='footnote-80'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-80'>80)</a></div><p >This implies that an object
cannot be deleted using a pointer of type
<span class='texttt'>void*</span> because <span class='texttt'>void</span> is not an object type.</p></div><div class='footnote' id='footnote-81'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-81'>81)</a></div><p >For non-zero-length
arrays, this is the same as a pointer to the first
element of the array created by that <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
Zero-length arrays do not have a first element.</p></div><div class='footnote' id='footnote-82'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-82'>82)</a></div><p >If the static type of the object to be deleted is complete
and is different from the dynamic type, and the destructor is not virtual, the size might
be incorrect, but that case is already undefined, as stated above.</p></div></div></div></body></html>