<!DOCTYPE html><html lang='en'><head><title>[temp.dep.type]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref' href='temp.res#temp.dep.type'>[temp.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref' href='temp.dep#type'>[temp.dep]</a></h3><div id='temp.dep.type'><h4 ><a class='secnum' style='min-width:118pt'>14.6.2.1</a> Dependent types <a class='abbr_ref'>[temp.dep.type]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A name refers to the
<a class='hidden_link' href='#def:current_instantiation' id='def:current_instantiation'><i>current instantiation</i></a>
if it is</p><ul ><li ><p >in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause <a href='class'>[class]</a>) of the class template or nested class,
</p></li><li ><p >in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization),
</p></li><li ><p >in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
</p></li><li ><p >in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization).
If the <i>n</i>th template parameter is
a parameter pack, the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the parameter pack.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The template argument list of a primary template is a
template argument list in which the
<i>n</i>th
template argument has the value of the
<i>n</i>th
template parameter of the class template.
If the <i>n</i>th template parameter is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the template parameter pack.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  A* p1;                        <span class='comment'>// <span class='texttt'>A</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is the current instantiation
</span>  A&lt;T*&gt; p3;                     <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is not the current instantiation
</span>  ::A&lt;T&gt;* p4;                   <span class='comment'>// <span class='texttt'>::A&lt;T&gt;</span> is the current instantiation
</span>  class B {
    B* p1;                      <span class='comment'>// <span class='texttt'>B</span> is the current instantiation
</span>    A&lt;T&gt;::B* p2;                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::B</span> is the current instantiation
</span>    typename A&lt;T*&gt;::B* p3;      <span class='comment'>// <span class='texttt'>A&lt;T*&gt;::B</span> is not the
</span>                                <span class='comment'>// current instantiation
</span>  };
};

template &lt;class T&gt; class A&lt;T*&gt; {
  A&lt;T*&gt;* p1;                    <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is not the current instantiation
</span>};

template &lt;class T1, class T2, int I&gt; struct B {
  B&lt;T1, T2, I&gt;* b1;             <span class='comment'>// refers to the current instantiation
</span>  B&lt;T2, T1, I&gt;* b2;             <span class='comment'>// not the current instantiation
</span>  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B&lt;my_T1, T2, my_I&gt;* b3;       <span class='comment'>// refers to the current instantiation
</span>  B&lt;my_T1, T2, my_I2&gt;* b4;      <span class='comment'>// not the current instantiation
</span>  B&lt;my_T1, T2, my_I3&gt;* b5;      <span class='comment'>// refers to the current instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='instantiation,member_of_the_current'></a></span>A name is a
<a class='hidden_link' href='#def:member_of_the_current_instantiation' id='def:member_of_the_current_instantiation'><i>member of the current instantiation</i></a>
if it is</p><ul ><li ><p >An unqualified name that, when looked up, refers to
at least one member of a class that is
the current instantiation or a non-dependent base class thereof.
[&nbsp;<i>Note:</i>
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li ><p >A
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation
and that, when looked up, refers to at least one member of a class that is
the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) for which the type of the object expression is the
current instantiation, and the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>, when looked
up (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), refers to at least one member of a class
that is the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  static const int i = 5;
  int n1[i];        <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>  int n2[A::i];     <span class='comment'>// <span class='texttt'>A::i</span> refers to a member of the current instantiation
</span>  int n3[A&lt;T&gt;::i];  <span class='comment'>// <span class='texttt'>A&lt;T&gt;::i</span> refers to a member of the current instantiation
</span>  int f();
};

template &lt;class T&gt; int A&lt;T&gt;::f() {
  return i;         <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='instantiation,dependent_member_of_the_current'></a></span>A name is a <a class='hidden_link' href='#def:dependent_member_of_the_current_instantiation' id='def:dependent_member_of_the_current_instantiation'><i>dependent member of the current instantiation</i></a> if it is a
member of the current instantiation that, when looked up, refers to at least
one member of a class that is the current instantiation.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A name is a
<a class='hidden_link' href='#def:member_of_an_unknown_specialization' id='def:member_of_an_unknown_specialization'><i>member of an unknown specialization</i></a>
if it is</p><ul ><li ><p >A
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
names a dependent type that is not the current instantiation.</p></li><li ><p >A <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> does not
find any member of a class that is the current instantiation or a non-dependent
base class thereof.</p></li><li ><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) in which either
</p><ul ><li ><p >the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> does not find a member of a class that is
the current instantiation or a non-dependent base class thereof; or</p></li><li ><p >the type of the object expression is dependent and is not the current
instantiation.
</p></li></ul></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is not instantiated; no
diagnostic required. Similarly, if the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; class A {
  typedef int type;
  void f() {
    A&lt;T&gt;::type i;           <span class='comment'>// OK: refers to a member of the current instantiation
</span>    typename A&lt;T&gt;::other j; <span class='comment'>// error: neither a member of the current instantiation nor
</span>                            <span class='comment'>// a member of an unknown specialization
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> or class member access expression, the name in the
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous. [&nbsp;<i>Note:</i> the result of name lookup differs only when the member of
the current instantiation was found in a non-dependent base class of the current
instantiation and a member with the same name is also introduced by the
substitution for a dependent base class of the current instantiation. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A type is dependent if it is
</p><ul ><li ><p >a template parameter,
</p></li><li ><p >a member of an unknown specialization,
</p></li><li ><p >a nested class or enumeration that is a dependent member of the current
instantiation,
</p></li><li ><p >a cv-qualified type where the cv-unqualified type is dependent,
</p></li><li ><p >a compound type constructed from any dependent type,
</p></li><li ><p >an array type constructed from any dependent type or whose
size is specified by a constant expression that is value-dependent,
</p></li><li ><p >a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent, or
</p></li><li ><p >denoted by <span class='texttt'>decltype(</span><i ><a href='expr.comma#nt:expression'>expression</a></i><span class='texttt'>)</span>,
where <i ><a href='expr.comma#nt:expression'>expression</a></i> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
</p></li></ul></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i>
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>