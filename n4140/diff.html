<!DOCTYPE html><html lang='en'><head><title>[diff]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='diff'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><div id='iso'><h2 ><a class='secnum' href='#iso' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso'>[diff.iso]</a></h2><div class='para' id='iso-1'><div class='marginalizedparent'><a class='marginalized' href='#iso-1'>1</a></div><p ><span class='indexparent'><a class='index' id='summary,compatibility_with_ISO_C'></a></span>This subclause lists the differences between C++ and
ISO C, by the chapters of this document.</p></div><div id='lex'><h3 ><a class='secnum' href='#lex' style='min-width:103pt'>C.1.1</a> Clause <a href='lex'>[lex]</a>: lexical conventions <a class='abbr_ref' href='diff.lex'>[diff.lex]</a></h3><p ><a href='lex.key'>[lex.key]</a>
<span class='hfill'></span><br/><b>Change:</b> New Keywords<br/>
New keywords are added to C++;
see <a href='lex.key'>[lex.key]</a>.
<span class='hfill'></span><br/><b>Rationale:</b>
These keywords were added in order to implement the new
semantics of C++.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
Any ISO C programs that used any of these keywords as identifiers
are not valid C++ programs.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
Converting one specific program is easy.
Converting a large collection
of related programs takes more work.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='lex.ccon'>[lex.ccon]</a>
<span class='hfill'></span><br/><b>Change:</b> Type of character literal is changed from <span class='texttt'>int</span> to <span class='texttt'>char</span>
<span class='hfill'></span><br/><b>Rationale:</b>
This is needed for improved overloaded function argument type
matching.
For example:</p><pre class='codeblock'>
int function( int i );
int function( char c );

function( 'x' );
</pre><p >It is preferable that this call match the second version of
function rather than the first.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
ISO C programs which depend on</p><pre class='codeblock'>
sizeof('x') == sizeof(int)
</pre><p >will not work the same as C++ programs.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Simple.
<span class='hfill'></span><br/><b>How widely used:</b>
Programs which depend upon <span class='texttt'>sizeof('x')</span> are probably rare.</p><p >Subclause <a href='lex.string'>[lex.string]</a>:
<span class='hfill'></span><br/><b>Change:</b> String literals made const<br/>
The type of a string literal is changed
from “array of <span class='texttt'>char</span>”
to “array of <span class='texttt'>const char</span>.”
The type of a <span class='texttt'>char16_t</span> string literal is changed
from “array of <i>some-integer-type</i>”
to “array of <span class='texttt'>const char16_t</span>.”
The type of a <span class='texttt'>char32_t</span> string literal is changed
from “array of <i>some-integer-type</i>”
to “array of <span class='texttt'>const char32_t</span>.”
The type of a wide string literal is changed
from “array of <span class='texttt'>wchar_t</span>”
to “array of <span class='texttt'>const wchar_t</span>.”
<span class='hfill'></span><br/><b>Rationale:</b>
This avoids calling an inappropriate overloaded function,
which might expect to be able to modify its argument.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation. The fix is to add a cast:</p><pre class='codeblock'>
char* p = "abc";                <span class='comment'>// valid in C, invalid in C++
</span>void f(char*) {
  char* p = (char*)"abc";       <span class='comment'>// OK: cast added
</span>  f(p);
  f((char*)"def");              <span class='comment'>// OK: cast added
</span>}
</pre><p ><span class='hfill'></span><br/><b>How widely used:</b>
Programs that have a legitimate reason to treat string literals
as pointers to potentially modifiable memory are probably rare.</p></div><div id='basic'><h3 ><a class='secnum' href='#basic' style='min-width:103pt'>C.1.2</a> Clause <a href='basic'>[basic]</a>: basic concepts <a class='abbr_ref' href='diff.basic'>[diff.basic]</a></h3><p ><a href='basic.def'>[basic.def]</a>
<span class='hfill'></span><br/><b>Change:</b> C++ does not have “tentative definitions” as in C
E.g., at file scope,</p><pre class='codeblock'>
int i;
int i;
</pre><p >is valid in C, invalid in C++.
This makes it impossible to define
mutually referential file-local static objects, if initializers are
restricted to the syntactic forms of C.
For example,</p><pre class='codeblock'>
struct X { int i; struct X* next; };

static struct X a;
static struct X b = { 0, &amp;a };
static struct X a = { 1, &amp;b };
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
This avoids having different initialization rules for
fundamental types and user-defined types.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>Rationale:</b>
In C++, the initializer for one of a set of
mutually-referential file-local static objects must invoke a function
call to achieve the initialization.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='basic.scope'>[basic.scope]</a>
<span class='hfill'></span><br/><b>Change:</b> A <span class='texttt'>struct</span> is a scope in C++, not in C
<span class='hfill'></span><br/><b>Rationale:</b>
Class scope is crucial to C++, and a struct is a class.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
C programs use <span class='texttt'>struct</span> extremely frequently, but the
change is only noticeable when <span class='texttt'>struct</span>, enumeration, or enumerator
names are referred to outside the <span class='texttt'>struct</span>.
The latter is probably rare.</p><p ><a href='basic.link'>[basic.link]</a> [also <a href='dcl.type'>[dcl.type]</a>] 
<span class='hfill'></span><br/><b>Change:</b> A name of file scope that is explicitly declared <span class='texttt'>const</span>, and not explicitly
declared <span class='texttt'>extern</span>, has internal linkage, while in C it would have external linkage
<span class='hfill'></span><br/><b>Rationale:</b>
Because <span class='texttt'>const</span> objects can be used as compile-time values in
C++, this feature urges programmers to provide explicit initializer
values for each <span class='texttt'>const</span>.
This feature allows the user to put <span class='texttt'>const</span>objects in header files that are included
in many compilation units.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom</p><p ><a href='basic.start'>[basic.start]</a>
<span class='hfill'></span><br/><b>Change:</b> Main cannot be called recursively and cannot have its address taken
<span class='hfill'></span><br/><b>Rationale:</b>
The  main  function may require special actions.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Trivial: create an intermediary function such as
<span class='texttt'>mymain(argc, argv)</span>.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom</p><p ><a href='basic.types'>[basic.types]</a>
<span class='hfill'></span><br/><b>Change:</b> C allows “compatible types” in several places, C++ does not
For example,
otherwise-identical <span class='texttt'>struct</span> types with different tag names
are “compatible” in C but are distinctly different types
in C++.
<span class='hfill'></span><br/><b>Rationale:</b>
Stricter type checking is essential for C++.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
The “typesafe linkage” mechanism will find many, but not all,
of such problems.
Those problems not found by typesafe linkage will continue to
function properly,
according to the “layout compatibility rules” of this
International Standard.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p></div><div id='conv'><h3 ><a class='secnum' href='#conv' style='min-width:103pt'>C.1.3</a> Clause <a href='conv'>[conv]</a>: standard conversions <a class='abbr_ref' href='diff.conv'>[diff.conv]</a></h3><p ><a href='conv.ptr'>[conv.ptr]</a>
<span class='hfill'></span><br/><b>Change:</b> Converting <span class='texttt'>void*</span> to a pointer-to-object type requires casting</p><pre class='codeblock'>
char a[10];
void* b=a;
void foo() {
  char* c=b;
}
</pre><p >ISO C will accept this usage of pointer to void being assigned
to a pointer to object type.
C++ will not.
<span class='hfill'></span><br/><b>Rationale:</b>
C++ tries harder than C to enforce compile-time type safety.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Could be automated.
Violations will be diagnosed by the C++ translator.
The
fix is to add a  cast.
For example:</p><pre class='codeblock'>
char* c = (char*) b;
</pre><p ><span class='hfill'></span><br/><b>How widely used:</b>
This is fairly widely used but it is good
programming practice to add the cast when assigning pointer-to-void to pointer-to-object.
Some ISO C translators will give a warning
if the cast is not used.</p></div><div id='expr'><h3 ><a class='secnum' href='#expr' style='min-width:103pt'>C.1.4</a> Clause <a href='expr'>[expr]</a>: expressions <a class='abbr_ref' href='diff.expr'>[diff.expr]</a></h3><p ><a href='expr.call'>[expr.call]</a>
<span class='hfill'></span><br/><b>Change:</b> Implicit declaration of functions is not allowed
<span class='hfill'></span><br/><b>Rationale:</b>
The type-safe nature of C++.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
Note: the original feature was labeled as “obsolescent” in ISO C.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
Facilities for producing explicit function declarations are fairly
widespread commercially.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='expr.sizeof'>[expr.sizeof]</a>, <a href='expr.cast'>[expr.cast]</a>
<span class='hfill'></span><br/><b>Change:</b> Types must be declared in declarations, not in expressions
In C, a sizeof expression or cast expression may create a new type.
For example,
</p><pre class='codeblock'>
p = (void*)(struct x {int i;} *)0;
</pre><p >declares a new type, struct x .
<span class='hfill'></span><br/><b>Rationale:</b>
This prohibition helps to clarify the location of
declarations in the source code.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of a semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='expr.cond'>[expr.cond]</a>, <a href='expr.ass'>[expr.ass]</a>, <a href='expr.comma'>[expr.comma]</a></p><p ><span class='indexparent'><a class='index' id='conversion,lvalue-to-rvalue'></a></span><span class='indexparent'><a class='index' id='rvalue,lvalue_conversion_to'></a></span><span class='indexparent'><a class='index' id='lvalue'></a></span><span class='hfill'></span><br/><b>Change:</b> The result of a conditional expression, an assignment expression, or a comma expression may be an lvalue
<span class='hfill'></span><br/><b>Rationale:</b>
C++ is an object-oriented language, placing relatively
more emphasis on lvalues.  For example, functions may
return lvalues.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.  Some C
expressions that implicitly rely on lvalue-to-rvalue
conversions will yield different results.  For example,</p><pre class='codeblock'>
char arr[100];
sizeof(0, arr)
</pre><p >yields
<span class='texttt'>100</span>
in C++ and
<span class='texttt'>sizeof(char*)</span>
in C.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Programs must add explicit casts to the appropriate rvalue.
<span class='hfill'></span><br/><b>How widely used:</b>
Rare.</p></div><div id='stat'><h3 ><a class='secnum' href='#stat' style='min-width:103pt'>C.1.5</a> Clause <a href='stmt.stmt'>[stmt.stmt]</a>: statements <a class='abbr_ref' href='diff.stat'>[diff.stat]</a></h3><p ><a href='stmt.switch'>[stmt.switch]</a>, <a href='stmt.goto'>[stmt.goto]</a>
<span class='hfill'></span><br/><b>Change:</b> It is now invalid to jump past a declaration with explicit or implicit initializer (except across entire block not entered)
<span class='hfill'></span><br/><b>Rationale:</b>
Constructors used in initializers may allocate
resources which need to be de-allocated upon leaving the
block.
Allowing jump past initializers would require
complicated run-time determination of allocation.
Furthermore, any use of the uninitialized object could be a
disaster.
With this simple compile-time rule, C++ assures that
if an initialized variable is in scope, then it has assuredly been
initialized.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='stmt.return'>[stmt.return]</a>
<span class='hfill'></span><br/><b>Change:</b> It is now invalid to return (explicitly or implicitly) from a function which is
declared to return a value without actually returning a value
<span class='hfill'></span><br/><b>Rationale:</b>
The caller and callee may assume fairly elaborate
return-value mechanisms for the return of class objects.
If
some flow paths execute a return without specifying any value,
the implementation must embody many more complications.
Besides,
promising to return a value of a given type, and then not returning
such a value, has always been recognized to be a questionable
practice, tolerated only because very-old C had no distinction between
void  functions and  int  functions.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
Add an appropriate return value to the source code, such as zero.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
For several years, many existing C implementations have produced warnings in
this case.</p></div><div id='dcl'><h3 ><a class='secnum' href='#dcl' style='min-width:103pt'>C.1.6</a> Clause <a href='dcl.dcl'>[dcl.dcl]</a>: declarations <a class='abbr_ref' href='diff.dcl'>[diff.dcl]</a></h3><p ><a href='dcl.stc'>[dcl.stc]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, the <span class='texttt'>static</span> or <span class='texttt'>extern</span> specifiers can only be applied to names of objects or functions
Using these specifiers with type declarations is illegal in C++.
In C, these specifiers are ignored when used on type declarations.</p><p >Example:</p><pre class='codeblock'>
static struct S {               <span class='comment'>// valid C, invalid in C++
</span>  int i;
};
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
Storage class specifiers don't have any meaning when associated
with a type.
In C++, class members can be declared with the <span class='texttt'>static</span> storage
class specifier.
Allowing storage class specifiers on type
declarations could render the code confusing for users.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.typedef'>[dcl.typedef]</a>
<span class='hfill'></span><br/><b>Change:</b> A C++ typedef name must be different from any class type name declared
in the same scope (except if the typedef is a synonym of the class name with the
same name). In C, a typedef name and a struct tag name declared in the same scope
can have the same name (because they have different name spaces)</p><p >Example:
</p><pre class='codeblock'>
typedef struct name1 { <span class='comment'>/*...*/</span> } name1;         <span class='comment'>// valid C and C++
</span>struct name { <span class='comment'>/*...*/</span> };
typedef int name;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
For ease of use, C++ doesn't require that a type name be prefixed
with the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span> or <span class='texttt'>union</span> when used in object
declarations or type casts.</p><p >Example:
</p><pre class='codeblock'>
class name { <span class='comment'>/*...*/</span> };
name i;                         <span class='comment'>// <span class='texttt'>i</span> has type <span class='texttt'>class name</span>
</span></pre><p ><span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
One of the 2 types has to be renamed.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a> [see also <a href='basic.link'>[basic.link]</a>]
<span class='hfill'></span><br/><b>Change:</b> const objects must be initialized in C++ but can be left uninitialized in C
<span class='hfill'></span><br/><b>Rationale:</b>
A const object cannot be assigned to so it must be initialized
to hold a useful value.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a>
<span class='hfill'></span><br/><b>Change:</b> Banning implicit int</p><p >In C++ a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
must contain a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, unless
it is followed by a declarator for a constructor, a destructor, or a
conversion function.
In the following example, the
left-hand column presents valid C;
the right-hand column presents
equivalent C++ :</p><pre class='codeblock'>
void f(const parm);            void f(const int parm);
const n = 3;                   const int n = 3;
main()                         int main()
    <span class='comment'>/* ... */</span>                      <span class='comment'>/* ... */</span>
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
In C++, implicit int creates several opportunities for
ambiguity between expressions involving function-like
casts and declarations.
Explicit declaration is increasingly considered
to be proper style.
Liaison with WG14 (C) indicated support for (at least)
deprecating implicit int in the next revision of C.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
Could be automated.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.spec.auto'>[dcl.spec.auto]</a>
<span class='hfill'></span><br/><b>Change:</b>
The keyword <span class='texttt'>auto</span> cannot be used as a storage class specifier.</p><pre class='codeblock'>
void f() {
  auto int x;     <span class='comment'>// valid C, invalid C++
</span>}
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b> Allowing the use of <span class='texttt'>auto</span> to deduce the type
of a variable from its initializer results in undesired interpretations of
<span class='texttt'>auto</span> as a storage class specifier in certain contexts.
<span class='hfill'></span><br/><b>Effect on original feature:</b> Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b> Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b> Rare.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<span class='hfill'></span><br/><b>Change:</b> C++ objects of enumeration type can only be assigned values of the same enumeration type.
In C, objects of enumeration type can be assigned values of any integral type</p><p >Example:
</p><pre class='codeblock'>
enum color { red, blue, green };
enum color c = 1;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
The type-safe nature of C++.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
(The type error produced by the assignment can be automatically
corrected by applying an explicit cast.)
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, the type of an enumerator is its enumeration. In C, the type of an enumerator is <span class='texttt'>int</span>.</p><p >Example:</p><pre class='codeblock'>
enum e { A };
sizeof(A) == sizeof(int)        <span class='comment'>// in C
</span>sizeof(A) == sizeof(e)          <span class='comment'>// in C++
</span><span class='comment'>/* <i><span class='textrm'>and <span class='texttt'>sizeof(int)</span> is not necessarily equal to <span class='texttt'>sizeof(e)</span></span></i> */</span>
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
In C++, an enumeration is a distinct type.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
The only time this affects existing C code is when the size of an
enumerator is taken.
Taking the size of an enumerator is not a
common C coding practice.</p></div><div id='decl'><h3 ><a class='secnum' href='#decl' style='min-width:103pt'>C.1.7</a> Clause <a href='dcl.decl'>[dcl.decl]</a>: declarators <a class='abbr_ref' href='diff.decl'>[diff.decl]</a></h3><p ><a href='dcl.fct'>[dcl.fct]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, a function declared with an empty parameter list takes no arguments.
In C, an empty parameter list means that the number and type of the function arguments are unknown.</p><p >Example:</p><pre class='codeblock'>
int f();            <span class='comment'>// means   <span class='texttt'>int f(void)</span> in C++
</span>                    <span class='comment'>// <span class='texttt'>int f(</span> unknown <span class='texttt'>)</span> in C
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
This is to avoid erroneous function calls (i.e., function calls
with the wrong number or type of arguments).
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
This feature was marked as “obsolescent” in C.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
The function declarations using C incomplete declaration style must
be completed to become full prototype declarations.
A program may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or
if the type of corresponding arguments differed.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.fct'>[dcl.fct]</a> [see <a href='expr.sizeof'>[expr.sizeof]</a>]
<span class='hfill'></span><br/><b>Change:</b> In C++, types may not be defined in return or parameter types. In C, these type definitions are allowed</p><p >Example:</p><pre class='codeblock'>
void f( struct S { int a; } arg ) {}    <span class='comment'>// valid C, invalid C++
</span>enum E { A, B, C } f() {}               <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
When comparing types in different compilation units, C++ relies
on name equivalence when C relies on structural equivalence.
Regarding parameter types: since the type defined in an parameter list
would be in the scope of the function, the only legal calls in C++
would be from within the function itself.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
The type definitions must be moved to file scope, or in header files.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
This style of type definitions is seen as poor coding style.</p><p ><a href='dcl.fct.def'>[dcl.fct.def]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, the syntax for function definition excludes the “old-style” C function.
In C, “old-style” syntax is allowed, but deprecated as “obsolescent.”
<span class='hfill'></span><br/><b>Rationale:</b>
Prototypes are essential to type safety.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Common in old programs, but already known to be obsolescent.</p><p ><a href='dcl.init.string'>[dcl.init.string]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, when initializing an array of character with a string, the number of
characters in the string (including the terminating <span class='texttt'>'\0'</span>) must not exceed the
number of elements in the array. In C, an array can be initialized with a string even if
the array is not large enough to contain the string-terminating <span class='texttt'>'\0'</span></p><p >Example:</p><pre class='codeblock'>
char array[4] = "abcd";         <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
When these non-terminated arrays are manipulated by standard
string routines, there is potential for major catastrophe.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
The arrays must be declared one element bigger to contain the
string terminating <span class='texttt'>'\0'</span>.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
This style of array initialization is seen as poor coding style.</p></div><div id='class'><h3 ><a class='secnum' href='#class' style='min-width:103pt'>C.1.8</a> Clause <a href='class'>[class]</a>: classes <a class='abbr_ref' href='diff.class'>[diff.class]</a></h3><p ><a href='class.name'>[class.name]</a> [see also <a href='dcl.typedef'>[dcl.typedef]</a>]
<span class='hfill'></span><br/><b>Change:</b> In C++, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope. In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope</p><p >Example:</p><pre class='codeblock'>
int x[99];
void f() {
  struct x { int a; };
  sizeof(x);  <span class='comment'>/* <i><span class='textrm'>size of the array in C</span></i> */</span>
  <span class='comment'>/* <i><span class='textrm'>size of the struct in C++</span></i> */</span>
}
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
This is one of the few incompatibilities between C and C++ that
can be attributed to the new C++ name space definition where a
name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that
the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span>, <span class='texttt'>union</span> or <span class='texttt'>enum</span> be used to refer to the type name.
This new name space definition provides important notational
conveniences to C++ programmers and helps making the use of the
user-defined types as similar as possible to the use of fundamental
types.
The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
If the hidden name that needs to be accessed is at global scope,
the <span class='texttt'>::</span> C++ operator can be used.
If the hidden name is at block scope, either the type or the struct
tag has to be renamed.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.bit'>[class.bit]</a>
<span class='hfill'></span><br/><b>Change:</b>
<span class='indexparent'><a class='index' id='bit-field,implementation-defined_sign_of'></a></span>Bit-fields of type plain <span class='texttt'>int</span> are signed.
<span class='hfill'></span><br/><b>Rationale:</b>
Leaving the choice of signedness to implementations could lead to
inconsistent definitions of template specializations. For consistency,
the implementation freedom was eliminated for non-dependent types,
too.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
The choise is implementation-defined in C, but not so in C++.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nest'>[class.nest]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, the name of a nested class is local to its enclosing class. In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class.</p><p >Example:</p><pre class='codeblock'>
struct X {
  struct Y { <span class='comment'>/* ... */</span> } y;
};
struct Y yy;                    <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
C++ classes have member functions which require that classes
establish scopes.
The C rule would leave classes as an incomplete scope mechanism
which would prevent C++ programmers from maintaining locality
within a class.
A coherent set of scope rules for C++ based on the C rule would
be very complicated and C++ programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change of semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined.
Example:</p><pre class='codeblock'>
struct Y;                       <span class='comment'>// <span class='texttt'>struct Y</span> and <span class='texttt'>struct X</span> are at the same scope
</span>struct X {
  struct Y { <span class='comment'>/* ... */</span> } y;
};
</pre><p >All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct.
Note: this is a consequence of the difference in scope rules,
which is documented in <a href='basic.scope'>[basic.scope]</a>.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nested.type'>[class.nested.type]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, a typedef name may not be redeclared in a class definition after being used in that definition</p><p >Example:</p><pre class='codeblock'>
typedef int I;
struct S {
  I i;
  int I;                  <span class='comment'>// valid C, invalid C++
</span>};
</pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for C++
programmers as to what the meaning of 'I' really is.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
Either the type or the struct member has to be renamed.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p></div><div id='special'><h3 ><a class='secnum' href='#special' style='min-width:103pt'>C.1.9</a> Clause <a href='special'>[special]</a>: special member functions <a class='abbr_ref' href='diff.special'>[diff.special]</a></h3><p ><a href='class.copy'>[class.copy]</a>
<span class='hfill'></span><br/><b>Change:</b> Copying volatile objects</p><p >The implicitly-declared copy constructor and
implicitly-declared copy assignment operator
cannot make a copy of a volatile lvalue.
For example, the following is valid in ISO C:</p><pre class='codeblock'>
struct X { int i; };
volatile struct X x1 = {0};
struct X x2(x1);                <span class='comment'>// invalid C++
</span>struct X x3;
x3 = x1;                        <span class='comment'>// also invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
Several alternatives were debated at length.
Changing the parameter to
<span class='texttt'>volatile</span>
<span class='texttt'>const</span>
<span class='texttt'>X&amp;</span>
would greatly complicate the generation of
efficient code for class objects.
Discussion of
providing two alternative signatures for these
implicitly-defined operations raised
unanswered concerns about creating
ambiguities and complicating
the rules that specify the formation of
these operators according to the bases and
members.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
If volatile semantics are required for the copy,
a user-declared constructor or assignment must
be provided. [&nbsp;<i>Note:</i> This user-declared
constructor may be explicitly defaulted. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If non-volatile semantics are required,
an explicit
<span class='texttt'>const_cast</span>
can be used.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.</p></div><div id='cpp'><h3 ><a class='secnum' href='#cpp' style='min-width:103pt'>C.1.10</a> Clause <a href='cpp'>[cpp]</a>: preprocessing directives <a class='abbr_ref' href='diff.cpp'>[diff.cpp]</a></h3><p ><a href='cpp.predefined'>[cpp.predefined]</a>
<span class='hfill'></span><br/><b>Change:</b> Whether <span class='texttt'>__STDC__</span> is defined and if so, what its value is, are
implementation-defined
<span class='hfill'></span><br/><b>Rationale:</b>
C++ is not identical to ISO C.
Mandating that <span class='texttt'>__STDC__</span>
be defined would require that translators make an incorrect claim.
Each implementation must choose the behavior that will be most
useful to its marketplace.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Programs and headers that reference <span class='texttt'>__STDC__</span> are
quite common.</p></div></div><div id='cpp03'><h2 ><a class='secnum' href='#cpp03' style='min-width:88pt'>C.2</a> C++ and ISO C++ 2003 <a class='abbr_ref' href='diff.cpp03'>[diff.cpp03]</a></h2><div class='para' id='cpp03-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp03-1'>1</a></div><p ><span class='indexparent'><a class='index' id='summary,compatibility_with_ISO_C++_2003_'></a></span>This subclause lists the differences between C++ and
ISO C++ 2003 (ISO/IEC 14882:2003, <i>Programming Languages — C++</i>),
by the chapters of this document.</p></div><div id='cpp03.lex'><h3 ><a class='secnum' href='#cpp03.lex' style='min-width:103pt'>C.2.1</a> Clause <a href='lex'>[lex]</a>: lexical conventions <a class='abbr_ref' href='diff.cpp03.lex'>[diff.cpp03.lex]</a></h3><p ><a href='lex.pptoken'>[lex.pptoken]</a>
<span class='hfill'></span><br/><b>Change:</b> New kinds of string literals
<span class='hfill'></span><br/><b>Rationale:</b> Required for new features.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may fail to compile or produce different results in
this International Standard. Specifically, macros named <span class='texttt'>R</span>, <span class='texttt'>u8</span>,
<span class='texttt'>u8R</span>, <span class='texttt'>u</span>, <span class='texttt'>uR</span>, <span class='texttt'>U</span>, <span class='texttt'>UR</span>, or <span class='texttt'>LR</span> will
not be expanded when adjacent to a string literal but will be interpreted as
part of the string literal. For example,</p><pre class='codeblock'>
#define u8 "abc"
const char* s = u8"def";        <span class='comment'>// Previously <span class='texttt'>"abcdef"</span>, now <span class='texttt'>"def"</span>
</span></pre><p ><a href='lex.pptoken'>[lex.pptoken]</a>
<span class='hfill'></span><br/><b>Change:</b> User-defined literal string support
<span class='hfill'></span><br/><b>Rationale:</b> Required for new features.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may fail to compile or produce different results in
this International Standard, as the following example illustrates.</p><pre class='codeblock'>
#define _x "there"
"hello"_x         <span class='comment'>// #1
</span></pre><p >Previously, #1 would have consisted of two separate preprocessing tokens and
the macro <span class='texttt'>_x</span> would have been expanded. In this International Standard,
#1 consists of a single preprocessing tokens, so the macro is not expanded.</p><p ><a href='lex.key'>[lex.key]</a>
<span class='hfill'></span><br/><b>Change:</b> New keywords
<span class='hfill'></span><br/><b>Rationale:</b> Required for new features.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Added to Table <a href='lex.key#tab:keywords'>[tab:keywords]</a>, the following identifiers are new keywords:
<span class='texttt'>alignas</span>,
<span class='texttt'>alignof</span>,
<span class='texttt'>char16_t</span>,
<span class='texttt'>char32_t</span>,
<span class='texttt'>constexpr</span>,
<span class='texttt'>decltype</span>,
<span class='texttt'>noexcept</span>,
<span class='texttt'>nullptr</span>,
<span class='texttt'>static_assert</span>,
and
<span class='texttt'>thread_local</span>.
Valid C++ 2003 code using these identifiers is invalid in this International
Standard.</p><p ><a href='lex.icon'>[lex.icon]</a>
<span class='hfill'></span><br/><b>Change:</b> Type of integer literals
<span class='hfill'></span><br/><b>Rationale:</b> C99 compatibility.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Certain integer literals larger than can be represented by <span class='texttt'>long</span> could
change from an unsigned integer type to <span class='texttt'>signed long long</span>.</p></div><div id='cpp03.conv'><h3 ><a class='secnum' href='#cpp03.conv' style='min-width:103pt'>C.2.2</a> Clause <a href='conv'>[conv]</a>: standard conversions <a class='abbr_ref' href='diff.cpp03.conv'>[diff.cpp03.conv]</a></h3><p ><a href='conv.ptr'>[conv.ptr]</a>
<span class='hfill'></span><br/><b>Change:</b> Only literals are integer null pointer constants
<span class='hfill'></span><br/><b>Rationale:</b> Removing surprising interactions with templates and constant
expressions
<span class='hfill'></span><br/><b>Effect on original feature:</b> Valid C++ 2003 code may fail to compile or produce different results in
this International Standard, as the following example illustrates:</p><pre class='codeblock'>
void f(void *);  <span class='comment'>// #1
</span>void f(...);     <span class='comment'>// #2
</span>template&lt;int N&gt; void g() {
  f(0*N);        <span class='comment'>// calls #2; used to call #1
</span>}
</pre></div><div id='cpp03.expr'><h3 ><a class='secnum' href='#cpp03.expr' style='min-width:103pt'>C.2.3</a> Clause <a href='expr'>[expr]</a>: expressions <a class='abbr_ref' href='diff.cpp03.expr'>[diff.cpp03.expr]</a></h3><p ><a href='expr.mul'>[expr.mul]</a>
<span class='hfill'></span><br/><b>Change:</b> Specify rounding for results of integer <span class='texttt'>/</span> and <span class='texttt'>%</span>
<span class='hfill'></span><br/><b>Rationale:</b> Increase portability, C99 compatibility.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that uses integer division rounds the result toward 0 or
toward negative infinity, whereas this International Standard always rounds
the result toward 0.</p></div><div id='cpp03.dcl.dcl'><h3 ><a class='secnum' href='#cpp03.dcl.dcl' style='min-width:103pt'>C.2.4</a> Clause <a href='dcl.dcl'>[dcl.dcl]</a>: declarations <a class='abbr_ref' href='diff.cpp03.dcl.dcl'>[diff.cpp03.dcl.dcl]</a></h3><p ><a href='dcl.spec'>[dcl.spec]</a>
<span class='hfill'></span><br/><b>Change:</b> Remove <span class='texttt'>auto</span> as a storage class specifier
<span class='hfill'></span><br/><b>Rationale:</b> New feature.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that uses the keyword <span class='texttt'>auto</span> as a storage class
specifier may be invalid in this International Standard. In this International
Standard, <span class='texttt'>auto</span> indicates that the type of a variable is to be deduced
from its initializer expression.</p></div><div id='cpp03.dcl.decl'><h3 ><a class='secnum' href='#cpp03.dcl.decl' style='min-width:103pt'>C.2.5</a> Clause <a href='dcl.decl'>[dcl.decl]</a>: declarators <a class='abbr_ref' href='diff.cpp03.dcl.decl'>[diff.cpp03.dcl.decl]</a></h3><p ><a href='dcl.init.list'>[dcl.init.list]</a>
<span class='hfill'></span><br/><b>Change:</b> Narrowing restrictions in aggregate initializers
<span class='hfill'></span><br/><b>Rationale:</b> Catches bugs.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may fail to compile in this International Standard. For
example, the following code is valid in C++ 2003 but invalid in this
International Standard because <span class='texttt'>double</span> to <span class='texttt'>int</span> is a narrowing
conversion:</p><pre class='codeblock'>
int x[] = { 2.0 };
</pre></div><div id='cpp03.special'><h3 ><a class='secnum' href='#cpp03.special' style='min-width:103pt'>C.2.6</a> Clause <a href='special'>[special]</a>: special member functions <a class='abbr_ref' href='diff.cpp03.special'>[diff.cpp03.special]</a></h3><p ><a href='class.ctor'>[class.ctor]</a>, <a href='class.dtor'>[class.dtor]</a>, <a href='class.copy'>[class.copy]</a>
<span class='hfill'></span><br/><b>Change:</b> Implicitly-declared special member functions are defined as deleted
when the implicit definition would have been ill-formed.
<span class='hfill'></span><br/><b>Rationale:</b> Improves template argument deduction failure.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
A valid C++ 2003 program that uses one of these special member functions in a
context where the definition is not required (e.g., in an expression that is
not potentially evaluated) becomes ill-formed.</p><p ><a href='class.dtor'>[class.dtor]</a> (destructors)
<span class='hfill'></span><br/><b>Change:</b> User-declared destructors have an implicit exception specification.
<span class='hfill'></span><br/><b>Rationale:</b> Clarification of destructor requirements.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may execute differently in this International Standard. In
particular, destructors that throw exceptions will call <span class='texttt'>std::terminate()</span>
(without calling <span class='texttt'>std::unexpected()</span>) if their exception specification is
<span class='texttt'>noexcept</span> or <span class='texttt'>noexcept(true)</span>. For a throwing virtual destructor
of a derived class, <span class='texttt'>std::terminate()</span> can be avoided only if the base class
virtual destructor has an exception specification that is not <span class='texttt'>noexcept</span>
and not <span class='texttt'>noexcept(true)</span>.</p></div><div id='cpp03.temp'><h3 ><a class='secnum' href='#cpp03.temp' style='min-width:103pt'>C.2.7</a> Clause <a href='temp'>[temp]</a>: templates <a class='abbr_ref' href='diff.cpp03.temp'>[diff.cpp03.temp]</a></h3><p ><a href='temp.param'>[temp.param]</a>
<span class='hfill'></span><br/><b>Change:</b> Remove <span class='texttt'>export</span>
<span class='hfill'></span><br/><b>Rationale:</b> No implementation consensus.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
A valid C++ 2003 declaration containing <span class='texttt'>export</span> is ill-formed in this
International Standard.</p><p ><a href='temp.arg'>[temp.arg]</a>
<span class='hfill'></span><br/><b>Change:</b> Remove whitespace requirement for nested closing template right angle
brackets
<span class='hfill'></span><br/><b>Rationale:</b> Considered a persistent but minor annoyance. Template aliases
representing nonclass types would exacerbate whitespace issues.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined expression. A valid C++ 2003 expression
containing a right angle bracket (“<span class='texttt'>&gt;</span>”) followed immediately by
another right angle bracket may now be treated as closing two templates.
For example, the following code is valid in C++ 2003 because “<span class='texttt'>&gt;&gt;</span>”
is a right-shift operator, but invalid in this International Standard because
“<span class='texttt'>&gt;&gt;</span>” closes two templates.</p><pre class='codeblock'>
template &lt;class T&gt; struct X { };
template &lt;int N&gt; struct Y { };
X&lt; Y&lt; 1 &gt;&gt; 2 &gt; &gt; x;
</pre><p ><a href='temp.dep.candidate'>[temp.dep.candidate]</a>
<span class='hfill'></span><br/><b>Change:</b> Allow dependent calls of functions with internal linkage
<span class='hfill'></span><br/><b>Rationale:</b> Overly constrained, simplify overload resolution rules.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
A valid C++ 2003 program could get a different result than this
International Standard.</p></div><div id='cpp03.library'><h3 ><a class='secnum' href='#cpp03.library' style='min-width:103pt'>C.2.8</a> Clause <a href='library'>[library]</a>: library introduction <a class='abbr_ref' href='diff.cpp03.library'>[diff.cpp03.library]</a></h3><p ><a href='library'>[library]</a> – <a href='thread'>[thread]</a>
<span class='hfill'></span><br/><b>Change:</b> New reserved identifiers
<span class='hfill'></span><br/><b>Rationale:</b> Required by new features.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that uses any identifiers added to the C++ standard
library by this International Standard may fail to compile or produce different
results in This International Standard. A comprehensive list of identifiers used
by the C++ standard library can be found in the Index of Library Names in this
International Standard.</p><p ><a href='headers'>[headers]</a>
<span class='hfill'></span><br/><b>Change:</b> New headers
<span class='hfill'></span><br/><b>Rationale:</b> New functionality.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
The following C++ headers are new:
<span class='texttt'>&lt;array&gt;</span>,
<span class='texttt'>&lt;atomic&gt;</span>,
<span class='texttt'>&lt;chrono&gt;</span>,
<span class='texttt'>&lt;codecvt&gt;</span>,
<span class='texttt'>&lt;condition_variable&gt;</span>,
<span class='texttt'>&lt;forward_list&gt;</span>,
<span class='texttt'>&lt;future&gt;</span>,
<span class='texttt'>&lt;initializer_list&gt;</span>,
<span class='texttt'>&lt;mutex&gt;</span>,
<span class='texttt'>&lt;random&gt;</span>,
<span class='texttt'>&lt;ratio&gt;</span>,
<span class='texttt'>&lt;regex&gt;</span>,
<span class='texttt'>&lt;scoped_allocator&gt;</span>,
<span class='texttt'>&lt;system_error&gt;</span>,
<span class='texttt'>&lt;thread&gt;</span>,
<span class='texttt'>&lt;tuple&gt;</span>,
<span class='texttt'>&lt;typeindex&gt;</span>,
<span class='texttt'>&lt;type_traits&gt;</span>,<br/>
<span class='texttt'>&lt;unordered_map&gt;</span>,
and
<span class='texttt'>&lt;unordered_set&gt;</span>.
In addition the following C compatibility headers are new:
<span class='texttt'>&lt;ccomplex&gt;</span>,
<span class='texttt'>&lt;cfenv&gt;</span>,
<span class='texttt'>&lt;cinttypes&gt;</span>,
<span class='texttt'>&lt;cstdalign&gt;</span>,
<span class='texttt'>&lt;cstdbool&gt;</span>,
<span class='texttt'>&lt;cstdint&gt;</span>,
<span class='texttt'>&lt;ctgmath&gt;</span>,
and
<span class='texttt'>&lt;cuchar&gt;</span>.
Valid C++ 2003 code that <span class='texttt'>#include</span>s headers with these names may be
invalid in this International Standard.</p><p ><a href='swappable.requirements'>[swappable.requirements]</a>
<span class='hfill'></span><br/><b>Effect on original feature:</b> Function <span class='texttt'>swap</span> moved to a different header
<span class='hfill'></span><br/><b>Rationale:</b> Remove dependency on <span class='texttt'>&lt;algorithm&gt;</span> for <span class='texttt'>swap</span>.
<span class='hfill'></span><br/><b>Effect on original feature:</b> Valid C++ 2003 code that has been compiled expecting swap to be in
<span class='texttt'>&lt;algorithm&gt;</span> may have to instead include <span class='texttt'>&lt;utility&gt;</span>.</p><p ><a href='namespace.posix'>[namespace.posix]</a>
<span class='hfill'></span><br/><b>Change:</b> New reserved namespace
<span class='hfill'></span><br/><b>Rationale:</b> New functionality.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
The global namespace <span class='texttt'>posix</span> is now reserved for standardization. Valid
C++ 2003 code that uses a top-level namespace <span class='texttt'>posix</span> may be invalid in
this International Standard.</p><p ><a href='res.on.macro.definitions'>[res.on.macro.definitions]</a>
<span class='hfill'></span><br/><b>Change:</b> Additional restrictions on macro names
<span class='hfill'></span><br/><b>Rationale:</b> Avoid hard to diagnose or non-portable constructs.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Names of attribute identifiers may not be used as macro names. Valid C++
2003 code that defines <span class='texttt'>override</span>, <span class='texttt'>final</span>,
<span class='texttt'>carries_dependency</span>, or <span class='texttt'>noreturn</span> as macros is invalid in this
International Standard.</p></div><div id='cpp03.language.support'><h3 ><a class='secnum' href='#cpp03.language.support' style='min-width:103pt'>C.2.9</a> Clause <a href='language.support'>[language.support]</a>:
language support library <a class='abbr_ref' href='diff.cpp03.language.support'>[diff.cpp03.language.support]</a></h3><p ><a href='new.delete.single'>[new.delete.single]</a>
<span class='hfill'></span><br/><b>Change:</b> Linking <span class='texttt'>new</span> and <span class='texttt'>delete</span> operators
<span class='hfill'></span><br/><b>Rationale:</b> The two throwing single-object signatures of <span class='texttt'>operator new</span> and
<span class='texttt'>operator delete</span> are now specified to form the base functionality for
the other operators. This clarifies that replacing just these two signatures
changes others, even if they are not explicitly changed.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that replaces global <span class='texttt'>new</span> or <span class='texttt'>delete</span>
operators may execute differently in this International Standard. For
example, the following program should write <span class='texttt'>"custom deallocation"</span> twice,
once for the single-object delete and once for the array delete.</p><pre class='codeblock'>
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;

void* operator new(std::size_t size) throw(std::bad_alloc) {
  return std::malloc(size);
}

void operator delete(void* ptr) throw() {
  std::puts("custom deallocation");
  std::free(ptr);
}

int main() {
  int* i = new int;
  delete i;                     <span class='comment'>// single-object delete
</span>  int* a = new int[3];
  delete [] a;                  <span class='comment'>// array delete
</span>  return 0;
}
</pre><p ><a href='new.delete.single'>[new.delete.single]</a>
<span class='hfill'></span><br/><b>Change:</b> <span class='texttt'>operator new</span> may throw exceptions other than
<span class='texttt'>std::bad_alloc</span>
<span class='hfill'></span><br/><b>Rationale:</b> Consistent application of <span class='texttt'>noexcept</span>.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that assumes that global <span class='texttt'>operator new</span> only
throws <span class='texttt'>std::bad_alloc</span> may execute differently in this International
Standard.</p></div><div id='cpp03.diagnostics'><h3 ><a class='secnum' href='#cpp03.diagnostics' style='min-width:103pt'>C.2.10</a> Clause <a href='diagnostics'>[diagnostics]</a>: diagnostics library <a class='abbr_ref' href='diff.cpp03.diagnostics'>[diff.cpp03.diagnostics]</a></h3><p ><a href='errno'>[errno]</a>
<span class='hfill'></span><br/><b>Change:</b> Thread-local error numbers
<span class='hfill'></span><br/><b>Rationale:</b> Support for new thread facilities.
<span class='hfill'></span><br/><b>Effect on original feature:</b> Valid but implementation-specific C++ 2003 code that relies on
<span class='texttt'>errno</span> being the same across threads may change behavior in this
International Standard.</p></div><div id='cpp03.utilities'><h3 ><a class='secnum' href='#cpp03.utilities' style='min-width:103pt'>C.2.11</a> Clause <a href='utilities'>[utilities]</a>: general utilities library <a class='abbr_ref' href='diff.cpp03.utilities'>[diff.cpp03.utilities]</a></h3><p ><a href='util.dynamic.safety'>[util.dynamic.safety]</a>
<span class='hfill'></span><br/><b>Change:</b> Minimal support for garbage-collected regions
<span class='hfill'></span><br/><b>Rationale:</b> Required by new feature.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code, compiled without traceable pointer support,
that interacts with newer C++ code using regions declared reachable may
have different runtime behavior.</p><p ><a href='refwrap'>[refwrap]</a>, <a href='arithmetic.operations'>[arithmetic.operations]</a>, <a href='comparisons'>[comparisons]</a>,
<a href='logical.operations'>[logical.operations]</a>, <a href='bitwise.operations'>[bitwise.operations]</a>, <a href='negators'>[negators]</a>
<span class='hfill'></span><br/><b>Change:</b> Standard function object types no longer derived from
<span class='texttt'>std::unary_function</span> or <span class='texttt'>std::binary_function</span>
<span class='hfill'></span><br/><b>Rationale:</b> Superseded by new feature.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that depends on function object types being derived from
<span class='texttt'>unary_function</span> or <span class='texttt'>binary_function</span> will execute differently
in this International Standard.</p></div><div id='cpp03.strings'><h3 ><a class='secnum' href='#cpp03.strings' style='min-width:103pt'>C.2.12</a> Clause <a href='strings'>[strings]</a>: strings library <a class='abbr_ref' href='diff.cpp03.strings'>[diff.cpp03.strings]</a></h3><p ><a href='string.classes'>[string.classes]</a>
<span class='hfill'></span><br/><b>Change:</b> <span class='texttt'>basic_string</span> requirements no longer allow reference-counted
strings
<span class='hfill'></span><br/><b>Rationale:</b> Invalidation is subtly different with reference-counted strings.
This change regularizes behavior for this International Standard.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may execute differently in this International Standard.</p><p ><a href='string.require'>[string.require]</a>
<span class='hfill'></span><br/><b>Change:</b> Loosen <span class='texttt'>basic_string</span> invalidation rules
<span class='hfill'></span><br/><b>Rationale:</b> Allow small-string optimization.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code may execute differently in this International Standard.
Some <span class='texttt'>const</span> member functions, such as <span class='texttt'>data</span> and <span class='texttt'>c_str</span>,
no longer invalidate iterators.</p></div><div id='cpp03.containers'><h3 ><a class='secnum' href='#cpp03.containers' style='min-width:103pt'>C.2.13</a> Clause <a href='containers'>[containers]</a>: containers library <a class='abbr_ref' href='diff.cpp03.containers'>[diff.cpp03.containers]</a></h3><p ><a href='container.requirements'>[container.requirements]</a>
<span class='hfill'></span><br/><b>Change:</b> Complexity of <span class='texttt'>size()</span> member functions now constant
<span class='hfill'></span><br/><b>Rationale:</b> Lack of specification of complexity of <span class='texttt'>size()</span> resulted in
divergent implementations with inconsistent performance characteristics.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Some container implementations that conform to C++ 2003 may not conform to the
specified <span class='texttt'>size()</span> requirements in this International Standard. Adjusting
containers such as <span class='texttt'>std::list</span> to the stricter requirements may require
incompatible changes.</p><p ><a href='container.requirements'>[container.requirements]</a>
<span class='hfill'></span><br/><b>Change:</b> Requirements change: relaxation
<span class='hfill'></span><br/><b>Rationale:</b> Clarification.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that attempts to meet the specified container requirements
may now be over-specified. Code that attempted to be portable across containers
may need to be adjusted as follows:
</p><ul ><li id='cpp03.containers-1'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-1'>(1)</a></div><p >not all containers provide <span class='texttt'>size()</span>; use <span class='texttt'>empty()</span> instead
of <span class='texttt'>size() == 0</span>;
</p></li><li id='cpp03.containers-2'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-2'>(2)</a></div><p >not all containers are empty after construction (<span class='texttt'>array</span>);
</p></li><li id='cpp03.containers-3'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-3'>(3)</a></div><p >not all containers have constant complexity for <span class='texttt'>swap()</span> (<span class='texttt'>array</span>).
</p></li></ul><p ><a href='container.requirements'>[container.requirements]</a>
<span class='hfill'></span><br/><b>Change:</b> Requirements change: default constructible
<span class='hfill'></span><br/><b>Rationale:</b> Clarification of container requirements.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that attempts to explicitly instantiate a container using
a user-defined type with no default constructor may fail to compile.</p><p ><a href='sequence.reqmts'>[sequence.reqmts]</a>, <a href='associative.reqmts'>[associative.reqmts]</a>
<span class='hfill'></span><br/><b>Change:</b> Signature changes: from <span class='texttt'>void</span> return types
<span class='hfill'></span><br/><b>Rationale:</b> Old signature threw away useful information that may be expensive
to recalculate.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
The following member functions have changed:
</p><ul ><li id='cpp03.containers-1'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-1'>(1)</a></div><p ><span class='texttt'>erase(iter)</span> for <span class='texttt'>set</span>, <span class='texttt'>multiset</span>, <span class='texttt'>map</span>, <span class='texttt'>multimap</span>
</p></li><li id='cpp03.containers-2'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-2'>(2)</a></div><p ><span class='texttt'>erase(begin, end)</span> for <span class='texttt'>set</span>, <span class='texttt'>multiset</span>, <span class='texttt'>map</span>, <span class='texttt'>multimap</span>
</p></li><li id='cpp03.containers-3'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-3'>(3)</a></div><p ><span class='texttt'>insert(pos, num, val)</span> for <span class='texttt'>vector</span>, <span class='texttt'>deque</span>, <span class='texttt'>list</span>, <span class='texttt'>forward_list</span>
</p></li><li id='cpp03.containers-4'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-4'>(4)</a></div><p ><span class='texttt'>insert(pos, beg, end)</span> for <span class='texttt'>vector</span>, <span class='texttt'>deque</span>, <span class='texttt'>list</span>, <span class='texttt'>forward_list</span>
</p></li></ul><p >Valid C++ 2003 code that relies on these functions returning <span class='texttt'>void</span>
(e.g., code that creates a pointer to member function that points to one
of these functions) will fail to compile with this International Standard.</p><p ><a href='sequence.reqmts'>[sequence.reqmts]</a>, <a href='associative.reqmts'>[associative.reqmts]</a>
<span class='hfill'></span><br/><b>Change:</b> Signature changes: from <span class='texttt'>iterator</span> to <span class='texttt'>const_iterator</span>
parameters
<span class='hfill'></span><br/><b>Rationale:</b> Overspecification.
<i>Effects:</i>
The signatures of the following member functions changed from taking an
<span class='texttt'>iterator</span> to taking a <span class='texttt'>const_iterator</span>:</p><ul ><li id='cpp03.containers-1'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-1'>(1)</a></div><p ><span class='texttt'>insert(iter, val)</span> for <span class='texttt'>vector</span>, <span class='texttt'>deque</span>, <span class='texttt'>list</span>,
<span class='texttt'>set</span>, <span class='texttt'>multiset</span>, <span class='texttt'>map</span>, <span class='texttt'>multimap</span>
</p></li><li id='cpp03.containers-2'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-2'>(2)</a></div><p ><span class='texttt'>insert(pos, beg, end)</span> for <span class='texttt'>vector</span>, <span class='texttt'>deque</span>, <span class='texttt'>list</span>,
<span class='texttt'>forward_list</span>
</p></li><li id='cpp03.containers-3'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-3'>(3)</a></div><p ><span class='texttt'>erase(iter)</span> for <span class='texttt'>set</span>, <span class='texttt'>multiset</span>, <span class='texttt'>map</span>, <span class='texttt'>multimap</span>
</p></li><li id='cpp03.containers-4'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-4'>(4)</a></div><p ><span class='texttt'>erase(begin, end)</span> for <span class='texttt'>set</span>, <span class='texttt'>multiset</span>, <span class='texttt'>map</span>, <span class='texttt'>multimap</span>
</p></li><li id='cpp03.containers-5'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-5'>(5)</a></div><p >all forms of <span class='texttt'>list::splice</span>
</p></li><li id='cpp03.containers-6'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.containers-6'>(6)</a></div><p >all forms of <span class='texttt'>list::merge</span>
</p></li></ul><p >Valid C++ 2003 code that uses these functions may fail to compile with this
International Standard.</p><p ><a href='sequence.reqmts'>[sequence.reqmts]</a>, <a href='associative.reqmts'>[associative.reqmts]</a>
<span class='hfill'></span><br/><b>Change:</b> Signature changes: <span class='texttt'>resize</span>
<span class='hfill'></span><br/><b>Rationale:</b> Performance, compatibility with move semantics.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
For <span class='texttt'>vector</span>, <span class='texttt'>deque</span>, and <span class='texttt'>list</span>
the fill value passed to <span class='texttt'>resize</span> is now passed by reference instead of
by value, and an additional overload of <span class='texttt'>resize</span> has been added. Valid
C++ 2003 code that uses this function may fail to compile with this International
Standard.</p></div><div id='cpp03.algorithms'><h3 ><a class='secnum' href='#cpp03.algorithms' style='min-width:103pt'>C.2.14</a> Clause <a href='algorithms'>[algorithms]</a>: algorithms library <a class='abbr_ref' href='diff.cpp03.algorithms'>[diff.cpp03.algorithms]</a></h3><p ><a href='algorithms.general'>[algorithms.general]</a>
<span class='hfill'></span><br/><b>Change:</b> Result state of inputs after application of some algorithms
<span class='hfill'></span><br/><b>Rationale:</b> Required by new feature.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
A valid C++ 2003 program may detect that an object with a valid but
unspecified state has a different valid but unspecified state with this
International Standard. For example, <span class='texttt'>std::remove</span> and
<span class='texttt'>std::remove_if</span> may leave the tail of the input sequence with a
different set of values than previously.</p></div><div id='cpp03.numerics'><h3 ><a class='secnum' href='#cpp03.numerics' style='min-width:103pt'>C.2.15</a> Clause <a href='numerics'>[numerics]</a>: numerics library <a class='abbr_ref' href='diff.cpp03.numerics'>[diff.cpp03.numerics]</a></h3><p ><a href='complex.numbers'>[complex.numbers]</a>
<span class='hfill'></span><br/><b>Change:</b> Specified representation of complex numbers
<span class='hfill'></span><br/><b>Rationale:</b> Compatibility with C99.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that uses implementation-specific knowledge about the
binary representation of the required template specializations of
<span class='texttt'>std::complex</span> may not be compatible with this International Standard.</p></div><div id='cpp03.input.output'><h3 ><a class='secnum' href='#cpp03.input.output' style='min-width:103pt'>C.2.16</a> Clause <a href='input.output'>[input.output]</a>: Input/output library <a class='abbr_ref' href='diff.cpp03.input.output'>[diff.cpp03.input.output]</a></h3><p ><a href='./istream::sentry'>[istream::sentry]</a>,
<a href='./ostream::sentry'>[ostream::sentry]</a>,
<a href='iostate.flags'>[iostate.flags]</a>
<span class='hfill'></span><br/><b>Change:</b> Specify use of explicit in existing boolean conversion operators
<span class='hfill'></span><br/><b>Rationale:</b> Clarify intentions, avoid workarounds.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that relies on implicit boolean conversions will fail to
compile with this International Standard. Such conversions occur in the
following conditions:</p><ul ><li id='cpp03.input.output-1'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.input.output-1'>(1)</a></div><p >passing a value to a function that takes an argument of type <span class='texttt'>bool</span>;
</p></li><li id='cpp03.input.output-2'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.input.output-2'>(2)</a></div><p >using <span class='texttt'>operator==</span> to compare to <span class='texttt'>false</span> or <span class='texttt'>true</span>;
</p></li><li id='cpp03.input.output-3'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.input.output-3'>(3)</a></div><p >returning a value from a function with a return type of <span class='texttt'>bool</span>;
</p></li><li id='cpp03.input.output-4'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.input.output-4'>(4)</a></div><p >initializing members of type <span class='texttt'>bool</span> via aggregate initialization;
</p></li><li id='cpp03.input.output-5'><div class='marginalizedparent' style='left:-5em'><a class='marginalized' href='#cpp03.input.output-5'>(5)</a></div><p >initializing a <span class='texttt'>const bool&amp;</span> which would bind to a temporary.
</p></li></ul><p ><a href='./ios::failure'>[ios::failure]</a>
<span class='hfill'></span><br/><b>Change:</b> Change base class of <span class='texttt'>std::ios_base::failure</span>
<span class='hfill'></span><br/><b>Rationale:</b> More detailed error messages.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
<span class='texttt'>std::ios_base::failure</span> is no longer derived directly from
<span class='texttt'>std::exception</span>, but is now derived from <span class='texttt'>std::system_error</span>,
which in turn is derived from <span class='texttt'>std::runtime_error</span>. Valid C++ 2003 code
that assumes that <span class='texttt'>std::ios_base::failure</span> is derived directly from
<span class='texttt'>std::exception</span> may execute differently in this International Standard.</p><p ><a href='ios.base'>[ios.base]</a>
<span class='hfill'></span><br/><b>Change:</b> Flag types in <span class='texttt'>std::ios_base</span> are now bitmasks with values
defined as constexpr static members
<span class='hfill'></span><br/><b>Rationale:</b> Required for new features.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2003 code that relies on <span class='texttt'>std::ios_base</span> flag types being
represented as <span class='texttt'>std::bitset</span> or as an integer type may fail to compile
with this International Standard. For example:</p><pre class='codeblock'>
#include &lt;iostream&gt;

int main() {
  int flag = std::ios_base::hex;
  std::cout.setf(flag);         <span class='comment'>// error: <span class='texttt'>setf</span> does not take argument of type <span class='texttt'>int</span>
</span>  return 0;
}
</pre></div></div><div id='cpp11'><h2 ><a class='secnum' href='#cpp11' style='min-width:88pt'>C.3</a> C++ and ISO C++ 2011 <a class='abbr_ref' href='diff.cpp11'>[diff.cpp11]</a></h2><div class='para' id='cpp11-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp11-1'>1</a></div><p ><span class='indexparent'><a class='index' id='summary,compatibility_with_ISO_C++_2011_'></a></span>This subclause lists the differences between C++ and
ISO C++ 2011 (ISO/IEC 14882:2011, <i>Programming Languages — C++</i>),
by the chapters of this document.</p></div><div id='cpp11.lex'><h3 ><a class='secnum' href='#cpp11.lex' style='min-width:103pt'>C.3.1</a> Clause <a href='lex'>[lex]</a>: lexical conventions <a class='abbr_ref' href='diff.cpp11.lex'>[diff.cpp11.lex]</a></h3><p ><a href='lex.ppnumber'>[lex.ppnumber]</a>
<span class='hfill'></span><br/><b>Change:</b> <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i> can contain one or more single quotes.
<span class='hfill'></span><br/><b>Rationale:</b> Necessary to enable single quotes as digit separators.
<span class='hfill'></span><br/><b>Effect on original feature:</b> Valid C++ 2011 code may fail to compile or may change meaning in this
International Standard. For example, the following code is valid both in C++ 2011 and in
this International Standard, but the macro invocation produces different outcomes
because the single quotes delimit a character literal in C++ 2011, whereas they are digit
separators in this International Standard:</p><pre class='codeblock'>
#define M(x, ...) __VA_ARGS__
int x[2] = { M(1'2,3'4) };
<span class='comment'>// <span class='texttt'>int x[2] = {};     </span> — C++ 2011
</span><span class='comment'>// <span class='texttt'>int x[2] = { 3'4 };</span> — this International Standard
</span></pre></div><div id='cpp11.basic'><h3 ><a class='secnum' href='#cpp11.basic' style='min-width:103pt'>C.3.2</a> Clause <a href='basic'>[basic]</a>: basic concepts <a class='abbr_ref' href='diff.cpp11.basic'>[diff.cpp11.basic]</a></h3><p ><a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>
<span class='hfill'></span><br/><b>Change:</b> New usual (non-placement) deallocator 
<span class='hfill'></span><br/><b>Rationale:</b> Required for sized deallocation.
<span class='hfill'></span><br/><b>Effect on original feature:</b> Valid C++ 2011 code could declare a global placement allocation function and
deallocation function as follows:</p><pre class='codeblock'>
void operator new(std::size_t, std::size_t);
void operator delete(void*, std::size_t) noexcept;
</pre><p >In this International Standard, however, the declaration of <span class='texttt'>operator delete</span>
might match a predefined usual (non-placement)
<span class='texttt'>operator delete</span> (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>). If so, the
program is ill-formed, as it was for class member allocation functions and
deallocation functions (<a href='expr.new'>[expr.new]</a>).</p></div><div id='cpp11.dcl.dcl'><h3 ><a class='secnum' href='#cpp11.dcl.dcl' style='min-width:103pt'>C.3.3</a> Clause <a href='dcl.dcl'>[dcl.dcl]</a>: declarations <a class='abbr_ref' href='diff.cpp11.dcl.dcl'>[diff.cpp11.dcl.dcl]</a></h3><p ><a href='dcl.constexpr'>[dcl.constexpr]</a>
<span class='hfill'></span><br/><b>Change:</b> <span class='texttt'>constexpr</span> non-static member functions are not implicitly
<span class='texttt'>const</span> member functions.
<span class='hfill'></span><br/><b>Rationale:</b> Necessary to allow <span class='texttt'>constexpr</span> member functions to mutate
the object.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2011 code may fail to compile in this International Standard.
For example, the following code is valid in C++ 2011
but invalid in this International Standard because it declares the same member
function twice with different return types:</p><pre class='codeblock'>
struct S {
  constexpr const int &amp;f();
  int &amp;f();
};
</pre></div><div id='cpp11.input.output'><h3 ><a class='secnum' href='#cpp11.input.output' style='min-width:103pt'>C.3.4</a> Clause <a href='input.output'>[input.output]</a>: input/output library <a class='abbr_ref' href='diff.cpp11.input.output'>[diff.cpp11.input.output]</a></h3><p ><a href='c.files'>[c.files]</a>
<span class='hfill'></span><br/><b>Change:</b> <span class='texttt'>gets</span> is not defined.
<span class='hfill'></span><br/><b>Rationale:</b> Use of <span class='texttt'>gets</span> is considered dangerous.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Valid C++ 2011 code that uses the <span class='texttt'>gets</span> function may fail to compile
in this International Standard.</p></div></div><div id='library'><h2 ><a class='secnum' href='#library' style='min-width:88pt'>C.4</a> C standard library <a class='abbr_ref' href='diff.library'>[diff.library]</a></h2><p ><span class='indexparent'><a class='index' id='library,C_standard'></a></span>
</p><div class='para' id='library-1'><div class='marginalizedparent'><a class='marginalized' href='#library-1'>1</a></div><p >This subclause summarizes the contents of the C++ standard library
included from the Standard C library.
It also summarizes the explicit changes in definitions,
declarations, or behavior from the Standard C library
noted in other subclauses (<a href='headers'>[headers]</a>, <a href='support.types'>[support.types]</a>, <a href='c.strings'>[c.strings]</a>).</p></div><div class='para' id='library-2'><div class='marginalizedparent'><a class='marginalized' href='#library-2'>2</a></div><p >The C++ standard library provides 57 standard macros from the C library,
as shown in Table <a href='#tab:diff.standard.macros'>[tab:diff.standard.macros]</a>.</p></div><div class='para' id='library-3'><div class='marginalizedparent'><a class='marginalized' href='#library-3'>3</a></div><p >The header names (enclosed in
<span class='texttt'>&lt;</span>
and
<span class='texttt'>&gt;</span>)
indicate that the macro may be defined in more than one header.
All such definitions are equivalent (<a href='basic.def.odr'>[basic.def.odr]</a>).</p><div class='numberedTable' id='tab:diff.standard.macros'>Table <a href='#tab:diff.standard.macros'>150</a> — Standard macros<br><table ><tr class='rowsep'><td class='left'>


<span class='texttt'>assert</span>    </td><td class='left'>
<span class='texttt'>HUGE_VAL</span>  </td><td class='left'>
<span class='texttt'>NULL &lt;cstring&gt;</span>  </td><td class='left'>
<span class='texttt'>SIGINT</span>    </td><td class='left'>
<span class='texttt'>va_end</span>    </td></tr><tr ><td class='left'><span class='texttt'>BUFSIZ</span>    </td><td class='left'>
<span class='texttt'>LC_ALL</span>    </td><td class='left'>
<span class='texttt'>NULL &lt;ctime&gt;</span>  </td><td class='left'>
<span class='texttt'>SIGSEGV</span> </td><td class='left'>
<span class='texttt'>va_start</span>  </td></tr><tr ><td class='left'><span class='texttt'>CLOCKS_PER_SEC</span>  </td><td class='left'>
<span class='texttt'>LC_COLLATE</span>  </td><td class='left'>
<span class='texttt'>NULL &lt;cwchar&gt;</span> </td><td class='left'>
<span class='texttt'>SIGTERM</span> </td><td class='left'>
<span class='texttt'>WCHAR_MAX</span> </td></tr><tr ><td class='left'><span class='texttt'>EDOM</span>    </td><td class='left'>
<span class='texttt'>LC_CTYPE</span>  </td><td class='left'>
<span class='texttt'>offsetof</span>  </td><td class='left'>
<span class='texttt'>SIG_DFL</span> </td><td class='left'>
<span class='texttt'>WCHAR_MIN</span> </td></tr><tr ><td class='left'><span class='texttt'>EILSEQ</span>    </td><td class='left'>
<span class='texttt'>LC_MONETARY</span> </td><td class='left'>
<span class='texttt'>RAND_MAX</span>  </td><td class='left'>
<span class='texttt'>SIG_ERR</span> </td><td class='left'>
<span class='texttt'>WEOF &lt;cwchar&gt;</span> </td></tr><tr ><td class='left'><span class='texttt'>EOF</span>     </td><td class='left'>
<span class='texttt'>LC_NUMERIC</span>  </td><td class='left'>
<span class='texttt'>SEEK_CUR</span>  </td><td class='left'>
<span class='texttt'>SIG_IGN</span> </td><td class='left'>
<span class='texttt'>WEOF &lt;cwctype&gt;</span>  </td></tr><tr ><td class='left'><span class='texttt'>ERANGE</span>    </td><td class='left'>
<span class='texttt'>LC_TIME</span> </td><td class='left'>
<span class='texttt'>SEEK_END</span>  </td><td class='left'>
<span class='texttt'>stderr</span>    </td><td class='left'>
<span class='texttt'>_IOFBF</span>    </td></tr><tr ><td class='left'><span class='texttt'>errno</span>   </td><td class='left'>
<span class='texttt'>L_tmpnam</span>  </td><td class='left'>
<span class='texttt'>SEEK_SET</span>  </td><td class='left'>
<span class='texttt'>stdin</span>   </td><td class='left'>
<span class='texttt'>_IOLBF</span>    </td></tr><tr ><td class='left'><span class='texttt'>EXIT_FAILURE</span>  </td><td class='left'>
<span class='texttt'>MB_CUR_MAX</span>  </td><td class='left'>
<span class='texttt'>setjmp</span>    </td><td class='left'>
<span class='texttt'>stdout</span>    </td><td class='left'>
<span class='texttt'>_IONBF</span>    </td></tr><tr ><td class='left'><span class='texttt'>EXIT_SUCCESS</span>  </td><td class='left'>
<span class='texttt'>NULL &lt;clocale&gt;</span>  </td><td class='left'>
<span class='texttt'>SIGABRT</span> </td><td class='left'>
<span class='texttt'>TMP_MAX</span> </td><td class='left'> </td></tr><tr ><td class='left'><span class='texttt'>FILENAME_MAX</span>  </td><td class='left'>
<span class='texttt'>NULL &lt;cstddef&gt;</span>  </td><td class='left'>
<span class='texttt'>SIGFPE</span>    </td><td class='left'>
<span class='texttt'>va_arg</span>    </td><td class='left'> </td></tr><tr ><td class='left'><span class='texttt'>FOPEN_MAX</span> </td><td class='left'>
<span class='texttt'>NULL &lt;cstdlib&gt;</span>  </td><td class='left'>
<span class='texttt'>SIGILL</span>    </td><td class='left'>
<span class='texttt'>va_copy</span>   </td><td class='left'> </td></tr></table></div></div><div class='para' id='library-4'><div class='marginalizedparent'><a class='marginalized' href='#library-4'>4</a></div><p >The C++ standard library provides 57 standard values from the C library,
as shown in Table <a href='#tab:diff.standard.values'>[tab:diff.standard.values]</a>.</p><div class='numberedTable' id='tab:diff.standard.values'>Table <a href='#tab:diff.standard.values'>151</a> — Standard values<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>CHAR_BIT</span>  </td><td class='left'>
 <span class='texttt'>FLT_DIG</span>  </td><td class='left'>
 <span class='texttt'>INT_MIN</span>  </td><td class='left'>
 <span class='texttt'>MB_LEN_MAX</span> </td></tr><tr ><td class='left'>
<span class='texttt'>CHAR_MAX</span>  </td><td class='left'>
 <span class='texttt'>FLT_EPSILON</span>  </td><td class='left'>
 <span class='texttt'>LDBL_DIG</span> </td><td class='left'>
 <span class='texttt'>SCHAR_MAX</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>CHAR_MIN</span>  </td><td class='left'>
 <span class='texttt'>FLT_MANT_DIG</span> </td><td class='left'>
 <span class='texttt'>LDBL_EPSILON</span> </td><td class='left'>
 <span class='texttt'>SCHAR_MIN</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_DIG</span>   </td><td class='left'>
 <span class='texttt'>FLT_MAX</span>  </td><td class='left'>
 <span class='texttt'>LDBL_MANT_DIG</span>  </td><td class='left'>
 <span class='texttt'>SHRT_MAX</span> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_EPSILON</span> </td><td class='left'>
 <span class='texttt'>FLT_MAX_10_EXP</span> </td><td class='left'>
 <span class='texttt'>LDBL_MAX</span> </td><td class='left'>
 <span class='texttt'>SHRT_MIN</span> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MANT_DIG</span>  </td><td class='left'>
 <span class='texttt'>FLT_MAX_EXP</span>  </td><td class='left'>
 <span class='texttt'>LDBL_MAX_10_EXP</span>  </td><td class='left'>
 <span class='texttt'>UCHAR_MAX</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MAX</span>   </td><td class='left'>
 <span class='texttt'>FLT_MIN</span>  </td><td class='left'>
 <span class='texttt'>LDBL_MAX_EXP</span> </td><td class='left'>
 <span class='texttt'>UINT_MAX</span> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MAX_10_EXP</span>  </td><td class='left'>
 <span class='texttt'>FLT_MIN_10_EXP</span> </td><td class='left'>
 <span class='texttt'>LDBL_MIN</span> </td><td class='left'>
 <span class='texttt'>ULONG_MAX</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MAX_EXP</span> </td><td class='left'>
 <span class='texttt'>FLT_MIN_EXP</span>  </td><td class='left'>
 <span class='texttt'>LDBL_MIN_10_EXP</span></td><td class='left'>
 <span class='texttt'>USHRT_MAX</span> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MIN</span>   </td><td class='left'>
 <span class='texttt'>FLT_RADIX</span>  </td><td class='left'>
 <span class='texttt'>LDBL_MIN_EXP</span> </td><td class='left'> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MIN_10_EXP</span>  </td><td class='left'>
 <span class='texttt'>FLT_ROUNDS</span> </td><td class='left'>
 <span class='texttt'>LONG_MAX</span> </td><td class='left'> </td></tr><tr ><td class='left'>
<span class='texttt'>DBL_MIN_EXP</span> </td><td class='left'>
 <span class='texttt'>INT_MAX</span>  </td><td class='left'>
 <span class='texttt'>LONG_MIN</span> </td><td class='left'> </td></tr></table></div></div><div class='para' id='library-5'><div class='marginalizedparent'><a class='marginalized' href='#library-5'>5</a></div><p >The C++ standard library provides 20 standard types from the C library,
as shown in Table <a href='#tab:diff.standard.types'>[tab:diff.standard.types]</a>.</p><div class='numberedTable' id='tab:diff.standard.types'>Table <a href='#tab:diff.standard.types'>152</a> — Standard types<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>clock_t</span>   </td><td class='left'>
 <span class='texttt'>ldiv_t</span>   </td><td class='left'>
 <span class='texttt'>size_t &lt;cstdio&gt;</span>  </td><td class='left'>
 <span class='texttt'>va_list</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>div_t</span>   </td><td class='left'>
 <span class='texttt'>mbstate_t</span>  </td><td class='left'>
 <span class='texttt'>size_t &lt;cstdlib&gt;</span> </td><td class='left'>
 <span class='texttt'>wctrans_t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>FILE</span>    </td><td class='left'>
 <span class='texttt'>ptrdiff_t</span>  </td><td class='left'>
 <span class='texttt'>size_t &lt;cstring&gt;</span> </td><td class='left'>
 <span class='texttt'>wctype_t</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fpos_t</span>    </td><td class='left'>
 <span class='texttt'>sig_atomic_t</span> </td><td class='left'>
 <span class='texttt'>size_t &lt;ctime&gt;</span> </td><td class='left'>
 <span class='texttt'>wint_t &lt;cwchar&gt;</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>jmp_buf</span>   </td><td class='left'>
 <span class='texttt'>size_t &lt;cstddef&gt;</span> </td><td class='left'>
 <span class='texttt'>time_t</span>   </td><td class='left'>
 <span class='texttt'>wint_t &lt;cwctype&gt;</span> </td></tr></table></div></div><div class='para' id='library-6'><div class='marginalizedparent'><a class='marginalized' href='#library-6'>6</a></div><p >The C++ standard library provides 2 standard
<span class='texttt'>struct</span>s
from the C library,
as shown in Table <a href='#tab:diff.standard.structs'>[tab:diff.standard.structs]</a>.</p><div class='numberedTable' id='tab:diff.standard.structs'>Table <a href='#tab:diff.standard.structs'>153</a> — Standard structs<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>lconv</span> </td><td class='left'> <span class='texttt'>tm</span>  </td></tr></table></div></div><div class='para' id='library-7'><div class='marginalizedparent'><a class='marginalized' href='#library-7'>7</a></div><p >The C++ standard library provides 209 standard functions from the C library,
as shown in Table <a href='#tab:diff.standard.functions'>[tab:diff.standard.functions]</a>.</p><div class='numberedTable' id='tab:diff.standard.functions'>Table <a href='#tab:diff.standard.functions'>154</a> — Standard functions<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>abort</span> </td><td class='left'>
<span class='texttt'>fmod</span> </td><td class='left'>
<span class='texttt'>iswalnum</span> </td><td class='left'>
<span class='texttt'>modf</span> </td><td class='left'>
<span class='texttt'>strlen</span> </td><td class='left'>
<span class='texttt'>wcscat</span> </td></tr><tr ><td class='left'>
<span class='texttt'>abs</span> </td><td class='left'>
<span class='texttt'>fopen</span> </td><td class='left'>
<span class='texttt'>iswalpha</span> </td><td class='left'>
<span class='texttt'>perror</span> </td><td class='left'>
<span class='texttt'>strncat</span> </td><td class='left'>
<span class='texttt'>wcschr</span> </td></tr><tr ><td class='left'>
<span class='texttt'>acos</span> </td><td class='left'>
<span class='texttt'>fprintf</span> </td><td class='left'>
<span class='texttt'>iswcntrl</span> </td><td class='left'>
<span class='texttt'>pow</span> </td><td class='left'>
<span class='texttt'>strncmp</span> </td><td class='left'>
<span class='texttt'>wcscmp</span> </td></tr><tr ><td class='left'>
<span class='texttt'>asctime</span> </td><td class='left'>
<span class='texttt'>fputc</span> </td><td class='left'>
<span class='texttt'>iswctype</span> </td><td class='left'>
<span class='texttt'>printf</span> </td><td class='left'>
<span class='texttt'>strncpy</span> </td><td class='left'>
<span class='texttt'>wcscoll</span> </td></tr><tr ><td class='left'>
<span class='texttt'>asin</span> </td><td class='left'>
<span class='texttt'>fputs</span> </td><td class='left'>
<span class='texttt'>iswdigit</span> </td><td class='left'>
<span class='texttt'>putc</span> </td><td class='left'>
<span class='texttt'>strpbrk</span> </td><td class='left'>
<span class='texttt'>wcscpy</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atan</span> </td><td class='left'>
<span class='texttt'>fputwc</span> </td><td class='left'>
<span class='texttt'>iswgraph</span> </td><td class='left'>
<span class='texttt'>putchar</span> </td><td class='left'>
<span class='texttt'>strrchr</span> </td><td class='left'>
<span class='texttt'>wcscspn</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atan2</span> </td><td class='left'>
<span class='texttt'>fputws</span> </td><td class='left'>
<span class='texttt'>iswlower</span> </td><td class='left'>
<span class='texttt'>puts</span> </td><td class='left'>
<span class='texttt'>strspn</span> </td><td class='left'>
<span class='texttt'>wcsftime</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atexit</span> </td><td class='left'>
<span class='texttt'>fread</span> </td><td class='left'>
<span class='texttt'>iswprint</span> </td><td class='left'>
<span class='texttt'>putwc</span> </td><td class='left'>
<span class='texttt'>strstr</span> </td><td class='left'>
<span class='texttt'>wcslen</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atof</span> </td><td class='left'>
<span class='texttt'>free</span> </td><td class='left'>
<span class='texttt'>iswpunct</span> </td><td class='left'>
<span class='texttt'>putwchar</span> </td><td class='left'>
<span class='texttt'>strtod</span> </td><td class='left'>
<span class='texttt'>wcsncat</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atoi</span> </td><td class='left'>
<span class='texttt'>freopen</span> </td><td class='left'>
<span class='texttt'>iswspace</span> </td><td class='left'>
<span class='texttt'>qsort</span> </td><td class='left'>
<span class='texttt'>strtok</span> </td><td class='left'>
<span class='texttt'>wcsncmp</span> </td></tr><tr ><td class='left'>
<span class='texttt'>atol</span> </td><td class='left'>
<span class='texttt'>frexp</span> </td><td class='left'>
<span class='texttt'>iswupper</span> </td><td class='left'>
<span class='texttt'>raise</span> </td><td class='left'>
<span class='texttt'>strtol</span> </td><td class='left'>
<span class='texttt'>wcsncpy</span> </td></tr><tr ><td class='left'>
<span class='texttt'>bsearch</span> </td><td class='left'>
<span class='texttt'>fscanf</span> </td><td class='left'>
<span class='texttt'>iswxdigit</span> </td><td class='left'>
<span class='texttt'>rand</span> </td><td class='left'>
<span class='texttt'>strtoul</span> </td><td class='left'>
<span class='texttt'>wcspbrk</span> </td></tr><tr ><td class='left'>
<span class='texttt'>btowc</span> </td><td class='left'>
<span class='texttt'>fseek</span> </td><td class='left'>
<span class='texttt'>isxdigit</span> </td><td class='left'>
<span class='texttt'>realloc</span> </td><td class='left'>
<span class='texttt'>strxfrm</span> </td><td class='left'>
<span class='texttt'>wcsrchr</span> </td></tr><tr ><td class='left'>
<span class='texttt'>calloc</span> </td><td class='left'>
<span class='texttt'>fsetpos</span> </td><td class='left'>
<span class='texttt'>labs</span> </td><td class='left'>
<span class='texttt'>remove</span> </td><td class='left'>
<span class='texttt'>swprintf</span> </td><td class='left'>
<span class='texttt'>wcsrtombs</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ceil</span> </td><td class='left'>
<span class='texttt'>ftell</span> </td><td class='left'>
<span class='texttt'>ldexp</span> </td><td class='left'>
<span class='texttt'>rename</span> </td><td class='left'>
<span class='texttt'>swscanf</span> </td><td class='left'>
<span class='texttt'>wcsspn</span> </td></tr><tr ><td class='left'>
<span class='texttt'>clearerr</span> </td><td class='left'>
<span class='texttt'>fwide</span> </td><td class='left'>
<span class='texttt'>ldiv</span> </td><td class='left'>
<span class='texttt'>rewind</span> </td><td class='left'>
<span class='texttt'>system</span> </td><td class='left'>
<span class='texttt'>wcsstr</span> </td></tr><tr ><td class='left'>
<span class='texttt'>clock</span> </td><td class='left'>
<span class='texttt'>fwprintf</span> </td><td class='left'>
<span class='texttt'>localeconv</span> </td><td class='left'>
<span class='texttt'>scanf</span> </td><td class='left'>
<span class='texttt'>tan</span> </td><td class='left'>
<span class='texttt'>wcstod</span> </td></tr><tr ><td class='left'>
<span class='texttt'>cos</span> </td><td class='left'>
<span class='texttt'>fwrite</span> </td><td class='left'>
<span class='texttt'>localtime</span> </td><td class='left'>
<span class='texttt'>setbuf</span> </td><td class='left'>
<span class='texttt'>tanh</span> </td><td class='left'>
<span class='texttt'>wcstok</span> </td></tr><tr ><td class='left'>
<span class='texttt'>cosh</span> </td><td class='left'>
<span class='texttt'>fwscanf</span> </td><td class='left'>
<span class='texttt'>log</span> </td><td class='left'>
<span class='texttt'>setlocale</span> </td><td class='left'>
<span class='texttt'>time</span> </td><td class='left'>
<span class='texttt'>wcstol</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ctime</span> </td><td class='left'>
<span class='texttt'>getc</span> </td><td class='left'>
<span class='texttt'>log10</span> </td><td class='left'>
<span class='texttt'>setvbuf</span> </td><td class='left'>
<span class='texttt'>tmpfile</span> </td><td class='left'>
<span class='texttt'>wcstombs</span> </td></tr><tr ><td class='left'>
<span class='texttt'>difftime</span> </td><td class='left'>
<span class='texttt'>getchar</span> </td><td class='left'>
<span class='texttt'>longjmp</span> </td><td class='left'>
<span class='texttt'>signal</span> </td><td class='left'>
<span class='texttt'>tmpnam</span> </td><td class='left'>
<span class='texttt'>wcstoul</span> </td></tr><tr ><td class='left'>
<span class='texttt'>div</span> </td><td class='left'>
<span class='texttt'>getenv</span> </td><td class='left'>
<span class='texttt'>malloc</span> </td><td class='left'>
<span class='texttt'>sin</span> </td><td class='left'>
<span class='texttt'>tolower</span> </td><td class='left'>
<span class='texttt'>wcsxfrm</span> </td></tr><tr ><td class='left'>
<span class='texttt'>exit</span> </td><td class='left'>
<span class='texttt'>getwc</span> </td><td class='left'>
<span class='texttt'>mblen</span> </td><td class='left'>
<span class='texttt'>sinh</span> </td><td class='left'>
<span class='texttt'>toupper</span> </td><td class='left'>
<span class='texttt'>wctob</span> </td></tr><tr ><td class='left'>
<span class='texttt'>exp</span> </td><td class='left'>
<span class='texttt'>getwchar</span> </td><td class='left'>
<span class='texttt'>mbrlen</span> </td><td class='left'>
<span class='texttt'>sprintf</span> </td><td class='left'>
<span class='texttt'>towctrans</span> </td><td class='left'>
<span class='texttt'>wctomb</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fabs</span> </td><td class='left'>
<span class='texttt'>gmtime</span> </td><td class='left'>
<span class='texttt'>mbrtowc</span> </td><td class='left'>
<span class='texttt'>sqrt</span> </td><td class='left'>
<span class='texttt'>towlower</span> </td><td class='left'>
<span class='texttt'>wctrans</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fclose</span> </td><td class='left'>
<span class='texttt'>isalnum</span> </td><td class='left'>
<span class='texttt'>mbsinit</span> </td><td class='left'>
<span class='texttt'>srand</span> </td><td class='left'>
<span class='texttt'>towupper</span> </td><td class='left'>
<span class='texttt'>wctype</span> </td></tr><tr ><td class='left'>
<span class='texttt'>feof</span> </td><td class='left'>
<span class='texttt'>isalpha</span> </td><td class='left'>
<span class='texttt'>mbsrtowcs</span> </td><td class='left'>
<span class='texttt'>sscanf</span> </td><td class='left'>
<span class='texttt'>ungetc</span> </td><td class='left'>
<span class='texttt'>wmemchr</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ferror</span> </td><td class='left'>
<span class='texttt'>iscntrl</span> </td><td class='left'>
<span class='texttt'>mbstowcs</span> </td><td class='left'>
<span class='texttt'>strcat</span> </td><td class='left'>
<span class='texttt'>ungetwc</span> </td><td class='left'>
<span class='texttt'>wmemcmp</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fflush</span> </td><td class='left'>
<span class='texttt'>isdigit</span> </td><td class='left'>
<span class='texttt'>mbtowc</span> </td><td class='left'>
<span class='texttt'>strchr</span> </td><td class='left'>
<span class='texttt'>vfprintf</span> </td><td class='left'>
<span class='texttt'>wmemcpy</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fgetc</span> </td><td class='left'>
<span class='texttt'>isgraph</span> </td><td class='left'>
<span class='texttt'>memchr</span> </td><td class='left'>
<span class='texttt'>strcmp</span> </td><td class='left'>
<span class='texttt'>vfwprintf</span> </td><td class='left'>
<span class='texttt'>wmemmove</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fgetpos</span> </td><td class='left'>
<span class='texttt'>islower</span> </td><td class='left'>
<span class='texttt'>memcmp</span> </td><td class='left'>
<span class='texttt'>strcoll</span> </td><td class='left'>
<span class='texttt'>vprintf</span> </td><td class='left'>
<span class='texttt'>wmemset</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fgets</span> </td><td class='left'>
<span class='texttt'>isprint</span> </td><td class='left'>
<span class='texttt'>memcpy</span> </td><td class='left'>
<span class='texttt'>strcpy</span> </td><td class='left'>
<span class='texttt'>vsprintf</span> </td><td class='left'>
<span class='texttt'>wprintf</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fgetwc</span> </td><td class='left'>
<span class='texttt'>ispunct</span> </td><td class='left'>
<span class='texttt'>memmove</span> </td><td class='left'>
<span class='texttt'>strcspn</span> </td><td class='left'>
<span class='texttt'>vswprintf</span> </td><td class='left'>
<span class='texttt'>wscanf</span> </td></tr><tr ><td class='left'>
<span class='texttt'>fgetws</span> </td><td class='left'>
<span class='texttt'>isspace</span> </td><td class='left'>
<span class='texttt'>memset</span> </td><td class='left'>
<span class='texttt'>strerror</span> </td><td class='left'>
<span class='texttt'>vwprintf</span> </td><td class='left'></td></tr><tr ><td class='left'>
<span class='texttt'>floor</span> </td><td class='left'>
<span class='texttt'>isupper</span> </td><td class='left'>
<span class='texttt'>mktime</span> </td><td class='left'>
<span class='texttt'>strftime</span> </td><td class='left'>
<span class='texttt'>wcrtomb</span> </td><td class='left'></td></tr></table></div></div><div id='mods.to.headers'><h3 ><a class='secnum' href='#mods.to.headers' style='min-width:103pt'>C.4.1</a> Modifications to headers <a class='abbr_ref' href='diff.mods.to.headers'>[diff.mods.to.headers]</a></h3><div class='para' id='mods.to.headers-1'><div class='marginalizedparent'><a class='marginalized' href='#mods.to.headers-1'>1</a></div><p >For compatibility with the Standard C library,
<span class='indexparent'><a class='index' id='library,C_standard'></a></span>the C++ standard library provides the C headers enumerated
in <a href='depr.c.headers'>[depr.c.headers]</a>, but their use is deprecated in C++.</p></div></div><div id='mods.to.definitions'><h3 ><a class='secnum' href='#mods.to.definitions' style='min-width:103pt'>C.4.2</a> Modifications to definitions <a class='abbr_ref' href='diff.mods.to.definitions'>[diff.mods.to.definitions]</a></h3><div id='char16'><h4 ><a class='secnum' href='#char16' style='min-width:118pt'>C.4.2.1</a> Types <span class='texttt'>char16_t</span> and <span class='texttt'>char32_t</span> <a class='abbr_ref' href='diff.char16'>[diff.char16]</a></h4><div class='para' id='char16-1'><div class='marginalizedparent'><a class='marginalized' href='#char16-1'>1</a></div><p >The types <span class='texttt'>char16_t</span> and <span class='texttt'>char32_t</span>
are distinct types rather than typedefs to existing integral types.</p></div></div><div id='wchar.t'><h4 ><a class='secnum' href='#wchar.t' style='min-width:118pt'>C.4.2.2</a> Type <span class='texttt'>wchar_t</span> <a class='abbr_ref' href='diff.wchar.t'>[diff.wchar.t]</a></h4><div class='para' id='wchar.t-1'><div class='marginalizedparent'><a class='marginalized' href='#wchar.t-1'>1</a></div><p ><span class='texttt'>wchar_t</span>
is a keyword in this International Standard (<a href='lex.key'>[lex.key]</a>).
It does not appear as a type name defined in any of
<span class='texttt'>&lt;cstddef&gt;</span>,
<span class='indexparent'><a class='index' id='cstddef'></a></span><span class='texttt'>&lt;cstdlib&gt;</span>,
<span class='indexparent'><a class='index' id='cstdlib'></a></span>or
<span class='texttt'>&lt;cwchar&gt;</span>
<span class='indexparent'><a class='index' id='cwchar'></a></span>(<a href='c.strings'>[c.strings]</a>).</p></div></div><div id='header.iso646.h'><h4 ><a class='secnum' href='#header.iso646.h' style='min-width:118pt'>C.4.2.3</a> Header <span class='texttt'>&lt;iso646.h&gt;</span> <a class='abbr_ref' href='diff.header.iso646.h'>[diff.header.iso646.h]</a></h4><p ><span class='indexparent'><a class='index' id='iso646.h'></a></span>
</p><div class='para' id='header.iso646.h-1'><div class='marginalizedparent'><a class='marginalized' href='#header.iso646.h-1'>1</a></div><p >The tokens
<span class='texttt'>and</span>,
<span class='texttt'>and_eq</span>,
<span class='texttt'>bitand</span>,
<span class='texttt'>bitor</span>,
<span class='texttt'>compl</span>,
<span class='texttt'>not_eq</span>,
<span class='texttt'>not</span>,
<span class='texttt'>or</span>,
<span class='texttt'>or_eq</span>,
<span class='texttt'>xor</span>,
and
<span class='texttt'>xor_eq</span>
are keywords in this International
Standard (<a href='lex.key'>[lex.key]</a>).
They do not appear as macro names defined in
<span class='texttt'>&lt;ciso646&gt;</span>.
<span class='indexparent'><a class='index' id='ciso646'></a></span>
</p></div></div><div id='null'><h4 ><a class='secnum' href='#null' style='min-width:118pt'>C.4.2.4</a> Macro <span class='texttt'>NULL</span> <a class='abbr_ref' href='diff.null'>[diff.null]</a></h4><div class='para' id='null-1'><div class='marginalizedparent'><a class='marginalized' href='#null-1'>1</a></div><p >The macro
<span class='texttt'>NULL</span>,
defined in any of
<span class='indexparent'><a class='index' id='clocale'></a></span><span class='texttt'>&lt;clocale&gt;</span>,
<span class='indexparent'><a class='index' id='cstddef'></a></span><span class='texttt'>&lt;cstddef&gt;</span>,
<span class='indexparent'><a class='index' id='cstdio'></a></span><span class='texttt'>&lt;cstdio&gt;</span>,
<span class='indexparent'><a class='index' id='cstdlib'></a></span><span class='texttt'>&lt;cstdlib&gt;</span>,
<span class='indexparent'><a class='index' id='cstring'></a></span><span class='texttt'>&lt;cstring&gt;</span>,
<span class='indexparent'><a class='index' id='ctime'></a></span><span class='texttt'>&lt;ctime&gt;</span>,
or
<span class='texttt'>&lt;cwchar&gt;</span>,
<span class='indexparent'><a class='index' id='cwchar'></a></span>is an implementation-defined C++ null pointer constant in
<span class='indexparent'><a class='index' id='implementation-defined'></a></span>this International Standard (<a href='support.types'>[support.types]</a>).</p></div></div></div><div id='mods.to.declarations'><h3 ><a class='secnum' href='#mods.to.declarations' style='min-width:103pt'>C.4.3</a> Modifications to declarations <a class='abbr_ref' href='diff.mods.to.declarations'>[diff.mods.to.declarations]</a></h3><div class='para' id='mods.to.declarations-1'><div class='marginalizedparent'><a class='marginalized' href='#mods.to.declarations-1'>1</a></div><p >Header
<span class='texttt'>&lt;cstring&gt;</span>:
<span class='indexparent'><a class='index' id='cstring'></a></span>The following functions have different declarations:
</p><ul ><li id='mods.to.declarations-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.declarations-1.1'>(1.1)</a></div><p ><span class='texttt'>strchr</span>
</p></li><li id='mods.to.declarations-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.declarations-1.2'>(1.2)</a></div><p ><span class='texttt'>strpbrk</span>
</p></li><li id='mods.to.declarations-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.declarations-1.3'>(1.3)</a></div><p ><span class='texttt'>strrchr</span>
</p></li><li id='mods.to.declarations-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.declarations-1.4'>(1.4)</a></div><p ><span class='texttt'>strstr</span>
</p></li><li id='mods.to.declarations-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.declarations-1.5'>(1.5)</a></div><p ><span class='texttt'>memchr</span>
</p></li></ul><p ><a href='c.strings'>[c.strings]</a> describes the changes.</p></div></div><div id='mods.to.behavior'><h3 ><a class='secnum' href='#mods.to.behavior' style='min-width:103pt'>C.4.4</a> Modifications to behavior <a class='abbr_ref' href='diff.mods.to.behavior'>[diff.mods.to.behavior]</a></h3><div class='para' id='mods.to.behavior-1'><div class='marginalizedparent'><a class='marginalized' href='#mods.to.behavior-1'>1</a></div><p >Header
<span class='texttt'>&lt;cstdlib&gt;</span>:
The following functions have different behavior:
</p><ul ><li id='mods.to.behavior-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.behavior-1.1'>(1.1)</a></div><p ><span class='texttt'>atexit</span>
</p></li><li id='mods.to.behavior-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.behavior-1.2'>(1.2)</a></div><p ><span class='texttt'>exit</span>
</p></li><li id='mods.to.behavior-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.behavior-1.3'>(1.3)</a></div><p ><span class='texttt'>abort</span>
</p></li></ul><p ><a href='support.start.term'>[support.start.term]</a> describes the changes.</p></div><div class='para' id='mods.to.behavior-2'><div class='marginalizedparent'><a class='marginalized' href='#mods.to.behavior-2'>2</a></div><p >Header
<span class='texttt'>&lt;csetjmp&gt;</span>:
The following functions have different behavior:
</p><ul ><li id='mods.to.behavior-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mods.to.behavior-2.1'>(2.1)</a></div><p ><span class='texttt'>longjmp</span>
</p></li></ul><p ><a href='support.runtime'>[support.runtime]</a> describes the changes.</p></div><div id='offsetof'><h4 ><a class='secnum' href='#offsetof' style='min-width:118pt'>C.4.4.1</a> Macro <span class='texttt'>offsetof(type, member-designator)</span> <a class='abbr_ref' href='diff.offsetof'>[diff.offsetof]</a></h4><p ><span class='indexparent'><a class='index' id='offsetof'></a></span>
</p><div class='para' id='offsetof-1'><div class='marginalizedparent'><a class='marginalized' href='#offsetof-1'>1</a></div><p >The macro
<span class='texttt'>offsetof</span>,
defined in
<span class='indexparent'><a class='index' id='cstddef'></a></span><span class='texttt'>&lt;cstddef&gt;</span>,
accepts a restricted set of <span class='texttt'>type</span> arguments in this International Standard.
<a href='support.types'>[support.types]</a> describes the change.</p></div></div><div id='malloc'><h4 ><a class='secnum' href='#malloc' style='min-width:118pt'>C.4.4.2</a> Memory allocation functions <a class='abbr_ref' href='diff.malloc'>[diff.malloc]</a></h4><div class='para' id='malloc-1'><div class='marginalizedparent'><a class='marginalized' href='#malloc-1'>1</a></div><p >The functions
<span class='indexparent'><a class='index' id='calloc'></a></span><span class='texttt'>calloc</span>,
<span class='indexparent'><a class='index' id='malloc'></a></span><span class='texttt'>malloc</span>,
and
<span class='indexparent'><a class='index' id='realloc'></a></span><span class='texttt'>realloc</span>
are restricted in this International Standard.
<a href='c.malloc'>[c.malloc]</a> describes the changes.
</p></div></div></div></div></div></div></body></html>