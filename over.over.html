<!DOCTYPE html><html lang='en'><head><title>[over.over]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><div id='over.over'><h2 ><a class='secnum' style='min-width:88pt'>13.4</a> Address of overloaded function <a class='abbr_ref'>[over.over]</a></h2><p ><span class='indexparent'><a class='index' id='overloading,address_of_overloaded_function'></a></span><span class='indexparent'><a class='index' id='overloaded_function,address_of'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A use of an overloaded function name without arguments is resolved
in certain contexts to a function, a pointer to function or a pointer to
member function for a specific function from the overload set.
A function template name is considered to name a set of overloaded functions
in such contexts.
A function with type <span class='texttt'>F</span> is selected for the function type <span class='texttt'>FT</span>
of the target type required in the context if <span class='texttt'>F</span>
(after possibly applying the function pointer conversion (<a href='conv.fctptr'>[conv.fctptr]</a>))
is identical to <span class='texttt'>FT</span>.
[&nbsp;<i>Note:</i><span class='space'></span>
That is, the class of which the function is a member is ignored when matching a
pointer-to-member-function type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The target can be</p><ul ><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >an object or reference being initialized (<a href='dcl.init'>[dcl.init]</a>, <a href='dcl.init.ref'>[dcl.init.ref]</a>,
<a href='dcl.init.list'>[dcl.init.list]</a>),
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >the left side of an assignment (<a href='expr.ass'>[expr.ass]</a>),
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >a parameter of a function (<a href='expr.call'>[expr.call]</a>),
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >a parameter of a user-defined operator (<a href='over.oper'>[over.oper]</a>),
</p></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><p >the return value of a function, operator function, or conversion (<a href='stmt.return'>[stmt.return]</a>),
</p></li><li id='1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.6'>(1.6)</a></div><p >an explicit type conversion (<a href='expr.type.conv'>[expr.type.conv]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>,
<a href='expr.cast'>[expr.cast]</a>), or
</p></li><li id='1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.7'>(1.7)</a></div><p >a non-type
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> (<a href='temp.arg.nontype'>[temp.arg.nontype]</a>).
</p></li></ul><p >The overloaded function name can be preceded by the
<span class='texttt'>&amp;</span>
operator.
An overloaded function name shall not be used without arguments in contexts
other than those listed.
[&nbsp;<i>Note:</i><span class='space'></span>
Any redundant set of parentheses surrounding the overloaded function name is
ignored (<a href='expr.prim'>[expr.prim]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If the name is a function template, template argument deduction is
done (<a href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a>), and if the argument deduction succeeds,
the
resulting template argument list is
used to generate a single
function template specialization,
which is added to the set of overloaded functions
considered.
[&nbsp;<i>Note:</i><span class='space'></span>
As described in <a href='temp.arg.explicit'>[temp.arg.explicit]</a>, if deduction fails and the
function template name is followed by an explicit template argument list,
the
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
is then examined to see whether it identifies a single function template
specialization. If it does, the
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
is considered to be an lvalue for that function template specialization.
The target type is not used in that determination.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Non-member functions and static member functions
match targets of function pointer type or
reference to function type.
Non-static member functions match targets of
pointer to member function type.
If a non-static member function is selected, the reference to the overloaded
function name is required to have the form of a pointer to member as
described in <a href='expr.unary.op'>[expr.unary.op]</a>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If more than one function is selected, any
function template specializations
in the set
are eliminated if the set also contains a function that is not a
function template specialization, and
any given
function template specialization
<span class='texttt'>F1</span>
is eliminated if the set contains a second
function template specialization whose function template
is more specialized than the
function template of
<span class='texttt'>F1</span>
according to
the partial ordering rules of <a href='temp.func.order'>[temp.func.order]</a>.
After such eliminations,
if any, there shall remain exactly one selected function.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int f(double);
int f(int);
int (*pfd)(double) = &amp;f;        <span class='comment'>// selects <span class='texttt'>f(double)</span>
</span>int (*pfi)(int) = &amp;f;           <span class='comment'>// selects <span class='texttt'>f(int)</span>
</span>int (*pfe)(...) = &amp;f;           <span class='comment'>// error: type mismatch
</span>int (&amp;rfi)(int) = f;            <span class='comment'>// selects <span class='texttt'>f(int)</span>
</span>int (&amp;rfd)(double) = f;         <span class='comment'>// selects <span class='texttt'>f(double)</span>
</span>void g() {
  (int (*)(int))&amp;f;             <span class='comment'>// cast expression as selector
</span>}
</pre><p >The initialization of
<span class='texttt'>pfe</span>
is ill-formed because no
<span class='texttt'>f()</span>
with type
<span class='texttt'>int(...)</span>
has been declared, and not because of any ambiguity.
For another example,</p><pre class='codeblock'>
struct X {
  int f(int);
  static int f(long);
};

int (X::*p1)(int)  = &amp;X::f;     <span class='comment'>// OK
</span>int    (*p2)(int)  = &amp;X::f;     <span class='comment'>// error: mismatch
</span>int    (*p3)(long) = &amp;X::f;     <span class='comment'>// OK
</span>int (X::*p4)(long) = &amp;X::f;     <span class='comment'>// error: mismatch
</span>int (X::*p5)(int)  = &amp;(X::f);   <span class='comment'>// error: wrong syntax for
</span>                                <span class='comment'>// pointer to member
</span>int    (*p6)(long) = &amp;(X::f);   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
If
<span class='texttt'>f()</span>
and
<span class='texttt'>g()</span>
are both overloaded functions, the
cross product of possibilities must be considered
to resolve
<span class='texttt'>f(&amp;g)</span>,
or the equivalent expression
<span class='texttt'>f(g)</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='conversion,overload_resolution_and_pointer'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
Even if <span class='texttt'>B</span> is a public base of <span class='texttt'>D</span>,
we have</p><pre class='codeblock'>
D* f();
B* (*p1)() = &amp;f;                <span class='comment'>// error
</span>
void g(D*);
void (*p2)(B*) = &amp;g;            <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>