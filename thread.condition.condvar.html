<!DOCTYPE html><html lang='en'><head><title>[thread.condition.condvar]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>30.5</a> Condition variables <a class='abbr_ref' href='thread.condition#condvar'>[thread.condition]</a></h2><div id='thread.condition.condvar'><h3 ><a class='secnum' style='min-width:103pt'>30.5.1</a> Class <span class='texttt'>condition_variable</span> <a class='abbr_ref'>[thread.condition.condvar]</a></h3><p ><span class='indexparent'><a class='index' id='condition_variable'></a></span></p><pre class='codeblock'>
namespace std {
  class condition_variable {
  public:

    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
      void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    template &lt;class Clock, class Duration&gt;
      cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                           const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Clock, class Duration, class Predicate&gt;
      bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                      const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                      Predicate pred);

    template &lt;class Rep, class Period&gt;
      cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                         const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Rep, class Period, class Predicate&gt;
      bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                    Predicate pred);

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The class <span class='texttt'>condition_variable</span> shall be a standard-layout class (Clause <a href='class'>[class]</a>).</p><p ><span class='indexparent'><a class='index' id='condition_variable,constructor'></a></span><code class='itemdecl'>
condition_variable();
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if some non-memory resource
limitation prevents initialization.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,destructor'></a></span><code class='itemdecl'>
~condition_variable();
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_one,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,notify_one'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_all,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,notify_all'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><code class='itemdecl'>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.
</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>
or a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li></ul></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pred</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                       const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li ><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function.
</p></li></ul></div></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='29'><div class='marginalizedparent'><a class='marginalized' href='#29'>29</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='30'><div class='marginalizedparent'><a class='marginalized' href='#30'>30</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration, class Predicate&gt;
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                  Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='31'><div class='marginalizedparent'><a class='marginalized' href='#31'>31</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='32'><div class='marginalizedparent'><a class='marginalized' href='#32'>32</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='33'><div class='marginalizedparent'><a class='marginalized' href='#33'>33</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='34'><div class='marginalizedparent'><a class='marginalized' href='#34'>34</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='35'><div class='marginalizedparent'><a class='marginalized' href='#35'>35</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluated to
<span class='texttt'>true</span> regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='36'><div class='marginalizedparent'><a class='marginalized' href='#36'>36</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>) or any exception thrown by <span class='texttt'>pred</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period, class Predicate&gt;
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='37'><div class='marginalizedparent'><a class='marginalized' href='#37'>37</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='38'><div class='marginalizedparent'><a class='marginalized' href='#38'>38</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div><div class='para' id='39'><div class='marginalizedparent'><a class='marginalized' href='#39'>39</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, even if the
timeout has already expired. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='40'><div class='marginalizedparent'><a class='marginalized' href='#40'>40</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='41'><div class='marginalizedparent'><a class='marginalized' href='#41'>41</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='42'><div class='marginalizedparent'><a class='marginalized' href='#42'>42</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='43'><div class='marginalizedparent'><a class='marginalized' href='#43'>43</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>) or any exception thrown by <span class='texttt'>pred</span>.</p></div></div></div></div></body></html>