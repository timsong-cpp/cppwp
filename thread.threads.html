<!DOCTYPE html><html lang='en'><head><title>[thread.threads]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><div id='thread.threads'><h2 ><a class='secnum' style='min-width:88pt'>30.3</a> Threads <a class='abbr_ref'>[thread.threads]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><a href='thread.threads'>[thread.threads]</a> describes components that can be used to create and manage threads.
[&nbsp;<i>Note:</i><span class='space'></span> These threads are intended to map one-to-one with operating system threads.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><b>Header <span class='texttt'>&lt;thread&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='thread'></a></span>
</p><pre class='codeblock'>
namespace std {
  class thread;

  void swap(thread&amp; x, thread&amp; y) noexcept;

  namespace this_thread {
    thread::id get_id() noexcept;

    void yield() noexcept;
    template &lt;class Clock, class Duration&gt;
      void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Rep, class Period&gt;
      void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  }
}
</pre></div><div id='thread.thread.class'><h3 ><a class='secnum' href='#thread.thread.class' style='min-width:103pt'>30.3.1</a> Class <span class='texttt'>thread</span> <a class='abbr_ref' href='thread.thread.class'>[thread.thread.class]</a></h3><div class='para' id='thread.thread.class-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.class-1'>1</a></div><p >The class <span class='texttt'>thread</span> provides a mechanism to create a new thread of execution, to join with
a thread (i.e., wait for a thread to complete), and to perform other operations that manage and
query the state of a thread. A <span class='texttt'>thread</span> object uniquely represents a particular thread of
execution. That representation may be transferred to other <span class='texttt'>thread</span> objects in such a way
that no two <span class='texttt'>thread</span> objects simultaneously represent the same thread of execution. A
thread of execution is <i>detached</i> when no <span class='texttt'>thread</span> object represents that thread.
Objects of class <span class='texttt'>thread</span> can be in a state that does not represent a thread of
execution. [&nbsp;<i>Note:</i><span class='space'></span> A <span class='texttt'>thread</span> object does not represent a thread of execution after
default construction, after being moved from, or after a successful call to <span class='texttt'>detach</span> or
<span class='texttt'>join</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='thread'></a></span></p><pre class='codeblock'>
namespace std {
  class thread {
  public:
    <span class='comment'>// types:
</span>    class id;
    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>
    <span class='comment'>// construct/copy/destroy:
</span>    thread() noexcept;
    template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
    ~thread();
    thread(const thread&amp;) = delete;
    thread(thread&amp;&amp;) noexcept;
    thread&amp; operator=(const thread&amp;) = delete;
    thread&amp; operator=(thread&amp;&amp;) noexcept;

    <span class='comment'>// members:
</span>    void swap(thread&amp;) noexcept;
    bool joinable() const noexcept;
    void join();
    void detach();
    id get_id() const noexcept;
    native_handle_type native_handle(); <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>
    <span class='comment'>// static members:
</span>    static unsigned hardware_concurrency() noexcept;
  };
}
</pre></div><div id='thread.thread.id'><h4 ><a class='secnum' href='#thread.thread.id' style='min-width:118pt'>30.3.1.1</a> Class <span class='texttt'>thread::id</span> <a class='abbr_ref' href='thread.thread.id'>[thread.thread.id]</a></h4><p ><span class='indexparent'><a class='index' id='thread::id'></a></span><span class='indexparent'><a class='index' id='thread,id'></a></span></p><pre class='codeblock'>
namespace std {
  class thread::id {
  public:
      id() noexcept;
  };

  bool operator==(thread::id x, thread::id y) noexcept;
  bool operator!=(thread::id x, thread::id y) noexcept;
  bool operator&lt;(thread::id x, thread::id y) noexcept;
  bool operator&lt;=(thread::id x, thread::id y) noexcept;
  bool operator&gt;(thread::id x, thread::id y) noexcept;
  bool operator&gt;=(thread::id x, thread::id y) noexcept;

  template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp; out, thread::id id);

  <span class='comment'>// Hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;thread::id&gt;;
}
</pre><div class='para' id='thread.thread.id-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-1'>1</a></div><p >An object of type <span class='texttt'>thread::id</span> provides a unique identifier for
each thread of execution and a single distinct value for all <span class='texttt'>thread</span>
objects that do not represent a thread of
execution (<a href='thread.thread.class'>[thread.thread.class]</a>). Each thread of execution has an
associated <span class='texttt'>thread::id</span> object that is not equal to the
<span class='texttt'>thread::id</span> object of any other thread of execution and that is not
equal to the <span class='texttt'>thread::id</span> object of any <span class='texttt'>std::thread</span> object that
does not represent threads of execution.</p></div><div class='para' id='thread.thread.id-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-2'>2</a></div><p ><span class='texttt'>thread::id</span> shall be a trivially copyable class (Clause <a href='class'>[class]</a>).
The library may reuse the value of a <span class='texttt'>thread::id</span> of a terminated thread that can no longer be joined.</p></div><div class='para' id='thread.thread.id-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Relational operators allow <span class='texttt'>thread::id</span> objects to be used as
keys in associative containers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='thread::id,constructor'></a></span><code class='itemdecl'>
id() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='thread.thread.id-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>id</span>.</p></div></div><div class='para' id='thread.thread.id-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The constructed object does not represent a thread of execution.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator=='></a></span><code class='itemdecl'>
bool operator==(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>x</span> and <span class='texttt'>y</span> represent the same
thread of execution or neither <span class='texttt'>x</span> nor <span class='texttt'>y</span> represents a thread of
execution.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator!='></a></span><code class='itemdecl'>
bool operator!=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x == y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<'></a></span><code class='itemdecl'>
bool operator&lt;(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> A value such that <span class='texttt'>operator&lt;</span> is a total ordering as described in <a href='alg.sorting'>[alg.sorting]</a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<='></a></span><code class='itemdecl'>
bool operator&lt;=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(y &lt; x)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator>'></a></span><code class='itemdecl'>
bool operator&gt;(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>y &lt; x</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator>='></a></span><code class='itemdecl'>
bool operator&gt;=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x &lt; y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<<'></a></span><code class='itemdecl'>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp; out, thread::id id);
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-12'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts an unspecified text representation of <span class='texttt'>id</span> into
<span class='texttt'>out</span>. For two objects of type <span class='texttt'>thread::id</span> <span class='texttt'>x</span> and <span class='texttt'>y</span>,
if <span class='texttt'>x == y</span> the <span class='texttt'>thread::id</span> objects shall have the same text
representation and if <span class='texttt'>x != y</span> the <span class='texttt'>thread::id</span> objects shall have
distinct text representations.</p></div></div><div class='para' id='thread.thread.id-13'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>out</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='hash,thread::id'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.id-14'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.id-14'>14</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div><div id='thread.thread.constr'><h4 ><a class='secnum' href='#thread.thread.constr' style='min-width:118pt'>30.3.1.2</a> <span class='texttt'>thread</span> constructors <a class='abbr_ref' href='thread.thread.constr'>[thread.thread.constr]</a></h4><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
thread() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.constr-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>thread</span> object that does not represent a thread of execution.</p></div></div><div class='para' id='thread.thread.constr-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-2'>2</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get_id() == id()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.constr-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> and each <span class='texttt'>Ti</span> in <span class='texttt'>Args</span> shall satisfy the
<span class='texttt'>MoveConstructible</span> requirements.
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span> (<a href='func.require'>[func.require]</a>) shall be
a valid expression.</p></div></div><div class='para' id='thread.thread.constr-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This constructor shall not participate in overload resolution if <span class='texttt'>decay_t&lt;F&gt;</span>
is the same type as <span class='texttt'>std::thread</span>.</p></div></div><div class='para' id='thread.thread.constr-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>thread</span>. The new thread of execution executes
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span> with the calls to
<span class='discretionary'></span><span class='texttt'><i>DECAY_COPY</i></span> being evaluated in the constructing thread. Any return value from this invocation
is ignored. [&nbsp;<i>Note:</i><span class='space'></span> This implies that any exceptions not thrown from the invocation of the copy
of <span class='texttt'>f</span> will be thrown in the constructing thread, not the new thread. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If the
invocation of
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
terminates with an uncaught exception, <span class='texttt'>std::terminate</span> shall be called.</p></div></div><div class='para' id='thread.thread.constr-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-6'>6</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of the invocation of the constructor
synchronizes with the beginning of the invocation of the copy of <span class='texttt'>f</span>.</p></div></div><div class='para' id='thread.thread.constr-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_id() != id()</span>. <span class='texttt'>*this</span> represents the newly started thread.</p></div></div><div class='para' id='thread.thread.constr-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> if unable to start the new thread.</p></div></div><div class='para' id='thread.thread.constr-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-9'>9</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — the system lacked the necessary
resources to create another thread, or the system-imposed limit on the number of
threads in a process would be exceeded.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
thread(thread&amp;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.constr-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>thread</span> from <span class='texttt'>x</span>, and sets
<span class='texttt'>x</span> to a default constructed state.</p></div></div><div class='para' id='thread.thread.constr-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.constr-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>x.get_id() == id()</span> and <span class='texttt'>get_id()</span> returns the
value of <span class='texttt'>x.get_id()</span> prior to the start of construction.</p></div></div></div><div id='thread.thread.destr'><h4 ><a class='secnum' href='#thread.thread.destr' style='min-width:118pt'>30.3.1.3</a> <span class='texttt'>thread</span> destructor <a class='abbr_ref' href='thread.thread.destr'>[thread.thread.destr]</a></h4><p ><span class='indexparent'><a class='index' id='thread,destructor'></a></span><code class='itemdecl'>
~thread();
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.destr-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.destr-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>joinable()</span>, calls <span class='texttt'>std::terminate()</span>. Otherwise, has no effects.
[&nbsp;<i>Note:</i><span class='space'></span> Either implicitly detaching or joining a <span class='texttt'>joinable()</span> thread in its
destructor could result in difficult to debug correctness (for detach) or performance
(for join) bugs encountered only when an exception is raised. Thus the programmer must
ensure that the destructor is never executed while the thread is still joinable.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='thread.thread.assign'><h4 ><a class='secnum' href='#thread.thread.assign' style='min-width:118pt'>30.3.1.4</a> <span class='texttt'>thread</span> assignment <a class='abbr_ref' href='thread.thread.assign'>[thread.thread.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,thread'></a></span><span class='indexparent'><a class='index' id='thread,operator='></a></span><code class='itemdecl'>
thread&amp; operator=(thread&amp;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>joinable()</span>, calls <span class='texttt'>std::terminate()</span>. Otherwise, assigns the
state of <span class='texttt'>x</span> to <span class='texttt'>*this</span> and sets <span class='texttt'>x</span> to a default constructed state.</p></div></div><div class='para' id='thread.thread.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>x.get_id() == id()</span> and <span class='texttt'>get_id()</span> returns the value of
<span class='texttt'>x.get_id()</span> prior to the assignment.</p></div></div><div class='para' id='thread.thread.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='thread.thread.member'><h4 ><a class='secnum' href='#thread.thread.member' style='min-width:118pt'>30.3.1.5</a> <span class='texttt'>thread</span> members <a class='abbr_ref' href='thread.thread.member'>[thread.thread.member]</a></h4><p ><span class='indexparent'><a class='index' id='swap,thread'></a></span><span class='indexparent'><a class='index' id='thread,swap'></a></span><code class='itemdecl'>
void swap(thread&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.member-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Swaps the state of <span class='texttt'>*this</span> and <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='joinable,thread'></a></span><span class='indexparent'><a class='index' id='thread,joinable'></a></span><code class='itemdecl'>
bool joinable() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.member-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get_id() != id()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='join,thread'></a></span><span class='indexparent'><a class='index' id='thread,join'></a></span><code class='itemdecl'>
void join();
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.member-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks until the thread represented by <span class='texttt'>*this</span> has completed.</p></div></div><div class='para' id='thread.thread.member-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-4'>4</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of the thread represented by <span class='texttt'>*this</span> synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the corresponding successful
<span class='texttt'>join()</span> return. [&nbsp;<i>Note:</i><span class='space'></span> Operations on
<span class='texttt'>*this</span> are not synchronized. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='thread.thread.member-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The thread represented by <span class='texttt'>*this</span> has completed. <span class='texttt'>get_id() == id()</span>.</p></div></div><div class='para' id='thread.thread.member-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='thread.thread.member-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_deadlock_would_occur</span> — if deadlock is detected or
<span class='texttt'>get_id() == std::this_thread::get_id()</span>.</p></li><li ><p ><span class='texttt'>no_such_process</span> — if the thread is not valid.</p></li><li ><p ><span class='texttt'>invalid_argument</span> — if the thread is not joinable.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='detach,thread'></a></span><span class='indexparent'><a class='index' id='thread,detach'></a></span><code class='itemdecl'>
void detach();
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.member-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> The thread represented by <span class='texttt'>*this</span> continues execution without the calling thread
blocking. When <span class='texttt'>detach()</span> returns, <span class='texttt'>*this</span> no longer represents the possibly continuing
thread of execution. When the thread previously represented by <span class='texttt'>*this</span> ends execution, the
implementation shall release any owned resources.</p></div></div><div class='para' id='thread.thread.member-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-9'>9</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get_id() == id()</span>.</p></div></div><div class='para' id='thread.thread.member-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-10'>10</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='thread.thread.member-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-11'>11</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>no_such_process</span> — if the thread is not valid.
</p></li><li ><p ><span class='texttt'>invalid_argument</span> — if the thread is not joinable.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='get_id,thread'></a></span><span class='indexparent'><a class='index' id='thread,get_id'></a></span><code class='itemdecl'>
id get_id() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.member-12'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.member-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A default constructed <span class='texttt'>id</span> object if <span class='texttt'>*this</span> does not represent a thread,
otherwise <span class='texttt'>this_thread::get_id()</span> for the thread of execution represented by
<span class='texttt'>*this</span>.
</p></div></div></div><div id='thread.thread.static'><h4 ><a class='secnum' href='#thread.thread.static' style='min-width:118pt'>30.3.1.6</a> <span class='texttt'>thread</span> static members <a class='abbr_ref' href='thread.thread.static'>[thread.thread.static]</a></h4><p ><span class='indexparent'><a class='index' id='hardware_concurrency,thread'></a></span><span class='indexparent'><a class='index' id='thread,hardware_concurrency'></a></span><code class='itemdecl'>
unsigned hardware_concurrency() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.static-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of hardware thread contexts. [&nbsp;<i>Note:</i><span class='space'></span> This value should
only be considered to be a hint. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If this value is not computable or
well defined an implementation should return 0.
</p></div></div></div><div id='thread.thread.algorithm'><h4 ><a class='secnum' href='#thread.thread.algorithm' style='min-width:118pt'>30.3.1.7</a> <span class='texttt'>thread</span> specialized algorithms <a class='abbr_ref' href='thread.thread.algorithm'>[thread.thread.algorithm]</a></h4><p ><span class='indexparent'><a class='index' id='swap,thread'></a></span><span class='indexparent'><a class='index' id='thread,swap'></a></span><code class='itemdecl'>
void swap(thread&amp; x, thread&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.algorithm-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.algorithm-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='thread.thread.this'><h3 ><a class='secnum' href='#thread.thread.this' style='min-width:103pt'>30.3.2</a> Namespace <span class='texttt'>this_thread</span> <a class='abbr_ref' href='thread.thread.this'>[thread.thread.this]</a></h3><pre class='codeblock'>
namespace std::this_thread {
  thread::id get_id() noexcept;

  void yield() noexcept;
  template &lt;class Clock, class Duration&gt;
    void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Rep, class Period&gt;
    void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
}
</pre><p ><span class='indexparent'><a class='index' id='get_id,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,get_id'></a></span><code class='itemdecl'>
thread::id this_thread::get_id() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.this-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of type <span class='texttt'>thread::id</span> that uniquely identifies the current thread of
execution. No other thread of execution shall have this id and this thread of execution shall
always have this id. The object returned shall not compare equal to a default constructed
<span class='texttt'>thread::id</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='yield,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,yield'></a></span><code class='itemdecl'>
void this_thread::yield() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.this-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Offers the implementation the opportunity to reschedule.</p></div></div><div class='para' id='thread.thread.this-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-3'>3</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.
</p></div></div><p ><span class='indexparent'><a class='index' id='sleep_until,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,sleep_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.this-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread for the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified
by <span class='texttt'>abs_time</span>.</p></div></div><div class='para' id='thread.thread.this-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-5'>5</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.</p></div></div><div class='para' id='thread.thread.this-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='sleep_for,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,sleep_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='thread.thread.this-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread for the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified
by <span class='texttt'>rel_time</span>.</p></div></div><div class='para' id='thread.thread.this-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.</p></div></div><div class='para' id='thread.thread.this-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.thread.this-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div></div></div></div></body></html>