<!DOCTYPE html><html lang='en'><head><title>[class.copy.elision]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>15.8</a> Copying and moving class objects <a class='abbr_ref' href='class.copy#elision'>[class.copy]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>15.8.3</a> Copy/move elision <a class='abbr_ref'>[class.copy.elision]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e3b4927ea0f4e8c8bf1f7461226c729b4e2c00be/source/special.tex#L3134'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id=':constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id=':side_effects'></a></span>side effects<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization<a class='hidden_link' href='#1.sentence-3'>.</a><a class='footnotenum' href='#footnote-122'>122</a></div> <div id='1.sentence-4' class='sentence'>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id=':constructor,copy,elision_'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision_'></a></span><a class='hidden_link' href='#def:copy_elision' id='def:copy_elision'><i>copy elision</i></a>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</div><div id='1.sentence-5' class='sentence'><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><div id='1.1.sentence-1' class='sentence'>in a <span class='texttt'>return</span> statement in a function with a class return type,
when the <i ><a href='expr.comma#nt:expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#nt:handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</div></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><div id='1.2.sentence-1' class='sentence'>in a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>), when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the <a href='except.throw#def:exception_handling,exception_object'>exception object</a> can be omitted by
constructing the automatic object directly into the exception object</div></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><div id='1.3.sentence-1' class='sentence'>when the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of an
exception handler (<a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the
<a href='except.throw#def:exception_handling,exception_object'>exception object</a>,
the copy operation can be omitted by treating
the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i><a class='hidden_link' href='#1.3.sentence-1'>.</a></div> <div id='1.3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.3.sentence-2' class='sentence'>There cannot be a move from the exception object because it is
always an lvalue<a class='hidden_link' href='#1.3.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul>
Copy elision is required
where an expression is evaluated in a context
requiring a <a href='expr.const'>constant expression</a>
and in <a href='basic.start.static#def:constant_initialization'>constant initialization</a><a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-6' class='sentence'>Copy elision might not be performed
if the same expression
is evaluated in another context<a class='hidden_link' href='#1.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e3b4927ea0f4e8c8bf1f7461226c729b4e2c00be/source/special.tex#L3205'>#</a></div><div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&amp;);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;          <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>a.p</span> points to <span class='tcode_in_codeblock'>a</span>
</span>constexpr A b = g();    <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>b.p</span> points to <span class='tcode_in_codeblock'>b</span>
</span>
void g() {
  A c = g();            <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>c.p</span> may point to <span class='tcode_in_codeblock'>c</span> or to an ephemeral temporary
</span>}</pre> <div id='2.sentence-1' class='sentence'>
Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f()</span>,
which is the global object
<span class='texttt'>t2</span><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided<a class='hidden_link' href='#2.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e3b4927ea0f4e8c8bf1f7461226c729b4e2c00be/source/special.tex#L3258'>#</a></div><div id='3.sentence-1' class='sentence'>In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'>If the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <a href='stmt.return'><span class='texttt'>return</span> statement</a>
is a (possibly parenthesized) <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, or</div></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'>if the operand of a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>)
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one),</div></li></ul>
overload resolution to select the constructor
for the copy is first performed as if the object were designated by an
rvalue<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-3' class='sentence'>This two-stage overload resolution must be performed regardless
of whether copy elision will occur<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided<a class='hidden_link' href='#3.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e3b4927ea0f4e8c8bf1f7461226c729b4e2c00be/source/special.tex#L3287'>#</a></div><div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&amp;&amp;);
private:
  Thing(const Thing&amp;);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='tcode_in_codeblock'>t</span>
</span>  return t;             <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='tcode_in_codeblock'>t</span>
</span>}

Thing t2 = f(false);    <span class='comment'>// OK: no extra copy/move performed, <span class='tcode_in_codeblock'>t2</span> constructed by call to <span class='tcode_in_codeblock'>f</span>
</span>
struct Weird {
  Weird();
  Weird(Weird&amp;);
};

Weird g() {
  Weird w;
  return w;             <span class='comment'>// OK: first overload resolution fails, second overload resolution selects <span class='tcode_in_codeblock'>Weird(Weird&amp;)</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-122'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-122'>122)</a></div><div id='footnote-122.sentence-1' class='sentence'>Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed<a class='hidden_link' href='#footnote-122.sentence-1'>.</a></div></div></div></body></html>