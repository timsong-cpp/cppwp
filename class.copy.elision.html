<!DOCTYPE html><html lang='en'><head><title>[class.copy.elision]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.8</a> Copying and moving class objects <a class='abbr_ref' href='class.copy#elision'>[class.copy]</a></h2><div id='class.copy.elision'><h3 ><a class='secnum' style='min-width:103pt'>12.8.3</a> Copy/move elision <a class='abbr_ref'>[class.copy.elision]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id='elision,copy_constructor'></a></span><span class='indexparent'><a class='index' id='elision,move_constructor'></a></span><span class='indexparent'><a class='index' id='constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id='constructor,move,elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id='side_effects'></a></span>side effects.  In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object. If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization.<a class='footnotenum' href='#footnote-122'>122</a>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id='copy_elision'></a></span><span class='indexparent'><a class='index' id='elision,copy'></a></span><span class='indexparent'><a class='index' id='constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id='constructor,move,elision'></a></span><a class='hidden_link' href='#def:copy_elision' id='def:copy_elision'><i>copy elision</i></a>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >in a <span class='texttt'>return</span> statement in a function with a class return type,
when the <i ><a href='expr.comma#nt:expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#nt:handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >in a <span class='rmfamily'></span><i> throw-expression</i> (<a href='expr.throw'>[expr.throw]</a>), when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the exception object (<a href='except.throw'>[except.throw]</a>) can be omitted by
constructing the automatic object directly into the exception object</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >when the <span class='rmfamily'></span><i> exception-declaration</i> of an
exception handler (Clause <a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the exception
object (<a href='except.throw'>[except.throw]</a>), the copy operation can be omitted by treating
the <span class='rmfamily'></span><i> exception-declaration</i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<span class='rmfamily'></span><i> exception-declaration</i>.
[&nbsp;<i>Note:</i> There cannot be a move from the exception object because it is
always an lvalue.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >Copy elision is required
where an expression is evaluated in a context
requiring a constant expression (<a href='expr.const'>[expr.const]</a>)
and in constant initialization (<a href='basic.start.static'>[basic.start.static]</a>).
[&nbsp;<i>Note:</i>
Copy elision might not be performed
if the same expression
is evaluated in another context.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&amp;);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;          <span class='comment'>// well-formed, <span class='texttt'>a.p</span> points to <span class='texttt'>a</span>
</span>constexpr A b = g();    <span class='comment'>// well-formed, <span class='texttt'>b.p</span> points to <span class='texttt'>b</span>
</span>
void g() {
  A c = g();            <span class='comment'>// well-formed, <span class='texttt'>c.p</span> may point to <span class='texttt'>c</span> or to an ephemeral temporary
</span>}
</pre><p >Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f()</span>,
which is the global object
<span class='texttt'>t2</span>.
Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit.
Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <span class='texttt'>return</span> statement (<a href='stmt.return'>[stmt.return]</a>)
is a (possibly parenthesized) <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, or</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >if the operand of a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>)
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one),
</p></li></ul><p >overload resolution to select the constructor
for the copy is first performed as if the object were designated by an
rvalue.
If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue.
[&nbsp;<i>Note:</i>
This two-stage overload resolution must be performed regardless
of whether copy elision will occur. It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&amp;&amp;);
private:
  Thing(const Thing&amp;);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            <span class='comment'>// OK: <span class='texttt'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='texttt'>t</span>
</span>  return t;             <span class='comment'>// OK: <span class='texttt'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='texttt'>t</span>
</span>}

Thing t2 = f(false);    <span class='comment'>// OK: no extra copy/move performed, <span class='texttt'>t2</span> constructed by call to <span class='texttt'>f</span>
</span>
struct Weird {
  Weird();
  Weird(Weird&amp;);
};

Weird g() {
  Weird w;
  return w;             <span class='comment'>// OK: first overload resolution fails, second overload resolution selects <span class='texttt'>Weird(Weird&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div><div class='footnote' id='footnote-122'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-122'>122)</a></div><p >Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed.</p></div></div></div></body></html>