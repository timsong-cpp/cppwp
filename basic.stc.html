<!DOCTYPE html><html lang='en'><head><title>[basic.stc]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.stc'><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref'>[basic.stc]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2799'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration'></a></span>The <a class='hidden_link' href='#def:storage_duration' id='def:storage_duration'><i>storage duration</i></a> is the property of an object that defines the minimum
potential lifetime of the storage containing the object. The storage
duration is determined by the construct used to create the object and is
one of the following:</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >static storage duration
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >thread storage duration
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >automatic storage duration
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >dynamic storage duration
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2813'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,static'></a></span><span class='indexparent'><a class='index' id='storage_duration,thread'></a></span><span class='indexparent'><a class='index' id='storage_duration,automatic'></a></span><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span>Static, thread, and automatic storage durations are associated with objects
introduced by declarations (<a href='basic.def'>[basic.def]</a>) and implicitly created by
the implementation (<a href='class.temporary'>[class.temporary]</a>). The dynamic storage duration
is associated with objects created with <span class='texttt'>operator</span>
<span class='texttt'>new</span> (<a href='expr.new'>[expr.new]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2824'>#</a></div><p >The storage duration categories apply to references as well.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2827'>#</a></div><p >When the end of the duration of a region of storage is reached,
the values of all pointers
representing the address of any part of that region of storage
become invalid pointer values (<a href='basic.compound'>[basic.compound]</a>).
Indirection through an invalid pointer value and
passing an invalid pointer value to a deallocation function
have undefined behavior.
Any other use of an invalid pointer value has
<span class='indexparent'><a class='index' id='any_use_of_an_invalid_pointer_other_than_to_perform_indirection_or_deallocate'></a></span>implementation-defined
behavior.<a class='footnotenum' href='#footnote-37'>37</a></p></div><div class='footnote' id='footnote-37'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-37'>37)</a></div><p >Some implementations might define that
copying an invalid pointer value
causes a system-generated runtime fault.</p></div><div id='static'><h3 ><a class='secnum' href='#static' style='min-width:103pt'>3.7.1</a> Static storage duration <a class='abbr_ref' href='basic.stc.static'>[basic.stc.static]</a></h3><div class='para' id='static-1'><div class='marginalizedparent'><a class='marginalized' href='#static-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2843'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,static'></a></span>All variables which do not have dynamic storage duration, do not have thread
storage duration, and are not local
have <a class='hidden_link' href='#def:static_storage_duration' id='def:static_storage_duration'><i>static storage duration</i></a>. The
storage for these entities shall last for the duration of the
program (<a href='basic.start.static'>[basic.start.static]</a>, <a href='basic.start.term'>[basic.start.term]</a>).</p></div><div class='para' id='static-2'><div class='marginalizedparent'><a class='marginalized' href='#static-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2851'>#</a></div><p >If a variable with static storage duration has initialization or a
destructor with side effects, it shall not be eliminated even if it
appears to be unused, except that a class object or its copy/move may be
eliminated as specified in <a href='class.copy'>[class.copy]</a>.</p></div><div class='para' id='static-3'><div class='marginalizedparent'><a class='marginalized' href='#static-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2857'>#</a></div><p ><span class='indexparent'><a class='index' id='object,local_static'></a></span>The keyword <span class='texttt'>static</span> can be used to declare a local variable with
static storage duration. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> <a href='stmt.dcl'>[stmt.dcl]</a> describes the
initialization of local <span class='texttt'>static</span> variables; <a href='basic.start.term'>[basic.start.term]</a>
describes the destruction of local <span class='texttt'>static</span> variables. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='static-4'><div class='marginalizedparent'><a class='marginalized' href='#static-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2864'>#</a></div><p ><span class='indexparent'><a class='index' id='member,class_static'></a></span>The keyword <span class='texttt'>static</span> applied to a class data member in a class
definition gives the data member static storage duration.</p></div></div><div id='thread'><h3 ><a class='secnum' href='#thread' style='min-width:103pt'>3.7.2</a> Thread storage duration <a class='abbr_ref' href='basic.stc.thread'>[basic.stc.thread]</a></h3><div class='para' id='thread-1'><div class='marginalizedparent'><a class='marginalized' href='#thread-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2871'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,thread'></a></span>All variables declared with the <span class='texttt'>thread_&shy;local</span> keyword have <a class='hidden_link' href='#def:thread_storage_duration' id='def:thread_storage_duration'><i>thread
storage duration</i></a>. The storage for these entities shall last for the duration of
the thread in which they are created. There is a distinct object or reference
per thread, and use of the declared name refers to the entity associated with
the current thread.</p></div><div class='para' id='thread-2'><div class='marginalizedparent'><a class='marginalized' href='#thread-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2879'>#</a></div><p >A variable with thread storage duration shall be initialized before
its first odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) and, if constructed, shall be destroyed on thread exit.</p></div></div><div id='auto'><h3 ><a class='secnum' href='#auto' style='min-width:103pt'>3.7.3</a> Automatic storage duration <a class='abbr_ref' href='basic.stc.auto'>[basic.stc.auto]</a></h3><div class='para' id='auto-1'><div class='marginalizedparent'><a class='marginalized' href='#auto-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2885'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,automatic'></a></span><span class='indexparent'><a class='index' id='storage_duration,local_object'></a></span>Block-scope variables
not explicitly declared <span class='texttt'>static</span>, <span class='texttt'>thread_&shy;local</span>, or <span class='texttt'>extern</span> have
<a class='hidden_link' href='#def:automatic_storage_duration' id='def:automatic_storage_duration'><i>automatic storage duration</i></a>. The storage
for these entities lasts until the block in which they are created exits.</p></div><div class='para' id='auto-2'><div class='marginalizedparent'><a class='marginalized' href='#auto-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2893'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
These variables are initialized and destroyed as described in <a href='stmt.dcl'>[stmt.dcl]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='auto-3'><div class='marginalizedparent'><a class='marginalized' href='#auto-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2898'>#</a></div><p >If a variable with automatic storage duration has initialization or a destructor with side
effects, an implementation shall not destroy it before the end of its block
nor eliminate it as an optimization, even if it appears to be
unused, except that a class object or its copy/move may be eliminated as
specified in <a href='class.copy'>[class.copy]</a>.</p></div></div><div id='dynamic'><h3 ><a class='secnum' href='#dynamic' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref' href='basic.stc.dynamic'>[basic.stc.dynamic]</a></h3><p ><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p><div class='para' id='dynamic-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2908'>#</a></div><p >Objects can be created dynamically during program
execution (<a href='intro.execution'>[intro.execution]</a>), using
<span class='indexparent'><a class='index' id='new'></a></span><i ><a href='expr.new#nt:new-expression'>new-expressions</a></i> (<a href='expr.new'>[expr.new]</a>), and destroyed using
<span class='indexparent'><a class='index' id='delete'></a></span><i ><a href='expr.delete#nt:delete-expression'>delete-expressions</a></i> (<a href='expr.delete'>[expr.delete]</a>). A C++ implementation
provides access to, and management of, dynamic storage via the global
<a class='hidden_link' href='#def:allocation_functions' id='def:allocation_functions'><i>allocation functions</i></a> <span class='texttt'>operator new</span> and <span class='texttt'>operator
new[]</span> and the global <a class='hidden_link' href='#def:deallocation_functions' id='def:deallocation_functions'><i>deallocation functions</i></a> <span class='texttt'>operator
delete</span> and <span class='texttt'>operator delete[]</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The non-allocating forms described in <a href='new.delete.placement'>[new.delete.placement]</a>
do not perform allocation or deallocation.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='dynamic-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2924'>#</a></div><p >The library provides default definitions for the global allocation and
deallocation functions. Some global allocation and deallocation
functions are replaceable (<a href='new.delete'>[new.delete]</a>). A C++ program shall
provide at most one definition of a replaceable allocation or
deallocation function. Any such function definition replaces the default
version provided in the library (<a href='replacement.functions'>[replacement.functions]</a>). The
following allocation and deallocation functions (<a href='support.dynamic'>[support.dynamic]</a>)
are implicitly declared in global scope in each translation unit of a
program.</p><pre class='codeblock'>
void* operator new(std::size_t);
void* operator new(std::size_t, std::align_val_t);

void operator delete(void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete(void*, std::align_val_t) noexcept;
void operator delete(void*, std::size_t, std::align_val_t) noexcept;

void* operator new[](std::size_t);
void* operator new[](std::size_t, std::align_val_t);

void operator delete[](void*) noexcept;
void operator delete[](void*, std::size_t) noexcept;
void operator delete[](void*, std::align_val_t) noexcept;
void operator delete[](void*, std::size_t, std::align_val_t) noexcept;</pre><p >These implicit declarations introduce only the function names
<span class='texttt'>operator</span> <span class='texttt'>new</span>, <span class='texttt'>operator</span> <span class='texttt'>new[]</span>,
<span class='texttt'>operator</span> <span class='texttt'>delete</span>, and <span class='texttt'>operator</span>
<span class='texttt'>delete[]</span>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> The implicit declarations do not introduce
the names <span class='texttt'>std</span>,
<span class='texttt'>std&#x200b;&#x200b;::&#x200b;&#x200b;size_&shy;t</span>,
<span class='texttt'>std&#x200b;&#x200b;::&#x200b;&#x200b;align_&shy;val_&shy;t</span>,
or any other names that the library uses to
declare these names. Thus, a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> or function call that refers to one of
these functions without including the header <span class='texttt'>&lt;new&gt;</span> is
well-formed. However, referring to <span class='texttt'>std</span>
or <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>
or <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>
is ill-formed unless the name has been declared
by including the appropriate header. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] Allocation and/or
deallocation functions may also be declared and defined for any
class (<a href='class.free'>[class.free]</a>).</p></div><div class='para' id='dynamic-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2972'>#</a></div><p >Any allocation and/or deallocation functions defined in a C++ program,
including the default versions in the library, shall conform to the
semantics specified in <a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>
and <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.</p></div><div id='dynamic.allocation'><h4 ><a class='secnum' href='#dynamic.allocation' style='min-width:118pt'>3.7.4.1</a> Allocation functions <a class='abbr_ref' href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a></h4><div class='para' id='dynamic.allocation-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2980'>#</a></div><p ><span class='indexparent'><a class='index' id='function,allocation'></a></span>An allocation function shall be a class member function or a global
function; a program is ill-formed if an allocation function is declared
in a namespace scope other than global scope or declared static in
global scope. The return type shall be <span class='texttt'>void*</span>. The first
parameter shall have type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> (<a href='support.types'>[support.types]</a>). The
first parameter shall not have an associated default
argument (<a href='dcl.fct.default'>[dcl.fct.default]</a>). The value of the first parameter shall
be interpreted as the requested size of the allocation. An allocation
function can be a function template. Such a template shall declare its
return type and first parameter as specified above (that is, template
parameter types shall not be used in the return type and first parameter
type). Template allocation functions shall have two or more parameters.</p></div><div class='para' id='dynamic.allocation-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L2995'>#</a></div><p >The allocation function attempts to allocate the requested amount of
storage. If it is successful, it shall return the address of the start
of a block of storage whose length in bytes shall be at least as large
as the requested size. There are no constraints on the contents of the
allocated storage on return from the allocation function. The order,
contiguity, and initial value of storage allocated by successive calls
to an allocation function are unspecified. The pointer returned shall be
suitably aligned so that it can be converted to a pointer to any
suitable complete object type (<a href='new.delete.single'>[new.delete.single]</a>)
and then used to access the object or array in the
storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space
requested is zero, the request can fail. If the request succeeds, the
value returned shall be a non-null pointer value (<a href='conv.ptr'>[conv.ptr]</a>)
<span class='texttt'>p0</span> different from any previously returned value <span class='texttt'>p1</span>,
unless that value <span class='texttt'>p1</span> was subsequently passed to an
<span class='texttt'>operator</span> <span class='texttt'>delete</span>.
Furthermore, for the library allocation functions
in <a href='new.delete.single'>[new.delete.single]</a> and <a href='new.delete.array'>[new.delete.array]</a>,
<span class='texttt'>p0</span> shall represent the address of a block of storage disjoint from the storage
for any other object accessible to the caller.
The effect of indirecting through a pointer
returned as a request for zero size is undefined.<a class='footnotenum' href='#footnote-38'>38</a></p></div><div class='para' id='dynamic.allocation-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3024'>#</a></div><p >An allocation function that fails to allocate storage can invoke the
currently installed new-handler function (<a href='new.handler'>[new.handler]</a>), if any.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
<span class='indexparent'><a class='index' id='new_handler'></a></span>A program-supplied allocation function can obtain the address of the
currently installed <span class='texttt'>new_&shy;handler</span> using the
<span class='texttt'>std&#x200b;::&#x200b;get_&shy;new_&shy;handler</span> function (<a href='set.new.handler'>[set.new.handler]</a>). <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
If an allocation function that has a non-throwing
exception specification (<a href='except.spec'>[except.spec]</a>)
fails to allocate storage, it shall return a null pointer. Any other
allocation function that fails to allocate storage shall indicate
failure only by throwing an exception (<a href='except.throw'>[except.throw]</a>) of a type
that would match a handler (<a href='except.handle'>[except.handle]</a>) of type
<span class='texttt'>std&#x200b;::&#x200b;bad_&shy;alloc</span> (<a href='bad.alloc'>[bad.alloc]</a>).</p></div><div class='para' id='dynamic.allocation-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3040'>#</a></div><p >A global allocation function is only called as the result of a new
expression (<a href='expr.new'>[expr.new]</a>), or called directly using the function call
syntax (<a href='expr.call'>[expr.call]</a>), or called indirectly through calls to the
functions in the C++ standard library. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> In particular, a
global allocation function is not called to allocate storage for objects
with static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>), for objects or references
with thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>), for objects of
type <span class='texttt'>std&#x200b;::&#x200b;type_&shy;info</span> (<a href='expr.typeid'>[expr.typeid]</a>), or for an
exception object (<a href='except.throw'>[except.throw]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-38'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-38'>38)</a></div><p >The intent is
to have <span class='texttt'>operator new()</span> implementable by
calling <span class='texttt'>std&#x200b;::&#x200b;malloc()</span> or <span class='texttt'>std&#x200b;::&#x200b;calloc()</span>, so the rules are
substantially the same. C++ differs from C in requiring a zero request
to return a non-null pointer.</p></div></div><div id='dynamic.deallocation'><h4 ><a class='secnum' href='#dynamic.deallocation' style='min-width:118pt'>3.7.4.2</a> Deallocation functions <a class='abbr_ref' href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a></h4><div class='para' id='dynamic.deallocation-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3054'>#</a></div><p ><span class='indexparent'><a class='index' id='function,deallocation'></a></span>Deallocation functions shall be class member functions or global
functions; a program is ill-formed if deallocation functions are
declared in a namespace scope other than global scope or declared static
in global scope.</p></div><div class='para' id='dynamic.deallocation-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3061'>#</a></div><p ><span class='indexparent'><a class='index' id='delete,overloading_and'></a></span>Each deallocation function shall return <span class='texttt'>void</span> and its first
parameter shall be <span class='texttt'>void*</span>. A deallocation function may have more
than one parameter.
<span class='indexparent'><a class='index' id='deallocation_function,usual'></a></span>A <a class='hidden_link' href='#def:usual_deallocation_function' id='def:usual_deallocation_function'><i>usual deallocation function</i></a> is a deallocation function that has:
</p><ul class='itemize'><li id='dynamic.deallocation-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.deallocation-2.1'>(2.1)</a></div><p >exactly one parameter; or
</p></li><li id='dynamic.deallocation-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.deallocation-2.2'>(2.2)</a></div><p >exactly two parameters,
the type of the second being either
<span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span> or
<span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span><a class='footnotenum' href='#footnote-39'>39</a>; or
</p></li><li id='dynamic.deallocation-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.deallocation-2.3'>(2.3)</a></div><p >exactly three parameters,
the type of the second being <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>
and
the type of the third being <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>.
</p></li></ul><p >A deallocation function may be an instance of a function
template. Neither the first parameter nor the return type shall depend
on a template parameter. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> That is, a deallocation function
template shall have a first parameter of type <span class='texttt'>void*</span> and a return
type of <span class='texttt'>void</span> (as specified above). <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] A deallocation
function template shall have two or more function parameters. A template
instance is never a usual deallocation function, regardless of its
signature.</p></div><div class='para' id='dynamic.deallocation-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3095'>#</a></div><p >If a deallocation function terminates by throwing an exception, the behavior is undefined.
The value of the first argument supplied to a deallocation function may
be a null pointer value; if so, and if the deallocation function is one
supplied in the standard library, the call has no effect.</p></div><div class='para' id='dynamic.deallocation-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3101'>#</a></div><p >If the argument given to a deallocation function in the standard library
is a pointer that is not the null pointer value (<a href='conv.ptr'>[conv.ptr]</a>), the
deallocation function shall deallocate the storage referenced by the
pointer, ending the duration of the region of storage.</p></div><div class='footnote' id='footnote-39'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-39'>39)</a></div><p >The global <span class='texttt'>operator delete(void*, std&#x200b;::&#x200b;size_&shy;t)</span>
precludes use of an
allocation function <span class='texttt'>void operator new(std&#x200b;::&#x200b;size_&shy;t, std&#x200b;::&#x200b;size_&shy;t)</span> as a placement
allocation function (<a href='diff.cpp11.basic'>[diff.cpp11.basic]</a>).</p></div></div><div id='dynamic.safety'><h4 ><a class='secnum' href='#dynamic.safety' style='min-width:118pt'>3.7.4.3</a> Safely-derived pointers <a class='abbr_ref' href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a></h4><div class='para' id='dynamic.safety-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3109'>#</a></div><p ><span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='pointer,to_traceable_object'></a></span>A <a class='hidden_link' href='#def:traceable_pointer_object' id='def:traceable_pointer_object'><i>traceable pointer object</i></a> is
</p><ul class='itemize'><li id='dynamic.safety-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.1'>(1.1)</a></div><p >an object of an object pointer
type (<a href='basic.compound'>[basic.compound]</a>), or
</p></li><li id='dynamic.safety-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.2'>(1.2)</a></div><p >an object of an integral type that is at least as large as <span class='texttt'>std&#x200b;::&#x200b;intptr_&shy;t</span>,
or
</p></li><li id='dynamic.safety-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.3'>(1.3)</a></div><p >a sequence of elements in an array of narrow character
type (<a href='basic.fundamental'>[basic.fundamental]</a>), where the size and alignment of the sequence
match those of some object pointer type.
</p></li></ul></div><div class='para' id='dynamic.safety-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3123'>#</a></div><p ><span class='indexparent'><a class='index' id='safely-derived_pointer'></a></span>A pointer value is a <span class='grammarterm'>safely-derived pointer</span> to a dynamic object only if it
has an object pointer type and it is one of the following:
</p><ul class='itemize'><li id='dynamic.safety-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.1'>(2.1)</a></div><p >the value returned by a call to the C++ standard library implementation of
<span class='texttt'>&#x200b;::&#x200b;operator new(std&#x200b;&#x200b;::&#x200b;&#x200b;size_&shy;t)</span> or
<span class='texttt'>&#x200b;::&#x200b;operator new(std&#x200b;&#x200b;::&#x200b;&#x200b;size_&shy;t, std&#x200b;&#x200b;::&#x200b;&#x200b;align_&shy;val_&shy;t)</span>;<a class='footnotenum' href='#footnote-40'>40</a></p></li><li id='dynamic.safety-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.2'>(2.2)</a></div><p >the result of taking the address of an object (or one of its
  subobjects) designated by an lvalue resulting from indirection
  through a safely-derived pointer value;</p></li><li id='dynamic.safety-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.3'>(2.3)</a></div><p >the result of well-defined pointer arithmetic (<a href='expr.add'>[expr.add]</a>) using a safely-derived pointer
value;</p></li><li id='dynamic.safety-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.4'>(2.4)</a></div><p >the result of a well-defined pointer
conversion (<a href='conv.ptr'>[conv.ptr]</a>, <a href='expr.cast'>[expr.cast]</a>) of a safely-derived pointer value;</p></li><li id='dynamic.safety-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.5'>(2.5)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of a safely-derived pointer value;</p></li><li id='dynamic.safety-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.6'>(2.6)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of an integer representation of a
safely-derived pointer value;</p></li><li id='dynamic.safety-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.7'>(2.7)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained a copy of a safely-derived
pointer value.
</p></li></ul></div><div class='para' id='dynamic.safety-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3157'>#</a></div><p ><span class='indexparent'><a class='index' id='integer_representation'></a></span><span class='indexparent'><a class='index' id='safely-derived_pointer,integer_representation'></a></span><span class='indexparent'><a class='index' id='pointer,_integer_representation_of_safely-derived'></a></span>An integer value is an <span class='grammarterm'>integer representation of a safely-derived pointer</span>
only if its type is at least as large as <span class='texttt'>std&#x200b;::&#x200b;intptr_&shy;t</span> and it is one of the
following:</p><ul class='itemize'><li id='dynamic.safety-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.1'>(3.1)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of a safely-derived pointer value;</p></li><li id='dynamic.safety-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.2'>(3.2)</a></div><p >the result of a valid conversion of an integer representation of a safely-derived
pointer value;</p></li><li id='dynamic.safety-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.3'>(3.3)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained an integer representation of a
safely-derived pointer value;</p></li><li id='dynamic.safety-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.4'>(3.4)</a></div><p >the result of an additive or bitwise operation, one of whose operands is an
integer representation of a safely-derived pointer value <span class='texttt'>P</span>, if that result
converted by <span class='texttt'>reinterpret_&shy;cast&lt;void*&gt;</span> would compare equal to a safely-derived
pointer computable from <span class='texttt'>reinterpret_&shy;cast&lt;void*&gt;(P)</span>.
</p></li></ul></div><div class='para' id='dynamic.safety-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3181'>#</a></div><p >An implementation may have <a class='hidden_link' href='#def:relaxed_pointer_safety' id='def:relaxed_pointer_safety'><i>relaxed pointer safety</i></a>, in which case the
validity of a pointer value does not depend on whether it is a safely-derived
pointer value. Alternatively, an implementation may have <a class='hidden_link' href='#def:strict_pointer_safety' id='def:strict_pointer_safety'><i>strict pointer
safety</i></a>, in which case a pointer value referring to an object with dynamic
storage duration that is not a safely-derived pointer
value is an invalid pointer value unless
the referenced complete object has previously been declared
reachable (<a href='util.dynamic.safety'>[util.dynamic.safety]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The effect of using an invalid pointer value (including passing it to a
deallocation function) is undefined, see <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.
This is true even if the unsafely-derived pointer value might compare equal to
some safely-derived pointer value. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] It is
<span class='indexparent'><a class='index' id='whether_an_implementation_has_relaxed_or_strict_pointer_safety'></a></span>implementation-defined whether an implementation has relaxed or strict pointer safety.<span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p></div><div class='footnote' id='footnote-40'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-40'>40)</a></div><p >This section does not impose restrictions
on indirection through pointers to memory not allocated by <span class='texttt'>&#x200b;::&#x200b;operator new</span>. This
maintains the ability of many C++ implementations to use binary libraries and
components written in other languages. In particular, this applies to C binaries,
because indirection through pointers to memory allocated by <span class='texttt'>std&#x200b;&#x200b;::&#x200b;&#x200b;malloc</span> is not restricted.</p></div></div></div><div id='inherit'><h3 ><a class='secnum' href='#inherit' style='min-width:103pt'>3.7.5</a> Duration of subobjects <a class='abbr_ref' href='basic.stc.inherit'>[basic.stc.inherit]</a></h3><div class='para' id='inherit-1'><div class='marginalizedparent'><a class='marginalized' href='#inherit-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c7f6a9139872aad48a944d018ce5e4b3de15ce81/source/basic.tex#L3201'>#</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,class_member'></a></span>The storage duration of subobjects and reference members
is that of their complete object (<a href='intro.object'>[intro.object]</a>).
<span class='indexparent'><a class='index' id='storage_duration'></a></span>
</p></div></div></div></div></body></html>