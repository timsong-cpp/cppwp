<!DOCTYPE html><html lang='en'><head><title>[over.match]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><div id='over.match'><h2 ><a class='secnum' style='min-width:88pt'>13.3</a> Overload resolution <a class='abbr_ref'>[over.match]</a></h2><p ><span class='indexparent'><a class='index' id='overloading,resolution'></a></span><span class='indexparent'><a class='index' id='resolution'></a></span><span class='indexparent'><a class='index' id='ambiguity,overloaded_function'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L393'>#</a></div><p >Overload resolution is a mechanism for selecting the best
function to call given a list of expressions that are to be the
arguments of the call and a set of
<a class='hidden_link' href='#def:candidate_functions' id='def:candidate_functions'><i>candidate functions</i></a>
that can
be called based on the context of the call.
The selection
criteria for the best function are the number of arguments, how
well the arguments match the parameter-type-list of the
candidate function,
how well (for non-static member functions) the object
matches the implicit object parameter,
and certain other properties of the candidate function.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The function selected by overload resolution is not
guaranteed to be appropriate for the context.
Other restrictions,
such as the accessibility of the function, can make its use in
the calling context ill-formed.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L415'>#</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,contexts'></a></span>Overload resolution selects the function to call in seven distinct
contexts within the language:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >invocation of a function named in the function call syntax (<a href='over.call.func'>[over.call.func]</a>);
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >invocation of a function call operator, a pointer-to-function
conversion function, a reference-to-pointer-to-function conversion
function, or a reference-to-function
conversion function on a class object named in the function
call syntax (<a href='over.call.object'>[over.call.object]</a>);
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >invocation of the operator referenced in an expression (<a href='over.match.oper'>[over.match.oper]</a>);
</p></li><li id='2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.4'>(2.4)</a></div><p >invocation of a constructor for default- or direct-initialization (<a href='dcl.init'>[dcl.init]</a>)
of a class object (<a href='over.match.ctor'>[over.match.ctor]</a>);
</p></li><li id='2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.5'>(2.5)</a></div><p >invocation of a user-defined conversion for
copy-initialization (<a href='dcl.init'>[dcl.init]</a>) of a class object (<a href='over.match.copy'>[over.match.copy]</a>);
</p></li><li id='2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.6'>(2.6)</a></div><p >invocation of a conversion function for initialization of an object of a
non-class type from an expression of class type (<a href='over.match.conv'>[over.match.conv]</a>); and
</p></li><li id='2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.7'>(2.7)</a></div><p >invocation of a conversion function for conversion to a glvalue
or class prvalue
to which a reference (<a href='dcl.init.ref'>[dcl.init.ref]</a>)
will be directly bound (<a href='over.match.ref'>[over.match.ref]</a>).
</p></li></ul><p >Each of these contexts defines the set of candidate functions and
the list of arguments in its own unique way.
But, once the
candidate functions and argument lists have been identified, the
selection of the best function is the same in all cases:</p><ul class='itemize'><li id='2.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.8'>(2.8)</a></div><p >First, a subset of the candidate functions (those that have
the proper number of arguments and meet certain other
conditions) is selected to form a set of
<span class='indexparent'><a class='index' id='function,viable'></a></span>viable functions (<a href='over.match.viable'>[over.match.viable]</a>).
</p></li><li id='2.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.9'>(2.9)</a></div><p >Then the best viable function is selected based on the
implicit conversion sequences (<a href='over.best.ics'>[over.best.ics]</a>) needed to
match each argument to the corresponding parameter of each
viable function.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L467'>#</a></div><p >If a best viable function exists and is unique, overload
resolution succeeds and produces it as the result.
Otherwise
overload resolution fails and the invocation is ill-formed.
When overload resolution succeeds,
and the best viable function is not accessible (Clause <a href='class.access'>[class.access]</a>) in the context
in which it is used,
the program is ill-formed.</p></div><div id='funcs'><h3 ><a class='secnum' href='#funcs' style='min-width:103pt'>13.3.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs'>[over.match.funcs]</a></h3><p ><span class='indexparent'><a class='index' id='overloading,candidate_functions'></a></span><span class='indexparent'><a class='index' id='overloading,argument_lists'></a></span></p><div class='para' id='funcs-1'><div class='marginalizedparent'><a class='marginalized' href='#funcs-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L481'>#</a></div><p >The subclauses of <a href='over.match.funcs'>[over.match.funcs]</a> describe
the set of candidate functions and the argument list submitted to
overload resolution in each of the seven contexts in which
overload resolution is used.
The source transformations and constructions defined
in these subclauses are only for the purpose of describing the
overload resolution process.
An implementation is not required
to use such transformations and constructions.</p></div><div class='para' id='funcs-2'><div class='marginalizedparent'><a class='marginalized' href='#funcs-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L492'>#</a></div><p ><span class='indexparent'><a class='index' id='member_function,overload_resolution_and'></a></span><span class='indexparent'><a class='index' id='function,overload_resolution_and'></a></span>The set of candidate functions can contain both member and non-member
functions to be resolved against the same argument list.
So that argument and parameter lists are comparable within this
heterogeneous set, a member function is considered to have an
extra parameter, called the
<a class='hidden_link' href='#def:implicit_object_parameter' id='def:implicit_object_parameter'><i>implicit object parameter</i></a>,
which represents the object for which the member function has been
called.
For the purposes of overload resolution, both static and
non-static member functions have an implicit object parameter,
but constructors do not.</p></div><div class='para' id='funcs-3'><div class='marginalizedparent'><a class='marginalized' href='#funcs-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L507'>#</a></div><p >Similarly, when appropriate, the context can construct an
argument list that contains an
<a class='hidden_link' href='#def:implied_object_argument' id='def:implied_object_argument'><i>implied object argument</i></a>
to denote
the object to be operated on.
Since arguments and parameters are
associated by position within their respective lists, the
convention is that the implicit object parameter, if present, is
always the first parameter and the implied object argument, if
present, is always the first argument.</p></div><div class='para' id='funcs-4'><div class='marginalizedparent'><a class='marginalized' href='#funcs-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L519'>#</a></div><p >For non-static member functions, the type of the implicit object
parameter is</p><ul class='itemize'><li id='funcs-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#funcs-4.1'>(4.1)</a></div><p >“lvalue reference to <i>cv</i> <span class='texttt'>X</span>” for functions declared
without a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> or with the
<span class='texttt'>&amp;</span> <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>
</p></li><li id='funcs-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#funcs-4.2'>(4.2)</a></div><p >“rvalue reference to <i>cv</i> <span class='texttt'>X</span>” for functions declared with the
<span class='texttt'>&amp;&amp;</span> <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>
</p></li></ul><p >where
<span class='texttt'>X</span>
is the class of which the function is a member and
<i>cv</i>
is the cv-qualification on the
member function declaration.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
for a
<span class='texttt'>const</span>
member
function of class
<span class='texttt'>X</span>,
the extra parameter is assumed to have type
“reference to
<span class='texttt'>const X</span>”.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
For conversion functions, the function is considered to be a member of the
class of the implied object argument for the purpose of defining the
type of the implicit object parameter.
For non-conversion functions
introduced by a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
into a derived class, the function is
considered to be a member of the derived class for the purpose of defining
the type of the implicit object parameter.
For static member functions, the implicit object parameter is considered
to match any object (since if the function is selected, the object is
discarded).
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
No actual type is established for the implicit object parameter
of a static member function, and no attempt will be made to determine a
conversion sequence for that parameter (<a href='over.match.best'>[over.match.best]</a>).
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='funcs-5'><div class='marginalizedparent'><a class='marginalized' href='#funcs-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L565'>#</a></div><p ><span class='indexparent'><a class='index' id='implied_object_argument,implicit_conversion_sequences'></a></span>During overload resolution, the implied object argument is
indistinguishable from other arguments.
The implicit object
parameter, however, retains its identity since
no user-defined conversions can be applied to achieve a type
match with it.
<span class='indexparent'><a class='index' id='implied_object_argument,non-static_member_function_and'></a></span>For non-static member functions declared without a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>,
an additional rule applies:</p><ul class='itemize'><li id='funcs-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#funcs-5.1'>(5.1)</a></div><p >even if the implicit object parameter is not
const-qualified,
an rvalue can be bound to the parameter
as long as in all other respects the argument can be
converted to the type of the implicit object parameter.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> The fact that such an argument is an rvalue does not
affect the ranking of implicit conversion sequences (<a href='over.ics.rank'>[over.ics.rank]</a>).
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></div><div class='para' id='funcs-6'><div class='marginalizedparent'><a class='marginalized' href='#funcs-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L589'>#</a></div><p >Because other than in list-initialization only one user-defined conversion
is allowed
in an
implicit conversion sequence, special rules apply when selecting
the best user-defined conversion (<a href='over.match.best'>[over.match.best]</a>,
<a href='over.best.ics'>[over.best.ics]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
class T {
public:
  T();
};

class C : T {
public:
  C(int);
};
T a = 1;            <span class='comment'>// ill-formed: <span class='texttt'>T(C(1))</span> not tried
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='funcs-7'><div class='marginalizedparent'><a class='marginalized' href='#funcs-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L612'>#</a></div><p >In each case where a candidate is a function template, candidate
function template specializations
are generated using template argument deduction (<a href='temp.over'>[temp.over]</a>,
<a href='temp.deduct'>[temp.deduct]</a>).
Those candidates are then handled as candidate
functions in the usual way.<a class='footnotenum' href='#footnote-124'>124</a>
A given name can refer to one or more function templates and also
to a set of overloaded non-template functions.
In such a case, the
candidate functions generated from each function template are combined
with the set of non-template candidate functions.</p></div><div class='para' id='funcs-8'><div class='marginalizedparent'><a class='marginalized' href='#funcs-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L636'>#</a></div><p >A defaulted move constructor or assignment operator (<a href='class.copy'>[class.copy]</a>) that is
defined as deleted is excluded from the set of candidate functions in all
contexts.</p></div><div class='footnote' id='footnote-124'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-124'>124)</a></div><p >The process of argument deduction fully
determines the parameter types of
the
function template specializations,
i.e., the parameters of
function template specializations
contain
no template parameter types.
Therefore, except where specified otherwise,
function template specializations
and non-template functions (<a href='dcl.fct'>[dcl.fct]</a>) are treated equivalently
for the remainder of overload resolution.</p></div><div id='call'><h4 ><a class='secnum' href='#call' style='min-width:118pt'>13.3.1.1</a> Function call syntax <a class='abbr_ref' href='over.match.call'>[over.match.call]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,function_call_syntax'></a></span></p><div class='para' id='call-1'><div class='marginalizedparent'><a class='marginalized' href='#call-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L644'>#</a></div><p >In a function call (<a href='expr.call'>[expr.call]</a>)</p><pre class='ncsimplebnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>)</span>
</pre><p >if the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> denotes a set of overloaded functions and/or
function templates, overload resolution is applied as specified in <a href='over.call.func'>[over.call.func]</a>.
If the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> denotes an object of class type, overload
resolution is applied as specified in <a href='over.call.object'>[over.call.object]</a>.</p></div><div class='para' id='call-2'><div class='marginalizedparent'><a class='marginalized' href='#call-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L656'>#</a></div><p >If the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> denotes the address of a set of overloaded
functions and/or function templates, overload resolution is applied using that set as
described above. If the function selected by overload resolution is a non-static member
function, the program is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> The resolution of the address of an
overload set in other contexts is described in <a href='over.over'>[over.over]</a>. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div id='over.call.func'><h4 ><a class='secnum' href='#over.call.func' style='min-width:133pt'>13.3.1.1.1</a> Call to named function <a class='abbr_ref' href='over.call.func'>[over.call.func]</a></h4><div class='para' id='over.call.func-1'><div class='marginalizedparent'><a class='marginalized' href='#over.call.func-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L665'>#</a></div><p >Of interest in <a href='over.call.func'>[over.call.func]</a> are only those function calls in
which the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
ultimately contains a name that
denotes one or more functions that might be called.
Such a
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>,
perhaps nested arbitrarily deep in
parentheses, has one of the following forms:</p><pre class='ncbnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>:
&#9;<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
&#9;<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
&#9;<i ><a href='expr.prim#nt:primary-expression'>primary-expression</a></i>
</pre><p >These represent two syntactic subcategories of function calls:
qualified function calls and unqualified function calls.</p></div><div class='para' id='over.call.func-2'><div class='marginalizedparent'><a class='marginalized' href='#over.call.func-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L686'>#</a></div><p >In qualified function calls, the name to be resolved is an
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
and is preceded by an
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
operator.
Since the
construct
<span class='texttt'>A-&gt;B</span>
is generally equivalent to
<span class='texttt'>(*A).B</span>,
the rest of
Clause <a href='over'>[over]</a> assumes, without loss of generality, that all member
function calls have been normalized to the form that uses an
object and the
<span class='texttt'>.</span>
operator.
Furthermore, Clause <a href='over'>[over]</a> assumes that
the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
that is the left operand of the
<span class='texttt'>.</span>
operator
has type “<i>cv</i> <span class='texttt'>T</span>”
where
<span class='texttt'>T</span>
denotes a class<a class='footnotenum' href='#footnote-125'>125</a>.
Under this
assumption, the
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
in the call is looked up as a
member function of
<span class='texttt'>T</span>
following the rules for looking up names in
classes (<a href='class.member.lookup'>[class.member.lookup]</a>).
The function declarations found by that lookup constitute the set of
candidate functions.
The argument list is the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call augmented by the addition of the left operand of
the
<span class='texttt'>.</span>
operator in the normalized member function call as the
implied object argument (<a href='over.match.funcs'>[over.match.funcs]</a>).</p></div><div class='para' id='over.call.func-3'><div class='marginalizedparent'><a class='marginalized' href='#over.call.func-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L736'>#</a></div><p >In unqualified function calls, the name is not qualified by an
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
operator and has the more general form of a
<i ><a href='expr.prim#nt:primary-expression'>primary-expression</a></i>.
The name is looked up in the context of the function
call following the normal rules for name lookup in function
calls (<a href='basic.lookup'>[basic.lookup]</a>).
The function declarations found by that lookup constitute the
set of candidate functions.
Because of the rules for name lookup, the set of candidate functions
consists (1) entirely of non-member functions or (2) entirely of
member functions of some class
<span class='texttt'>T</span>.
In case (1),
the argument list is
the same as the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call.
In case (2), the argument list is the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call augmented by the addition of an implied object
argument as in a qualified function call.
If the keyword
<span class='texttt'>this</span> (<a href='class.this'>[class.this]</a>) is in scope and refers to
class
<span class='texttt'>T</span>,
or a derived class of
<span class='texttt'>T</span>,
then the implied object argument is
<span class='texttt'>(*this)</span>.
If the keyword
<span class='texttt'>this</span>
is not in
scope or refers to another class, then
a contrived object of type
<span class='texttt'>T</span>
becomes the implied object
argument<a class='footnotenum' href='#footnote-126'>126</a>.
If the argument list is augmented by a contrived object and overload
resolution selects one of the non-static member functions of
<span class='texttt'>T</span>,
the call is ill-formed.</p></div><div class='footnote' id='footnote-125'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-125'>125)</a></div><p >Note that cv-qualifiers on the type of objects are
significant in overload
resolution for
both glvalue and class prvalue objects.</p></div><div class='footnote' id='footnote-126'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-126'>126)</a></div><p >An implied object argument must be contrived to
correspond to the implicit object
parameter attributed to member functions during overload resolution.
It is not
used in
the call to the selected function.
Since the member functions all have the
same implicit
object parameter, the contrived object will not be the cause to select or
reject a
function.</p></div></div><div id='over.call.object'><h4 ><a class='secnum' href='#over.call.object' style='min-width:133pt'>13.3.1.1.2</a> Call to object of class type <a class='abbr_ref' href='over.call.object'>[over.call.object]</a></h4><div class='para' id='over.call.object-1'><div class='marginalizedparent'><a class='marginalized' href='#over.call.object-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L794'>#</a></div><p >If the
<i ><a href='expr.prim#nt:primary-expression'>primary-expression</a></i>
<span class='texttt'>E</span>
in the function call syntax evaluates
to a class object of type “<i>cv</i> <span class='texttt'>T</span>”,
then the set of candidate
functions includes at least the function call operators of
<span class='texttt'>T</span>.
The
function call operators of
<span class='texttt'>T</span>
are obtained by ordinary lookup of
the name
<span class='texttt'>operator()</span>
in the context of
<span class='texttt'>(E).operator()</span>.</p></div><div class='para' id='over.call.object-2'><div class='marginalizedparent'><a class='marginalized' href='#over.call.object-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L812'>#</a></div><p >In addition, for each non-explicit conversion function declared in <span class='texttt'>T</span> of the
form</p><pre class='ncsimplebnf'><span class='terminal'>operator</span> <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> <span class='terminal'>(<span style='white-space:nowrap'>&thinsp;</span>)</span> <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>;</span>
</pre><p >where
<i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i>
is the same cv-qualification as, or a greater cv-qualification than,
<i>cv</i>,
and where
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
denotes the type “pointer to function
of (<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-texatom"><span id="MJXc-Node-5" class="mjx-mrow"><span id="MJXc-Node-6" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-7" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span><span id="MJXc-Node-8" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-9" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.372em;">…</span></span><span id="MJXc-Node-10" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-11" class="mjx-msubsup MJXc-space1"><span class="mjx-base"><span id="MJXc-Node-12" class="mjx-texatom"><span id="MJXc-Node-13" class="mjx-mrow"><span id="MJXc-Node-14" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-15" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span>) returning <span class='texttt'>R</span>”,
or the type “reference to pointer to function
of (<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-texatom"><span id="MJXc-Node-5" class="mjx-mrow"><span id="MJXc-Node-6" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-7" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span><span id="MJXc-Node-8" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-9" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.372em;">…</span></span><span id="MJXc-Node-10" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-11" class="mjx-msubsup MJXc-space1"><span class="mjx-base"><span id="MJXc-Node-12" class="mjx-texatom"><span id="MJXc-Node-13" class="mjx-mrow"><span id="MJXc-Node-14" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-15" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span>) returning <span class='texttt'>R</span>”,
or the type
“reference to function of (<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-texatom"><span id="MJXc-Node-5" class="mjx-mrow"><span id="MJXc-Node-6" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-7" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span><span id="MJXc-Node-8" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-9" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.372em;">…</span></span><span id="MJXc-Node-10" class="mjx-mo MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.144em; padding-bottom: 0.519em;">,</span></span><span id="MJXc-Node-11" class="mjx-msubsup MJXc-space1"><span class="mjx-base"><span id="MJXc-Node-12" class="mjx-texatom"><span id="MJXc-Node-13" class="mjx-mrow"><span id="MJXc-Node-14" class="mjx-mtext"><span class="mjx-char MJXc-TeX-type-R" style="padding-top: 0.372em; padding-bottom: 0.225em;">P</span></span></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-15" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span>)
returning <span class='texttt'>R</span>”, a <a class='hidden_link' href='#def:surrogate_call_function' id='def:surrogate_call_function'><i>surrogate call function</i></a> with the unique name
<span class='grammarterm'>call-function</span>
and having the form</p><pre class='ncbnf'><span class='terminal'>R</span> call-function <span class='terminal'>(</span> <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> &nbsp;<span class='terminal'>F, P<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span></span></span></span> a<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span></span></span></span>, <span class='math'>&hellip;</span>, P<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span> a<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span>)</span> <span class='terminal'>{ return F (a<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span></span></span></span>, <span class='math'>&hellip;</span>, a<span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-mi" style=""><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span></span></span></span></span>); }</span>
</pre><p >is also considered as a candidate function.
Similarly, surrogate
call functions are added to the set of candidate functions for
each non-explicit conversion function declared in a base class of
<span class='texttt'>T</span>
provided the function is not hidden within
<span class='texttt'>T</span>
by another
intervening declaration<a class='footnotenum' href='#footnote-127'>127</a>.</p></div><div class='para' id='over.call.object-3'><div class='marginalizedparent'><a class='marginalized' href='#over.call.object-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L859'>#</a></div><p >If such a surrogate call function is selected by overload
resolution, the corresponding conversion function will be called to convert
<span class='texttt'>E</span>
to the appropriate function pointer or reference, and the function
will then be invoked with the arguments of the call. If the
conversion function cannot be called (e.g., because of an ambiguity),
the program is ill-formed.</p></div><div class='para' id='over.call.object-4'><div class='marginalizedparent'><a class='marginalized' href='#over.call.object-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L868'>#</a></div><p >The argument list submitted to overload resolution consists of
the argument expressions present in the function call syntax
preceded by the implied object argument
<span class='texttt'>(E)</span>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
When comparing the
call against the function call operators, the implied object
argument is compared against the implicit object parameter of the
function call operator.
When comparing the call against a
surrogate call function, the implied object argument is compared
against the first parameter of the surrogate call function.
The
conversion function from which the surrogate call function was
derived will be used in the conversion sequence for that
parameter since it converts the implied object argument to the
appropriate function pointer or reference required by that first
parameter.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
  operator fp1() { return f1; }
  operator fp2() { return f2; }
} a;
int i = a(1);                   <span class='comment'>// calls <span class='texttt'>f1</span> via pointer returned from conversion function
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]<span class='indexparent'><a class='index' id='overloading,resolution,function_call_syntax'></a></span></p></div><div class='footnote' id='footnote-127'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-127'>127)</a></div><p >Note that this construction can yield
candidate call functions that cannot be
differentiated one from the other by overload resolution because they have
identical
declarations or differ only in their return type.
The call will be ambiguous
if overload
resolution cannot select a match to the call that is uniquely better than such
undifferentiable functions.</p></div></div></div><div id='oper'><h4 ><a class='secnum' href='#oper' style='min-width:118pt'>13.3.1.2</a> Operators in expressions <a class='abbr_ref' href='over.match.oper'>[over.match.oper]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,operators'></a></span></p><div class='para' id='oper-1'><div class='marginalizedparent'><a class='marginalized' href='#oper-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L907'>#</a></div><p >If no operand of an operator in an expression has a type that is a class
or an enumeration, the operator is assumed to be a built-in operator
and interpreted according to Clause <a href='expr'>[expr]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Because
<span class='texttt'>.</span>,
<span class='texttt'>.*</span>,
and
<span class='texttt'>::</span>
cannot be overloaded,
these operators are always built-in operators interpreted according to
Clause <a href='expr'>[expr]</a>.
<span class='texttt'>?:</span>
cannot be overloaded, but the rules in this subclause are used to determine
the conversions to be applied to the second and third operands when they
have class or enumeration type (<a href='expr.cond'>[expr.cond]</a>).
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
struct String {
  String (const String&amp;);
  String (const char*);
  operator const char* ();
};
String operator + (const String&amp;, const String&amp;);

void f() {
 const char* p= "one" + "two";  <span class='comment'>// ill-formed because neither operand has class or enumeration type
</span> int I = 1 + 1;                 <span class='comment'>// always evaluates to <span class='texttt'>2</span> even if class or enumeration types exist
</span>                                <span class='comment'>// that would perform the operation.
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='oper-2'><div class='marginalizedparent'><a class='marginalized' href='#oper-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L943'>#</a></div><p >If either operand has a type that is a class or an enumeration, a
user-defined operator function might be declared that implements
this operator or a user-defined conversion can be necessary to
convert the operand to a type that is appropriate for a built-in
operator.
In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the
operator.
Therefore, the operator notation is first transformed
to the equivalent function-call notation as summarized in
Table <a href='#tab:over.rel.op.func'>[tab:over.rel.op.func]</a>
(where <span class='texttt'>@</span> denotes one of the operators covered in the specified subclause).
However, the operands are sequenced in the order prescribed
for the built-in operator (Clause <a href='expr'>[expr]</a>).</p><div class='numberedTable' id='tab:over.rel.op.func'>Table <a href='#tab:over.rel.op.func'>12</a> — Relationship between operator and function call notation<br><table ><tr class='rowsep'><td class='left'>



<b>Subclause</b> </td><td class='border left'>   <b>Expression</b> </td><td class='border left'>   <b>As member function</b> </td><td class='border left'>   <b>As non-member function</b> </td></tr><tr class='capsep'><td class='left'> 
<a href='over.unary'>[over.unary]</a>    </td><td class='border left'>   <span class='texttt'>@a</span>   </td><td class='border left'>   <span class='texttt'>(a).operator@ (<span style='white-space:nowrap'>&thinsp;</span>)</span>  </td><td class='border left'>   <span class='texttt'>operator@(a)</span>    </td></tr><tr ><td class='left'>
<a href='over.binary'>[over.binary]</a>   </td><td class='border left'>   <span class='texttt'>a@b</span>  </td><td class='border left'>   <span class='texttt'>(a).operator@ (b)</span>   </td><td class='border left'>   <span class='texttt'>operator@(a, b)</span> </td></tr><tr ><td class='left'>
<a href='over.ass'>[over.ass]</a>      </td><td class='border left'>   <span class='texttt'>a=b</span>  </td><td class='border left'>   <span class='texttt'>(a).operator= (b)</span>   </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.sub'>[over.sub]</a>      </td><td class='border left'>   <span class='texttt'>a[b]</span> </td><td class='border left'>   <span class='texttt'>(a).operator[](b)</span>   </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.ref'>[over.ref]</a>      </td><td class='border left'>   <span class='texttt'>a-&gt;</span>  </td><td class='border left'>   <span class='texttt'>(a).operator-&gt;(<span style='white-space:nowrap'>&thinsp;</span>)</span>  </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.inc'>[over.inc]</a>      </td><td class='border left'>   <span class='texttt'>a@</span>   </td><td class='border left'>   <span class='texttt'>(a).operator@ (0)</span>   </td><td class='border left'>   <span class='texttt'>operator@(a, 0)</span> </td></tr></table></div></div><div class='para' id='oper-3'><div class='marginalizedparent'><a class='marginalized' href='#oper-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L971'>#</a></div><p >For a unary operator
<span class='texttt'>@</span>
with an operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>,
and for a binary operator
<span class='texttt'>@</span>
with a left operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>
and a right operand of a type whose cv-unqualified version is
<span class='texttt'>T2</span>,
three sets of candidate functions, designated
<a class='hidden_link' href='#def:member_candidates' id='def:member_candidates'><i>member candidates</i></a>,
<a class='hidden_link' href='#def:non-member_candidates' id='def:non-member_candidates'><i>non-member candidates</i></a>
and
<a class='hidden_link' href='#def:built-in_candidates' id='def:built-in_candidates'><i>built-in candidates</i></a>,
are constructed as follows:
</p><ul class='itemize'><li id='oper-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#oper-3.1'>(3.1)</a></div><p >If
<span class='texttt'>T1</span>
is a complete class type or a class currently being defined, the set of member candidates is the
result of the qualified lookup of
<span class='texttt'>T1::operator@</span> (<a href='over.call.func'>[over.call.func]</a>); otherwise, the set of member
candidates is empty.
</p></li><li id='oper-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#oper-3.2'>(3.2)</a></div><p >The set of non-member candidates is the result of the unqualified lookup of
<span class='texttt'>operator@</span>
in the context of
the expression according to the usual rules for name
lookup in unqualified function calls (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except
that all member functions are ignored.
However, if no operand has a class type, only those non-member
functions in the lookup set that have a first parameter of type
<span class='texttt'>T1</span>
or “reference to <i>cv</i> <span class='texttt'>T1</span>”,
when
<span class='texttt'>T1</span>
is an enumeration type,
or (if there is a right operand) a second parameter of type
<span class='texttt'>T2</span>
or “reference to <i>cv</i> <span class='texttt'>T2</span>”,
when
<span class='texttt'>T2</span>
is an enumeration type,
are candidate functions.
</p></li><li id='oper-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#oper-3.3'>(3.3)</a></div><p >For the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
the built-in candidates set is empty.
For all other operators, the built-in candidates include all
of the candidate operator functions defined in <a href='over.built'>[over.built]</a> that,
compared to the given operator,</p><ul class='itemize'><li id='oper-3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#oper-3.3.1'>(3.3.1)</a></div><p >have the same operator name, and
</p></li><li id='oper-3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#oper-3.3.2'>(3.3.2)</a></div><p >accept the same number of operands, and
</p></li><li id='oper-3.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#oper-3.3.3'>(3.3.3)</a></div><p >accept operand types to which the given operand or
operands can be converted according to <a href='over.best.ics'>[over.best.ics]</a>, and
</p></li><li id='oper-3.3.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#oper-3.3.4'>(3.3.4)</a></div><p >do not have the same parameter-type-list as any non-member candidate
that is not a function template specialization.
</p></li></ul></li></ul></div><div class='para' id='oper-4'><div class='marginalizedparent'><a class='marginalized' href='#oper-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1043'>#</a></div><p >For the built-in assignment operators, conversions of the left
operand are restricted as follows:</p><ul class='itemize'><li id='oper-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#oper-4.1'>(4.1)</a></div><p >no temporaries are introduced to hold the left operand, and
</p></li><li id='oper-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#oper-4.2'>(4.2)</a></div><p >no user-defined conversions are applied to the left operand to achieve
a type match with the left-most parameter of a built-in candidate.
</p></li></ul></div><div class='para' id='oper-5'><div class='marginalizedparent'><a class='marginalized' href='#oper-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1055'>#</a></div><p >For all other operators, no such restrictions apply.</p></div><div class='para' id='oper-6'><div class='marginalizedparent'><a class='marginalized' href='#oper-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1058'>#</a></div><p >The set of candidate functions for overload resolution is the
union of the member candidates, the non-member candidates, and
the built-in candidates.
The argument list contains all of the
operands of the operator.
The best function from the set of candidate functions is selected
according to <a href='over.match.viable'>[over.match.viable]</a>
and <a href='over.match.best'>[over.match.best]</a>.<a class='footnotenum' href='#footnote-128'>128</a>
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
struct A {
  operator int();
};
A operator+(const A&amp;, const A&amp;);
void m() {
  A a, b;
  a + b;                        <span class='comment'>// <span class='texttt'>operator+(a, b)</span> chosen over <span class='texttt'>int(a) + int(b)</span>
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='oper-7'><div class='marginalizedparent'><a class='marginalized' href='#oper-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1083'>#</a></div><p >If a built-in candidate is selected by overload resolution, the
operands of class type are converted to the types of the corresponding parameters
of the selected operation function, except that the second standard conversion
sequence of a user-defined conversion sequence (<a href='over.ics.user'>[over.ics.user]</a>) is not applied.
Then the operator is treated as the corresponding
built-in operator and interpreted according to Clause <a href='expr'>[expr]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0;           <span class='comment'>// error: pointer arithmetic requires integral operand
</span>int *b = Y() + X();             <span class='comment'>// error: pointer arithmetic requires integral operand
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='oper-8'><div class='marginalizedparent'><a class='marginalized' href='#oper-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1105'>#</a></div><p >The second operand of operator
<span class='texttt'>-&gt;</span>
is ignored in selecting an
<span class='texttt'>operator-&gt;</span>
function, and is not an argument when the
<span class='texttt'>operator-&gt;</span>
function is called.
When
<span class='texttt'>operator-&gt;</span>
returns, the operator
<span class='texttt'>-&gt;</span>
is applied to the value returned, with the original second
operand.<a class='footnotenum' href='#footnote-129'>129</a></p></div><div class='para' id='oper-9'><div class='marginalizedparent'><a class='marginalized' href='#oper-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1127'>#</a></div><p >If the operator is the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
and there are no viable functions, then the operator is
assumed to be the built-in operator and interpreted according to
Clause <a href='expr'>[expr]</a>.</p></div><div class='para' id='oper-10'><div class='marginalizedparent'><a class='marginalized' href='#oper-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1138'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The lookup rules for operators in expressions are different than
the lookup
rules for operator function names in a function call, as shown in the following
example:</p><pre class='codeblock'>
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);              <span class='comment'>// error: global operator hidden by member
</span>  a + a;                        <span class='comment'>// OK: calls global <span class='texttt'>operator+</span>
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-128'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-128'>128)</a></div><p >If the set of candidate functions is empty,
overload resolution is unsuccessful.</p></div><div class='footnote' id='footnote-129'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-129'>129)</a></div><p >If the value returned by the
<span class='texttt'>operator-&gt;</span>
function has class type, this may result in selecting and calling another
<span class='texttt'>operator-&gt;</span>
function.
The process repeats until an
<span class='texttt'>operator-&gt;</span>
function returns a value of non-class type.</p></div></div><div id='ctor'><h4 ><a class='secnum' href='#ctor' style='min-width:118pt'>13.3.1.3</a> Initialization by constructor <a class='abbr_ref' href='over.match.ctor'>[over.match.ctor]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,initialization'></a></span></p><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1166'>#</a></div><p >When objects of class type are direct-initialized (<a href='dcl.init'>[dcl.init]</a>),
copy-initialized from an expression of the same or a
derived class type (<a href='dcl.init'>[dcl.init]</a>),
or default-initialized (<a href='dcl.init'>[dcl.init]</a>),
overload resolution selects the constructor.
For direct-initialization or default-initialization
that is not in the context of copy-initialization, the
candidate functions are
all the constructors of the class of the object being
initialized.
For copy-initialization, the candidate functions are all
the converting constructors (<a href='class.conv.ctor'>[class.conv.ctor]</a>) of that
class.
The argument list is the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i> or <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
of the <i ><a href='dcl.init#nt:initializer'>initializer</a></i>.</p></div></div><div id='copy'><h4 ><a class='secnum' href='#copy' style='min-width:118pt'>13.3.1.4</a> Copy-initialization of class by user-defined conversion <a class='abbr_ref' href='over.match.copy'>[over.match.copy]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,initialization'></a></span></p><div class='para' id='copy-1'><div class='marginalizedparent'><a class='marginalized' href='#copy-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1187'>#</a></div><p >Under the conditions specified in <a href='dcl.init'>[dcl.init]</a>, as
part of a copy-initialization of an object of class type, a user-defined
conversion can be invoked to convert an initializer expression to the
type of the object being initialized.
Overload resolution is used
to select the user-defined conversion to be invoked.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> The conversion performed for indirect binding to a reference to a possibly
cv-qualified class type is determined in terms of a corresponding non-reference
copy-initialization. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
Assuming that
“<i>cv1</i> <span class='texttt'>T</span>” is the type of the object being initialized, with
<span class='texttt'>T</span>
a class type,
the candidate functions are selected as follows:</p><ul class='itemize'><li id='copy-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copy-1.1'>(1.1)</a></div><p >The converting constructors (<a href='class.conv.ctor'>[class.conv.ctor]</a>) of
<span class='texttt'>T</span>
are candidate functions.
</p></li><li id='copy-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copy-1.2'>(1.2)</a></div><p >When the type of the initializer expression is a class type
“<i>cv</i> <span class='texttt'>S</span>”,
the non-explicit conversion functions of
<span class='texttt'>S</span>
and its base classes are considered.
When initializing a temporary to be bound to the first parameter of a
constructor
where the parameter is of type
“reference to possibly <i>cv</i>-qualified <span class='texttt'>T</span>”
and the constructor is
called with a single argument in the context of
direct-initialization of an object of type “<i>cv2</i> <span class='texttt'>T</span>”, explicit
conversion functions are also considered.
Those that are not hidden within
<span class='texttt'>S</span>
and yield a type whose cv-unqualified version is the same type as
<span class='texttt'>T</span>
or is a derived class thereof
are candidate functions.
Conversion functions that return “reference to
<span class='texttt'>X</span>”
return
lvalues or xvalues, depending on the type of reference, of type
<span class='texttt'>X</span>
and are therefore considered to yield
<span class='texttt'>X</span>
for this
process of selecting candidate functions.
</p></li></ul></div><div class='para' id='copy-2'><div class='marginalizedparent'><a class='marginalized' href='#copy-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1239'>#</a></div><p >In both cases, the argument list has one argument, which is the initializer
expression.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This argument will be compared against
the first parameter of the constructors and against the implicit
object parameter of the conversion functions.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='conv'><h4 ><a class='secnum' href='#conv' style='min-width:118pt'>13.3.1.5</a> Initialization by conversion function <a class='abbr_ref' href='over.match.conv'>[over.match.conv]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,initialization'></a></span></p><div class='para' id='conv-1'><div class='marginalizedparent'><a class='marginalized' href='#conv-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1251'>#</a></div><p >Under the conditions specified in <a href='dcl.init'>[dcl.init]</a>, as
part of an initialization of an object of non-class type,
a conversion function can be invoked to convert an initializer
expression of class type to the type of the object
being initialized.
Overload resolution is used to select the
conversion function to be invoked.
Assuming that “<i>cv1</i> <span class='texttt'>T</span>” is the
type of the object being initialized, and “<i>cv</i> <span class='texttt'>S</span>” is the type
of the initializer expression, with
<span class='texttt'>S</span>
a class type,
the candidate functions are selected as follows:</p><ul class='itemize'><li id='conv-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#conv-1.1'>(1.1)</a></div><p >The conversion functions of
<span class='texttt'>S</span>
and its base classes are considered.
Those non-explicit conversion functions that are not hidden
within
<span class='texttt'>S</span>
and yield type
<span class='texttt'>T</span>
or a type that can be converted to type
<span class='texttt'>T</span>
via a standard conversion sequence (<a href='over.ics.scs'>[over.ics.scs]</a>)
are candidate functions.
For direct-initialization, those explicit conversion functions that are not
hidden within <span class='texttt'>S</span> and yield type <span class='texttt'>T</span> or a type that can be converted
to type <span class='texttt'>T</span> with a qualification conversion (<a href='conv.qual'>[conv.qual]</a>) are also
candidate functions.
Conversion functions that return a cv-qualified type
are considered to yield the cv-unqualified version of that type
for this process of selecting candidate functions.
Conversion functions that return “reference to
<i>cv2</i>
<span class='texttt'>X</span>”
return
lvalues or xvalues, depending on the type of reference, of type
“<i>cv2</i>
<span class='texttt'>X</span>”
and are therefore considered to yield
<span class='texttt'>X</span>
for this
process of selecting candidate functions.
</p></li></ul></div><div class='para' id='conv-2'><div class='marginalizedparent'><a class='marginalized' href='#conv-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1300'>#</a></div><p >The argument list has one argument, which is the initializer expression.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This argument will be compared against
the implicit object parameter of the conversion functions.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='ref'><h4 ><a class='secnum' href='#ref' style='min-width:118pt'>13.3.1.6</a> Initialization by conversion function for direct reference binding <a class='abbr_ref' href='over.match.ref'>[over.match.ref]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,initialization'></a></span></p><div class='para' id='ref-1'><div class='marginalizedparent'><a class='marginalized' href='#ref-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1310'>#</a></div><p >Under the conditions specified in <a href='dcl.init.ref'>[dcl.init.ref]</a>, a reference can be bound directly
to a glvalue or class prvalue that is the result of applying a conversion
function to an initializer expression.
Overload resolution is used to select the
conversion function to be invoked.
Assuming that “reference to <i>cv1</i> <span class='texttt'>T</span>” is the
type of the reference being initialized, and
“<i>cv</i> <span class='texttt'>S</span>” is the type
of the initializer expression, with
<span class='texttt'>S</span>
a class type,
the candidate functions are selected as follows:
</p><ul class='itemize'><li id='ref-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ref-1.1'>(1.1)</a></div><p >The conversion functions of
<span class='texttt'>S</span>
and its base classes are considered.
Those non-explicit conversion functions that are not hidden within
<span class='texttt'>S</span>
and yield type “lvalue reference to <i>cv2</i> <span class='texttt'>T2</span>”
(when initializing an lvalue reference or an rvalue reference to function) or
“<i>cv2</i> <span class='texttt'>T2</span>”
or “rvalue reference to <i>cv2</i> <span class='texttt'>T2</span>” (when initializing an
rvalue reference or an lvalue reference to function),
where “<i>cv1</i> <span class='texttt'>T</span>” is reference-compatible (<a href='dcl.init.ref'>[dcl.init.ref]</a>)
with “<i>cv2</i> <span class='texttt'>T2</span>”,
are candidate functions. For direct-initialization, those explicit
conversion functions that are not hidden within <span class='texttt'>S</span> and yield
type “lvalue reference to <i>cv2</i> <span class='texttt'>T2</span>” or “<i>cv2</i>
<span class='texttt'>T2</span>” or “rvalue reference to <i>cv2</i> <span class='texttt'>T2</span>”,
respectively, where <span class='texttt'>T2</span> is the same type as <span class='texttt'>T</span> or can be
converted to type <span class='texttt'>T</span> with a qualification
conversion (<a href='conv.qual'>[conv.qual]</a>), are also candidate functions.</p></li></ul></div><div class='para' id='ref-2'><div class='marginalizedparent'><a class='marginalized' href='#ref-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1347'>#</a></div><p >The argument list has one argument, which is the initializer expression.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This argument will be compared against
the implicit object parameter of the conversion functions.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='list'><h4 ><a class='secnum' href='#list' style='min-width:118pt'>13.3.1.7</a> Initialization by list-initialization <a class='abbr_ref' href='over.match.list'>[over.match.list]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,initialization'></a></span></p><div class='para' id='list-1'><div class='marginalizedparent'><a class='marginalized' href='#list-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1357'>#</a></div><p >When objects of non-aggregate class type <span class='texttt'>T</span> are
list-initialized such that <a href='dcl.init.list'>[dcl.init.list]</a> specifies that overload resolution
is performed according to the rules in this section, overload resolution selects the
constructor in two phases:</p><ul class='itemize'><li id='list-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#list-1.1'>(1.1)</a></div><p >Initially, the candidate functions are the initializer-list constructors (<a href='dcl.init.list'>[dcl.init.list]</a>)
of the class <span class='texttt'>T</span> and
the argument list consists of the initializer list as a single argument.</p></li><li id='list-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#list-1.2'>(1.2)</a></div><p >If no viable initializer-list constructor is found, overload resolution is
performed again, where the candidate functions are all the constructors of
the class <span class='texttt'>T</span> and
the argument list consists of the elements of the initializer list.
</p></li></ul><p >If the initializer list has no elements and <span class='texttt'>T</span> has a default constructor,
the first phase is omitted.
In copy-list-initialization, if an <span class='texttt'>explicit</span> constructor is
chosen, the initialization is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This differs from other situations (<a href='over.match.ctor'>[over.match.ctor]</a>, <a href='over.match.copy'>[over.match.copy]</a>),
where only converting constructors are considered for copy-initialization.
This restriction only
applies if this initialization is part of the final result of overload
resolution. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='class.deduct'><h4 ><a class='secnum' href='#class.deduct' style='min-width:118pt'>13.3.1.8</a> Class template argument deduction <a class='abbr_ref' href='over.match.class.deduct'>[over.match.class.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>
</p><div class='para' id='class.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#class.deduct-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1389'>#</a></div><p >A set of functions and function templates is formed comprising:</p><ul class='itemize'><li id='class.deduct-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.deduct-1.1'>(1.1)</a></div><p >For each constructor
of the class template
designated by the <i ><a href='temp.names#nt:template-name'>template-name</a></i>,
a function template with the following properties:
</p><ul class='itemize'><li id='class.deduct-1.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.deduct-1.1.1'>(1.1.1)</a></div><p >The template parameters are the template parameters of the class template
followed
by the template parameters (including default template arguments) of the constructor,
if any.
</p></li><li id='class.deduct-1.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.deduct-1.1.2'>(1.1.2)</a></div><p >The types of the function parameters are those of the constructor.
</p></li><li id='class.deduct-1.1.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.deduct-1.1.3'>(1.1.3)</a></div><p >The return type is the class template specialization
designated by the <i ><a href='temp.names#nt:template-name'>template-name</a></i>
and template arguments
corresponding to the template parameters
obtained from the class template.
</p></li></ul></li><li id='class.deduct-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.deduct-1.2'>(1.2)</a></div><p >For each <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>,
a function or function template
with the following properties:</p><ul class='itemize'><li id='class.deduct-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.deduct-1.2.1'>(1.2.1)</a></div><p >The template parameters, if any,
and function parameters
are those of the <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>.
</p></li><li id='class.deduct-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#class.deduct-1.2.2'>(1.2.2)</a></div><p >The return type
is the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
of the <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>.
</p></li></ul></li></ul></div><div class='para' id='class.deduct-2'><div class='marginalizedparent'><a class='marginalized' href='#class.deduct-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1431'>#</a></div><p >Initialization and overload resolution are performed as described
in <a href='dcl.init'>[dcl.init]</a> and <a href='over.match.ctor'>[over.match.ctor]</a>, <a href='over.match.copy'>[over.match.copy]</a>,
or <a href='over.match.list'>[over.match.list]</a> (as appropriate for the type of initialization
performed) for an object of a hypothetical class type, where
the selected functions and function templates are considered to be the
constructors of that class type for the purpose of forming an overload
set, and the initializer is provided by the context in which class
template argument deduction was performed. Each such notional constructor
is considered to be explicit if the function or function template was
generated from a constructor or <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i> that was
declared <span class='texttt'>explicit</span>.</p></div><div class='para' id='class.deduct-3'><div class='marginalizedparent'><a class='marginalized' href='#class.deduct-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1444'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  explicit A(const T&amp;, ...) noexcept;  <span class='comment'>// #1
</span>  A(T&amp;&amp;, ...);                         <span class='comment'>// #2
</span>};

int i;
A a1 = { i, i };    <span class='comment'>// error: explicit constructor #1 selected in copy-list-initialization during deduction,
</span>                    <span class='comment'>// cannot deduce from non-forwarding rvalue reference in #2
</span>
A a2{i, i};         <span class='comment'>// OK, #1 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>A a3{0, i};         <span class='comment'>// OK, #2 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>A a4 = {0, i};      <span class='comment'>// OK, #2 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>
template &lt;class T&gt; A(const T&amp;, const T&amp;) -&gt; A&lt;T&amp;&gt;;  <span class='comment'>// #3
</span>template &lt;class T&gt; explicit A(T&amp;&amp;, T&amp;&amp;) -&gt; A&lt;T&gt;;    <span class='comment'>// #4
</span>
A a5 = {0, 1};      <span class='comment'>// error: explicit deduction guide #4 selected in copy-list-initialization during deduction
</span>A a6{0,1};          <span class='comment'>// OK, #4 deduces to <span class='texttt'>A&lt;int&gt;</span> and #2 initializes
</span>A a7 = {0, i};      <span class='comment'>// error: #3 deduces to <span class='texttt'>A&lt;int&amp;&gt;</span>, #1 and #2 declare same constructor
</span>A a8{0,i};          <span class='comment'>// error: #3 deduces to <span class='texttt'>A&lt;int&amp;&gt;</span>, #1 and #2 declare same constructor
</span>
template &lt;class T&gt; struct B {
  template &lt;class U&gt; using TA = T;
  template &lt;class U&gt; B(U, TA&lt;U&gt;);
};

B b{(int*)0, (char*)0};         <span class='comment'>// OK, deduces <span class='texttt'>B&lt;char*&gt;</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]<span class='indexparent'><a class='index' id='overloading,argument_lists'></a></span><span class='indexparent'><a class='index' id='overloading,candidate_functions'></a></span></p></div></div></div><div id='viable'><h3 ><a class='secnum' href='#viable' style='min-width:103pt'>13.3.2</a> Viable functions <a class='abbr_ref' href='over.match.viable'>[over.match.viable]</a></h3><p ><span class='indexparent'><a class='index' id='overloading,resolution,viable_functions'></a></span></p><div class='para' id='viable-1'><div class='marginalizedparent'><a class='marginalized' href='#viable-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1482'>#</a></div><p >From the set of candidate functions constructed for a given
context (<a href='over.match.funcs'>[over.match.funcs]</a>), a set of viable functions is
chosen, from which the best function will be selected by
comparing argument conversion sequences for the best fit (<a href='over.match.best'>[over.match.best]</a>).
The selection of viable functions considers
relationships between arguments and function parameters other
than the ranking of conversion sequences.</p></div><div class='para' id='viable-2'><div class='marginalizedparent'><a class='marginalized' href='#viable-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1491'>#</a></div><p ><span class='indexparent'><a class='index' id='ellipsis,overload_resolution_and'></a></span><span class='indexparent'><a class='index' id='default_argument,overload_resolution_and'></a></span>First, to be a viable function, a candidate function shall have
enough parameters to agree in number with the arguments in the
list.</p><ul class='itemize'><li id='viable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#viable-2.1'>(2.1)</a></div><p >If there are
<i>m</i>
arguments in the list, all candidate
functions having exactly
<i>m</i>
parameters are viable.
</p></li><li id='viable-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#viable-2.2'>(2.2)</a></div><p >A candidate function having fewer than
<i>m</i>
parameters is
viable only if it has an ellipsis in its parameter list (<a href='dcl.fct'>[dcl.fct]</a>).
For the purposes of overload resolution,
any argument for which there is no corresponding parameter is
considered to “match the ellipsis” (<a href='over.ics.ellipsis'>[over.ics.ellipsis]</a>) .
</p></li><li id='viable-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#viable-2.3'>(2.3)</a></div><p >A candidate function having more than
<i>m</i>
parameters is viable
only if the
<i>(m+1)</i>-st
parameter has a default
argument (<a href='dcl.fct.default'>[dcl.fct.default]</a>).<a class='footnotenum' href='#footnote-130'>130</a>
For the purposes of overload
resolution, the parameter list is truncated on the right, so
that there are exactly
<i>m</i>
parameters.
</p></li></ul></div><div class='para' id='viable-3'><div class='marginalizedparent'><a class='marginalized' href='#viable-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1532'>#</a></div><p >Second, for
<span class='texttt'>F</span>
to be a viable function, there shall exist for each
argument an
<a class='hidden_link' href='#def:implicit_conversion_sequence' id='def:implicit_conversion_sequence'><i>implicit conversion sequence</i></a> (<a href='over.best.ics'>[over.best.ics]</a>) that
converts that argument to the corresponding parameter of
<span class='texttt'>F</span>.
If the parameter has reference type, the implicit conversion sequence
includes the operation of binding the reference, and the fact that
an lvalue reference to non-<span class='texttt'>const</span> cannot be bound to an rvalue
and that an rvalue reference cannot be bound to an lvalue
can affect
the viability of the function (see <a href='over.ics.ref'>[over.ics.ref]</a>).</p></div><div class='footnote' id='footnote-130'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-130'>130)</a></div><p >According to <a href='dcl.fct.default'>[dcl.fct.default]</a>,
parameters following the
<i>(m+1)</i>-st
parameter must also have default arguments.</p></div></div><div id='best'><h3 ><a class='secnum' href='#best' style='min-width:103pt'>13.3.3</a> Best viable function <a class='abbr_ref' href='over.match.best'>[over.match.best]</a></h3><p ><span class='indexparent'><a class='index' id='overloading,resolution,best_viable_function'></a></span></p><div class='para' id='best-1'><div class='marginalizedparent'><a class='marginalized' href='#best-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1550'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,overload_resolution_and'></a></span>Define ICS<i>i</i>(<span class='texttt'>F</span>) as follows:</p><ul class='itemize'><li id='best-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.1'>(1.1)</a></div><p >if
<span class='texttt'>F</span>
is a static member function, ICS<i>1</i>(<span class='texttt'>F</span>) is defined such that
ICS<i>1</i>(<span class='texttt'>F</span>) is neither better nor worse than ICS<i>1</i>(<span class='texttt'>G</span>)
for any function
<span class='texttt'>G</span>,
and, symmetrically, ICS<i>1</i>(<span class='texttt'>G</span>) is neither better nor worse than
ICS<i>1</i>(<span class='texttt'>F</span>)<a class='footnotenum' href='#footnote-131'>131</a>;
otherwise,
</p></li><li id='best-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.2'>(1.2)</a></div><p >let ICS<i>i</i>(<span class='texttt'>F</span>) denote the implicit conversion sequence that converts
the <i>i</i>-th argument in the list to the type of the
<i>i</i>-th
parameter
of viable function
<span class='texttt'>F</span>.
<a href='over.best.ics'>[over.best.ics]</a> defines the implicit conversion sequences and <a href='over.ics.rank'>[over.ics.rank]</a>
defines what it means for one implicit conversion sequence to be
a better conversion sequence or worse conversion sequence than
another.
</p></li></ul><p >Given these definitions, a viable function
<span class='texttt'>F1</span>
is defined
to be a
<a class='hidden_link' href='#def:better' id='def:better'><i>better</i></a>
function than another viable function
<span class='texttt'>F2</span>
if
for all arguments
<i>i</i>,
ICS<i>i</i>(<span class='texttt'>F1</span>) is not a worse conversion
sequence than ICS<i>i</i>(<span class='texttt'>F2</span>), and then
</p><ul class='itemize'><li id='best-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.3'>(1.3)</a></div><p >for some argument
<i>j</i>,
ICS<i>j</i>(<span class='texttt'>F1</span>) is a better conversion
sequence than ICS<i>j</i>(<span class='texttt'>F2</span>), or, if not that,</p></li><li id='best-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.4'>(1.4)</a></div><p >the context is an initialization by user-defined conversion
(see <a href='dcl.init'>[dcl.init]</a>,
<a href='over.match.conv'>[over.match.conv]</a>, and <a href='over.match.ref'>[over.match.ref]</a>)
and the standard conversion sequence from the return type of
<span class='texttt'>F1</span>
to the destination type (i.e., the type of the entity being initialized)
is a better conversion sequence than the standard conversion sequence
from the return type of
<span class='texttt'>F2</span>
to the destination type.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;          <span class='comment'>// <span class='texttt'>a.operator int()</span> followed by no conversion is better than
</span>                    <span class='comment'>// <span class='texttt'>a.operator double()</span> followed by a conversion to <span class='texttt'>int</span>
</span>float x = a;        <span class='comment'>// ambiguous: both possibilities require conversions,
</span>                    <span class='comment'>// and neither is better than the other
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='best-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.5'>(1.5)</a></div><p >the context is an initialization by conversion function for direct
reference binding (<a href='over.match.ref'>[over.match.ref]</a>) of a reference to function type, the
return type of <span class='texttt'>F1</span> is the same kind of reference (i.e. lvalue or rvalue)
as the reference being initialized, and the return type of <span class='texttt'>F2</span> is not
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  operator T&amp;();    <span class='comment'>// #1
</span>  operator T&amp;&amp;();   <span class='comment'>// #2
</span>};
typedef int Fn();
A&lt;Fn&gt; a;
Fn&amp; lf = a;         <span class='comment'>// calls #1
</span>Fn&amp;&amp; rf = a;        <span class='comment'>// calls #2
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='best-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.6'>(1.6)</a></div><p ><span class='texttt'>F1</span> is generated from a
<i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i> (<a href='over.match.class.deduct'>[over.match.class.deduct]</a>)
and <span class='texttt'>F2</span> is not
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  A(T, int*);       <span class='comment'>// #1
</span>  A(A&lt;T&gt;&amp;, int*);   <span class='comment'>// #2
</span>  enum { value };
};

template &lt;class T, int N = T::value&gt; A(T&amp;&amp;, int*) -&gt; A&lt;T&gt;;  <span class='comment'>// #3
</span>
A a{1, 0};          <span class='comment'>// uses #1 to deduce <span class='texttt'>A&lt;int&gt;</span> and initializes with #1
</span>A b{a, 0};          <span class='comment'>// uses #3 (not #2) to deduce <span class='texttt'>A&lt;A&lt;int&gt;&amp;&gt;</span> and initializes with #1
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='best-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.7'>(1.7)</a></div><p ><span class='texttt'>F1</span>
is not a function template specialization and
<span class='texttt'>F2</span>
is a
function template
specialization, or, if not that,</p></li><li id='best-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#best-1.8'>(1.8)</a></div><p ><span class='texttt'>F1</span>
and
<span class='texttt'>F2</span>
are
function template specializations,
and the function template
for
<span class='texttt'>F1</span>
is more specialized than the template for
<span class='texttt'>F2</span>
according to the partial ordering rules described in <a href='temp.func.order'>[temp.func.order]</a>.
</p></li></ul></div><div class='para' id='best-2'><div class='marginalizedparent'><a class='marginalized' href='#best-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1689'>#</a></div><p >If there is exactly one viable function that is a better function
than all other viable functions, then it is the one selected by
overload resolution; otherwise the call is ill-formed.<a class='footnotenum' href='#footnote-132'>132</a>
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
void Fcn(const int*,  short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&amp;i, s);       <span class='comment'>// is ambiguous because <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>int*</span> is better than <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>const int*</span>
</span>                    <span class='comment'>// but <span class='texttt'>s</span> <span class='math'>→</span> <span class='texttt'>short</span> is also better than <span class='texttt'>s</span> <span class='math'>→</span> <span class='texttt'>int</span>
</span>
  Fcn(&amp;i, 1L);      <span class='comment'>// calls <span class='texttt'>Fcn(int*, int)</span>, because <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>int*</span> is better than <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>const int*</span>
</span>                    <span class='comment'>// and <span class='texttt'>1L</span> <span class='math'>→</span> <span class='texttt'>short</span> and <span class='texttt'>1L</span> <span class='math'>→</span> <span class='texttt'>int</span> are indistinguishable
</span>
  Fcn(&amp;i, 'c');     <span class='comment'>// calls <span class='texttt'>Fcn(int*, int)</span>, because <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>int*</span> is better than <span class='texttt'>&amp;i</span> <span class='math'>→</span> <span class='texttt'>const int*</span>
</span>                    <span class='comment'>// and <span class='texttt'>c</span> <span class='math'>→</span> <span class='texttt'>int</span> is better than <span class='texttt'>c</span> <span class='math'>→</span> <span class='texttt'>short</span>
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='best-3'><div class='marginalizedparent'><a class='marginalized' href='#best-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1748'>#</a></div><p >If the best viable function resolves to a function for
which multiple declarations were found, and if at least
two of these declarations — or the declarations they
refer to in the case of
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>
— specify a default argument that made the function
viable, the program is ill-formed.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3);             <span class='comment'>// OK, default argument was not used for viability
</span>  f();              <span class='comment'>// Error: found default argument twice
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-131'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-131'>131)</a></div><p >If a function is a static member function, this
definition means that the first argument, the implied object argument,
has no effect in the determination of whether the function is better
or worse than any other function.</p></div><div class='footnote' id='footnote-132'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-132'>132)</a></div><p >The algorithm
for selecting the best viable function is linear in the number
of viable
functions.
Run a simple tournament to find a function
<span class='texttt'>W</span>
that is not
worse than any
opponent it faced.
Although another function
<span class='texttt'>F</span>
that
<span class='texttt'>W</span>
did not face
might be at least as good as
<span class='texttt'>W</span>,
<span class='texttt'>F</span>
cannot be the best function because at some point in the
tournament
<span class='texttt'>F</span>
encountered another function
<span class='texttt'>G</span>
such that
<span class='texttt'>F</span>
was not better than
<span class='texttt'>G</span>.
Hence,
<span class='texttt'>W</span>
is either
the best function or there is no best function.
So, make a second pass over
the viable
functions to verify that
<span class='texttt'>W</span>
is better than all other functions.</p></div><div id='over.best.ics'><h4 ><a class='secnum' href='#over.best.ics' style='min-width:118pt'>13.3.3.1</a> Implicit conversion sequences <a class='abbr_ref' href='over.best.ics'>[over.best.ics]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,implicit_conversions_and'></a></span></p><div class='para' id='over.best.ics-1'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1778'>#</a></div><p >An
<a class='hidden_link' href='#def:implicit_conversion_sequence' id='def:implicit_conversion_sequence'><i>implicit conversion sequence</i></a>
<span class='indexparent'><a class='index' id='sequence,implicit_conversion'></a></span>is a sequence of conversions used
to convert an argument in a function call to the type of the
corresponding parameter of the function being called.
The
sequence of conversions is an implicit conversion as defined in
Clause <a href='conv'>[conv]</a>, which means it is governed by the rules for
initialization of an object or reference by a single
expression (<a href='dcl.init'>[dcl.init]</a>, <a href='dcl.init.ref'>[dcl.init.ref]</a>).</p></div><div class='para' id='over.best.ics-2'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1791'>#</a></div><p >Implicit conversion sequences are concerned only with the type,
cv-qualification, and value category of the argument and how these
are converted to match the corresponding properties of the
parameter.
Other properties, such as the lifetime, storage class,
alignment, accessibility of the argument, whether the argument is a bit-field,
and whether a function is deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>), are ignored.
So, although an implicit
conversion sequence can be defined for a given argument-parameter
pair, the conversion from the argument to the parameter might still
be ill-formed in the final analysis.</p></div><div class='para' id='over.best.ics-3'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1804'>#</a></div><p >A
well-formed implicit conversion
sequence is one of the following forms:</p><ul class='itemize'><li id='over.best.ics-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-3.1'>(3.1)</a></div><p >a
<a class='hidden_link' href='#def:standard_conversion_sequence' id='def:standard_conversion_sequence'><i>standard conversion sequence</i></a> (<a href='over.ics.scs'>[over.ics.scs]</a>),
</p></li><li id='over.best.ics-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-3.2'>(3.2)</a></div><p >a
<span class='grammarterm'>user-defined conversion sequence</span> (<a href='over.ics.user'>[over.ics.user]</a>), or
</p></li><li id='over.best.ics-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-3.3'>(3.3)</a></div><p >an
<a class='hidden_link' href='#def:ellipsis_conversion_sequence' id='def:ellipsis_conversion_sequence'><i>ellipsis conversion sequence</i></a> (<a href='over.ics.ellipsis'>[over.ics.ellipsis]</a>).
</p></li></ul></div><div class='para' id='over.best.ics-4'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1821'>#</a></div><p >However, if the target is
</p><ul class='itemize'><li id='over.best.ics-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-4.1'>(4.1)</a></div><p >the first parameter of a constructor or
</p></li><li id='over.best.ics-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-4.2'>(4.2)</a></div><p >the implicit object parameter of a user-defined conversion function
</p></li></ul><p >and the constructor or user-defined conversion function is a candidate by
</p><ul class='itemize'><li id='over.best.ics-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-4.3'>(4.3)</a></div><p ><a href='over.match.ctor'>[over.match.ctor]</a>, when the argument is the temporary in the second
step of a class copy-initialization,
</p></li><li id='over.best.ics-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-4.4'>(4.4)</a></div><p ><a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.conv'>[over.match.conv]</a>, or <a href='over.match.ref'>[over.match.ref]</a>
(in all cases), or
</p></li><li id='over.best.ics-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.best.ics-4.5'>(4.5)</a></div><p >the second phase of <a href='over.match.list'>[over.match.list]</a>
when the initializer list has exactly one element that
is itself an initializer list, and
the target is the first parameter of a constructor of class <span class='texttt'>X</span>, and
the conversion is to <span class='texttt'>X</span> or reference to <i>cv</i> <span class='texttt'>X</span>,
</p></li></ul><p >user-defined conversion sequences are not considered.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
These rules prevent more than one user-defined conversion from being
applied during overload resolution, thereby avoiding infinite recursion.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
  struct Y { Y(int); };
  struct A { operator int(); };
  Y y1 = A();       <span class='comment'>// error: <span class='texttt'>A::operator int()</span> is not a candidate
</span>
  struct X { };
  struct B { operator X(); };
  B b;
  X x({b});         <span class='comment'>// error: <span class='texttt'>B::operator X()</span> is not a candidate
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.best.ics-5'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1857'>#</a></div><p >For the case where the parameter type is a reference, see <a href='over.ics.ref'>[over.ics.ref]</a>.</p></div><div class='para' id='over.best.ics-6'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1860'>#</a></div><p >When the parameter type is not a reference, the implicit conversion
sequence models a copy-initialization of the parameter from the argument
expression.
The implicit conversion sequence is the one required to convert the
argument expression to a prvalue of the type of
the parameter.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
When the parameter has a class type, this is a conceptual conversion
defined for the purposes of Clause <a href='over'>[over]</a>; the actual initialization is
defined in terms of constructors and is not a conversion.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
Any difference in top-level cv-qualification is
subsumed by the initialization itself and does not constitute a conversion.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
a parameter of type
<span class='texttt'>A</span>
can be initialized from an argument of type
<span class='texttt'>const A</span>.
The implicit conversion sequence for that case is the identity sequence; it
contains no “conversion” from
<span class='texttt'>const A</span>
to
<span class='texttt'>A</span>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
When the parameter has a class type and the argument expression has the
same type, the implicit conversion sequence is an identity conversion.
When the parameter has a class type and the argument expression has a
derived class type, the implicit conversion sequence is a
derived-to-base
<span class='indexparent'><a class='index' id='conversion,derived-to-base'></a></span>Conversion from the derived class to the base class.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
There is no such standard conversion; this derived-to-base Conversion exists
only in the description of implicit conversion sequences.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
A derived-to-base Conversion has Conversion rank (<a href='over.ics.scs'>[over.ics.scs]</a>).</p></div><div class='para' id='over.best.ics-7'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1898'>#</a></div><p >In all contexts, when converting to the implicit object parameter
or when converting to the left operand of an assignment operation
only standard conversion sequences are allowed.</p></div><div class='para' id='over.best.ics-8'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1903'>#</a></div><p >If no conversions are required to match an argument to a
parameter type, the implicit conversion sequence is the standard
conversion sequence consisting of the identity conversion (<a href='over.ics.scs'>[over.ics.scs]</a>).</p></div><div class='para' id='over.best.ics-9'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1908'>#</a></div><p >If no sequence of conversions can be found to convert an argument
to a parameter type, an implicit conversion sequence cannot be formed.</p></div><div class='para' id='over.best.ics-10'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1912'>#</a></div><p >If several different sequences of conversions exist that each
convert the argument to the parameter type, the implicit
conversion sequence associated with the parameter is defined to be
the unique conversion sequence designated the
<a class='hidden_link' href='#def:ambiguous_conversion_sequence' id='def:ambiguous_conversion_sequence'><i>ambiguous conversion sequence</i></a>.
<span class='indexparent'><a class='index' id='sequence,ambiguous_conversion'></a></span>For the purpose of ranking implicit conversion sequences as described
in <a href='over.ics.rank'>[over.ics.rank]</a>, the ambiguous conversion sequence is treated
as a user-defined conversion sequence that is indistinguishable from any
other user-defined conversion sequence.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This rule prevents a function from becoming non-viable because of an ambiguous
conversion sequence for one of its parameters.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
class B;
class A { A (B&amp;);};
class B { operator A (); };
class C { C (B&amp;); };
void f(A) { }
void f(C) { }
B b;
f(b);               <span class='comment'>// ill-formed: ambiguous because there is a conversion <span class='texttt'>b</span> <span class='math'>→</span> <span class='texttt'>C</span> (via constructor)
</span>                    <span class='comment'>// and an (ambiguous) conversion <span class='texttt'>b</span> <span class='math'>→</span> <span class='texttt'>A</span> (via constructor or conversion function)
</span>void f(B) { }
f(b);               <span class='comment'>// OK, unambiguous
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
If a function that uses the ambiguous conversion sequence is selected
as the best viable function, the call will be ill-formed because the conversion
of one of the arguments in the call is ambiguous.</p></div><div class='para' id='over.best.ics-11'><div class='marginalizedparent'><a class='marginalized' href='#over.best.ics-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1946'>#</a></div><p >The three forms of implicit conversion sequences mentioned above
are defined in the following subclauses.</p></div><div id='over.ics.scs'><h4 ><a class='secnum' href='#over.ics.scs' style='min-width:133pt'>13.3.3.1.1</a> Standard conversion sequences <a class='abbr_ref' href='over.ics.scs'>[over.ics.scs]</a></h4><div class='para' id='over.ics.scs-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1952'>#</a></div><p >Table <a href='#tab:over.conversions'>[tab:over.conversions]</a>
summarizes the conversions defined in Clause <a href='conv'>[conv]</a> and
partitions them into four disjoint categories: Lvalue Transformation,
Qualification Adjustment, Promotion, and Conversion.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
These categories are orthogonal with respect to value category,
cv-qualification, and data representation: the Lvalue Transformations
do not change the cv-qualification or data
representation of the type; the Qualification Adjustments do not
change the value category or data representation of the type; and
the Promotions and Conversions do not change the
value category or cv-qualification of the type.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.scs-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1967'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
As described in Clause <a href='conv'>[conv]</a>,
a standard conversion sequence is either the Identity conversion
by itself (that is, no conversion) or consists of one to three
conversions from the other
four categories.
If there are two or more conversions in the sequence, the
conversions are applied in the canonical order:
<b>Lvalue Transformation</b>,
<b>Promotion</b>
or
<b>Conversion</b>,
<b>Qualification Adjustment</b>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.scs-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L1983'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion_rank'></a></span>Each conversion in Table <a href='#tab:over.conversions'>[tab:over.conversions]</a>
also has an associated rank (Exact
Match, Promotion, or Conversion).
These are used
to rank standard conversion sequences (<a href='over.ics.rank'>[over.ics.rank]</a>).
The rank of a conversion sequence is determined by considering the
rank of each conversion in the sequence and the rank of any reference
binding (<a href='over.ics.ref'>[over.ics.ref]</a>).
If any of those has Conversion rank, the
sequence has Conversion rank; otherwise, if any of those has Promotion rank,
the sequence has Promotion rank; otherwise, the sequence has Exact
Match rank.</p><div class='numberedTable' id='tab:over.conversions'>Table <a href='#tab:over.conversions'>13</a> — Conversions<br><table ><tr class='rowsep'><td class='left'>



<b>Conversion</b>            </td><td class='border center'>   <b>Category</b>          </td><td class='border center'>   <b>Rank</b>  </td><td class='border center'>   <b>Subclause</b> </td></tr><tr class='capsep'><td class='left'> 
No conversions required         </td><td class='border center'>   Identity                    </td><td class='border center'>                   </td><td class='border center'>                       </td></tr><tr ><td class='left cline'> 
Lvalue-to-rvalue conversion     </td><td class='border center cline'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.lval'>[conv.lval]</a>     </td></tr><tr ><td class='left cline'> 
Array-to-pointer conversion     </td><td class='border center'>   Lvalue Transformation       </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.array'>[conv.array]</a>    </td></tr><tr ><td class='left cline'> 
Function-to-pointer conversion  </td><td class='border center'>                               </td><td class='border center'>   <span style='position: relative; top: -1.5ex'>Exact Match</span></td><td class='border center cline'>   <a href='conv.func'>[conv.func]</a>     </td></tr><tr ><td class='left cline'> 
Qualification conversions       </td><td class='border center cline'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.qual'>[conv.qual]</a>     </td></tr><tr ><td class='left cline'> 
Function pointer conversion     </td><td class='border center'> <span style='position: relative; top: -1.5ex'>Qualification Adjustment</span> </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.fctptr'>[conv.fctptr]</a>   </td></tr><tr class='rowsep'><td class='left'> 
Integral promotions             </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center'>   <a href='conv.prom'>[conv.prom]</a>     </td></tr><tr ><td class='left cline'> 
Floating-point promotion        </td><td class='border center'>   <span style='position: relative; top: -1.5ex'>Promotion</span>              </td><td class='border center'>   <span style='position: relative; top: -1.5ex'>Promotion</span>  </td><td class='border center cline'>   <a href='conv.fpprom'>[conv.fpprom]</a>   </td></tr><tr class='rowsep'><td class='left'> 
Integral conversions            </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center'>   <a href='conv.integral'>[conv.integral]</a> </td></tr><tr ><td class='left cline'> 
Floating-point conversions      </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.double'>[conv.double]</a>   </td></tr><tr ><td class='left cline'> 
Floating-integral conversions   </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.fpint'>[conv.fpint]</a>    </td></tr><tr ><td class='left cline'> 
Pointer conversions             </td><td class='border center'>   <span style='position: relative; top: -1.5ex'>Conversion</span>             </td><td class='border center'>   <span style='position: relative; top: -1.5ex'>Conversion</span> </td><td class='border center cline'>   <a href='conv.ptr'>[conv.ptr]</a>      </td></tr><tr ><td class='left cline'> 
Pointer to member conversions   </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.mem'>[conv.mem]</a>      </td></tr><tr ><td class='left cline'> 
Boolean conversions             </td><td class='border center'>                               </td><td class='border center'>                   </td><td class='border center cline'>   <a href='conv.bool'>[conv.bool]</a>     </td></tr></table></div></div></div><div id='over.ics.user'><h4 ><a class='secnum' href='#over.ics.user' style='min-width:133pt'>13.3.3.1.2</a> User-defined conversion sequences <a class='abbr_ref' href='over.ics.user'>[over.ics.user]</a></h4><div class='para' id='over.ics.user-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2019'>#</a></div><p >A user-defined conversion sequence consists of an initial
standard conversion sequence followed by a user-defined
conversion (<a href='class.conv'>[class.conv]</a>) followed by a second standard
conversion sequence.
If the user-defined conversion is specified
by a constructor (<a href='class.conv.ctor'>[class.conv.ctor]</a>), the initial standard
conversion sequence converts the source type to the type required
by the argument of the constructor.
If the user-defined
conversion is specified by a conversion function (<a href='class.conv.fct'>[class.conv.fct]</a>), the
initial standard conversion sequence
converts the source type to the implicit object parameter of the
conversion function.</p></div><div class='para' id='over.ics.user-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2034'>#</a></div><p >The second standard conversion sequence converts the result of
the user-defined conversion to the target type for the sequence.
Since an implicit conversion sequence is an initialization, the
special rules for initialization by user-defined conversion apply
when selecting the best user-defined conversion for a
user-defined conversion sequence (see <a href='over.match.best'>[over.match.best]</a> and <a href='over.best.ics'>[over.best.ics]</a>).</p></div><div class='para' id='over.ics.user-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2042'>#</a></div><p >If the user-defined conversion is specified by a
specialization of a conversion function template,
the second standard conversion sequence shall have exact match rank.</p></div><div class='para' id='over.ics.user-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2047'>#</a></div><p >A conversion of an expression of class type
to the same class type is given Exact Match rank, and
a conversion of an expression of class type
to a base class of that type is given Conversion rank,
in spite of the
fact that a constructor (i.e., a user-defined conversion
function) is called for those cases.</p></div></div><div id='over.ics.ellipsis'><h4 ><a class='secnum' href='#over.ics.ellipsis' style='min-width:133pt'>13.3.3.1.3</a> Ellipsis conversion sequences <a class='abbr_ref' href='over.ics.ellipsis'>[over.ics.ellipsis]</a></h4><div class='para' id='over.ics.ellipsis-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ellipsis-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2058'>#</a></div><p ><span class='indexparent'><a class='index' id='ellipsis,conversion_sequence'></a></span>An ellipsis conversion sequence occurs when an argument in a
function call is matched with the ellipsis parameter
specification of the function called (see <a href='expr.call'>[expr.call]</a>).</p></div></div><div id='over.ics.ref'><h4 ><a class='secnum' href='#over.ics.ref' style='min-width:133pt'>13.3.3.1.4</a> Reference binding <a class='abbr_ref' href='over.ics.ref'>[over.ics.ref]</a></h4><div class='para' id='over.ics.ref-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2066'>#</a></div><p >When a parameter of reference type binds directly (<a href='dcl.init.ref'>[dcl.init.ref]</a>) to an
argument expression, the implicit conversion sequence is the identity conversion,
unless the argument expression has a type that is a derived class of the parameter
type, in which case the implicit conversion sequence is a derived-to-base
Conversion (<a href='over.best.ics'>[over.best.ics]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
struct A {};
struct B : public A {} b;
int f(A&amp;);
int f(B&amp;);
int i = f(b);       <span class='comment'>// calls <span class='texttt'>f(B&amp;)</span>, an exact match, rather than <span class='texttt'>f(A&amp;)</span>, a conversion
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
If the parameter binds directly to the result of
applying a conversion function to the argument expression, the implicit
conversion sequence is a user-defined conversion sequence (<a href='over.ics.user'>[over.ics.user]</a>),
with the second standard conversion sequence either an identity conversion or,
if the conversion function returns an entity of a type that is a derived class
of the parameter type, a derived-to-base Conversion.</p></div><div class='para' id='over.ics.ref-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2089'>#</a></div><p >When a parameter of reference type is not bound directly to an argument
expression, the conversion sequence is the one required to convert the argument
expression to the referenced type according to <a href='over.best.ics'>[over.best.ics]</a>.
Conceptually, this conversion sequence corresponds to copy-initializing a
temporary of the referenced type with the argument expression.
Any difference
in top-level cv-qualification is subsumed by the initialization itself and
does not constitute a conversion.</p></div><div class='para' id='over.ics.ref-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2099'>#</a></div><p >Except for an implicit object parameter, for which see <a href='over.match.funcs'>[over.match.funcs]</a>, a
standard conversion sequence cannot be formed if it requires
binding an lvalue reference
other than a reference to a non-volatile <span class='texttt'>const</span> type
to an rvalue
or binding an rvalue reference to an lvalue other than a function lvalue.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This means, for example, that a candidate function cannot be a viable
function if it has a non-<span class='texttt'>const</span> lvalue reference parameter (other than
the implicit object parameter) and the corresponding argument
would require a temporary to be created to initialize the lvalue
reference (see <a href='dcl.init.ref'>[dcl.init.ref]</a>).
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.ref-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2114'>#</a></div><p >Other restrictions on binding a reference to a particular argument
that are not based on the types of the reference and the argument
do not affect the formation of a standard conversion
sequence, however.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
a function with an “lvalue reference to <span class='texttt'>int</span>” parameter can
be a viable candidate even if the corresponding argument is an
<span class='texttt'>int</span>
bit-field.
The formation of implicit conversion sequences
treats the
<span class='texttt'>int</span>
bit-field as an
<span class='texttt'>int</span>
lvalue and finds an exact
match with the parameter.
If the function is selected by overload
resolution, the call will nonetheless be ill-formed because of
the prohibition on binding a non-<span class='texttt'>const</span> lvalue reference to a bit-field (<a href='dcl.init.ref'>[dcl.init.ref]</a>).
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='over.ics.list'><h4 ><a class='secnum' href='#over.ics.list' style='min-width:133pt'>13.3.3.1.5</a> List-initialization sequence <a class='abbr_ref' href='over.ics.list'>[over.ics.list]</a></h4><div class='para' id='over.ics.list-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2138'>#</a></div><p >When an argument is an initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), it is not an
expression and special rules apply for converting it to a parameter type.</p></div><div class='para' id='over.ics.list-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2142'>#</a></div><p >If the parameter type is an aggregate class <span class='texttt'>X</span> and the initializer list has a
single element of type <i>cv</i> <span class='texttt'>U</span>, where <span class='texttt'>U</span> is <span class='texttt'>X</span>
or a class derived from <span class='texttt'>X</span>, the implicit conversion sequence is the one
required to convert the element to the parameter type.</p></div><div class='para' id='over.ics.list-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2148'>#</a></div><p >Otherwise, if the parameter type is a character array<a class='footnotenum' href='#footnote-133'>133</a>
and the initializer list has a single element that is an appropriately-typed
string literal (<a href='dcl.init.string'>[dcl.init.string]</a>), the implicit conversion
sequence is the identity conversion.</p></div><div class='para' id='over.ics.list-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2156'>#</a></div><p >Otherwise, if the parameter type is <span class='texttt'>std::initializer_list&lt;X&gt;</span>
and all the elements
of the initializer list can be implicitly converted to <span class='texttt'>X</span>, the implicit
conversion sequence is the worst conversion necessary to convert an element of
the list to <span class='texttt'>X</span>, or if the initializer list has no elements, the identity
conversion. This conversion can be a user-defined conversion even in
the context of a call to an initializer-list constructor. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
void f(std::initializer_list&lt;int&gt;);
f( {} );                <span class='comment'>// OK: <span class='texttt'>f(initializer_list&lt;int&gt;)</span> identity conversion
</span>f( {1,2,3} );           <span class='comment'>// OK: <span class='texttt'>f(initializer_list&lt;int&gt;)</span> identity conversion
</span>f( {'a','b'} );         <span class='comment'>// OK: <span class='texttt'>f(initializer_list&lt;int&gt;)</span> integral promotion
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span>
struct A {
  A(std::initializer_list&lt;double&gt;);             <span class='comment'>// #1
</span>  A(std::initializer_list&lt;complex&lt;double&gt;&gt;);    <span class='comment'>// #2
</span>  A(std::initializer_list&lt;std::string&gt;);        <span class='comment'>// #3
</span>};
A a{ 1.0,2.0 };         <span class='comment'>// OK, uses #1
</span>
void g(A);
g({ "foo", "bar" });    <span class='comment'>// OK, uses #3
</span>
typedef int IA[3];
void h(const IA&amp;);
h({ 1, 2, 3 });         <span class='comment'>// OK: identity conversion
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.list-5'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2187'>#</a></div><p >Otherwise, if the parameter type is “array of <span class='texttt'>N</span> <span class='texttt'>X</span>”,
if there exists an implicit conversion sequence for each element of the array
from the corresponding element of the initializer list (or from <span class='texttt'>{}</span>
if there is no such element), the implicit conversion sequence is
the worst such implicit conversion sequence.</p></div><div class='para' id='over.ics.list-6'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2194'>#</a></div><p >Otherwise, if the parameter is a non-aggregate class <span class='texttt'>X</span> and overload
resolution per <a href='over.match.list'>[over.match.list]</a> chooses a single best constructor <span class='texttt'>C</span> of
<span class='texttt'>X</span> to perform the initialization of an object of type <span class='texttt'>X</span> from the
argument initializer list:
</p><ul class='itemize'><li id='over.ics.list-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-6.1'>(6.1)</a></div><p >If <span class='texttt'>C</span> is not an initializer-list constructor
and the initializer list has a single element of type <i>cv</i> <span class='texttt'>U</span>,
where <span class='texttt'>U</span> is <span class='texttt'>X</span> or a class derived from <span class='texttt'>X</span>,
the implicit conversion sequence has Exact Match rank if <span class='texttt'>U</span> is <span class='texttt'>X</span>,
or Conversion rank if <span class='texttt'>U</span> is derived from <span class='texttt'>X</span>.
</p></li><li id='over.ics.list-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-6.2'>(6.2)</a></div><p >Otherwise, the implicit conversion sequence is a user-defined
conversion sequence with the second standard conversion sequence an
identity conversion.
</p></li></ul><p >If multiple constructors are viable but none is better than
the others, the implicit conversion sequence is the ambiguous conversion
sequence. User-defined conversions are allowed for conversion of the initializer
list elements to the constructor parameter types except as noted
in <a href='over.best.ics'>[over.best.ics]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct A {
  A(std::initializer_list&lt;int&gt;);
};
void f(A);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='texttt'>f(A(std::initializer_list&lt;int&gt;))</span> user-defined conversion
</span>
struct B {
  B(int, double);
};
void g(B);
g( {'a', 'b'} );        <span class='comment'>// OK: <span class='texttt'>g(B(int, double))</span> user-defined conversion
</span>g( {1.0, 1.0} );        <span class='comment'>// error: narrowing
</span>
void f(B);
f( {'a', 'b'} );        <span class='comment'>// error: ambiguous <span class='texttt'>f(A)</span> or <span class='texttt'>f(B)</span>
</span>
struct C {
  C(std::string);
};
void h(C);
h({"foo"});             <span class='comment'>// OK: <span class='texttt'>h(C(std::string("foo")))</span>
</span>
struct D {
  D(A, C);
};
void i(D);
i({ {1,2}, {"bar"} });  <span class='comment'>// OK: <span class='texttt'>i(D(A(std::initializer_list&lt;int&gt;{1,2}), C(std::string("bar"))))</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.list-7'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2248'>#</a></div><p >Otherwise, if the parameter has an aggregate type which can be initialized from
the initializer list according to the rules for aggregate
initialization (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>), the implicit conversion sequence is a
user-defined conversion sequence with the second standard conversion
sequence an identity conversion. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct A {
  int m1;
  double m2;
};

void f(A);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='texttt'>f(A(int,double))</span> user-defined conversion
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.list-8'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2266'>#</a></div><p >Otherwise, if the parameter is a reference, see <a href='over.ics.ref'>[over.ics.ref]</a>. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The rules in this section will apply for initializing the underlying temporary
for the reference. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct A {
  int m1;
  double m2;
};

void f(const A&amp;);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='texttt'>f(A(int,double))</span> user-defined conversion
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span>
void g(const double &amp;);
g({1});                 <span class='comment'>// same conversion as <span class='texttt'>int</span> to <span class='texttt'>double</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='over.ics.list-9'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2285'>#</a></div><p >Otherwise, if the parameter type is not a class:</p><ul class='itemize'><li id='over.ics.list-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-9.1'>(9.1)</a></div><p >if the initializer list has one element that is not itself an initializer list,
the implicit conversion sequence is the one required to convert the element to
the parameter type; [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
void f(int);
f( {'a'} );             <span class='comment'>// OK: same conversion as <span class='texttt'>char</span> to <span class='texttt'>int</span>
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='over.ics.list-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-9.2'>(9.2)</a></div><p >if the initializer list has no elements, the implicit conversion sequence
is the identity conversion. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
void f(int);
f( { } );               <span class='comment'>// OK: identity conversion
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></div><div class='para' id='over.ics.list-10'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2308'>#</a></div><p >In all cases other than those enumerated above, no conversion is possible.</p></div><div class='footnote' id='footnote-133'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-133'>133)</a></div><p >Since there are no parameters of array type,
this will only occur as the referenced type of a reference parameter.</p></div></div></div><div id='over.ics.rank'><h4 ><a class='secnum' href='#over.ics.rank' style='min-width:118pt'>13.3.3.2</a> Ranking implicit conversion sequences <a class='abbr_ref' href='over.ics.rank'>[over.ics.rank]</a></h4><div class='para' id='over.ics.rank-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.rank-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2313'>#</a></div><p ><a href='over.ics.rank'>[over.ics.rank]</a> defines a partial ordering of implicit conversion
sequences based on the relationships
<a class='hidden_link' href='#def:better_conversion_sequence' id='def:better_conversion_sequence'><i>better conversion sequence</i></a>
and
<a class='hidden_link' href='#def:better_conversion' id='def:better_conversion'><i>better conversion</i></a>.
If an implicit conversion sequence S1 is
defined by these rules to be a better conversion sequence than
S2, then it is also the case that S2 is a
<a class='hidden_link' href='#def:worse_conversion_sequence' id='def:worse_conversion_sequence'><i>worse conversion sequence</i></a>
than S1.
If conversion sequence S1 is neither better
than nor worse than conversion sequence S2, S1 and S2 are said to
be
<a class='hidden_link' href='#def:indistinguishable_conversion_sequences' id='def:indistinguishable_conversion_sequences'><i>indistinguishable conversion sequences</i></a>.</p></div><div class='para' id='over.ics.rank-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.rank-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2329'>#</a></div><p >When comparing the basic forms of implicit conversion sequences
(as defined in <a href='over.best.ics'>[over.best.ics]</a>)</p><ul class='itemize'><li id='over.ics.rank-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-2.1'>(2.1)</a></div><p >a standard conversion sequence (<a href='over.ics.scs'>[over.ics.scs]</a>) is a better
conversion sequence than a user-defined conversion sequence
or an ellipsis conversion sequence, and
</p></li><li id='over.ics.rank-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-2.2'>(2.2)</a></div><p >a user-defined conversion sequence (<a href='over.ics.user'>[over.ics.user]</a>) is a
better conversion sequence than an ellipsis conversion
sequence (<a href='over.ics.ellipsis'>[over.ics.ellipsis]</a>).
</p></li></ul></div><div class='para' id='over.ics.rank-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.rank-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2344'>#</a></div><p >Two implicit conversion sequences of the same form are
indistinguishable conversion sequences unless one of the
following rules applies:</p><ul class='itemize'><li id='over.ics.rank-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-3.1'>(3.1)</a></div><p >List-initialization sequence <span class='texttt'>L1</span> is a better conversion sequence than
list-initialization sequence <span class='texttt'>L2</span> if</p><ul class='itemize'><li id='over.ics.rank-3.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.1.1'>(3.1.1)</a></div><p ><span class='texttt'>L1</span> converts to <span class='texttt'>std::initializer_list&lt;X&gt;</span> for some <span class='texttt'>X</span> and
<span class='texttt'>L2</span> does not, or, if not that,</p></li><li id='over.ics.rank-3.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.1.2'>(3.1.2)</a></div><p ><span class='texttt'>L1</span> converts to type “array of <span class='texttt'>N1</span> <span class='texttt'>T</span>”, <span class='texttt'>L2</span> converts to
type “array of <span class='texttt'>N2</span> <span class='texttt'>T</span>”, and <span class='texttt'>N1</span> is smaller than <span class='texttt'>N2</span>,
</p></li></ul><p >even if one of the other rules in this paragraph would otherwise apply.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
  void f1(int);                                 <span class='comment'>// #1
</span>  void f1(std::initializer_list&lt;long&gt;);         <span class='comment'>// #2
</span>  void g1() { f1({42}); }                       <span class='comment'>// chooses #2
</span>
  void f2(std::pair&lt;const char*, const char*&gt;); <span class='comment'>// #3
</span>  void f2(std::initializer_list&lt;std::string&gt;);  <span class='comment'>// #4
</span>  void g2() { f2({"foo","bar"}); }              <span class='comment'>// chooses #4
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='over.ics.rank-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-3.2'>(3.2)</a></div><p >Standard conversion sequence
<span class='texttt'>S1</span>
is a better conversion
sequence than standard conversion sequence
<span class='texttt'>S2</span>
if</p><ul class='itemize'><li id='over.ics.rank-3.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.1'>(3.2.1)</a></div><p ><span class='indexparent'><a class='index' id='subsequence_rule,overloading'></a></span><span class='texttt'>S1</span>
is a proper subsequence of
<span class='texttt'>S2</span>
(comparing the conversion sequences in the canonical form defined
by <a href='over.ics.scs'>[over.ics.scs]</a>, excluding any Lvalue Transformation;
the identity conversion sequence is considered to be a
subsequence of any non-identity conversion sequence)
or, if not that,
</p></li><li id='over.ics.rank-3.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.2'>(3.2.2)</a></div><p >the rank of
<span class='texttt'>S1</span>
is better than the rank of
<span class='texttt'>S2</span>,
or
<span class='texttt'>S1</span>
and
<span class='texttt'>S2</span>
have the same rank and are distinguishable by the rules
in the paragraph below,
or, if not that,</p></li><li id='over.ics.rank-3.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.3'>(3.2.3)</a></div><p ><span class='texttt'>S1</span> and <span class='texttt'>S2</span> are reference bindings (<a href='dcl.init.ref'>[dcl.init.ref]</a>) and
neither refers to an implicit object parameter of a non-static member function
declared without a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>,
and <span class='texttt'>S1</span> binds an rvalue reference to an
rvalue and <span class='texttt'>S2</span> binds an lvalue reference.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
int i;
int f1();
int&amp;&amp; f2();
int g(const int&amp;);
int g(const int&amp;&amp;);
int j = g(i);                   <span class='comment'>// calls <span class='texttt'>g(const int&amp;)</span>
</span>int k = g(f1());                <span class='comment'>// calls <span class='texttt'>g(const int&amp;&amp;)</span>
</span>int l = g(f2());                <span class='comment'>// calls <span class='texttt'>g(const int&amp;&amp;)</span>
</span>
struct A {
  A&amp; operator&lt;&lt;(int);
  void p() &amp;;
  void p() &amp;&amp;;
};
A&amp; operator&lt;&lt;(A&amp;&amp;, char);
A() &lt;&lt; 1;                       <span class='comment'>// calls <span class='texttt'>A::operator&lt;&lt;(int)</span>
</span>A() &lt;&lt; 'c';                     <span class='comment'>// calls <span class='texttt'>operator&lt;&lt;(A&amp;&amp;, char)</span>
</span>A a;
a &lt;&lt; 1;                         <span class='comment'>// calls <span class='texttt'>A::operator&lt;&lt;(int)</span>
</span>a &lt;&lt; 'c';                       <span class='comment'>// calls <span class='texttt'>A::operator&lt;&lt;(int)</span>
</span>A().p();                        <span class='comment'>// calls <span class='texttt'>A::p()&amp;&amp;</span>
</span>a.p();                          <span class='comment'>// calls <span class='texttt'>A::p()&amp;</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='over.ics.rank-3.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.4'>(3.2.4)</a></div><p ><span class='texttt'>S1</span> and <span class='texttt'>S2</span> are reference bindings (<a href='dcl.init.ref'>[dcl.init.ref]</a>) and
<span class='texttt'>S1</span> binds an lvalue reference to a function lvalue and <span class='texttt'>S2</span> binds
an rvalue reference to a function lvalue. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
int f(void(&amp;)());               <span class='comment'>// #1
</span>int f(void(&amp;&amp;)());              <span class='comment'>// #2
</span>void g();
int i1 = f(g);                  <span class='comment'>// calls #1
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='over.ics.rank-3.2.5'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.5'>(3.2.5)</a></div><p ><span class='texttt'>S1</span>
and
<span class='texttt'>S2</span>
differ only in their qualification conversion and yield similar types
<span class='texttt'>T1</span>
and
<span class='texttt'>T2</span> (<a href='conv.qual'>[conv.qual]</a>), respectively, and the cv-qualification signature of type
<span class='texttt'>T1</span>
is a proper subset of the cv-qualification signature of type
<span class='texttt'>T2</span>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&amp;i);                  <span class='comment'>// calls <span class='texttt'>f(const int*)</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
or, if not that,</p></li><li id='over.ics.rank-3.2.6'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-3.2.6'>(3.2.6)</a></div><p ><span class='texttt'>S1</span>
and
<span class='texttt'>S2</span>
are reference bindings (<a href='dcl.init.ref'>[dcl.init.ref]</a>), and the types to which the references
refer are the same type except for top-level cv-qualifiers, and the type to
which the reference initialized by
<span class='texttt'>S2</span>
refers is more cv-qualified than the type to which the reference initialized by
<span class='texttt'>S1</span>
refers.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
int f(const int &amp;);
int f(int &amp;);
int g(const int &amp;);
int g(int);

int i;
int j = f(i);                   <span class='comment'>// calls <span class='texttt'>f(int &amp;)</span>
</span>int k = g(i);                   <span class='comment'>// ambiguous
</span>
struct X {
  void f() const;
  void f();
};
void g(const X&amp; a, X b) {
  a.f();                        <span class='comment'>// calls <span class='texttt'>X::f() const</span>
</span>  b.f();                        <span class='comment'>// calls <span class='texttt'>X::f()</span>
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></li><li id='over.ics.rank-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-3.3'>(3.3)</a></div><p >User-defined conversion sequence
<span class='texttt'>U1</span>
is a better conversion sequence than another user-defined conversion
sequence
<span class='texttt'>U2</span>
if they contain the same user-defined conversion function or
constructor or they initialize the same class in an aggregate
initialization and in either case the second standard conversion
sequence of
<span class='texttt'>U1</span>
is better than
the second standard conversion sequence of
<span class='texttt'>U2</span>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
struct A {
  operator short();
} a;
int f(int);
int f(float);
int i = f(a);                   <span class='comment'>// calls <span class='texttt'>f(int)</span>, because <span class='texttt'>short</span> <span class='math'>→</span> <span class='texttt'>int</span> is
</span>                                <span class='comment'>// better than <span class='texttt'>short</span> <span class='math'>→</span> <span class='texttt'>float</span>.
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></li></ul></div><div class='para' id='over.ics.rank-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.rank-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/overloading.tex#L2541'>#</a></div><p >Standard conversion sequences are ordered by their ranks: an Exact Match is a
better conversion than a Promotion, which is a better conversion than
a Conversion.
Two conversion sequences with the same rank are indistinguishable unless
one of the following rules applies:</p><ul class='itemize'><li id='over.ics.rank-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-4.1'>(4.1)</a></div><p >A conversion that does not convert a pointer,
a pointer to member, or <span class='texttt'>std::nullptr_t</span>
to
<span class='texttt'>bool</span>
is better than one that does.</p></li><li id='over.ics.rank-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-4.2'>(4.2)</a></div><p >A conversion that promotes an enumeration whose underlying type is fixed to its underlying
type is better than one that promotes to the promoted underlying type, if the two are
different.</p></li><li id='over.ics.rank-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-4.3'>(4.3)</a></div><p >If class
<span class='texttt'>B</span>
is derived directly or indirectly from class
<span class='texttt'>A</span>,
conversion of
<span class='texttt'>B*</span>
to
<span class='texttt'>A*</span>
is better than conversion of
<span class='texttt'>B*</span>
to
<span class='texttt'>void*</span>,
and conversion of
<span class='texttt'>A*</span>
to
<span class='texttt'>void*</span>
is better than conversion
of
<span class='texttt'>B*</span>
to
<span class='texttt'>void*</span>.
</p></li><li id='over.ics.rank-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.rank-4.4'>(4.4)</a></div><p >If class
<span class='texttt'>B</span>
is derived directly or indirectly from class
<span class='texttt'>A</span>
and class
<span class='texttt'>C</span>
is derived directly or indirectly from
<span class='texttt'>B</span>,</p><ul class='itemize'><li id='over.ics.rank-4.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.1'>(4.4.1)</a></div><p >conversion of
<span class='texttt'>C*</span>
to
<span class='texttt'>B*</span>
is better than conversion of
<span class='texttt'>C*</span>
to
<span class='texttt'>A*</span>,
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);                  <span class='comment'>// calls <span class='texttt'>f(B*)</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='over.ics.rank-4.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.2'>(4.4.2)</a></div><p >binding of an expression of type
<span class='texttt'>C</span>
to a reference to type
<span class='texttt'>B</span>
is better than binding an expression of type
<span class='texttt'>C</span>
to a reference to type
<span class='texttt'>A</span>,
</p></li><li id='over.ics.rank-4.4.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.3'>(4.4.3)</a></div><p >conversion of
<span class='texttt'>A::*</span>
to
<span class='texttt'>B::*</span>
is better than conversion of
<span class='texttt'>A::*</span>
to
<span class='texttt'>C::*</span>,
</p></li><li id='over.ics.rank-4.4.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.4'>(4.4.4)</a></div><p >conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>B</span>
is better than conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>A</span>,
</p></li><li id='over.ics.rank-4.4.5'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.5'>(4.4.5)</a></div><p >conversion of
<span class='texttt'>B*</span>
to
<span class='texttt'>A*</span>
is better than conversion of
<span class='texttt'>C*</span>
to
<span class='texttt'>A*</span>,
</p></li><li id='over.ics.rank-4.4.6'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.6'>(4.4.6)</a></div><p >binding of an expression of type
<span class='texttt'>B</span>
to a reference to type
<span class='texttt'>A</span>
is better than binding an expression of type
<span class='texttt'>C</span>
to a
reference to type
<span class='texttt'>A</span>,
</p></li><li id='over.ics.rank-4.4.7'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.7'>(4.4.7)</a></div><p >conversion of
<span class='texttt'>B::*</span>
to
<span class='texttt'>C::*</span>
is better than conversion
of
<span class='texttt'>A::*</span>
to
<span class='texttt'>C::*</span>,
and
</p></li><li id='over.ics.rank-4.4.8'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#over.ics.rank-4.4.8'>(4.4.8)</a></div><p >conversion of
<span class='texttt'>B</span>
to
<span class='texttt'>A</span>
is better than conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>A</span>.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Compared conversion sequences will have different source types only in the
context of comparing the second standard conversion sequence of an
initialization by user-defined conversion (see <a href='over.match.best'>[over.match.best]</a>); in
all other contexts, the source types will be the same and the target
types will be different.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul><p ><span class='indexparent'><a class='index' id='overloading,resolution,implicit_conversions_and'></a></span><span class='indexparent'><a class='index' id='overloading,resolution'></a></span></p></div></div></div></div></div></body></html>