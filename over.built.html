<!DOCTYPE html><html lang='en'><head><title>[over.built]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.6</a> Built-in operators <a class='abbr_ref'>[over.built]</a></h2><span class='indexparent'><a class='index' id=':overloading,built-in_operators_and'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3592'>#</a></div><div id='1.sentence-1' class='sentence'>The candidate operator functions that represent the built-in operators
defined in <a href='expr.compound'>[expr.compound]</a> are specified in this subclause<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>These candidate
functions participate in the operator overload resolution process as
described in <a href='over.match.oper'>[over.match.oper]</a> and are used for no other purpose<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-3' class='sentence'>Because built-in operators take only operands with non-class type,
and operator overload resolution occurs only when an operand expression
originally has class or enumeration type,
operator overload resolution can resolve to a built-in operator only
when an operand has a class type that has a user-defined conversion to
a non-class type appropriate for the operator, or when an operand has
an enumeration type that can be converted to a type appropriate
for the operator<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>Also note that some of the candidate operator functions given in this subclause are
more permissive than the built-in operators themselves<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>As
described in <a href='over.match.oper'>[over.match.oper]</a>, after a built-in operator is selected
by overload resolution the expression is subject to the requirements for
the built-in operator given in <a href='expr.compound'>[expr.compound]</a>, and therefore to any
additional semantic constraints given there<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>If there is a user-written
candidate with the same name and parameter types as a built-in
candidate operator function, the built-in operator function
is hidden and is not included in the set of candidate functions<a class='hidden_link' href='#1.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3620'>#</a></div><div id='2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':type,integral,promoted'></a></span><span class='indexparent'><a class='index' id=':type,arithmetic,promoted'></a></span>In this subclause, the term
<a class='hidden_link' href='#def:promoted_integral_type' id='def:promoted_integral_type'><i >promoted integral type</i></a>
is used to refer to those integral types which are preserved by
<a href='conv.prom'>integral promotion</a> (including e.g.
<span class='texttt'>int</span>
and
<span class='texttt'>long</span>
but excluding e.g.
<span class='texttt'>char</span>)<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>Similarly, the term
<a class='hidden_link' href='#def:promoted_arithmetic_type' id='def:promoted_arithmetic_type'><i >promoted arithmetic type</i></a>
refers to floating-point types plus promoted integral types<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-3' class='sentence'>In all cases where a promoted integral type or promoted arithmetic type is
required, an operand of enumeration type will be acceptable by way of the
integral promotions<a class='hidden_link' href='#2.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3641'>#</a></div><div id='3.sentence-1' class='sentence'>In the remainder of this subclause, <span class='textit'>vq</span> represents either
<span class='texttt'>volatile</span> or no cv-qualifier<a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3645'>#</a></div><div id='4.sentence-1' class='sentence'>For every pair
(<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>vq</span>),
where
<span class='texttt'><span class='textit'>T</span></span>
is an arithmetic type other than <span class='texttt'>bool</span>,
there exist candidate operator functions of the form</div><pre class='codeblock'>
<span class='textit'>vq</span> <span class='textit'>T</span>&amp; operator++(<span class='textit'>vq</span> <span class='textit'>T</span>&amp;);
<span class='textit'>T</span> operator++(<span class='textit'>vq</span> <span class='textit'>T</span>&amp;, int);</pre></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3659'>#</a></div><div id='5.sentence-1' class='sentence'>For every pair
(<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>vq</span>),
where
<span class='texttt'><span class='textit'>T</span></span>
is an arithmetic type other than
<span class='texttt'>bool</span>,
there exist candidate operator functions of the form</div><pre class='codeblock'>
<span class='textit'>vq</span> <span class='textit'>T</span>&amp; operator--(<span class='textit'>vq</span> <span class='textit'>T</span>&amp;);
<span class='textit'>T</span> operator--(<span class='textit'>vq</span> <span class='textit'>T</span>&amp;, int);</pre></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3674'>#</a></div><div id='6.sentence-1' class='sentence'>For every pair
(<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>vq</span>),
where
<span class='texttt'><span class='textit'>T</span></span>
is a cv-qualified or cv-unqualified object type,
there exist candidate operator functions of the form</div><pre class='codeblock'>
<span class='textit'>T</span>*<span class='textit'>vq</span>&amp; operator++(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;);
<span class='textit'>T</span>*<span class='textit'>vq</span>&amp; operator--(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;);
<span class='textit'>T</span>*    operator++(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;, int);
<span class='textit'>T</span>*    operator--(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;, int);</pre></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3690'>#</a></div><div id='7.sentence-1' class='sentence'>For every cv-qualified or cv-unqualified object type
<span class='texttt'><span class='textit'>T</span></span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>&amp;    operator*(<span class='textit'>T</span>*);</pre></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3698'>#</a></div><div id='8.sentence-1' class='sentence'>For every function type
<span class='texttt'><span class='textit'>T</span></span> that does not have cv-qualifiers or a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>&amp;    operator*(<span class='textit'>T</span>*);</pre></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3706'>#</a></div><div id='9.sentence-1' class='sentence'>For every type <span class='texttt'><span class='textit'>T</span></span> there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>*    operator+(<span class='textit'>T</span>*);</pre></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3712'>#</a></div><div id='10.sentence-1' class='sentence'>For every promoted arithmetic type
<span class='texttt'><span class='textit'>T</span></span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span> operator+(<span class='textit'>T</span>);
<span class='textit'>T</span> operator-(<span class='textit'>T</span>);</pre></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3721'>#</a></div><div id='11.sentence-1' class='sentence'>For every promoted integral type
<span class='texttt'><span class='textit'>T</span></span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span> operator~(<span class='textit'>T</span>);</pre></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3729'>#</a></div><div id='12.sentence-1' class='sentence'>For every quintuple
(<span class='texttt'><span class='textit'>C1</span></span>,
<span class='texttt'><span class='textit'>C2</span></span>,
<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>cv1</span>,
<span class='textit'>cv2</span>),
where
<span class='texttt'><span class='textit'>C2</span></span>
is a class type,
<span class='texttt'><span class='textit'>C1</span></span>
is the same type as <span class='texttt'><span class='textit'>C2</span></span> or is a derived class of <span class='texttt'><span class='textit'>C2</span></span>, and
<span class='texttt'><span class='textit'>T</span></span>
is an object type or a function type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>cv12</span> <span class='textit'>T</span>&amp; operator-&gt;*(<span class='textit'>cv1</span> <span class='textit'>C1</span>*, <span class='textit'>cv2</span> <span class='textit'>T C2</span>::*);</pre></div><div id='12.sentence-2' class='sentence'>where <span class='textit'>cv12</span> is the union of <span class='textit'>cv1</span> and <span class='textit'>cv2</span><a class='hidden_link' href='#12.sentence-2'>.</a></div> <div id='12.sentence-3' class='sentence'>The return type is shown for exposition only; see <a href='expr.mptr.oper'>[expr.mptr.oper]</a> for the
determination of the operator's result type<a class='hidden_link' href='#12.sentence-3'>.</a></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3752'>#</a></div><div id='13.sentence-1' class='sentence'>For every pair of promoted arithmetic types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span>,
there exist candidate operator functions of the form</div><pre class='codeblock'>
<span class='textit'>LR</span>      operator*(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator/(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator+(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator-(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator==(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator!=(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator&lt;(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator&gt;(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator&lt;=(<span class='textit'>L</span>, <span class='textit'>R</span>);
bool    operator&gt;=(<span class='textit'>L</span>, <span class='textit'>R</span>);</pre><div id='13.sentence-2' class='sentence'>where
<span class='texttt'><span class='textit'>LR</span></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv'>[expr.arith.conv]</a>) between types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span><a class='hidden_link' href='#13.sentence-2'>.</a></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3779'>#</a></div><div id='14.sentence-1' class='sentence'>For every integral type <span class='texttt'><span class='textit'>T</span></span>
there exists a candidate operator function of the form</div><pre class='codeblock'>
std::strong_ordering operator&lt;=&gt;(<span class='textit'>T</span>, <span class='textit'>T</span>);</pre></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3787'>#</a></div><div id='15.sentence-1' class='sentence'>For every pair of floating-point types
<span class='texttt'><span class='textit'>L</span></span> and <span class='texttt'><span class='textit'>R</span></span>,
there exists a candidate operator function of the form</div><pre class='codeblock'>
std::partial_ordering operator&lt;=&gt;(<span class='textit'>L</span>, <span class='textit'>R</span>);</pre></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3796'>#</a></div><div id='16.sentence-1' class='sentence'>For every cv-qualified or cv-unqualified object type
<span class='texttt'><span class='textit'>T</span></span>
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>*      operator+(<span class='textit'>T</span>*, std::ptrdiff_t);
<span class='textit'>T</span>&amp;      operator[](<span class='textit'>T</span>*, std::ptrdiff_t);
<span class='textit'>T</span>*      operator-(<span class='textit'>T</span>*, std::ptrdiff_t);
<span class='textit'>T</span>*      operator+(std::ptrdiff_t, <span class='textit'>T</span>*);
<span class='textit'>T</span>&amp;      operator[](std::ptrdiff_t, <span class='textit'>T</span>*);</pre></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3808'>#</a></div><div id='17.sentence-1' class='sentence'>For every
<span class='texttt'><span class='textit'>T</span></span>,
where
<span class='texttt'><span class='textit'>T</span></span>
is a pointer to object type,
there exist candidate operator functions of the form
<pre class='codeblock'>
std::ptrdiff_t   operator-(<span class='textit'>T</span>, <span class='textit'>T</span>);</pre></div></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3819'>#</a></div><div id='18.sentence-1' class='sentence'>For every <span class='texttt'><span class='textit'>T</span></span>, where <span class='texttt'><span class='textit'>T</span></span> is an enumeration type or a pointer type,
there exist candidate operator functions of the form
<pre class='codeblock'>
bool    operator==(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool    operator!=(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool    operator&lt;(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool    operator&gt;(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool    operator&lt;=(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool    operator&gt;=(<span class='textit'>T</span>, <span class='textit'>T</span>);
<span class='textit'>R</span>       operator&lt;=&gt;(<span class='textit'>T</span>, <span class='textit'>T</span>);</pre></div><div id='18.sentence-2' class='sentence'>where <span class='texttt'><span class='textit'>R</span></span> is the result type specified in <a href='expr.spaceship'>[expr.spaceship]</a><a class='hidden_link' href='#18.sentence-2'>.</a></div></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3834'>#</a></div><div id='19.sentence-1' class='sentence'>For every <span class='texttt'><span class='textit'>T</span></span>, where <span class='texttt'><span class='textit'>T</span></span>
is a pointer-to-member type or <span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
bool                 operator==(<span class='textit'>T</span>, <span class='textit'>T</span>);
bool                 operator!=(<span class='textit'>T</span>, <span class='textit'>T</span>);
std::strong_equality operator&lt;=&gt;(<span class='textit'>T</span>, <span class='textit'>T</span>);</pre></div></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3844'>#</a></div><div id='20.sentence-1' class='sentence'>For every pair of promoted integral types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>LR</span>      operator%(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator&amp;(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator^(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>LR</span>      operator|(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>L</span>       operator&lt;&lt;(<span class='textit'>L</span>, <span class='textit'>R</span>);
<span class='textit'>L</span>       operator&gt;&gt;(<span class='textit'>L</span>, <span class='textit'>R</span>);</pre>
where
<span class='texttt'><span class='textit'>LR</span></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv'>[expr.arith.conv]</a>) between types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span><a class='hidden_link' href='#20.sentence-1'>.</a></div></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3865'>#</a></div><div id='21.sentence-1' class='sentence'>For every triple
(<span class='texttt'><span class='textit'>L</span></span>,
<span class='textit'>vq</span>,
<span class='texttt'><span class='textit'>R</span></span>),
where
<span class='texttt'><span class='textit'>L</span></span>
is an arithmetic type,
and
<span class='texttt'><span class='textit'>R</span></span>
is a promoted arithmetic type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator*=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator/=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator+=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator-=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);</pre></div></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3885'>#</a></div><div id='22.sentence-1' class='sentence'>For every pair (<span class='texttt'><span class='textit'>T</span></span>, <span class='textit'>vq</span>),
where <span class='texttt'><span class='textit'>T</span></span> is any type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;   operator=(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;, <span class='textit'>T</span>*);</pre></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3893'>#</a></div><div id='23.sentence-1' class='sentence'>For every pair
(<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>vq</span>),
where
<span class='texttt'><span class='textit'>T</span></span>
is an enumeration or pointer-to-member type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>vq</span> <span class='textit'>T</span>&amp;   operator=(<span class='textit'>vq</span> <span class='textit'>T</span>&amp;, <span class='textit'>T</span>);</pre></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3905'>#</a></div><div id='24.sentence-1' class='sentence'>For every pair
(<span class='texttt'><span class='textit'>T</span></span>,
<span class='textit'>vq</span>),
where
<span class='texttt'><span class='textit'>T</span></span>
is a cv-qualified or cv-unqualified object type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;   operator+=(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;, std::ptrdiff_t);
<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;   operator-=(<span class='textit'>T</span>*<span class='textit'>vq</span>&amp;, std::ptrdiff_t);</pre></div></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3918'>#</a></div><div id='25.sentence-1' class='sentence'>For every triple
(<span class='texttt'><span class='textit'>L</span></span>,
<span class='textit'>vq</span>,
<span class='texttt'><span class='textit'>R</span></span>),
where
<span class='texttt'><span class='textit'>L</span></span>
is an integral type, and
<span class='texttt'><span class='textit'>R</span></span>
is a promoted integral type,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator%=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator&lt;&lt;=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator&gt;&gt;=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator&amp;=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator^=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);
<span class='textit'>vq</span> <span class='textit'>L</span>&amp;   operator|=(<span class='textit'>vq</span> <span class='textit'>L</span>&amp;, <span class='textit'>R</span>);</pre></div></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3938'>#</a></div><div id='26.sentence-1' class='sentence'>There also exist candidate operator functions of the form
<pre class='codeblock'>
bool    operator!(bool);
bool    operator&amp;&amp;(bool, bool);
bool    operator||(bool, bool);</pre></div></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3946'>#</a></div><div id='27.sentence-1' class='sentence'>For every pair of promoted arithmetic types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span>,
there exist candidate operator functions of the form
<pre class='codeblock'>
<span class='textit'>LR</span>      operator?:(bool, <span class='textit'>L</span>, <span class='textit'>R</span>);</pre>
where
<span class='texttt'><span class='textit'>LR</span></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv'>[expr.arith.conv]</a>) between types
<span class='texttt'><span class='textit'>L</span></span>
and
<span class='texttt'><span class='textit'>R</span></span><a class='hidden_link' href='#27.sentence-1'>.</a></div> <div id='27.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#27.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='27.sentence-2' class='sentence'>As with all these descriptions of candidate functions, this declaration serves
only to describe the built-in operator for purposes of overload resolution<a class='hidden_link' href='#27.sentence-2'>.</a></div> <div id='27.sentence-3' class='sentence'>The operator
“<span class='texttt'>?:</span>”
cannot be overloaded<a class='hidden_link' href='#27.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/overloading.tex#L3969'>#</a></div><div id='28.sentence-1' class='sentence'>For every type
<span class='texttt'><span class='textit'>T</span></span>,
where
<span class='texttt'><span class='textit'>T</span></span>
is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator
functions of the form
<pre class='codeblock'>
<span class='textit'>T</span>       operator?:(bool, <span class='textit'>T</span>, <span class='textit'>T</span>);</pre></div></div></div></body></html>