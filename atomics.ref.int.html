<!DOCTYPE html><html lang='en'><head><title>[atomics.ref.int]</title><meta charset='UTF-8'><link rel='stylesheet' type='text/css' href='14882.css'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Serif'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans+Mono'><link rel='icon' href='icon.png'><link rel='stylesheet' type='text/css' href='expanded.css' title='Normal'><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'><link rel='alternate stylesheet' type='text/css' href='normative-only.css' title='Notes and examples hidden'></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:50pt'>32</a> Concurrency support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:65pt'>32.5</a> Atomic operations <a class='abbr_ref' href='atomics#ref.int'>[atomics]</a></h2><h3 ><a class='secnum' style='min-width:80pt'>32.5.7</a> Class template <span class='texttt'>atomic_<span class='shy'></span>ref</span> <a class='abbr_ref' href='atomics.ref.generic#atomics.ref.int'>[atomics.ref.generic]</a></h3><h4 ><a class='secnum' style='min-width:95pt'>32.5.7.3</a> Specializations for integral types <a class='abbr_ref'>[atomics.ref.int]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3664'>#</a></div><div class='texpara'><div id='1.sentence-1' class='sentence'><a class='index' id='lib:atomic_ref<integral-type>'></a>There are specializations of the <span class='texttt'>atomic_<span class='shy'></span>ref</span> class template
for all integral types except <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>bool</span></span><a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>For each such type <span class='texttt'><i >integral-type</i></span>,
the specialization <span class='texttt'>atomic_<span class='shy'></span>ref<span class='anglebracket'>&lt;</span><i >integral-type</i><span class='anglebracket'>&gt;</span></span> provides
additional atomic operations appropriate to integral types<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='note-1' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-1'>1</a></i>:&ensp;<div id='1.sentence-3' class='sentence'>The specialization <span class='texttt'>atomic_<span class='shy'></span>ref<span class='anglebracket'>&lt;</span><span class='keyword'>bool</span><span class='anglebracket'>&gt;</span></span>
uses the primary template (<a href='atomics.ref.generic' title='32.5.7&emsp;Class template atomic_&shy;ref'>[atomics.<span class='shy'></span>ref.<span class='shy'></span>generic]</a>)<a class='hidden_link' href='#1.sentence-3'>.</a></div> â€”&nbsp;<i>end note</i>]</div></div></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3676'>#</a></div><div class='texpara'><div id='2.sentence-1' class='sentence'>The program is ill-formed
if <span class='texttt'>is_<span class='shy'></span>always_<span class='shy'></span>lock_<span class='shy'></span>free</span> is <span class='texttt'><span class='literal'>false</span></span> and
<span class='texttt'>is_<span class='shy'></span>volatile_<span class='shy'></span>v<span class='anglebracket'>&lt;</span>T<span class='anglebracket'>&gt;</span></span> is <span class='texttt'><span class='literal'>true</span></span><a class='hidden_link' href='#2.sentence-1'>.</a></div></div><div class='texpara'><span class='codeblock'><span class='keyword'>namespace</span> std <span class='curlybracket'>{</span>
  <span class='keyword'>template</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&gt;</span> <span class='keyword'>struct</span> atomic_ref<span class='anglebracket'>&lt;</span><i >integral-type</i><span class='anglebracket'>&gt;</span> <span class='curlybracket'>{</span>
  <span class='keyword'>private</span><span class='operator'>:</span>
    <i >integral-type</i><span class='operator'>*</span> ptr;         <span class='comment'>// <i >exposition only</i></span>

  <span class='keyword'>public</span><span class='operator'>:</span>
    <span class='keyword'>using</span> value_type <span class='operator'>=</span> remove_cv_t<span class='anglebracket'>&lt;</span><i >integral-type</i><span class='anglebracket'>&gt;</span>;
    <span class='keyword'>using</span> difference_type <span class='operator'>=</span> value_type;
    <span class='keyword'>static</span> <span class='keyword'>constexpr</span> size_t required_alignment <span class='operator'>=</span> <a class='index' id=':required_alignment_for_atomic_ref_type&#39;s_operations'></a><i >implementation-defined</i>;

    <span class='keyword'>static</span> <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> is_always_lock_free <span class='operator'>=</span> <a class='index' id=':whether_a_given_atomic_ref_type&#39;s_operations_are_always_lock_free'></a><i >implementation-defined</i>;
    <span class='keyword'>bool</span> is_lock_free<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> <span class='keyword'>explicit</span> atomic_ref<span class='parenthesis'>(</span><i >integral-type</i><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
    <span class='keyword'>constexpr</span> atomic_ref<span class='parenthesis'>(</span><span class='keyword'>const</span> atomic_ref<span class='operator'>&amp;</span><span class='parenthesis'>)</span> <span class='keyword'>noexcept</span>;
    atomic_ref<span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><span class='keyword'>const</span> atomic_ref<span class='operator'>&amp;</span><span class='parenthesis'>)</span> <span class='operator'>=</span> <span class='keyword'>delete</span>;

    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store<span class='parenthesis'>(</span>value_type, memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type load<span class='parenthesis'>(</span>memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>operator</span> value_type<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> value_type exchange<span class='parenthesis'>(</span>value_type,
                                  memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> compare_exchange_weak<span class='parenthesis'>(</span>value_type<span class='operator'>&amp;</span>, value_type,
                                         memory_order, memory_order<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> compare_exchange_strong<span class='parenthesis'>(</span>value_type<span class='operator'>&amp;</span>, value_type,
                                           memory_order, memory_order<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> compare_exchange_weak<span class='parenthesis'>(</span>value_type<span class='operator'>&amp;</span>, value_type,
                                         memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>bool</span> compare_exchange_strong<span class='parenthesis'>(</span>value_type<span class='operator'>&amp;</span>, value_type,
                                           memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> value_type fetch_add<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_sub<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_and<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_or<span class='parenthesis'>(</span>value_type,
                                  memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_xor<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_max<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type fetch_min<span class='parenthesis'>(</span>value_type,
                                   memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_add<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_sub<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_and<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_or<span class='parenthesis'>(</span>value_type,
                            memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_xor<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_max<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_min<span class='parenthesis'>(</span>value_type,
                             memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>&amp;</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>|</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span><span class='operator'>^</span><span class='operator'>=</span><span class='parenthesis'>(</span>value_type<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;

    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> wait<span class='parenthesis'>(</span>value_type, memory_order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> notify_one<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <span class='keyword'>void</span> notify_all<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
    <span class='keyword'>constexpr</span> <i >integral-type</i><span class='operator'>*</span> address<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
  <span class='curlybracket'>}</span>;
<span class='curlybracket'>}</span>
</span></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3763'>#</a></div><div class='texpara'><div id='3.sentence-1' class='sentence'>Descriptions are provided below only for members
that differ from the primary template<a class='hidden_link' href='#3.sentence-1'>.</a></div></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3767'>#</a></div><div class='texpara'><div id='4.sentence-1' class='sentence'>The following operations perform arithmetic computations<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>The correspondence among key, operator, and computation is specified
in Table <a href='atomics.types.int#tab:atomic.types.int.comp' title='Table 155: Atomic arithmetic computations'>155</a><a class='hidden_link' href='#4.sentence-2'>.</a></div></div></div><div class='texpara'><div id='lib:atomic_ref<integral-type>,fetch_xor'><div id='lib:fetch_xor,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_sub'><div id='lib:fetch_sub,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_or'><div id='lib:fetch_or,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_min'><div id='lib:fetch_min,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_max'><div id='lib:fetch_max,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_and'><div id='lib:fetch_and,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,fetch_add'><div id='lib:fetch_add,atomic_ref<integral-type>'><div class='itemdecl'><div class='marginalizedparent'><a class='itemDeclLink' href='#lib:fetch_add,atomic_ref%3cintegral-type%3e'>ðŸ”—</a></div><code class='itemdeclcode'><span class='keyword'>constexpr</span> value_type fetch_<i >key</i><span class='parenthesis'>(</span>value_type operand,
  memory_order order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
</code></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3785'>#</a></div><div class='texpara'><div id='5.sentence-1' class='sentence'><i >Constraints</i>: <span class='texttt'>is_<span class='shy'></span>const_<span class='shy'></span>v<span class='anglebracket'>&lt;</span><i >integral-type</i><span class='anglebracket'>&gt;</span></span> is <span class='texttt'><span class='literal'>false</span></span><a class='hidden_link' href='#5.sentence-1'>.</a></div></div></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3789'>#</a></div><div class='texpara'><div id='6.sentence-1' class='sentence'><i >Effects</i>: Atomically replaces the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span> with
the result of the computation applied to the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span>
and the given operand<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>Memory is affected according to the value of <span class='texttt'>order</span><a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>These operations are atomic read-modify-write operations (<a href='intro.races' title='6.10.2.2&emsp;Data races'>[intro.<span class='shy'></span>races]</a>)<a class='hidden_link' href='#6.sentence-3'>.</a></div></div></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3797'>#</a></div><div class='texpara'><div id='7.sentence-1' class='sentence'><i >Returns</i>: Atomically, the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span>
immediately before the effects<a class='hidden_link' href='#7.sentence-1'>.</a></div></div></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3802'>#</a></div><div class='texpara'><div id='8.sentence-1' class='sentence'><a class='index' id=':signed_integer_representation,two&#39;s_complement'></a><i >Remarks</i>: Except for <span class='texttt'>fetch_<span class='shy'></span>max</span> and <span class='texttt'>fetch_<span class='shy'></span>min</span>, for signed integer types
the result is as if the object value and parameters
were converted to their corresponding unsigned types,
the computation performed on those types, and
the result converted back to the signed type<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='note-2' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-2'>2</a></i>:&ensp;<div id='8.sentence-2' class='sentence'>There are no undefined results arising from the computation<a class='hidden_link' href='#8.sentence-2'>.</a></div> â€”&nbsp;<i>end note</i>]</div></div></div></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3814'>#</a></div><div class='texpara'><div id='9.sentence-1' class='sentence'>For <span class='texttt'>fetch_<span class='shy'></span>max</span> and <span class='texttt'>fetch_<span class='shy'></span>min</span>, the maximum and minimum
computation is performed as if by <span class='texttt'>max</span> and <span class='texttt'>min</span>
algorithms (<a href='alg.min.max' title='26.8.9&emsp;Minimum and maximum'>[alg.<span class='shy'></span>min.<span class='shy'></span>max]</a>), respectively,
with the object value and the first parameter as the arguments<a class='hidden_link' href='#9.sentence-1'>.</a></div></div></div></div><div class='texpara'><div id='lib:atomic_ref<integral-type>,store_sub'><div id='lib:store_sub,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,store_or'><div id='lib:store_or,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,store_min'><div id='lib:store_min,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,store_max'><div id='lib:store_max,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,store_and'><div id='lib:store_and,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,store_add'><div id='lib:store_add,atomic_ref<integral-type>'><div class='itemdecl'><div class='marginalizedparent'><a class='itemDeclLink' href='#lib:store_add,atomic_ref%3cintegral-type%3e'>ðŸ”—</a></div><code class='itemdeclcode'><span class='keyword'>constexpr</span> <span class='keyword'>void</span> store_<i >key</i><span class='parenthesis'>(</span>value_type operand,
                         memory_order order <span class='operator'>=</span> memory_order<span class='operator'>::</span>seq_cst<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
</code></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3833'>#</a></div><div class='texpara'><div id='10.sentence-1' class='sentence'><i >Preconditions</i>: <span class='texttt'>order</span> is <span class='texttt'>memory_<span class='shy'></span>order<span class='operator'>&#x200b;::&#x200b;</span>relaxed</span>,
<span class='texttt'>memory_<span class='shy'></span>order<span class='operator'>&#x200b;::&#x200b;</span>release</span>, or
<span class='texttt'>memory_<span class='shy'></span>order<span class='operator'>&#x200b;::&#x200b;</span>seq_<span class='shy'></span>cst</span><a class='hidden_link' href='#10.sentence-1'>.</a></div></div></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3839'>#</a></div><div class='texpara'><div id='11.sentence-1' class='sentence'><i >Effects</i>: Atomically replaces the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span>
with the result of the computation applied to
the value referenced by <span class='texttt'><span class='operator'>*</span>ptr</span> and the given <span class='texttt'>operand</span><a class='hidden_link' href='#11.sentence-1'>.</a></div> <div id='11.sentence-2' class='sentence'>Memory is affected according to the value of <span class='texttt'>order</span><a class='hidden_link' href='#11.sentence-2'>.</a></div> <div id='11.sentence-3' class='sentence'>These operations are atomic modify-write operations (<a href='atomics.order' title='32.5.4&emsp;Order and consistency'>[atomics.<span class='shy'></span>order]</a>)<a class='hidden_link' href='#11.sentence-3'>.</a></div></div></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3847'>#</a></div><div class='texpara'><div id='12.sentence-1' class='sentence'><i >Remarks</i>: Except for <span class='texttt'>store_<span class='shy'></span>max</span> and <span class='texttt'>store_<span class='shy'></span>min</span>,
for signed integer types,
the result is as if <span class='texttt'><span class='operator'>*</span>ptr</span> and parameters
were converted to their corresponding unsigned types,
the computation performed on those types, and
the result converted back to the signed type<a class='hidden_link' href='#12.sentence-1'>.</a></div> <div id='note-3' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-3'>3</a></i>:&ensp;<div id='12.sentence-2' class='sentence'>There are no undefined results arising from the computation<a class='hidden_link' href='#12.sentence-2'>.</a></div> â€”&nbsp;<i>end note</i>]</div></div> <div id='12.sentence-3' class='sentence'>
For <span class='texttt'>store_<span class='shy'></span>max</span> and <span class='texttt'>store_<span class='shy'></span>min</span>,
the maximum and minimum computation is performed
as if by <span class='texttt'>max</span> and <span class='texttt'>min</span> algorithms (<a href='alg.min.max' title='26.8.9&emsp;Minimum and maximum'>[alg.<span class='shy'></span>min.<span class='shy'></span>max]</a>), respectively,
with <span class='texttt'><span class='operator'>*</span>ptr</span> and the first parameter as the arguments<a class='hidden_link' href='#12.sentence-3'>.</a></div></div></div></div><div class='texpara'><div id='lib:atomic_ref<integral-type>,operator^='><div id='lib:operator^=,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,operator|='><div id='lib:operator|=,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,operator&amp;='><div id='lib:operator&amp;=,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,operator-='><div id='lib:operator-=,atomic_ref<integral-type>'><div id='lib:atomic_ref<integral-type>,operator+='><div id='lib:operator+=,atomic_ref<integral-type>'><div class='itemdecl'><div class='marginalizedparent'><a class='itemDeclLink' href='#lib:operator+=,atomic_ref%3cintegral-type%3e'>ðŸ”—</a></div><code class='itemdeclcode'><span class='keyword'>constexpr</span> value_type <span class='keyword'>operator</span> <i >op</i><span class='operator'>=</span><span class='parenthesis'>(</span>value_type operand<span class='parenthesis'>)</span> <span class='keyword'>const</span> <span class='keyword'>noexcept</span>;
</code></div></div></div></div></div></div></div></div></div></div></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3874'>#</a></div><div class='texpara'><div id='13.sentence-1' class='sentence'><i >Constraints</i>: <span class='texttt'>is_<span class='shy'></span>const_<span class='shy'></span>v<span class='anglebracket'>&lt;</span><i >integral-type</i><span class='anglebracket'>&gt;</span></span> is <span class='texttt'><span class='literal'>false</span></span><a class='hidden_link' href='#13.sentence-1'>.</a></div></div></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/c3bd02a2e44c53c8fe7ba5b48a94bacc9186235d/source/threads.tex#L3878'>#</a></div><div class='texpara'><div id='14.sentence-1' class='sentence'><i >Effects</i>: Equivalent to:
<span class='texttt'><span class='keyword'>return</span> fetch_<span class='shy'></span><i >key</i><span class='parenthesis'>(</span>operand<span class='parenthesis'>)</span> <i >op</i> operand;</span></div></div></div></div></div></body></html>