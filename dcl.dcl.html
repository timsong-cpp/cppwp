<!DOCTYPE html><html lang='en'><head><title>[dcl.dcl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='dcl.dcl'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><p ><span class='indexparent'><a class='index' id='declaration'></a></span></p><p ><span class='indexparent'><a class='index' id='linkage_specification'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Declarations generally specify how names are to be interpreted. Declarations have
the form</p><pre class='bnf'><a id='nt:declaration-seq'>declaration-seq:</a>
    <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>
    <i ><a href='dcl.dcl#nt:declaration-seq'>declaration-seq</a></i> <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i></pre><pre class='bnf'><a id='nt:declaration'>declaration:</a>
    <i ><a href='dcl.dcl#nt:block-declaration'>block-declaration</a></i>
    <i ><a href='dcl.dcl#nt:nodeclspec-function-declaration'>nodeclspec-function-declaration</a></i>
    <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
    <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>
    <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>
    <i ><a href='temp.explicit#nt:explicit-instantiation'>explicit-instantiation</a></i>
    <i ><a href='temp.expl.spec#nt:explicit-specialization'>explicit-specialization</a></i>
    <i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i>
    <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i>
    <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i>
    <i ><a href='dcl.dcl#nt:attribute-declaration'>attribute-declaration</a></i></pre><pre class='bnf'><a id='nt:block-declaration'>block-declaration:</a>
    <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i>
    <i ><a href='dcl.asm#nt:asm-definition'>asm-definition</a></i>
    <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i>
    <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
    <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>
    <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>
    <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
    <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i></pre><pre class='bnf'><a id='nt:nodeclspec-function-declaration'>nodeclspec-function-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:alias-declaration'>alias-declaration:</a>
    <span class='terminal'>using</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>=</span> <i ><a href='dcl.name#nt:defining-type-id'>defining-type-id</a></i> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:simple-declaration'>simple-declaration:</a>
    <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> <span class='terminal'>;</span>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <span class='terminal'>[</span> <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> <span class='terminal'>]</span> <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:static_assert-declaration'>static_assert-declaration:</a>
  <span class='terminal'>static_assert</span> <span class='terminal'>(</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>)</span> <span class='terminal'>;</span>
  <span class='terminal'>static_assert</span> <span class='terminal'>(</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>,</span> <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <span class='terminal'>)</span> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:empty-declaration'>empty-declaration:</a>
    <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:attribute-declaration'>attribute-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> <span class='terminal'>;</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span>
<i ><a href='dcl.asm#nt:asm-definition'>asm-definitions</a></i> are described in <a href='dcl.asm'>[dcl.asm]</a>, and
<i ><a href='dcl.link#nt:linkage-specification'>linkage-specifications</a></i> are described in <a href='dcl.link'>[dcl.link]</a>.
<i ><a href='dcl.fct.def.general#nt:function-definition'>Function-definitions</a></i> are described in <a href='dcl.fct.def'>[dcl.fct.def]</a> and
<i ><a href='temp#nt:template-declaration'>template-declarations</a></i> and
<i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guides</a></i> are described in Clause <a href='temp'>[temp]</a>.
<i ><a href='namespace.def#nt:namespace-definition'>Namespace-definitions</a></i> are described in <a href='namespace.def'>[namespace.def]</a>,
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> are described in <a href='namespace.udecl'>[namespace.udecl]</a> and
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> are described in <a href='namespace.udir'>[namespace.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A
<i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i> or
<i ><a href='dcl.dcl#nt:nodeclspec-function-declaration'>nodeclspec-function-declaration</a></i> of the form</p><pre class='bnf'><i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span></pre><p >is divided into three parts.
Attributes are described in <a href='dcl.attr'>[dcl.attr]</a>.
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i>, the principal components of
a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, are described in <a href='dcl.spec'>[dcl.spec]</a>.
<i ><a href='dcl.decl#nt:declarator'>declarators</a></i>, the components of an
<i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>, are described in Clause <a href='dcl.decl'>[dcl.decl]</a>.
The <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
appertains to each of the entities declared by
the <i ><a href='dcl.decl#nt:declarator'>declarators</a></i>
of the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span> In the declaration for an entity, attributes appertaining to that
entity may appear at the start of the declaration and after the
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> for that declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
[[noreturn]] void f [[noreturn]] (); <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Except where otherwise specified, the meaning of an <i ><a href='dcl.dcl#nt:attribute-declaration'>attribute-declaration</a></i>
is <span class='indexparent'><a class='index' id='meaning_of_attribute_declaration'></a></span>implementation-defined.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='declaration'></a></span><span class='indexparent'><a class='index' id='scope'></a></span>A declaration occurs in a scope (<a href='basic.scope'>[basic.scope]</a>); the scope rules are
summarized in <a href='basic.lookup'>[basic.lookup]</a>. A declaration that declares a function
or defines a class, namespace, template, or function also has one or
more scopes nested within it. These nested scopes, in turn, can have
declarations nested within them. Unless otherwise stated, utterances in
Clause <a href='dcl.dcl'>[dcl.dcl]</a> about components in, of, or contained by a
declaration or subcomponent thereof refer only to those components of
the declaration that are <span class='emph'>not</span> nested within scopes nested within
the declaration.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='identifier'></a></span><span class='indexparent'><a class='index' id='declarator'></a></span>In a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i>, the optional
<i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> can be omitted only when declaring a
class (Clause <a href='class'>[class]</a>) or enumeration (<a href='dcl.enum'>[dcl.enum]</a>), that is,
when the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> contains either a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i>, an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> with
a <i ><a href='class#nt:class-key'>class-key</a></i> (<a href='class.name'>[class.name]</a>), or an
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>. In these cases and whenever a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> or <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> is present in
the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, the identifiers in these specifiers
are among the names being declared by the declaration (as
<i ><a href='class#nt:class-name'>class-names</a></i>, <i ><a href='dcl.enum#nt:enum-name'>enum-names</a></i>, or
<i ><a href='dcl.enum#nt:enumerator'>enumerators</a></i>, depending on the syntax). In such cases,
the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> shall introduce one or more names into
the program, or shall redeclare a name introduced by a previous
declaration.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum { };           <span class='comment'>// ill-formed
</span>typedef class { };  <span class='comment'>//  ill-formed
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='static_assert'></a></span>In a <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>, the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be
a contextually converted constant expression
of type <span class='texttt'>bool</span> (<a href='expr.const'>[expr.const]</a>).
If the value of the expression when
so converted is <span class='texttt'>true</span>, the declaration has no
effect. Otherwise, the program is ill-formed, and the resulting
diagnostic message (<a href='intro.compliance'>[intro.compliance]</a>) shall include the text of
the <i ><a href='lex.string#nt:string-literal'>string-literal</a></i>, if one is supplied,
except that characters not in the basic
source character set (<a href='lex.charset'>[lex.charset]</a>) are not required to appear in
the diagnostic message.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
static_assert(char(-1) &lt; 0, "this library requires plain 'char' to be signed");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >An <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i> has no effect.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i> with an <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> is called
a <a id='decomposition_declaration'><i>decomposition declaration</i></a> (<a href='dcl.decomp'>[dcl.decomp]</a>). The <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> shall
contain only the <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <span class='texttt'>auto</span> (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>)
and <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i>. The <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
shall be of the form “<span class='texttt'>=</span> <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>” or of the
form “<span class='texttt'>{</span> <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> <span class='texttt'>}</span>”, where the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> is of array or non-union class type.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >Each <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i> in the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
contains exactly one <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>, which is the name
declared by that <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i> and hence one of the names
declared by the declaration. The
<span class='grammarterm'>defining-type-specifiers</span> (<a href='dcl.type'>[dcl.type]</a>) in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and the recursive <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>
structure of the <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i> describe a
type (<a href='dcl.meaning'>[dcl.meaning]</a>), which is then associated with the name being
declared by the <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> contains the <span class='texttt'>typedef</span>
specifier, the declaration is called a <i>typedef declaration</i> and the name
of each <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>
is declared to be a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>, synonymous with its
associated type (<a href='dcl.typedef'>[dcl.typedef]</a>). If the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> contains no <span class='texttt'>typedef</span> specifier, the
declaration is called a <i>function declaration</i> if
the type associated with the name is a function type (<a href='dcl.fct'>[dcl.fct]</a>) and
an <i>object declaration</i> otherwise.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='definition,declaration_as'></a></span>Syntactic components beyond those found in the general form of
declaration are added to a function declaration to make a
<i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>. An object declaration, however, is also
a definition unless it contains the <span class='texttt'>extern</span> specifier and has no
initializer (<a href='basic.def'>[basic.def]</a>).
<span class='indexparent'><a class='index' id='initialization,definition_and'></a></span>A
definition causes the appropriate amount of storage to be reserved and
any appropriate initialization (<a href='dcl.init'>[dcl.init]</a>) to be done.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >A <i ><a href='dcl.dcl#nt:nodeclspec-function-declaration'>nodeclspec-function-declaration</a></i> shall declare a
constructor, destructor, or conversion function.  <a class='footnotenum' href='#footnote-92'>92</a>
[&nbsp;<i>Note:</i><span class='space'></span>
A <i ><a href='dcl.dcl#nt:nodeclspec-function-declaration'>nodeclspec-function-declaration</a></i> can only be used in a
<i ><a href='temp#nt:template-declaration'>template-declaration</a></i> (Clause <a href='temp'>[temp]</a>),
<i ><a href='temp.explicit#nt:explicit-instantiation'>explicit-instantiation</a></i> (<a href='temp.explicit'>[temp.explicit]</a>), or
<i ><a href='temp.expl.spec#nt:explicit-specialization'>explicit-specialization</a></i> (<a href='temp.expl.spec'>[temp.expl.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-92'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-92'>92)</a></div><p >The
“implicit int” rule of C is no longer supported.</p></div><div id='dcl.spec'><h2 ><a class='secnum' href='#dcl.spec' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec'>[dcl.spec]</a></h2><p ><span class='indexparent'><a class='index' id='specifier'></a></span></p><div class='para' id='dcl.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specifier,declaration'></a></span>The specifiers that can be used in a declaration are</p><pre class='bnf'><a id='nt:decl-specifier'>decl-specifier:</a>
    <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
    <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>
    <i ><a href='dcl.fct.spec#nt:function-specifier'>function-specifier</a></i>
    <span class='terminal'>friend</span>
    <span class='terminal'>typedef</span>
    <span class='terminal'>constexpr</span>
    <span class='terminal'>inline</span></pre><pre class='bnf'><a id='nt:decl-specifier-seq'>decl-specifier-seq:</a>
    <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
appertains to the type determined by the preceding
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> (<a href='dcl.meaning'>[dcl.meaning]</a>). The <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
affects the type only for the declaration it appears in, not other declarations involving the
same type.</p></div><div class='para' id='dcl.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec-2'>2</a></div><p >Each <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> shall appear at most once in a complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, except that
<span class='texttt'>long</span> may appear twice.</p></div><div class='para' id='dcl.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec-3'>3</a></div><p ><span class='indexparent'><a class='index' id='ambiguity,declaration_type'></a></span>If a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is encountered while parsing a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>,
it is interpreted as part of the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> if and only if there is no
previous <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> other than a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.
The sequence shall be self-consistent as
described below.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef char* Pc;
static Pc;                      <span class='comment'>// error: name missing
</span></pre><p >Here, the declaration <span class='texttt'>static</span> <span class='texttt'>Pc</span> is ill-formed because no
name was specified for the static variable of type <span class='texttt'>Pc</span>. To get a
variable called <span class='texttt'>Pc</span>, a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> (other than
<span class='texttt'>const</span> or <span class='texttt'>volatile</span>) has to be present to indicate that
the <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> <span class='texttt'>Pc</span> is the name being (re)declared,
rather than being part of the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> sequence. For
another example,</p><pre class='codeblock'>
void f(const Pc);               <span class='comment'>// <span class='texttt'>void f(char* const)</span> (not <span class='texttt'>const char*</span>)
</span>void g(const int Pc);           <span class='comment'>// <span class='texttt'>void g(const int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec-4'>4</a></div><p ><span class='indexparent'><a class='index' id='signed,typedef'></a></span><span class='indexparent'><a class='index' id='unsigned,typedef'></a></span><span class='indexparent'><a class='index' id='long,typedef'></a></span><span class='indexparent'><a class='index' id='short,typedef'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
Since <span class='texttt'>signed</span>, <span class='texttt'>unsigned</span>, <span class='texttt'>long</span>, and <span class='texttt'>short</span>
by default imply <span class='texttt'>int</span>, a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> appearing after one
of those specifiers is treated as the name being (re)declared.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void h(unsigned Pc);            <span class='comment'>// <span class='texttt'>void h(unsigned int)</span>
</span>void k(unsigned int Pc);        <span class='comment'>// <span class='texttt'>void k(unsigned int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='dcl.stc'><h3 ><a class='secnum' href='#dcl.stc' style='min-width:103pt'>7.1.1</a> Storage class specifiers <a class='abbr_ref' href='dcl.stc'>[dcl.stc]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,storage_class'></a></span><span class='indexparent'><a class='index' id='declaration,storage_class'></a></span><span class='indexparent'><a class='index' id='static'></a></span><span class='indexparent'><a class='index' id='thread_local'></a></span><span class='indexparent'><a class='index' id='extern'></a></span><span class='indexparent'><a class='index' id='mutable'></a></span></p><div class='para' id='dcl.stc-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-1'>1</a></div><p >The storage class specifiers are</p><pre class='bnf'><a id='nt:storage-class-specifier'>storage-class-specifier:</a>
    <span class='terminal'>static</span>
    <span class='terminal'>thread_local</span>
    <span class='terminal'>extern</span>
    <span class='terminal'>mutable</span></pre><p >At most one <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> shall appear in a given
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, except that <span class='texttt'>thread_local</span> may appear with <span class='texttt'>static</span> or 
<span class='texttt'>extern</span>. If <span class='texttt'>thread_local</span> appears in any declaration of
a variable it shall be present in all declarations of that entity. If a 
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
appears in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, there can be no
<span class='texttt'>typedef</span> specifier in the same <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and
the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> or <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i>
of the declaration shall not be
empty (except for an anonymous union declared in a named namespace or in the
global namespace, which shall be declared
<span class='indexparent'><a class='index' id='specifier,static'></a></span><span class='texttt'>static</span> (<a href='class.union.anon'>[class.union.anon]</a>)). The
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> applies to the name declared by each
<i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i> in the list and not to any names declared by
other specifiers. A <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
other than <span class='texttt'>thread_local</span>
shall not be
specified in an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) or an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) directive.</p></div><div class='para' id='dcl.stc-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A variable declared without a <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
at block scope or declared as a function parameter
has automatic storage duration by default (<a href='basic.stc.auto'>[basic.stc.auto]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.stc-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-3'>3</a></div><p >The <span class='texttt'>thread_local</span> specifier
indicates that the named entity has thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). It
shall be applied only
to the names of variables of namespace
or block scope and to the names of static data members.
When <span class='texttt'>thread_local</span> is applied to a variable of block scope the
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> <span class='texttt'>static</span> is implied if no other
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> appears in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.</p></div><div class='para' id='dcl.stc-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-4'>4</a></div><p ><span class='indexparent'><a class='index' id='restriction,static'></a></span>The <span class='texttt'>static</span> specifier can be applied only to names of variables and
functions and to anonymous unions (<a href='class.union.anon'>[class.union.anon]</a>). There can be no
<span class='texttt'>static</span> function declarations within a block, nor any
<span class='texttt'>static</span> function parameters. A <span class='texttt'>static</span> specifier used in
the declaration of a variable declares the variable to have static storage
duration (<a href='basic.stc.static'>[basic.stc.static]</a>), unless accompanied by the
<span class='texttt'>thread_local</span> specifier, which declares the variable to have thread
storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). A <span class='texttt'>static</span> specifier can be
used in declarations of class members; <a href='class.static'>[class.static]</a> describes its
effect.
<span class='indexparent'><a class='index' id='static,linkage_of'></a></span>For the linkage of a name declared with a <span class='texttt'>static</span> specifier,
see <a href='basic.link'>[basic.link]</a>.</p></div><div class='para' id='dcl.stc-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-5'>5</a></div><p ><span class='indexparent'><a class='index' id='restriction,extern'></a></span>The <span class='texttt'>extern</span> specifier can be applied only to the names of variables
and functions. The <span class='texttt'>extern</span> specifier cannot be used in the
declaration of class members or function parameters.
<span class='indexparent'><a class='index' id='extern,linkage_of'></a></span><span class='indexparent'><a class='index' id='consistency,linkage'></a></span>For the linkage of a name declared with an <span class='texttt'>extern</span> specifier,
see <a href='basic.link'>[basic.link]</a>.
[&nbsp;<i>Note:</i><span class='space'></span>
The <span class='texttt'>extern</span> keyword can also be used in
<span class='small'></span><span class='rmfamily'></span><i> explicit-instantiation</i>s and
<span class='small'></span><span class='rmfamily'></span><i> linkage-specification</i>s, but it is not a
<span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i> in such contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.stc-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-6'>6</a></div><p >The linkages implied by successive declarations for a given entity shall
agree. That is, within a given scope, each declaration declaring the
same variable name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions
can have a different linkage, however.
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='example,linkage_consistency'></a></span>
</p><pre class='codeblock'>
static char* f();               <span class='comment'>// <span class='texttt'>f()</span> has internal linkage
</span>char* f()                       <span class='comment'>// <span class='texttt'>f()</span> still has internal linkage
</span>  { <span class='comment'>/* ... */</span> }

char* g();                      <span class='comment'>// <span class='texttt'>g()</span> has external linkage
</span>static char* g()                <span class='comment'>// error: inconsistent linkage
</span>  { <span class='comment'>/* ... */</span> }

void h();
inline void h();                <span class='comment'>// external linkage
</span>
inline void l();
void l();                       <span class='comment'>// external linkage
</span>
inline void m();
extern void m();                <span class='comment'>// external linkage
</span>
static void n();
inline void n();                <span class='comment'>// internal linkage
</span>
static int a;                   <span class='comment'>// <span class='texttt'>a</span> has internal linkage
</span>int a;                          <span class='comment'>// error: two definitions
</span>
static int b;                   <span class='comment'>// <span class='texttt'>b</span> has internal linkage
</span>extern int b;                   <span class='comment'>// <span class='texttt'>b</span> still has internal linkage
</span>
int c;                          <span class='comment'>// <span class='texttt'>c</span> has external linkage
</span>static int c;                   <span class='comment'>// error: inconsistent linkage
</span>
extern int d;                   <span class='comment'>// <span class='texttt'>d</span> has external linkage
</span>static int d;                   <span class='comment'>// error: inconsistent linkage
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-7'>7</a></div><p ><span class='indexparent'><a class='index' id='declaration,forward'></a></span>The name of a declared but undefined class can be used in an
<span class='texttt'>extern</span> declaration. Such a declaration can only be used in ways
that do not require a complete class type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S;
extern S a;
extern S f();
extern void g(S);

void h() {
  g(a);                         <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>  f();                          <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-8'>8</a></div><p >The <span class='texttt'>mutable</span> specifier shall appear only in the declaration of
a non-static data member (<a href='class.mem'>[class.mem]</a>)
whose type is neither const-qualified nor a reference type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class X {
  mutable const int* p;         <span class='comment'>// OK
</span>  mutable int* const q;         <span class='comment'>// ill-formed
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-9'>9</a></div><p >The <span class='texttt'>mutable</span> specifier on a class data member nullifies a
<span class='texttt'>const</span> specifier applied to the containing class object and
permits modification of the mutable class member even though the rest of
the object is <span class='texttt'>const</span> (<a href='dcl.type.cv'>[dcl.type.cv]</a>).</p></div></div><div id='dcl.fct.spec'><h3 ><a class='secnum' href='#dcl.fct.spec' style='min-width:103pt'>7.1.2</a> Function specifiers <a class='abbr_ref' href='dcl.fct.spec'>[dcl.fct.spec]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,function'></a></span><span class='indexparent'><a class='index' id='function'></a></span></p><div class='para' id='dcl.fct.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-1'>1</a></div><p ><span class='grammarterm'>Function-specifiers</span>
can be used only in function declarations.</p><pre class='bnf'><a id='nt:function-specifier'>function-specifier:</a>
    <span class='terminal'>virtual</span>
    <span class='terminal'>explicit</span></pre></div><div class='para' id='dcl.fct.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-2'>2</a></div><p ><span class='indexparent'><a class='index' id='specifier,virtual'></a></span>The <span class='texttt'>virtual</span> specifier shall be used only in the initial
declaration of a non-static class member function;
see <a href='class.virtual'>[class.virtual]</a>.</p></div><div class='para' id='dcl.fct.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-3'>3</a></div><p ><span class='indexparent'><a class='index' id='specifier,explicit'></a></span>The <span class='texttt'>explicit</span> specifier shall be used only in the declaration of
a constructor or conversion function within its class definition;
see <a href='class.conv.ctor'>[class.conv.ctor]</a> and <a href='class.conv.fct'>[class.conv.fct]</a>.</p></div></div><div id='dcl.typedef'><h3 ><a class='secnum' href='#dcl.typedef' style='min-width:103pt'>7.1.3</a> The <span class='texttt'>typedef</span> specifier <a class='abbr_ref' href='dcl.typedef'>[dcl.typedef]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,typedef'></a></span></p><div class='para' id='dcl.typedef-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-1'>1</a></div><p >Declarations containing the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <span class='texttt'>typedef</span>
declare identifiers that can be used later for naming
fundamental (<a href='basic.fundamental'>[basic.fundamental]</a>) or compound (<a href='basic.compound'>[basic.compound]</a>)
types. The <span class='texttt'>typedef</span> specifier shall not be
combined in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> with any other kind of
specifier except a <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>, and it shall not be used in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> (<a href='dcl.fct'>[dcl.fct]</a>) nor in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
If a <span class='texttt'>typedef</span> specifier appears in a declaration without a <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>,
the program is ill-formed.</p><pre class='bnf'><a id='nt:typedef-name'>typedef-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><p >A name declared with the <span class='texttt'>typedef</span> specifier becomes a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>. Within the scope of its declaration, a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is syntactically equivalent to a keyword and
names the type associated with the identifier in the way described in
Clause <a href='dcl.decl'>[dcl.decl]</a>.
<span class='indexparent'><a class='index' id='declaration,typedef'></a></span><span class='indexparent'><a class='index' id='equivalence,type'></a></span><span class='indexparent'><a class='index' id='synonym,type_name_as'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is thus a synonym for another type. A
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> does not introduce a new type the way a class
declaration (<a href='class.name'>[class.name]</a>) or enum declaration does.
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='example,typedef'></a></span>after</p><pre class='codeblock'>
typedef int MILES, *KLICKSP;
</pre><p >the constructions</p><pre class='codeblock'>
MILES distance;
extern KLICKSP metricp;
</pre><p >are all correct declarations; the type of <span class='texttt'>distance</span> is
<span class='texttt'>int</span> and that of <span class='texttt'>metricp</span> is “pointer to <span class='texttt'>int</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-2'>2</a></div><p >A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> can also be introduced by an
<i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>. The <i ><a href='lex.name#nt:identifier'>identifier</a></i> following the
<span class='texttt'>using</span> keyword becomes a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
and the optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> following the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> appertains to that <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>.
Such a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> has the same
semantics as if it were introduced by the <span class='texttt'>typedef</span> specifier. In
particular, it does not define a new type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int);         <span class='comment'>// redeclare <span class='texttt'>ignore</span>
</span>using cell = pair&lt;void*, cell*&gt;;    <span class='comment'>// ill-formed
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>
of the <i ><a href='dcl.name#nt:defining-type-id'>defining-type-id</a></i> shall not define
a class or enumeration if the <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
is the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> of a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>.</p></div><div class='para' id='dcl.typedef-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-3'>3</a></div><p ><span class='indexparent'><a class='index' id='redefinition,typedef'></a></span>In a given non-class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine the name of any type declared in that scope to refer to the
type to which it already refers.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef struct s { <span class='comment'>/* ... */</span> } s;
typedef int I;
typedef int I;
typedef I I;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-4'>4</a></div><p >In a given class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine any <i ><a href='class#nt:class-name'>class-name</a></i> declared in that scope that is not
also a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> to refer to the type to which it already
refers.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S {
  typedef struct A { } A;       <span class='comment'>// OK
</span>  typedef struct B B;           <span class='comment'>// OK
</span>  typedef A A;                  <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-5'>5</a></div><p >If a <span class='texttt'>typedef</span> specifier is used to redefine in a given scope an
entity that can be referenced using an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>,
the entity can continue to be referenced by an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> or as an enumeration or class name
in an enumeration or class definition respectively. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S;
typedef struct S S;
int main() {
  struct S* p;                  <span class='comment'>// OK
</span>}
struct S { };                   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-6'>6</a></div><p >In a given scope, a <span class='texttt'>typedef</span> specifier shall not be used to
redefine the name of any type declared in that scope to refer to a
different type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class complex { <span class='comment'>/* ... */</span> };
typedef int complex;            <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-7'>7</a></div><p >Similarly, in a given scope, a class or enumeration shall not be
declared with the same name as a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that is
declared in that scope and refers to a type other than the class or
enumeration itself.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef int complex;
class complex <span class='texttt'>{ /* ... */ }</span>;   <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a class type, or a cv-qualified
version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>). If
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is used to identify the subject of an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>), a class
definition (Clause <a href='class'>[class]</a>), a constructor
declaration (<a href='class.ctor'>[class.ctor]</a>), or a destructor
declaration (<a href='class.dtor'>[class.dtor]</a>), the program is ill-formed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S {
  S();
  ~S();
};

typedef struct S T;

S a = T();                      <span class='comment'>// OK
</span>struct T * p;                   <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-9'>9</a></div><p ><span class='indexparent'><a class='index' id='class_name,typedef'></a></span><span class='indexparent'><a class='index' id='enum_name,typedef'></a></span><span class='indexparent'><a class='index' id='class,unnamed'></a></span>If the typedef declaration defines an unnamed class (or enum), the first
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> declared by the declaration to be that class
type (or enum type) is used to denote the class type (or enum type) for
linkage purposes only (<a href='basic.link'>[basic.link]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef struct { } *ps, S;      <span class='comment'>// <span class='texttt'>S</span> is the class name for linkage purposes
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.friend'><h3 ><a class='secnum' href='#dcl.friend' style='min-width:103pt'>7.1.4</a> The <span class='texttt'>friend</span> specifier <a class='abbr_ref' href='dcl.friend'>[dcl.friend]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,friend'></a></span></p><div class='para' id='dcl.friend-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.friend-1'>1</a></div><p >The <span class='texttt'>friend</span> specifier is used to specify access to class members;
see <a href='class.friend'>[class.friend]</a>.</p></div></div><div id='dcl.constexpr'><h3 ><a class='secnum' href='#dcl.constexpr' style='min-width:103pt'>7.1.5</a> The <span class='texttt'>constexpr</span> specifier <a class='abbr_ref' href='dcl.constexpr'>[dcl.constexpr]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,constexpr'></a></span></p><div class='para' id='dcl.constexpr-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-1'>1</a></div><p >The <span class='texttt'>constexpr</span> specifier shall be applied only to the definition of
a variable or variable template or
the declaration of a
function or function template.
A function or static data member declared with the <span class='texttt'>constexpr</span>
specifier is implicitly an inline function or variable (<a href='dcl.inline'>[dcl.inline]</a>).
If any declaration of a function or function template has
a <span class='texttt'>constexpr</span> specifier,
then all its declarations shall contain the <span class='texttt'>constexpr</span> specifier. [&nbsp;<i>Note:</i><span class='space'></span> An
explicit specialization can differ from the template declaration with respect to the
<span class='texttt'>constexpr</span> specifier. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Function parameters cannot be declared <span class='texttt'>constexpr</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
constexpr void square(int &amp;x);  <span class='comment'>// OK: declaration
</span>constexpr int bufsz = 1024;     <span class='comment'>// OK: definition
</span>constexpr struct pixel {        <span class='comment'>// error: <span class='texttt'>pixel</span> is a type
</span>  int x;
  int y;
  constexpr pixel(int);         <span class='comment'>// OK: declaration
</span>}; 
constexpr pixel::pixel(int a)
  : x(a), y(x)                  <span class='comment'>// OK: definition
</span>  { square(x); }
constexpr pixel small(2);       <span class='comment'>// error: <span class='texttt'>square</span> not defined, so <span class='texttt'>small(2)</span>
</span>                                <span class='comment'>// not constant (<a href='expr.const'>[expr.const]</a>) so <span class='texttt'>constexpr</span> not satisfied
</span>
constexpr void square(int &amp;x) { <span class='comment'>// OK: definition
</span>  x *= x;
}
constexpr pixel large(4);       <span class='comment'>// OK: <span class='texttt'>square</span> defined
</span>int next(constexpr int x) {     <span class='comment'>// error: not for parameters
</span>     return x + 1;
} 
extern constexpr int memsz;     <span class='comment'>// error: not a definition 
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-2'>2</a></div><p >A <span class='texttt'>constexpr</span> specifier used in the declaration of a function that is not a
constructor declares that
function to be a <a id='specifier,constexpr,function'><i>constexpr function</i></a>. Similarly, a
<span class='texttt'>constexpr</span> specifier used in 
a constructor declaration declares that constructor to be a
<a id='specifier,constexpr,constructor'><i>constexpr constructor</i></a>.</p></div><div class='para' id='dcl.constexpr-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-3'>3</a></div><p ><span class='indexparent'><a class='index' id='specifier,constexpr,function'></a></span>
<span class='indexparent'><a class='index' id='constexpr_function'></a></span>
The definition of a <span class='texttt'>constexpr</span> function shall satisfy the following
requirements:</p><ul ><li ><p >it shall not be virtual (<a href='class.virtual'>[class.virtual]</a>);</p></li><li ><p >for a defaulted copy/move assignment, the class of which it is a member
shall not have a mutable subobject that is a variant member;</p></li><li ><p >its return type shall be a literal type;</p></li><li ><p >each of its parameter types shall be a literal type;</p></li><li ><p >its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be
<span class='texttt'>= delete</span>, <span class='texttt'>= default</span>, or
a <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
that does not contain</p><ul ><li ><p >an <i ><a href='dcl.asm#nt:asm-definition'>asm-definition</a></i>,
</p></li><li ><p >a <span class='texttt'>goto</span> statement,
</p></li><li ><p >an identifier label (<a href='stmt.label'>[stmt.label]</a>),
</p></li><li ><p >a <i ><a href='except#nt:try-block'>try-block</a></i>, or
</p></li><li ><p >a definition of a variable
of non-literal type or
of static or thread storage duration or
for which no initialization is performed.
</p></li></ul></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
constexpr int square(int x) 
  { return x * x; }             <span class='comment'>// OK
</span>constexpr long long_max() 
  { return 2147483647; }        <span class='comment'>// OK
</span>constexpr int abs(int x) {
  if (x &lt; 0)
    x = -x;
  return x;                     <span class='comment'>// OK
</span>}
constexpr int first(int n) {
  static int value = n;         <span class='comment'>// error: variable has static storage duration
</span>  return value;
}
constexpr int uninit() {
  int a;                        <span class='comment'>// error: variable is uninitialized
</span>  return a;
}
constexpr int prev(int x)
  { return --x; }               <span class='comment'>// OK
</span>constexpr int g(int x, int n) { <span class='comment'>// OK
</span>  int r = 1;
  while (--n &gt; 0) r *= x;
  return r;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-4'>4</a></div><p ><span class='indexparent'><a class='index' id='specifier,constexpr,constructor'></a></span>The definition of a <span class='texttt'>constexpr</span> constructor shall satisfy the
following requirements:</p><ul ><li ><p >the class shall not have any virtual base classes;</p></li><li ><p >for a defaulted copy/move constructor, the class shall not have a
mutable subobject that is a variant member;</p></li><li ><p >each of the parameter types shall be a literal type;</p></li><li ><p >its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall not be a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>;
</p></li></ul><p >In addition, either its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be
<span class='texttt'>= delete</span>, or it shall satisfy the following requirements:</p><ul ><li ><p >either its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be <span class='texttt'>= default</span>, or the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i>
shall satisfy the requirements for a <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> of a
<span class='texttt'>constexpr</span> function;</p></li><li ><p >every non-variant non-static data member and base class sub-object
shall be initialized (<a href='class.base.init'>[class.base.init]</a>);</p></li><li ><p >if the class is a union having variant members (<a href='class.union'>[class.union]</a>), exactly one of them
shall be initialized;</p></li><li ><p >if the class is a union-like class, but is not a union, for each of its anonymous union
members having variant members, exactly one of them shall be initialized;</p></li><li ><p >for a non-delegating constructor, every constructor selected to initialize non-static
data members and base class sub-objects shall be a <span class='texttt'>constexpr</span> constructor;</p></li><li ><p >for a delegating constructor, the target constructor shall be a <span class='texttt'>constexpr</span>
constructor.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct Length { 
  constexpr explicit Length(int i = 0) : val(i) { }
private: 
  int val; 
}; 
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-5'>5</a></div><p >For a <span class='texttt'>constexpr</span> function or <span class='texttt'>constexpr</span> constructor
that is neither defaulted nor a template,
if no argument values exist such that
an invocation of the function or constructor could be an evaluated subexpression of a core
constant expression (<a href='expr.const'>[expr.const]</a>), or,
for a constructor, a constant initializer for some object (<a href='basic.start.static'>[basic.start.static]</a>),
the program is ill-formed; no diagnostic required.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
constexpr int f(bool b)
  { return b ? throw 0 : 0; }               <span class='comment'>// OK
</span>constexpr int f() { return f(true); }       <span class='comment'>// ill-formed, no diagnostic required
</span>
struct B {
  constexpr B(int x) : i(0) { }             <span class='comment'>// <span class='texttt'>x</span> is unused
</span>  int i;
};

int global;

struct D : B {
  constexpr D() : B(global) { }             <span class='comment'>// ill-formed, no diagnostic required
</span>                                            <span class='comment'>// lvalue-to-rvalue conversion on non-constant <span class='texttt'>global</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-6'>6</a></div><p >If the instantiated template specialization of a <span class='texttt'>constexpr</span> function
template
or member function of a class template
would fail to satisfy the requirements for a <span class='texttt'>constexpr</span>
function or <span class='texttt'>constexpr</span> constructor,
that specialization is still a <span class='texttt'>constexpr</span> function or <span class='texttt'>constexpr</span>
constructor, even though a call to such a function cannot appear in a constant
expression. If no specialization of the template would satisfy the
requirements for a <span class='texttt'>constexpr</span> function or <span class='texttt'>constexpr</span> constructor
when considered as a non-template function or constructor, the template is
ill-formed; no diagnostic
required.</p></div><div class='para' id='dcl.constexpr-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-7'>7</a></div><p >A call to a <span class='texttt'>constexpr</span> function produces the same result as a call to an equivalent
non-<span class='texttt'>constexpr</span> function in all respects except that
</p><ul ><li ><p >a call to a <span class='texttt'>constexpr</span>
function can appear in a constant expression (<a href='expr.const'>[expr.const]</a>) and
</p></li><li ><p >copy elision is mandatory in a constant expression (<a href='class.copy'>[class.copy]</a>).
</p></li></ul></div><div class='para' id='dcl.constexpr-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-8'>8</a></div><p >The <span class='texttt'>constexpr</span> specifier has no
effect on the type of a <span class='texttt'>constexpr</span> function or a <span class='texttt'>constexpr</span> constructor.  [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
constexpr int bar(int x, int y) <span class='comment'>// OK 
</span>    { return x + y + x*y; } 
<span class='comment'>// ... 
</span>int bar(int x, int y)           <span class='comment'>// error: redefinition of <span class='texttt'>bar</span>
</span>    { return x * 2 + 3 * y; } 
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-9'>9</a></div><p >A <span class='texttt'>constexpr</span> specifier used in an object
declaration declares the object as <span class='texttt'>const</span>.
Such an object
shall have literal type and
shall be initialized.
If it is initialized by a constructor call,
that call shall be a constant expression (<a href='expr.const'>[expr.const]</a>).
Otherwise,
or if a <span class='texttt'>constexpr</span> specifier is used in a reference declaration,
every full-expression that appears in its initializer shall be a constant expression. [&nbsp;<i>Note:</i><span class='space'></span> Each
implicit conversion used in converting the initializer expressions and each constructor call
used for the initialization is part of such a full-expression. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct pixel { 
  int x, y; 
}; 
constexpr pixel ur = { 1294, 1024 };<span class='comment'>// OK 
</span>constexpr pixel origin;             <span class='comment'>// error: initializer missing 
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.inline'><h3 ><a class='secnum' href='#dcl.inline' style='min-width:103pt'>7.1.6</a> The <span class='texttt'>inline</span> specifier <a class='abbr_ref' href='dcl.inline'>[dcl.inline]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,inline'></a></span></p><div class='para' id='dcl.inline-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-1'>1</a></div><p >The <span class='texttt'>inline</span> specifier can be applied only to the declaration
or definition of a variable or function.</p></div><div class='para' id='dcl.inline-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-2'>2</a></div><p ><span class='indexparent'><a class='index' id='specifier,inline'></a></span><span class='indexparent'><a class='index' id='inline_function'></a></span>A function declaration (<a href='dcl.fct'>[dcl.fct]</a>, <a href='class.mfct'>[class.mfct]</a>,
<a href='class.friend'>[class.friend]</a>) with an <span class='texttt'>inline</span> specifier declares an
<i>inline function</i>. The inline specifier indicates to
the implementation that inline substitution of the function body at the
point of call is to be preferred to the usual function call mechanism.
An implementation is not required to perform this inline substitution at
the point of call; however, even if this inline substitution is omitted,
the other rules for inline functions defined by <a href='dcl.fct.spec'>[dcl.fct.spec]</a> shall
still be respected.</p></div><div class='para' id='dcl.inline-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-3'>3</a></div><p >A variable declaration with an <span class='texttt'>inline</span> specifier declares an
<i>inline variable</i>.</p></div><div class='para' id='dcl.inline-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-4'>4</a></div><p >A function defined within a class definition is an inline function.</p></div><div class='para' id='dcl.inline-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-5'>5</a></div><p >The <span class='texttt'>inline</span> specifier shall not appear on a block scope
declaration.<a class='footnotenum' href='#footnote-93'>93</a>
If the <span class='texttt'>inline</span> specifier is used in a friend function declaration, that
declaration shall be a definition or the function shall have previously
been declared inline.</p></div><div class='para' id='dcl.inline-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-6'>6</a></div><p >An inline function or variable shall be defined in every translation unit in which
it is odr-used and shall have exactly the same definition in every
case (<a href='basic.def.odr'>[basic.def.odr]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
A call to the inline function or a use of the inline variable may be encountered before its definition
appears in the translation unit.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the definition of a function or variable appears in a translation unit before its
first declaration as inline, the program is ill-formed. If a function or variable
with external linkage is declared inline in one translation unit, it
shall be declared inline in all translation units in which it appears;
no diagnostic is required. An inline function or variable with external
linkage shall have the same address in all translation units.
[&nbsp;<i>Note:</i><span class='space'></span>
A <span class='texttt'>static</span> local variable in an inline
function with external linkage always refers to the same object.
A type defined within the body of an inline
function with external linkage is the
same type in every translation unit.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-93'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-93'>93)</a></div><p >The <span class='texttt'>inline</span> keyword has no effect on the linkage of a function.</p></div></div><div id='dcl.type'><h3 ><a class='secnum' href='#dcl.type' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type'>[dcl.type]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,type'></a></span></p><div class='para' id='dcl.type-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-1'>1</a></div><p >The type-specifiers are</p><p ><span class='indexparent'><a class='index' id='type,const'></a></span><span class='indexparent'><a class='index' id='type,volatile'></a></span></p><pre class='bnf'><a id='nt:type-specifier'>type-specifier:</a>
  <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
  <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
  <i ><a href='temp.res#nt:typename-specifier'>typename-specifier</a></i>
  <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i></pre><pre class='bnf'><a id='nt:type-specifier-seq'>type-specifier-seq:</a>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i></pre><pre class='bnf'><a id='nt:defining-type-specifier'>defining-type-specifier:</a>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
    <i ><a href='class#nt:class-specifier'>class-specifier</a></i>
    <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i></pre><pre class='bnf'><a id='nt:defining-type-specifier-seq'>defining-type-specifier-seq:</a>
  <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>
or a <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>
appertains
to the type denoted by the preceding <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i>
or <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifiers</a></i> (<a href='dcl.meaning'>[dcl.meaning]</a>). The
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> affects the type only for the declaration it appears in,
not other declarations involving the same type.</p></div><div class='para' id='dcl.type-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-2'>2</a></div><p >As a general rule, at most one
<i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>
is allowed in the complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> or in a
<i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>,
and at most one
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
is allowed in a
<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>.
The only exceptions to this rule are the following:</p><ul ><li ><p ><span class='texttt'>const</span> can be combined with any type specifier except itself.</p></li><li ><p ><span class='texttt'>volatile</span> can be combined with any type specifier except itself.</p></li><li ><p ><span class='texttt'>signed</span> or <span class='texttt'>unsigned</span> can be combined with
<span class='texttt'>char</span>, <span class='texttt'>long</span>, <span class='texttt'>short</span>, or <span class='texttt'>int</span>.</p></li><li ><p ><span class='texttt'>short</span> or <span class='texttt'>long</span> can be combined with <span class='texttt'>int</span>.</p></li><li ><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>double</span>.</p></li><li ><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>long</span>.
</p></li></ul></div><div class='para' id='dcl.type-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-3'>3</a></div><p >Except in a declaration of a constructor, destructor, or conversion
function, at least one <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> that is not a
<i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> shall appear in a complete
<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> or a complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.<a class='footnotenum' href='#footnote-94'>94</a></p></div><div class='para' id='dcl.type-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifiers</a></i>,
<i ><a href='class#nt:class-specifier'>class-specifiers</a></i>,
and
<i ><a href='temp.res#nt:typename-specifier'>typename-specifiers</a></i>
are discussed
in
<a href='dcl.enum'>[dcl.enum]</a>,
Clause <a href='class'>[class]</a>,
and
<a href='temp.res'>[temp.res]</a>, respectively. The remaining
<i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i> are discussed in the rest of this section.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-94'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-94'>94)</a></div><p >There is no special
provision for a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> that
lacks a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> or that has a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that only specifies <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i>.
The “implicit int” rule of C is no longer supported.</p></div><div id='dcl.type.cv'><h4 ><a class='secnum' href='#dcl.type.cv' style='min-width:118pt'>7.1.7.1</a> The <span class='grammarterm'>cv-qualifiers</span> <a class='abbr_ref' href='dcl.type.cv'>[dcl.type.cv]</a></h4><p ><span class='indexparent'><a class='index' id='specifier,cv-qualifier'></a></span><span class='indexparent'><a class='index' id='initialization,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span></p><div class='para' id='dcl.type.cv-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-1'>1</a></div><p >There are two <span class='grammarterm'>cv-qualifiers</span>, <span class='texttt'>const</span> and
<span class='texttt'>volatile</span>. Each <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> shall appear at most once in
a <i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i>. If a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> appears in a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
or <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> of
the declaration shall not be empty.
[&nbsp;<i>Note:</i><span class='space'></span>
<a href='basic.type.qualifier'>[basic.type.qualifier]</a> and <a href='dcl.fct'>[dcl.fct]</a> describe how cv-qualifiers affect object and
function types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Redundant cv-qualifications are ignored. [&nbsp;<i>Note:</i><span class='space'></span> For example,
these could be introduced by typedefs.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Declaring a variable <span class='texttt'>const</span> can affect its linkage (<a href='dcl.stc'>[dcl.stc]</a>)
and its usability in constant expressions (<a href='expr.const'>[expr.const]</a>). As
described in <a href='dcl.init'>[dcl.init]</a>, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-3'>3</a></div><p >A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
[&nbsp;<i>Note:</i><span class='space'></span>
Cv-qualifiers are supported by the type system so that they cannot be
subverted without casting (<a href='expr.const.cast'>[expr.const.cast]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-4'>4</a></div><p ><span class='indexparent'><a class='index' id='const_object,undefined_change_to'></a></span>Except that any class member declared <span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>)
can be modified, any attempt to modify a <span class='texttt'>const</span> object during its
lifetime (<a href='basic.life'>[basic.life]</a>) results in undefined behavior.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
const int ci = 3;               <span class='comment'>// cv-qualified (initialized as required)
</span>ci = 4;                         <span class='comment'>// ill-formed: attempt to modify <span class='texttt'>const</span>
</span>
int i = 2;                      <span class='comment'>// not cv-qualified
</span>const int* cip;                 <span class='comment'>// pointer to <span class='texttt'>const int</span>
</span>cip = &amp;i;                       <span class='comment'>// OK: cv-qualified access path to unqualified
</span>*cip = 4;                       <span class='comment'>// ill-formed: attempt to modify through ptr to <span class='texttt'>const</span>
</span>
int* ip;
ip = const_cast&lt;int*&gt;(cip);     <span class='comment'>// cast needed to convert <span class='texttt'>const int*</span> to <span class='texttt'>int*</span>
</span>*ip = 4;                        <span class='comment'>// defined: <span class='texttt'>*ip</span> points to <span class='texttt'>i</span>, a non-<span class='texttt'>const</span> object
</span>
const int* ciq = new const int (3);     <span class='comment'>// initialized as required
</span>int* iq = const_cast&lt;int*&gt;(ciq);        <span class='comment'>// cast required
</span>*iq = 4;                                <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> object
</span></pre></div><div class='para' id='dcl.type.cv-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-5'>5</a></div><p >For another example</p><pre class='codeblock'>
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                        <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>y.x.j++;                        <span class='comment'>// ill-formed: <span class='texttt'>const</span>-qualified member modified
</span>Y* p = const_cast&lt;Y*&gt;(&amp;y);      <span class='comment'>// cast away const-ness of <span class='texttt'>y</span>
</span>p-&gt;x.i = 99;                    <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>p-&gt;x.j = 99;                    <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> member
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-6'>6</a></div><p >What constitutes an access to an object that has volatile-qualified type is
<span class='indexparent'><a class='index' id='what_constitutes_an_access_to_an_object_that_has_volatile-qualified_type'></a></span>implementation-defined.
If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of a glvalue with a
non-volatile-qualified type, the behavior is undefined.</p></div><div class='para' id='dcl.type.cv-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-7'>7</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span><span class='indexparent'><a class='index' id='volatile,implementation-defined'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
<span class='texttt'>volatile</span> is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
Furthermore, for some implementations, <span class='texttt'>volatile</span> might indicate that
special hardware instructions are required to access the object.
See <a href='intro.execution'>[intro.execution]</a> for detailed semantics. In general, the
semantics of <span class='texttt'>volatile</span> are intended to be the same in C++ as
they are in C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='dcl.type.simple'><h4 ><a class='secnum' href='#dcl.type.simple' style='min-width:118pt'>7.1.7.2</a> Simple type specifiers <a class='abbr_ref' href='dcl.type.simple'>[dcl.type.simple]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,simple'></a></span></p><div class='para' id='dcl.type.simple-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-1'>1</a></div><p >The simple type specifiers are</p><pre class='bnf'><a id='nt:simple-type-specifier'>simple-type-specifier:</a>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
    <span class='terminal'>char</span>
    <span class='terminal'>char16_t</span>
    <span class='terminal'>char32_t</span>
    <span class='terminal'>wchar_t</span>
    <span class='terminal'>bool</span>
    <span class='terminal'>short</span>
    <span class='terminal'>int</span>
    <span class='terminal'>long</span>
    <span class='terminal'>signed</span>
    <span class='terminal'>unsigned</span>
    <span class='terminal'>float</span>
    <span class='terminal'>double</span>
    <span class='terminal'>void</span>
    <span class='terminal'>auto</span>
    <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i></pre><pre class='bnf'><a id='nt:type-name'>type-name:</a>
    <i ><a href='class#nt:class-name'>class-name</a></i>
    <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>
    <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><pre class='bnf'><a id='nt:decltype-specifier'>decltype-specifier:</a>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <span class='terminal'>auto</span> <span class='terminal'>)</span></pre></div><div class='para' id='dcl.type.simple-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-2'>2</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,char'></a></span><span class='indexparent'><a class='index' id='type_specifier,char16_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,char32_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,wchar_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,bool'></a></span><span class='indexparent'><a class='index' id='type_specifier,short'></a></span><span class='indexparent'><a class='index' id='type_specifier,int'></a></span><span class='indexparent'><a class='index' id='type_specifier,long'></a></span><span class='indexparent'><a class='index' id='type_specifier,signed'></a></span><span class='indexparent'><a class='index' id='type_specifier,unsigned'></a></span><span class='indexparent'><a class='index' id='type_specifier,float'></a></span><span class='indexparent'><a class='index' id='type_specifier,double'></a></span><span class='indexparent'><a class='index' id='type_specifier,void'></a></span><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span><span class='indexparent'><a class='index' id='type-name'></a></span><span class='indexparent'><a class='index' id='lambda-introducer'></a></span>The <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='texttt'>auto</span> is a placeholder for a type to be
deduced (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
<span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>A <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> of the form
<span class='texttt'>typename</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
is a placeholder for a deduced class type
and shall appear only as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i> (<a href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a>)
or as the <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
in an explicit type conversion (functional notation) (<a href='expr.type.conv'>[expr.type.conv]</a>).
The <i ><a href='temp.names#nt:template-name'>template-name</a></i> shall name a class template
that is not an injected-class-name.
The other
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
specify either a previously-declared type, a type determined from an
expression, or one of the
fundamental types (<a href='basic.fundamental'>[basic.fundamental]</a>).
Table <a href='#tab:simple.type.specifiers'>[tab:simple.type.specifiers]</a>
 summarizes the valid combinations of
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
and the types they specify.</p><div class='numberedTable' id='tab:simple.type.specifiers'>Table <a href='#tab:simple.type.specifiers'>9</a> — <span class='grammarterm'>simple-type-specifiers</span> and the types they specify<br><table ><tr class='rowsep'><td class='left'>


Specifier(s)                    </td><td class='left'>   Type                 </td></tr><tr class='capsep'><td class='left'> 
<span class='grammarterm'>type-name</span>         </td><td class='left'>   the type named          </td></tr><tr ><td class='left'>
<span class='grammarterm'>simple-template-id</span>    </td><td class='left'>   the type as defined in <a href='temp.names'>[temp.names]</a>   </td></tr><tr ><td class='left'>
<span class='grammarterm'>template-name</span>     </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
char                            </td><td class='left'>   “char”                </td></tr><tr ><td class='left'>
unsigned char                   </td><td class='left'>   “unsigned char”       </td></tr><tr ><td class='left'>
signed char                     </td><td class='left'>   “signed char”         </td></tr><tr ><td class='left'>
char16_t                        </td><td class='left'>   “char16_t”            </td></tr><tr ><td class='left'>
char32_t                        </td><td class='left'>   “char32_t”            </td></tr><tr ><td class='left'>
bool                            </td><td class='left'>   “bool”                </td></tr><tr ><td class='left'>
unsigned                        </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
unsigned int                    </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
signed                          </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
signed int                      </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
int                             </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
unsigned short int              </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned short                  </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned long int               </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long                   </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long long int          </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
unsigned long long              </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
signed long int                 </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long                     </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long long int            </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
signed long long                </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long int                   </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long                       </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long int                        </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
long                            </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed short int                </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
signed short                    </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short int                       </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short                           </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
wchar_t                         </td><td class='left'>   “wchar_t”             </td></tr><tr ><td class='left'>
float                           </td><td class='left'>   “float”               </td></tr><tr ><td class='left'>
double                          </td><td class='left'>   “double”              </td></tr><tr ><td class='left'>
long double                     </td><td class='left'>   “long double”         </td></tr><tr ><td class='left'>
void                            </td><td class='left'>   “void”                </td></tr><tr ><td class='left'>
auto                            </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(<span class='grammarterm'>expression</span>) </td><td class='left'>   the type as defined below</td></tr></table></div></div><div class='para' id='dcl.type.simple-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-3'>3</a></div><p >When multiple <span class='grammarterm'>simple-type-specifiers</span> are allowed, they can be
freely intermixed with other <span class='grammarterm'>decl-specifiers</span> in any order.
[&nbsp;<i>Note:</i><span class='space'></span>
It is <span class='indexparent'><a class='index' id='signedness_of_char'></a></span>implementation-defined whether objects of <span class='texttt'>char</span> type are
represented as signed or unsigned quantities. The <span class='texttt'>signed</span> specifier
forces <span class='texttt'>char</span> objects to be signed; it is redundant in other contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.simple-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-4'>4</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span>For an expression <span class='texttt'>e</span>, the type denoted by <span class='texttt'>decltype(e)</span> is defined as follows:</p><ul ><li ><p >if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> naming an lvalue or
reference introduced from the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> of a decomposition declaration,
<span class='texttt'>decltype(e)</span> is the referenced type as given in the specification of the decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>);</p></li><li ><p >otherwise, if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> or
an unparenthesized
class
member access (<a href='expr.ref'>[expr.ref]</a>), <span class='texttt'>decltype(e)</span> is the
type of the entity named by <span class='texttt'>e</span>. If there is no such entity, or
if <span class='texttt'>e</span> names a set of overloaded functions, the program is
ill-formed;</p></li><li ><p >otherwise, if <span class='texttt'>e</span> is
an xvalue, <span class='texttt'>decltype(e)</span> is <span class='texttt'>T&amp;&amp;</span>, where <span class='texttt'>T</span> is the type
of <span class='texttt'>e</span>;</p></li><li ><p >otherwise, if <span class='texttt'>e</span> is an lvalue, <span class='texttt'>decltype(e)</span>
is <span class='texttt'>T&amp;</span>, where <span class='texttt'>T</span> is the type of <span class='texttt'>e</span>;</p></li><li ><p >otherwise, <span class='texttt'>decltype(e)</span> is the type of <span class='texttt'>e</span>.
</p></li></ul><p >The operand of the <span class='texttt'>decltype</span> specifier is an unevaluated
operand (Clause <a href='expr'>[expr]</a>).</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const int&amp;&amp; foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = 17;        <span class='comment'>// type is <span class='texttt'>const int&amp;&amp;</span>
</span>decltype(i) x2;                 <span class='comment'>// type is <span class='texttt'>int</span>
</span>decltype(a-&gt;x) x3;              <span class='comment'>// type is <span class='texttt'>double</span>
</span>decltype((a-&gt;x)) x4 = x3;       <span class='comment'>// type is <span class='texttt'>const double&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
The rules for determining types involving <span class='texttt'>decltype(auto)</span> are specified
in <a href='dcl.spec.auto'>[dcl.spec.auto]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.simple-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-5'>5</a></div><p >If the operand of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is a prvalue,
the temporary materialization conversion is not applied (<a href='conv.rval'>[conv.rval]</a>)
and no result object is provided for the prvalue.
The type of the prvalue may be incomplete.
[&nbsp;<i>Note:</i><span class='space'></span>
As a result, storage is not allocated for the prvalue and it is not destroyed.
Thus, a class type is not instantiated
as a result of being the type of a function call in this context. 
In this context, the common purpose of
writing the expression is merely to refer to its type. In that sense, a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is analogous to a use of a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>,
so the usual reasons for requiring a complete type do not apply. In particular,
it is not necessary to allocate storage for a temporary object or to enforce the
semantic constraints associated with invoking the type's destructor.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Unlike the preceding rule, parentheses have no special meaning in this context.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A { ~A() = delete; };
template&lt;class T&gt; auto h()
  -&gt; A&lt;T&gt;;
template&lt;class T&gt; auto i(T)     <span class='comment'>// identity
</span>  -&gt; T;
template&lt;class T&gt; auto f(T)     <span class='comment'>// #1
</span>  -&gt; decltype(i(h&lt;T&gt;()));       <span class='comment'>// forces completion of <span class='texttt'>A&lt;T&gt;</span> and implicitly uses
</span>                                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::~A()</span> for the temporary introduced by the
</span>                                <span class='comment'>// use of <span class='texttt'>h()</span>. (A temporary is not introduced
</span>                                <span class='comment'>// as a result of the use of <span class='texttt'>i()</span>.)
</span>template&lt;class T&gt; auto f(T)     <span class='comment'>// #2
</span>  -&gt; void;
auto g() -&gt; void {
  f(42);                        <span class='comment'>// OK: calls #2. (#1 is not a viable candidate: type
</span>                                <span class='comment'>// deduction fails (<a href='temp.deduct'>[temp.deduct]</a>) because <span class='texttt'>A&lt;int&gt;::~A()</span>
</span>                                <span class='comment'>// is implicitly used in its <span class='grammarterm'>decltype-specifier</span>)
</span>}
template&lt;class T&gt; auto q(T)
  -&gt; decltype((h&lt;T&gt;()));        <span class='comment'>// does not force completion of <span class='texttt'>A&lt;T&gt;</span>; <span class='texttt'>A&lt;T&gt;::~A()</span> is
</span>                                <span class='comment'>// not implicitly used within the context of this <span class='grammarterm'>decltype-specifier</span>
</span>void r() {
  q(42);                        <span class='comment'>// Error: deduction against <span class='texttt'>q</span> succeeds, so overload resolution
</span>                                <span class='comment'>// selects the specialization “<span class='texttt'>q(T) -&gt; decltype((h&lt;T&gt;())) [with T=int]</span>”.
</span>                                <span class='comment'>// The return type is <span class='texttt'>A&lt;int&gt;</span>, so a temporary is introduced and its
</span>                                <span class='comment'>// destructor is used, so the program is ill-formed.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.type.elab'><h4 ><a class='secnum' href='#dcl.type.elab' style='min-width:118pt'>7.1.7.3</a> Elaborated type specifiers <a class='abbr_ref' href='dcl.type.elab'>[dcl.type.elab]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,elaborated'></a></span><span class='indexparent'><a class='index' id='typename'></a></span><span class='indexparent'><a class='index' id='type_specifier,enum'></a></span></p><pre class='bnf'><a id='nt:elaborated-type-specifier'>elaborated-type-specifier:</a>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <span class='terminal'>enum</span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='dcl.type.elab-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-1'>1</a></div><p ><span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='name,elaborated,enum'></a></span>An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> shall not appear in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
unless the latter is the sole constituent of a declaration.
If an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is the sole constituent of a
declaration, the declaration is ill-formed unless it is an explicit
specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>), an explicit
instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or it has one of the following
forms:</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span></pre><p >In the first case, the <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>, if any, appertains
to the class being declared; the attributes in the
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of
the class whenever it is named.</p></div><div class='para' id='dcl.type.elab-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-2'>2</a></div><p ><a href='basic.lookup.elab'>[basic.lookup.elab]</a> describes how name lookup proceeds for the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. If the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a <i ><a href='class#nt:class-name'>class-name</a></i> or
<i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>, the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
introduces it into the declaration the same way a
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> introduces its <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>. If
the <i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> or the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> resolves to
an alias template specialization,
the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span>
This implies that, within a class template with a template
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> <span class='texttt'>T</span>, the declaration</p><pre class='codeblock'>
friend class T;
</pre><p >is ill-formed. However, the similar declaration <span class='texttt'>friend T;</span> is allowed (<a href='class.friend'>[class.friend]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.elab-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-3'>3</a></div><p >The <i ><a href='class#nt:class-key'>class-key</a></i> or <span class='texttt'>enum</span> keyword
present in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> shall agree in kind with the
declaration to which the name in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> refers. This rule also applies to
the form of <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> that declares a
<i ><a href='class#nt:class-name'>class-name</a></i> or <span class='texttt'>friend</span> class since it can be construed
as referring to the definition of the class. Thus, in any
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, the <span class='texttt'>enum</span> keyword
shall be
used to refer to an enumeration (<a href='dcl.enum'>[dcl.enum]</a>), the <span class='texttt'>union</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a union
(Clause <a href='class'>[class]</a>), and either the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a class
(Clause <a href='class'>[class]</a>) declared using the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum class E { a, b };
enum E x = E::a;                <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.spec.auto'><h4 ><a class='secnum' href='#dcl.spec.auto' style='min-width:118pt'>7.1.7.4</a> The <span class='texttt'>auto</span> specifier <a class='abbr_ref' href='dcl.spec.auto'>[dcl.spec.auto]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span></p><div class='para' id='dcl.spec.auto-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-1'>1</a></div><p >The <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i>
are used to
designate a placeholder type that will be replaced later by deduction
from an initializer. The <span class='texttt'>auto</span>
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is also used to
introduce a function type having a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> or to
signify that a lambda is a generic lambda (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>).
The <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is also used to introduce a
decomposition declaration (<a href='dcl.decomp'>[dcl.decomp]</a>).</p></div><div class='para' id='dcl.spec.auto-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-2'>2</a></div><p >The placeholder type can appear with a function declarator in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>,
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>, or <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>,
in any context where such a declarator is valid. If the function declarator
includes a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> (<a href='dcl.fct'>[dcl.fct]</a>), that
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> specifies
the declared return type of the function. Otherwise, the function declarator
shall declare a function. If the declared return type of the
function contains a placeholder type, the return type of the function is
deduced from non-discarded <span class='texttt'>return</span> statements, if any, in the body
of the function (<a href='stmt.if'>[stmt.if]</a>).</p></div><div class='para' id='dcl.spec.auto-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-3'>3</a></div><p >If the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> appears as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, the
<span class='indexparent'><a class='index' id='generic_lambda,definition_of'></a></span>lambda is a <i>generic lambda</i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>). [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto glambda = [](int i, auto a) { return i; }; <span class='comment'>// OK: a generic lambda
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-4'>4</a></div><p >The type of a variable declared using <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> is
deduced from its initializer. This use is allowed when declaring variables in a
block (<a href='stmt.block'>[stmt.block]</a>), in
namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>), and in an
<span class='small'></span><span class='rmfamily'></span><i> init-statement</i> (Clause <a href='stmt.stmt'>[stmt.stmt]</a>).
<span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> shall appear as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall be followed by one or more <i ><a href='dcl.decl#nt:init-declarator'>init-declarators</a></i>, each of which shall
have a non-empty <i ><a href='dcl.init#nt:initializer'>initializer</a></i>. In an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> of the form</p><pre class='codeblock'>
( <span class='grammarterm'>expression-list</span> )
</pre><p >the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> shall be a single
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto x = 5;                 <span class='comment'>// OK: <span class='texttt'>x</span> has type <span class='texttt'>int</span>
</span>const auto *v = &amp;x, u = 6;  <span class='comment'>// OK: <span class='texttt'>v</span> has type <span class='texttt'>const int*</span>, <span class='texttt'>u</span> has type <span class='texttt'>const int</span>
</span>static auto y = 0.0;        <span class='comment'>// OK: <span class='texttt'>y</span> has type <span class='texttt'>double</span>
</span>auto int r;                 <span class='comment'>// error: auto is not a <span class='grammarterm'>storage-class-specifier</span>
</span>auto f() -&gt; int;            <span class='comment'>// OK: <span class='texttt'>f</span> returns <span class='texttt'>int</span>
</span>auto g() { return 0.0; }    <span class='comment'>// OK: <span class='texttt'>g</span> returns <span class='texttt'>double</span>
</span>auto h();                   <span class='comment'>// OK: <span class='texttt'>h</span>'s return type will be deduced when it is defined
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-5'>5</a></div><p >A placeholder type can also be used in declaring a variable in
the <span class='small'></span><span class='rmfamily'></span><i> condition</i> of a selection statement (<a href='stmt.select'>[stmt.select]</a>) or an iteration
statement (<a href='stmt.iter'>[stmt.iter]</a>), in the <span class='small'></span><span class='rmfamily'></span><i> type-specifier-seq</i> in 
the <span class='small'></span><span class='rmfamily'></span><i> new-type-id</i> or <span class='small'></span><span class='rmfamily'></span><i> type-id</i> of a
<span class='small'></span><span class='rmfamily'></span><i> new-expression</i> (<a href='expr.new'>[expr.new]</a>), in a
<i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>,
in declaring a static data member with a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> that appears within the
<span class='small'></span><span class='rmfamily'></span><i> member-specification</i> of a class definition (<a href='class.static.data'>[class.static.data]</a>),
and as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
of the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration's</a></i>
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
in a <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> (<a href='temp.param'>[temp.param]</a>).</p></div><div class='para' id='dcl.spec.auto-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-6'>6</a></div><p >A program that uses <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> in a context not
explicitly allowed in this section is ill-formed.</p></div><div class='para' id='dcl.spec.auto-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-7'>7</a></div><p >If the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> contains more than one
<i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>, they shall all form declarations of
variables. The type of each declared variable is determined
by placeholder type deduction (<a href='dcl.type.auto.deduct'>[dcl.type.auto.deduct]</a>),
and if the type that replaces the placeholder type is not the
same in each deduction, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto x = 5, *y = &amp;x;        <span class='comment'>// OK: <span class='texttt'>auto</span> is <span class='texttt'>int</span>
</span>auto a = 5, b = { 1, 2 };   <span class='comment'>// error: different types for <span class='texttt'>auto</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='specifier'></a></span></p></div><div class='para' id='dcl.spec.auto-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-8'>8</a></div><p >If a function with a declared return type that contains a placeholder type has
multiple non-discarded <span class='texttt'>return</span> statements, the return type is deduced for each
such <span class='texttt'>return</span> statement. If the type deduced is not the same in each
deduction, the program is ill-formed.</p></div><div class='para' id='dcl.spec.auto-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-9'>9</a></div><p >If a function with a declared return type that uses a placeholder type has no
non-discarded <span class='texttt'>return</span> statements, the return type is deduced as though from a
<span class='texttt'>return</span> statement with no operand at the closing brace of the function
body.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto  f() { } <span class='comment'>// OK, return type is <span class='texttt'>void</span>
</span>auto* g() { } <span class='comment'>// error, cannot deduce <span class='texttt'>auto*</span> from <span class='texttt'>void()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-10'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-10'>10</a></div><p >If the type of an entity with an undeduced placeholder type is needed to
determine the type of an expression, the program is ill-formed. Once a
non-discarded <span class='texttt'>return</span> statement has been seen in a function, however, the return type deduced
from that statement can be used in the rest of the function, including in other
<span class='texttt'>return</span> statements.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto n = n;            <span class='comment'>// error, <span class='texttt'>n</span>'s type is unknown
</span>auto f();
void g() { &amp;f; }       <span class='comment'>// error, <span class='texttt'>f</span>'s return type is unknown
</span>auto sum(int i) {
  if (i == 1)
    return i;          <span class='comment'>// <span class='texttt'>sum</span>'s return type is <span class='texttt'>int</span>
</span>  else
    return sum(i-1)+i; <span class='comment'>// OK, <span class='texttt'>sum</span>'s return type has been deduced
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-11'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-11'>11</a></div><p >Return type deduction for a function template with a placeholder in its
declared type occurs when the definition is instantiated even if the function
body contains a <span class='texttt'>return</span> statement with a non-type-dependent operand.
[&nbsp;<i>Note:</i><span class='space'></span> Therefore, any use of a specialization of the function template will
cause an implicit instantiation. Any errors that arise from this instantiation
are not in the immediate context of the function type and can result in the
program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; auto f(T t) { return t; }  <span class='comment'>// return type deduced at instantiation time
</span>typedef decltype(f(1)) fint_t;                <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to deduce return type
</span>template&lt;class T&gt; auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &amp;f; }             <span class='comment'>// instantiates both <span class='texttt'>f</span>s to determine return types,
</span>                                              <span class='comment'>// chooses second
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-12'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-12'>12</a></div><p >Redeclarations or specializations of a function or function template with a
declared return type that uses a placeholder type shall also use that
placeholder, not a deduced type.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto f();
auto f() { return 42; } <span class='comment'>// return type is <span class='texttt'>int</span>
</span>auto f();               <span class='comment'>// OK
</span>int f();                <span class='comment'>// error, cannot be overloaded with <span class='texttt'>auto f()</span>
</span>decltype(auto) f();     <span class='comment'>// error, <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> don't match
</span>
template &lt;typename T&gt; auto g(T t) { return t; } <span class='comment'>// #1
</span>template auto g(int);                           <span class='comment'>// OK, return type is <span class='texttt'>int</span>
</span>template char g(char);                          <span class='comment'>// error, no matching template
</span>template&lt;&gt; auto g(double);                      <span class='comment'>// OK, forward declaration with unknown return type
</span>
template &lt;class T&gt; T g(T t) { return t; } <span class='comment'>// OK, not functionally equivalent to #1
</span>template char g(char);                    <span class='comment'>// OK, now there is a matching template
</span>template auto g(float);                   <span class='comment'>// still matches #1
</span>
void h() { return g(42); } <span class='comment'>// error, ambiguous
</span>
template &lt;typename T&gt; struct A {
  friend T frf(T);
};
auto frf(int i) { return i; } <span class='comment'>// not a friend of <span class='texttt'>A&lt;int&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-13'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-13'>13</a></div><p >A function declared with a return type that uses a placeholder type shall not
be <span class='texttt'>virtual</span> (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='dcl.spec.auto-14'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-14'>14</a></div><p >An explicit instantiation declaration (<a href='temp.explicit'>[temp.explicit]</a>) does not cause the
instantiation of an entity declared using a placeholder type, but it also does
not prevent that entity from being instantiated as needed to determine its
type.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;typename T&gt; auto f(T t) { return t; }
extern template auto f(int); <span class='comment'>// does not instantiate <span class='texttt'>f&lt;int&gt;</span>
</span>int (*p)(int) = f;           <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to determine its return type, but an explicit
</span>                             <span class='comment'>// instantiation definition is still required somewhere in the program
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='dcl.type.auto.deduct'><h4 ><a class='secnum' href='#dcl.type.auto.deduct' style='min-width:133pt'>7.1.7.4.1</a> Placeholder type deduction <a class='abbr_ref' href='dcl.type.auto.deduct'>[dcl.type.auto.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,placeholder_type'></a></span>
</p><div class='para' id='dcl.type.auto.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-1'>1</a></div><p ><a id='placeholder_type_deduction'><i>Placeholder type deduction</i></a>
is the process by which
a type containing a placeholder type
is replaced by a deduced type.</p></div><div class='para' id='dcl.type.auto.deduct-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-2'>2</a></div><p >A type <span class='texttt'>T</span> containing a placeholder type,
and a corresponding initializer <span class='texttt'>e</span>,
are determined as follows:</p><ul ><li ><p >for a non-discarded <span class='texttt'>return</span> statement that occurs
in a function declared with a return type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared return type
and <span class='texttt'>e</span> is the operand of the <span class='texttt'>return</span> statement.
If the <span class='texttt'>return</span> statement
has no operand,
then <span class='texttt'>e</span> is <span class='texttt'>void()</span>;
</p></li><li ><p >for a variable declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the variable
and <span class='texttt'>e</span> is the initializer.
If the initialization is direct-list-initialization,
the initializer shall be a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
containing only a single <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
and <span class='texttt'>e</span> is the <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>;
</p></li><li ><p >for a non-type template parameter declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the non-type template parameter
and <span class='texttt'>e</span> is the corresponding template argument.
</p></li></ul><p >In the case of a <span class='texttt'>return</span> statement with no operand
or with an operand of type <span class='texttt'>void</span>,
<span class='texttt'>T</span> shall be either
<span class='texttt'>decltype(auto)</span> or <i>cv</i> <span class='texttt'>auto</span>.</p></div><div class='para' id='dcl.type.auto.deduct-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-3'>3</a></div><p >If the deduction is for a <span class='texttt'>return</span> statement
and <span class='texttt'>e</span> is a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>),
the program is ill-formed.</p></div><div class='para' id='dcl.type.auto.deduct-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-4'>4</a></div><p >If the placeholder is the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, the
deduced type
<span class='math'><span class='mathtt'>T</span>'</span> replacing <span class='texttt'>T</span>
is determined using the rules for template argument deduction.
Obtain <span class='texttt'>P</span> from
<span class='texttt'>T</span> by replacing the occurrences of <span class='texttt'>auto</span> with either a new
invented type template parameter <span class='texttt'>U</span> or,
if the initialization is copy-list-initialization, with
<span class='texttt'>std::initializer_list&lt;U&gt;</span>. Deduce a value for <span class='texttt'>U</span> using the rules
of template argument deduction from a function call (<a href='temp.deduct.call'>[temp.deduct.call]</a>),
where <span class='texttt'>P</span> is a
function template parameter type and
the corresponding argument is <span class='texttt'>e</span>.
If the deduction fails, the declaration is ill-formed.
Otherwise, <span class='math'><span class='mathtt'>T</span>'</span> is obtained by
substituting the deduced <span class='texttt'>U</span> into <span class='texttt'>P</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto x1 = { 1, 2 };         <span class='comment'>// <span class='texttt'>decltype(x1)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x2 = { 1, 2.0 };       <span class='comment'>// error: cannot deduce element type
</span>auto x3{ 1, 2 };            <span class='comment'>// error: not a single element
</span>auto x4 = { 3 };            <span class='comment'>// <span class='texttt'>decltype(x4)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x5{ 3 };               <span class='comment'>// <span class='texttt'>decltype(x5)</span> is <span class='texttt'>int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const auto &amp;i = expr;
</pre><p >The type of <span class='texttt'>i</span> is the deduced type of the parameter <span class='texttt'>u</span> in
the call <span class='texttt'>f(expr)</span> of the following invented function template:</p><pre class='codeblock'>
template &lt;class U&gt; void f(const U&amp; u);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.type.auto.deduct-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-5'>5</a></div><p >If the placeholder is the <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>,
<span class='texttt'>T</span> shall be the
placeholder alone. The type deduced for <span class='texttt'>T</span> is
determined as described in <a href='dcl.type.simple'>[dcl.type.simple]</a>, as though
<span class='texttt'>e</span> had
been the operand of the <span class='texttt'>decltype</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int i;
int&amp;&amp; f();
auto           x2a(i);         <span class='comment'>// <span class='texttt'>decltype(x2a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x2d(i);         <span class='comment'>// <span class='texttt'>decltype(x2d)</span> is <span class='texttt'>int</span>
</span>auto           x3a = i;        <span class='comment'>// <span class='texttt'>decltype(x3a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x3d = i;        <span class='comment'>// <span class='texttt'>decltype(x3d)</span> is <span class='texttt'>int</span>
</span>auto           x4a = (i);      <span class='comment'>// <span class='texttt'>decltype(x4a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x4d = (i);      <span class='comment'>// <span class='texttt'>decltype(x4d)</span> is <span class='texttt'>int&amp;</span>
</span>auto           x5a = f();      <span class='comment'>// <span class='texttt'>decltype(x5a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x5d = f();      <span class='comment'>// <span class='texttt'>decltype(x5d)</span> is <span class='texttt'>int&amp;&amp;</span>
</span>auto           x6a = { 1, 2 }; <span class='comment'>// <span class='texttt'>decltype(x6a)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>decltype(auto) x6d = { 1, 2 }; <span class='comment'>// error, <span class='texttt'>{ 1, 2 }</span> is not an expression
</span>auto          *x7a = &amp;i;       <span class='comment'>// <span class='texttt'>decltype(x7a)</span> is <span class='texttt'>int*</span>
</span>decltype(auto)*x7d = &amp;i;       <span class='comment'>// error, declared type is not plain <span class='texttt'>decltype(auto)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='dcl.type.class.deduct'><h4 ><a class='secnum' href='#dcl.type.class.deduct' style='min-width:118pt'>7.1.7.5</a> Deduced class template specialization types <a class='abbr_ref' href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>
</p><div class='para' id='dcl.type.class.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.class.deduct-1'>1</a></div><p >If a placeholder for a deduced class type
appears as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i>,
the <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>
of that declaration
shall be of the form</p><pre class='bnf'><i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.init#nt:initializer'>initializer</a></i></pre><p >The placeholder is replaced by the return type
of the function selected by overload resolution
for class template deduction (<a href='over.match.class.deduct'>[over.match.class.deduct]</a>).
If the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
contains more than one <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>,
the type that replaces the placeholder shall be the same in each deduction.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct container {
    container(T t) {}
    template&lt;class Iter&gt; container(Iter beg, Iter end);
};
template&lt;class Iter&gt;
container(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;
std::vector&lt;double&gt; v = { <span class='comment'>/* ... */</span>};

container c(7);                         <span class='comment'>// OK, deduces <span class='texttt'>int</span> for <span class='texttt'>T</span>
</span>auto d = container(v.begin(), v.end()); <span class='comment'>// OK, deduces <span class='texttt'>double</span> for <span class='texttt'>T</span>
</span>container e{5, 6};                      <span class='comment'>// error, <span class='texttt'>int</span> is not an iterator
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div><div id='dcl.enum'><h2 ><a class='secnum' href='#dcl.enum' style='min-width:88pt'>7.2</a> Enumeration declarations <a class='abbr_ref' href='dcl.enum'>[dcl.enum]</a></h2><p ><span class='indexparent'><a class='index' id='enumeration'></a></span><span class='indexparent'><a class='index' id='{},enum_declaration'></a></span><span class='indexparent'><a class='index' id='enum,type_of'></a></span></p><div class='para' id='dcl.enum-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-1'>1</a></div><p >An enumeration is a distinct type (<a href='basic.compound'>[basic.compound]</a>) with named
constants. Its name becomes an <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>, within its scope.</p><pre class='bnf'><a id='nt:enum-name'>enum-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:enum-specifier'>enum-specifier:</a>
    <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i> <span class='terminal'>{</span> <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span>
    <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i> <span class='terminal'>{</span> <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i> <span class='terminal'>, }</span></pre><pre class='bnf'><a id='nt:enum-head'>enum-head:</a>
    <i ><a href='dcl.enum#nt:enum-key'>enum-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.enum#nt:enum-key'>enum-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
<i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:opaque-enum-declaration'>opaque-enum-declaration:</a>
    <i ><a href='dcl.enum#nt:enum-key'>enum-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:enum-key'>enum-key:</a>
    <span class='terminal'>enum</span>
    <span class='terminal'>enum class</span>
    <span class='terminal'>enum struct</span></pre><pre class='bnf'><a id='nt:enum-base'>enum-base:</a>
    <span class='terminal'>:</span> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i></pre><pre class='bnf'><a id='nt:enumerator-list'>enumerator-list:</a>
    <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i>
    <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i></pre><pre class='bnf'><a id='nt:enumerator-definition'>enumerator-definition:</a>
    <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i>
    <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> <span class='terminal'>=</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><pre class='bnf'><a id='nt:enumerator'>enumerator:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in the <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i> and
the <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> appertains to the enumeration; the attributes
in that <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of the
enumeration whenever it is named.
A <span class='texttt'>:</span> following
“<span class='texttt'>enum</span> <span class='grammarterm'>nested-name-specifier<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>”
within the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>
is parsed as part of an <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span> This resolves a potential ambiguity between the declaration of an enumeration
with an <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i> and the declaration of an unnamed bit-field of enumeration
type. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
   struct S {
     enum E : int {};
     enum E : int {};  <span class='comment'>// error: redeclaration of enumeration
</span>   };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> contains
a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
the declaration shall be an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>).</p></div><div class='para' id='dcl.enum-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-2'>2</a></div><p ><span class='indexparent'><a class='index' id='constant,enumeration'></a></span><span class='indexparent'><a class='index' id='enumeration'></a></span><span class='indexparent'><a class='index' id='enumeration,unscoped'></a></span><span class='indexparent'><a class='index' id='enumeration,scoped'></a></span>The enumeration type declared with an <i ><a href='dcl.enum#nt:enum-key'>enum-key</a></i>
of only <span class='texttt'>enum</span> is an <i>unscoped enumeration</i>,
and its <i ><a href='dcl.enum#nt:enumerator'>enumerators</a></i> are <i>unscoped enumerators</i>.
The <i ><a href='dcl.enum#nt:enum-key'>enum-keys</a></i> <span class='texttt'>enum class</span> and
<span class='texttt'>enum struct</span> are semantically equivalent; an enumeration
type declared with one of these is a <i>scoped enumeration</i>,
and its <i ><a href='dcl.enum#nt:enumerator'>enumerators</a></i> are <i>scoped enumerators</i>.
The optional <i ><a href='lex.name#nt:identifier'>identifier</a></i> shall not be omitted in the declaration of a scoped enumeration.
The <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> of an <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i>
shall name an integral type; any cv-qualification is ignored.
An <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> declaring an unscoped enumeration shall
not omit the <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i>.
The identifiers in an <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i> are declared as
constants, and can appear wherever constants are required.
<span class='indexparent'><a class='index' id='enumerator,value_of'></a></span>An <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i> with <span class='texttt'>=</span> gives the associated
<i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> the value indicated by the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i>.
If the first <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i>
has no <i ><a href='dcl.init#nt:initializer'>initializer</a></i>, the value of the corresponding constant
is zero. An <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i> without an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> gives the <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> the value
obtained by increasing the value of the previous <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i>
by one.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum { a, b, c=0 };
enum { d, e, f=e+2 };
</pre><p >defines <span class='texttt'>a</span>, <span class='texttt'>c</span>, and <span class='texttt'>d</span> to be zero, <span class='texttt'>b</span> and
<span class='texttt'>e</span> to be <span class='texttt'>1</span>, and <span class='texttt'>f</span> to be <span class='texttt'>3</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in an
<i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> appertains to that enumerator.</p></div><div class='para' id='dcl.enum-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-3'>3</a></div><p >An <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> is either a redeclaration
of an enumeration in the current scope or a declaration of a new enumeration.
[&nbsp;<i>Note:</i><span class='space'></span> An enumeration declared by an
<i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> has fixed underlying type and is a
complete type. The list of enumerators can be provided in a later redeclaration
with an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] A scoped enumeration
shall not be later redeclared as unscoped or with a different underlying type.
An unscoped enumeration shall not be later redeclared as scoped and each
redeclaration shall include an <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i> specifying the same
underlying type as in the original declaration.</p></div><div class='para' id='dcl.enum-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-4'>4</a></div><p >If the <i ><a href='dcl.enum#nt:enum-key'>enum-key</a></i> is followed by a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, the <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> shall
refer to an enumeration that was previously declared directly in the class or
namespace to which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> refers (i.e., neither
inherited nor introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>), and the
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> shall appear in a namespace enclosing the previous
declaration.</p></div><div class='para' id='dcl.enum-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-5'>5</a></div><p ><span class='indexparent'><a class='index' id='enum,type_of'></a></span><span class='indexparent'><a class='index' id='enum,underlying_type'></a></span>Each enumeration defines a type that is different from all other types.
Each enumeration also has an underlying type.
The underlying type can be explicitly specified using an <i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i>.
For a scoped enumeration type, the underlying type is <span class='texttt'>int</span> if it is not
explicitly specified. In both of these cases, the underlying type is said to be
<i>fixed</i>.
Following the closing brace of an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>, each
enumerator has the type of its enumeration.
If the underlying type is fixed, the type of each enumerator
prior to the closing brace is the underlying
type
and the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> in the <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i>
shall be a converted constant expression of the underlying
type (<a href='expr.const'>[expr.const]</a>).
If the underlying
type is not fixed,
the type of each enumerator prior to the closing brace is determined as
follows:</p><ul ><li ><p >If an
initializer is specified for an enumerator, the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be an integral constant
expression (<a href='expr.const'>[expr.const]</a>). If the expression has
unscoped enumeration type, the enumerator has the underlying type of that
enumeration type, otherwise it has the same type as the expression.</p></li><li ><p >If no initializer is specified for the
first enumerator, its type is an unspecified signed integral type.</p></li><li ><p >Otherwise
the type of the enumerator is the same as that of the
preceding enumerator unless the incremented value is not representable
in that type, in which case the type is an unspecified integral type
sufficient to contain the incremented value. If no such type exists, the program
is ill-formed.
</p></li></ul></div><div class='para' id='dcl.enum-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-6'>6</a></div><p >An enumeration whose underlying type is fixed is an incomplete type from its
point of declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) to immediately after its
<i ><a href='dcl.enum#nt:enum-base'>enum-base</a></i> (if any), at which point it becomes a complete type.
An enumeration whose underlying type is not fixed is an incomplete type from
its point of declaration to immediately after the closing <span class='texttt'>}</span> of its
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>, at which point it becomes a complete type.</p></div><div class='para' id='dcl.enum-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-7'>7</a></div><p >For an enumeration whose underlying type is not fixed,
the underlying type
is an
integral type that can represent all the enumerator values defined in
the enumeration. If no integral type can represent all the enumerator
values, the enumeration is ill-formed. It is <span class='indexparent'><a class='index' id='underlying_type_for_enumeration'></a></span>implementation-defined
which integral type is used as the underlying type 
except that the underlying type shall not be larger than <span class='texttt'>int</span>
unless the value of an enumerator cannot fit in an <span class='texttt'>int</span> or
<span class='texttt'>unsigned int</span>. If the <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i> is empty, the
underlying type is as if the enumeration had a single enumerator with
value 0.</p></div><div class='para' id='dcl.enum-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-8'>8</a></div><p >For an enumeration whose underlying type is fixed, the values of
the enumeration are the values of the underlying type. Otherwise,
for an enumeration where <span class='math'><span class='mathalpha'>e</span><sub ><span class='mathit'>min</span></sub></span> is the smallest enumerator and
<span class='math'><span class='mathalpha'>e</span><sub ><span class='mathit'>max</span></sub></span> is the largest, the values of the enumeration are the
values in the range <span class='math'><span class='mathalpha'>b</span><sub ><span class='mathalpha'>min</span></sub></span> to <span class='math'><span class='mathalpha'>b</span><sub ><span class='mathalpha'>max</span></sub></span>, defined as follows: Let <span class='math'><span class='mathalpha'>K</span></span>
be 1 for a two's complement representation and 0 for a ones' complement
or sign-magnitude representation. <span class='math'><span class='mathalpha'>b</span><sub ><span class='mathalpha'>max</span></sub></span> is the smallest value
greater than or equal to <span class='math'><span class='mathalpha'>max</span>(|<span class='mathalpha'>e</span><sub ><span class='mathalpha'>min</span></sub>| - <span class='mathalpha'>K</span>, |<span class='mathalpha'>e</span><sub ><span class='mathalpha'>max</span></sub>|)</span> and equal to
<span class='math'>2<sup ><span class='mathalpha'>M</span></sup>-1</span>, where <span class='math'><span class='mathalpha'>M</span></span> is a non-negative integer. <span class='math'><span class='mathalpha'>b</span><sub ><span class='mathalpha'>min</span></sub></span> is zero if
<span class='math'><span class='mathalpha'>e</span><sub ><span class='mathalpha'>min</span></sub></span> is non-negative and <span class='math'>-(<span class='mathalpha'>b</span><sub ><span class='mathalpha'>max</span></sub>+<span class='mathalpha'>K</span>)</span> otherwise. The size of the
smallest bit-field large enough to hold all the values of the
enumeration type is <span class='math'><span class='mathalpha'>max</span>(<span class='mathalpha'>M</span>,1)</span> if <span class='math'><span class='mathalpha'>b</span><sub ><span class='mathalpha'>min</span></sub></span> is zero and <span class='math'><span class='mathalpha'>M</span>+1</span> otherwise.
It is possible to define an enumeration that has values not defined by
any of its enumerators. If the <i ><a href='dcl.enum#nt:enumerator-list'>enumerator-list</a></i> is empty, the
values of the enumeration are as if the enumeration had a single enumerator with
value 0.<a class='footnotenum' href='#footnote-95'>95</a></p></div><div class='para' id='dcl.enum-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-9'>9</a></div><p >Two enumeration types are <a id='layout-compatible,enumeration'><i>layout-compatible enumerations</i></a>
if they have the same underlying type.</p></div><div class='para' id='dcl.enum-10'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-10'>10</a></div><p >The value of an enumerator or an object of an unscoped enumeration type is
converted to an integer by integral promotion (<a href='conv.prom'>[conv.prom]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><p ><span class='indexparent'><a class='index' id='example,enumeration'></a></span></p><pre class='codeblock'>
  enum color { red, yellow, green=20, blue };
  color col = red;
  color* cp = &amp;col;
  if (*cp == blue)              <span class='comment'>// ...
</span></pre><p >makes <span class='texttt'>color</span> a type describing various colors, and then declares
<span class='texttt'>col</span> as an object of that type, and <span class='texttt'>cp</span> as a pointer to an
object of that type. The possible values of an object of type
<span class='texttt'>color</span> are <span class='texttt'>red</span>, <span class='texttt'>yellow</span>, <span class='texttt'>green</span>,
<span class='texttt'>blue</span>; these values can be converted to the integral values
<span class='texttt'>0</span>, <span class='texttt'>1</span>, <span class='texttt'>20</span>, and <span class='texttt'>21</span>. Since enumerations are
distinct types, objects of type <span class='texttt'>color</span> can be assigned only
values of type <span class='texttt'>color</span>.</p><pre class='codeblock'>
color c = 1;                    <span class='comment'>// error: type mismatch,
</span>                                <span class='comment'>// no conversion from <span class='texttt'>int</span> to <span class='texttt'>color</span>
</span>
int i = yellow;                 <span class='comment'>// OK: <span class='texttt'>yellow</span> converted to integral value <span class='texttt'>1</span>
</span>                                <span class='comment'>// integral promotion
</span></pre><p >Note that this implicit <span class='texttt'>enum</span> to <span class='texttt'>int</span>
conversion is not provided for a scoped enumeration:</p><pre class='codeblock'>
enum class Col { red, yellow, green };
int x = Col::red;               <span class='comment'>// error: no <span class='texttt'>Col</span> to <span class='texttt'>int</span> conversion
</span>Col y = Col::red;
if (y) { }                      <span class='comment'>// error: no <span class='texttt'>Col</span> to <span class='texttt'>bool</span> conversion
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.enum-11'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-11'>11</a></div><p ><span class='indexparent'><a class='index' id='class,scope_of_enumerator'></a></span>Each <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i> and each unscoped <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> is
declared in the scope that immediately contains the <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.
Each scoped <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i> is declared in the scope of the
enumeration.
These names obey the scope rules defined for all names
in (<a href='basic.scope'>[basic.scope]</a>) and (<a href='basic.lookup'>[basic.lookup]</a>).[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum direction { left='l', right='r' }; 

void g()  { 
  direction d;                  <span class='comment'>// OK 
</span>  d = left;                     <span class='comment'>// OK 
</span>  d = direction::right;         <span class='comment'>// OK 
</span>} 

enum class altitude { high='h', low='l' }; 

void h()  { 
  altitude a;                   <span class='comment'>// OK 
</span>  a = high;                     <span class='comment'>// error: high not in scope 
</span>  a = altitude::low;            <span class='comment'>// OK 
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='member,enumerator'></a></span>An enumerator declared in class scope can be referred to using the class
member access operators (<span class='texttt'>::</span>, <span class='texttt'>.</span> (dot) and <span class='texttt'>-&gt;</span>
(arrow)), see <a href='expr.ref'>[expr.ref]</a>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  enum direction { left='l', right='r' };
  int f(int i) { return i==left ? 0 : i==right ? 1 : 2; }
};

void g(X* p) {
  direction d;                  <span class='comment'>// error: <span class='texttt'>direction</span> not in scope
</span>  int i;
  i = p-&gt;f(left);               <span class='comment'>// error: <span class='texttt'>left</span> not in scope
</span>  i = p-&gt;f(X::right);           <span class='comment'>// OK
</span>  i = p-&gt;f(p-&gt;left);            <span class='comment'>// OK
</span>  <span class='comment'>// ...
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.enum-12'><div class='marginalizedparent'><a class='marginalized' href='#dcl.enum-12'>12</a></div><p >If an <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i> contains a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
the <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> shall refer to an enumeration
that was previously declared directly in the class or namespace
to which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> refers, or
in an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>)
of that namespace (i.e., not merely inherited or introduced by a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>), and
the <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> shall appear in
a namespace enclosing the previous declaration.
In such cases, the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
of the <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i> of the definition
shall not begin with a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.</p></div><div class='footnote' id='footnote-95'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-95'>95)</a></div><p >This set of values is used to define promotion and
conversion semantics for the enumeration type. It does not preclude an
expression of enumeration type from having a value that falls outside
this range.</p></div></div><div id='basic.namespace'><h2 ><a class='secnum' href='#basic.namespace' style='min-width:88pt'>7.3</a> Namespaces <a class='abbr_ref' href='basic.namespace'>[basic.namespace]</a></h2><p ><span class='indexparent'><a class='index' id='namespaces'></a></span></p><div class='para' id='basic.namespace-1'><div class='marginalizedparent'><a class='marginalized' href='#basic.namespace-1'>1</a></div><p >A namespace is an optionally-named declarative region. The name of a
namespace can be used to access entities declared in that namespace;
that is, the members of the namespace. Unlike other declarative regions,
the definition of a namespace can be split over several parts of one or
more translation units.</p></div><div class='para' id='basic.namespace-2'><div class='marginalizedparent'><a class='marginalized' href='#basic.namespace-2'>2</a></div><p >The outermost declarative region of a translation unit is a namespace;
see <a href='basic.scope.namespace'>[basic.scope.namespace]</a>.</p></div><div id='namespace.def'><h3 ><a class='secnum' href='#namespace.def' style='min-width:103pt'>7.3.1</a> Namespace definition <a class='abbr_ref' href='namespace.def'>[namespace.def]</a></h3><p ><span class='indexparent'><a class='index' id='definition,namespace'></a></span><span class='indexparent'><a class='index' id='namespace,definition'></a></span></p><pre class='bnf'><a id='nt:namespace-name'>namespace-name:</a>
        <i ><a href='lex.name#nt:identifier'>identifier</a></i>
        <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i></pre><pre class='bnf'><a id='nt:namespace-definition'>namespace-definition:</a>
        <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i>
        <i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i>
        <i ><a href='namespace.def#nt:nested-namespace-definition'>nested-namespace-definition</a></i></pre><pre class='bnf'><a id='nt:named-namespace-definition'>named-namespace-definition:</a>
        <span class='terminal'>inline<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>namespace</span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:unnamed-namespace-definition'>unnamed-namespace-definition:</a>
        <span class='terminal'>inline<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>namespace</span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:nested-namespace-definition'>nested-namespace-definition:</a>
        <span class='terminal'>namespace</span> <i ><a href='namespace.def#nt:enclosing-namespace-specifier'>enclosing-namespace-specifier</a></i> <span class='terminal'>::</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:enclosing-namespace-specifier'>enclosing-namespace-specifier:</a>
        <i ><a href='lex.name#nt:identifier'>identifier</a></i>
        <i ><a href='namespace.def#nt:enclosing-namespace-specifier'>enclosing-namespace-specifier</a></i> <span class='terminal'>::</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:namespace-body'>namespace-body:</a>
        <i ><a href='dcl.dcl#nt:declaration-seq'>declaration-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><div class='para' id='namespace.def-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-1'>1</a></div><p >Every <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> shall appear in the global scope
or in a namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>).</p></div><div class='para' id='namespace.def-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-2'>2</a></div><p >In a <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i>,
the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is the name of the namespace.
If the <i ><a href='lex.name#nt:identifier'>identifier</a></i>, when looked up (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>),
refers to a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> (but not a <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i>)
that was introduced in the namespace
in which the <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i> appears
or that was introduced in a member of the inline namespace set of that namespace,
the <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i>
<span class='indexparent'><a class='index' id='extend'></a></span>
<a id='namespace,extend'><i>extends</i></a> the previously-declared namespace.
Otherwise, the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is introduced
as a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> into the declarative region
in which the <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i> appears.</p></div><div class='para' id='namespace.def-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-3'>3</a></div><p >Because a <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> contains
<i ><a href='dcl.dcl#nt:declaration'>declarations</a></i> in its <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> and a
<i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> is itself a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>, it
follows that <span class='grammarterm'>namespace-definitions</span> can be nested.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace Outer {
  int i;
  namespace Inner {
    void f() { i++; }           <span class='comment'>// <span class='texttt'>Outer::i</span>
</span>    int i;
    void g() { i++; }           <span class='comment'>// <span class='texttt'>Inner::i</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.def-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-4'>4</a></div><p >The <i>enclosing namespaces</i> of a declaration are those
namespaces in which the declaration lexically appears, except for a
redeclaration of a namespace member outside its original namespace
(e.g., a definition as specified in <a href='namespace.memdef'>[namespace.memdef]</a>). Such a
redeclaration has the same enclosing namespaces as the original
declaration.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
namespace Q {
  namespace V {
    void f();   <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>    class C { void m(); };
  }
  void V::f() { <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>    extern void h();  <span class='comment'>// ... so this declares <span class='texttt'>Q::V::h</span>
</span>  }
  void V::C::m() { <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.def-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-5'>5</a></div><p >If the optional initial <span class='texttt'>inline</span> keyword appears in a
<i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> for a particular namespace, that namespace is
declared to be an <i>inline namespace</i>. The <span class='texttt'>inline</span> keyword may be
used on a <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> that extends a namespace
only if it was previously used on the <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> 
that initially declared the <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> for that namespace.</p></div><div class='para' id='namespace.def-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-6'>6</a></div><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
in a <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i>
appertains to the namespace being defined or extended.</p></div><div class='para' id='namespace.def-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-7'>7</a></div><p >Members of an inline namespace can be used in most respects as though they were members
of the enclosing namespace. Specifically, the inline namespace and its enclosing
namespace are both added to the set of associated namespaces used in
argument-dependent lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) whenever one of them is,
and a <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> (<a href='namespace.udir'>[namespace.udir]</a>) that names the inline
namespace is implicitly inserted into the enclosing namespace as for an unnamed
namespace (<a href='namespace.unnamed'>[namespace.unnamed]</a>). Furthermore, each
member of the inline namespace can subsequently be partially
specialized (<a href='temp.class.spec'>[temp.class.spec]</a>), explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>), or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>) as
though it were a member of the enclosing namespace. Finally, looking up a name in the
enclosing namespace via explicit qualification (<a href='namespace.qual'>[namespace.qual]</a>) will include
members of the inline namespace brought in by the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> even if
there are declarations of that name in the enclosing namespace.</p></div><div class='para' id='namespace.def-8'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-8'>8</a></div><p >These properties are transitive: if a namespace <span class='texttt'>N</span> contains an inline namespace
<span class='texttt'>M</span>, which in turn contains an inline namespace <span class='texttt'>O</span>, then the members of
<span class='texttt'>O</span> can be used as though they were members of <span class='texttt'>M</span> or <span class='texttt'>N</span>.
The <i>inline namespace set</i> of <span class='texttt'>N</span> is the transitive closure of all
inline namespaces in <span class='texttt'>N</span>.
The <i>enclosing namespace set</i> of <span class='texttt'>O</span> is the set of namespaces
consisting of the innermost non-inline namespace enclosing
an inline namespace <span class='texttt'>O</span>, together with any intervening inline namespaces.</p></div><div class='para' id='namespace.def-9'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-9'>9</a></div><p >A <i ><a href='namespace.def#nt:nested-namespace-definition'>nested-namespace-definition</a></i> with an
<i ><a href='namespace.def#nt:enclosing-namespace-specifier'>enclosing-namespace-specifier</a></i> <span class='texttt'>E</span>,
<i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='texttt'>I</span> and
<i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='texttt'>B</span>
is equivalent to
</p><pre class='codeblock'>
namespace E { namespace I { B } }
</pre><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
namespace A::B::C {
  int i;
}
</pre><p >The above has the same effect as:
</p><pre class='codeblock'>
namespace A {
  namespace B {
    namespace C {
      int i;
    }
  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='namespace.unnamed'><h4 ><a class='secnum' href='#namespace.unnamed' style='min-width:118pt'>7.3.1.1</a> Unnamed namespaces <a class='abbr_ref' href='namespace.unnamed'>[namespace.unnamed]</a></h4><p ><span class='indexparent'><a class='index' id='namespace,unnamed'></a></span></p><div class='para' id='namespace.unnamed-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.unnamed-1'>1</a></div><p >An <i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i> behaves as if it were
replaced by</p><pre class='bnf'><span class='terminal'>inline</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>namespace</span> <span class='textrm'><i><b>unique</b></i></span> <span class='terminal'>{ /* empty body */ }</span>
<span class='terminal'>using namespace</span> <span class='textrm'><i><b>unique</b></i></span> <span class='terminal'>;</span>
<span class='terminal'>namespace</span> <span class='textrm'><i><b>unique</b></i></span> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><p >where
<span class='texttt'>inline</span> appears if and only if it appears in the
<i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i>
and all occurrences of <span class='textrm'><i><b>unique</b></i></span> in a translation unit are replaced by
the same identifier, and this identifier differs from all other
identifiers in the translation unit.
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
in the <i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i>
appertains to <span class='textrm'><i><b>unique</b></i></span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace { int i; }            <span class='comment'>// <span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i</span>
</span>void f() { i++; }               <span class='comment'>// <span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i++</span>
</span>
namespace A {
  namespace {
    int i;                      <span class='comment'>// <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i</span>
</span>    int j;                      <span class='comment'>// <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::j</span>
</span>  }
  void g() { i++; }             <span class='comment'>// <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i++</span>
</span>}

using namespace A;
void h() {
  i++;                          <span class='comment'>// error: <span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i</span> or <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i</span>
</span>  A::i++;                       <span class='comment'>// <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::i</span>
</span>  j++;                          <span class='comment'>// <span class='texttt'>A::</span><span class='textrm'><i><b>unique</b></i></span><span class='texttt'>::j</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='namespace.memdef'><h4 ><a class='secnum' href='#namespace.memdef' style='min-width:118pt'>7.3.1.2</a> Namespace member definitions <a class='abbr_ref' href='namespace.memdef'>[namespace.memdef]</a></h4><p ><span class='indexparent'><a class='index' id='namespace,member_definition'></a></span></p><div class='para' id='namespace.memdef-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-1'>1</a></div><p >A declaration in a namespace <span class='texttt'>N</span> (excluding declarations in nested scopes)
whose <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>
declares (or redeclares) a member of <span class='texttt'>N</span>, and may be a definition.
[&nbsp;<i>Note:</i><span class='space'></span> An explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or
explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) of a template
does not introduce a name and thus may be declared using an
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> in a member of the enclosing namespace set,
if the primary template is declared in an inline namespace. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace X {
  void f() { <span class='comment'>/* ... */</span> }  <span class='comment'>// OK: introduces <span class='texttt'>X::f()</span>
</span>
  namespace M {
    void g();             <span class='comment'>// OK: introduces <span class='texttt'>X::M::g()</span>
</span>  }
  using M::g;
  void g();               <span class='comment'>// error: conflicts with <span class='texttt'>X::M::g()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.memdef-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-2'>2</a></div><p >Members of a named namespace can also be
defined outside that namespace by explicit
qualification (<a href='namespace.qual'>[namespace.qual]</a>) of the name being defined, provided
that the entity being defined was already declared in the namespace and
the definition appears after the point of declaration in a namespace
that encloses the declaration's namespace.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace Q {
  namespace V {
    void f();
  }
  void V::f() { <span class='comment'>/* ... */</span> }     <span class='comment'>// OK
</span>  void V::g() { <span class='comment'>/* ... */</span> }     <span class='comment'>// error: <span class='texttt'>g()</span> is not yet a member of <span class='texttt'>V</span>
</span>  namespace V {
    void g();
  }
}

namespace R {
  void Q::V::g() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>R</span> doesn't enclose <span class='texttt'>Q</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.memdef-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-3'>3</a></div><p >If a <span class='texttt'>friend</span> declaration in a non-local class first declares a
class, function, class template or function template<a class='footnotenum' href='#footnote-96'>96</a>
the friend is a member of the innermost enclosing
namespace. The <span class='texttt'>friend</span> declaration does not by itself make the name
visible to unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) or qualified
lookup (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>). [&nbsp;<i>Note:</i><span class='space'></span> The name of the friend will be
visible in its namespace if a matching declaration is provided at namespace
scope (either before or after the class definition granting friendship).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] If a friend
function or function template is called, its name may be found by the
name lookup that considers functions from namespaces and classes
associated with the types of the function
arguments (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>). If the
name in a <span class='texttt'>friend</span> declaration is neither qualified nor a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> and the declaration is a function or an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, the lookup to determine whether
the entity has been previously declared shall not consider any scopes
outside the innermost enclosing namespace. [&nbsp;<i>Note:</i><span class='space'></span> The other forms of
<span class='texttt'>friend</span> declarations cannot declare a new member of the innermost
enclosing namespace and thus follow the usual lookup rules.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
<span class='comment'>// Assume <span class='texttt'>f</span> and <span class='texttt'>g</span> have not yet been declared.
</span>void h(int);
template &lt;class T&gt; void f2(T);
namespace A {
  class X {
    friend void f(X);           <span class='comment'>// <span class='texttt'>A::f(X)</span> is a friend
</span>    class Y {
      friend void g();          <span class='comment'>// <span class='texttt'>A::g</span> is a friend
</span>      friend void h(int);       <span class='comment'>// <span class='texttt'>A::h</span> is a friend
</span>                                <span class='comment'>// <span class='texttt'>::h</span> not considered
</span>      friend void f2&lt;&gt;(int);    <span class='comment'>// <span class='texttt'>::f2&lt;&gt;(int)</span> is a friend
</span>    };
  };

  <span class='comment'>// <span class='texttt'>A::f</span>, <span class='texttt'>A::g</span> and <span class='texttt'>A::h</span> are not visible here
</span>  X x;
  void g() { f(x); }            <span class='comment'>// definition of <span class='texttt'>A::g</span>
</span>  void f(X) <span class='texttt'>{ /* ... */}</span>       <span class='comment'>// definition of <span class='texttt'>A::f</span>
</span>  void h(int) <span class='texttt'>{ /* ... */ }</span>    <span class='comment'>// definition of <span class='texttt'>A::h</span>
</span>  <span class='comment'>// <span class='texttt'>A::f</span>, <span class='texttt'>A::g</span> and <span class='texttt'>A::h</span> are visible here and known to be friends
</span>}

using A::x;

void h() {
  A::f(x);
  A::X::f(x);                   <span class='comment'>// error: <span class='texttt'>f</span> is not a member of <span class='texttt'>A::X</span>
</span>  A::X::Y::g();                 <span class='comment'>// error: <span class='texttt'>g</span> is not a member of <span class='texttt'>A::X::Y</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-96'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-96'>96)</a></div><p >this implies that the name of the class or function is unqualified.</p></div></div></div><div id='namespace.alias'><h3 ><a class='secnum' href='#namespace.alias' style='min-width:103pt'>7.3.2</a> Namespace alias <a class='abbr_ref' href='namespace.alias'>[namespace.alias]</a></h3><p ><span class='indexparent'><a class='index' id='namespace,alias'></a></span><span class='indexparent'><a class='index' id='alias,namespace'></a></span><span class='indexparent'><a class='index' id='synonym'></a></span></p><div class='para' id='namespace.alias-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-1'>1</a></div><p >A <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> declares an alternate name for a
namespace according to the following grammar:</p><pre class='bnf'><a id='nt:namespace-alias'>namespace-alias:</a>
        <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:namespace-alias-definition'>namespace-alias-definition:</a>
        <span class='terminal'>namespace</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>=</span> <i ><a href='namespace.alias#nt:qualified-namespace-specifier'>qualified-namespace-specifier</a></i> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:qualified-namespace-specifier'>qualified-namespace-specifier:</a>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i></pre></div><div class='para' id='namespace.alias-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-2'>2</a></div><p >The <i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> is
a synonym for the name of the namespace denoted by the
<i ><a href='namespace.alias#nt:qualified-namespace-specifier'>qualified-namespace-specifier</a></i> and becomes a
<i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
When looking up a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> in a
<i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i>, only namespace names are
considered, see <a href='basic.lookup.udir'>[basic.lookup.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.alias-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-3'>3</a></div><p >In a declarative region, a <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> can be
used to redefine a <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i> declared in that
declarative region to refer only to the namespace to which it already
refers.
[&nbsp;<i>Example:</i><span class='space'></span>
the following declarations are well-formed:</p><pre class='codeblock'>
namespace Company_with_very_long_name { <span class='comment'>/* ... */</span> }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name;          <span class='comment'>// OK: duplicate
</span>namespace CWVLN = CWVLN;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='namespace.udecl'><h3 ><a class='secnum' href='#namespace.udecl' style='min-width:103pt'>7.3.3</a> The <span class='texttt'>using</span> declaration <a class='abbr_ref' href='namespace.udecl'>[namespace.udecl]</a></h3><p ><span class='indexparent'><a class='index' id='using-declaration'></a></span></p><div class='para' id='namespace.udecl-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-1'>1</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> introduces a set of declarations into the declarative
region in which the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> appears.</p><pre class='bnf'><a id='nt:using-declaration'>using-declaration:</a>
    <span class='terminal'>using typename<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> <span class='terminal'>;</span></pre><p >The set of declarations introduced by the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is found by
performing qualified name lookup (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>, <a href='class.member.lookup'>[class.member.lookup]</a>)
for the name in the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>,
excluding functions that are hidden as described below.
If the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> does not name a constructor,
the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is declared in the declarative region
in which the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> appears
as a synonym for each declaration introduced by the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span> Only the specified name is so declared;
specifying an enumeration name in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
does not declare its enumerators
in the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration's</a></i> declarative region.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='inheritance,using-declaration'></a></span>If the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a constructor,
it declares that the class <i>inherits</i> the set of constructor declarations
introduced by the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> from the nominated base class.</p></div><div class='para' id='namespace.udecl-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-2'>2</a></div><p >Every <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> and a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> and so can be used in a class definition.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct B {
  void f(char);
  void g(char);
  enum E { e };
  union { int x; };
};

struct D : B {
  using B::f;
  void f(int) { f('c'); }       <span class='comment'>// calls <span class='texttt'>B::f(char)</span>
</span>  void g(int) { g('c'); }       <span class='comment'>// recursively calls <span class='texttt'>D::g(int)</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-3'>3</a></div><p >In a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> used as a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>, the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
shall name a base class of the class being defined. If such a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a constructor, the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> shall name a direct base class of the class
being defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class C {
  int g();
};

class D2 : public B {
  using B::f;                   <span class='comment'>// OK: <span class='texttt'>B</span> is a base of <span class='texttt'>D2</span>
</span>  using B::e;                   <span class='comment'>// OK: <span class='texttt'>e</span> is an enumerator of base <span class='texttt'>B</span>
</span>  using B::x;                   <span class='comment'>// OK: <span class='texttt'>x</span> is a union member of base <span class='texttt'>B</span>
</span>  using C::g;                   <span class='comment'>// error: <span class='texttt'>C</span> isn't a base of <span class='texttt'>D2</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Since destructors do not have names, a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> cannot refer to a
destructor for a base class. Since specializations of member templates
for conversion functions are not found by name lookup, they are not
considered when a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> specifies a conversion
function (<a href='temp.mem'>[temp.mem]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If a constructor or assignment operator brought from a base class into a derived class
has the signature of a copy/move constructor or assignment operator
for the derived class (<a href='class.copy'>[class.copy]</a>),
the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> does not by itself
suppress the implicit declaration of the derived class member;
the member from the base class is hidden or overridden
by the implicitly-declared copy/move constructor or assignment operator
of the derived class, as described below.</p></div><div class='para' id='namespace.udecl-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-5'>5</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a <i ><a href='temp.names#nt:template-id'>template-id</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; void f(T);
  template &lt;class T&gt; struct X { };
};
struct B : A {
  using A::f&lt;double&gt;;           <span class='comment'>// ill-formed
</span>  using A::X&lt;int&gt;;              <span class='comment'>// ill-formed
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-6'>6</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a namespace.</p></div><div class='para' id='namespace.udecl-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-7'>7</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a scoped enumerator.</p></div><div class='para' id='namespace.udecl-8'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-8'>8</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that names a class member shall be a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  int i;
  static int s;
};

void f() {
  using X::i;       <span class='comment'>// error: <span class='texttt'>X::i</span> is a class member
</span>                    <span class='comment'>// and this is not a member declaration.
</span>  using X::s;       <span class='comment'>// error: <span class='texttt'>X::s</span> is a class member
</span>                    <span class='comment'>// and this is not a member declaration.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-9'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-9'>9</a></div><p >Members declared by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> can be referred to by
explicit qualification just like other member
names (<a href='namespace.qual'>[namespace.qual]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f();

namespace A {
  void g();
}

namespace X {
  using ::f;        <span class='comment'>// global <span class='texttt'>f</span>
</span>  using A::g;       <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>g</span>
</span>}

void h(){
  X::f();           <span class='comment'>// calls <span class='texttt'>::f</span>
</span>  X::g();           <span class='comment'>// calls <span class='texttt'>A::g</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-10'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-10'>10</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> and can
therefore be used repeatedly where (and only where) multiple
declarations are allowed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  int i;
}

namespace A1 {
  using A::i;
  using A::i;       <span class='comment'>// OK: double declaration
</span>}

struct B {
  int i;
};

struct X : B {
  using B::i;
  using B::i;       <span class='comment'>// error: double member declaration
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-11'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-11'>11</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that names a namespace,
members added to the namespace after the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
are not in the set of introduced declarations, so they are not
considered when a use of the name is made. Thus, additional
overloads added after the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> are ignored, but
default function arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>), default template
arguments (<a href='temp.param'>[temp.param]</a>), and template specializations (<a href='temp.class.spec'>[temp.class.spec]</a>,
<a href='temp.expl.spec'>[temp.expl.spec]</a>) are considered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  void f(int);
}

using A::f;         <span class='comment'>// <span class='texttt'>f</span> is a synonym for <span class='texttt'>A::f</span>;
</span>                    <span class='comment'>// that is, for <span class='texttt'>A::f(int)</span>.
</span>namespace A {
  void f(char);
}

void foo() {
  f('a');           <span class='comment'>// calls <span class='texttt'>f(int)</span>,
</span>}                   <span class='comment'>// even though <span class='texttt'>f(char)</span> exists.
</span>
void bar() {
  using A::f;       <span class='comment'>// <span class='texttt'>f</span> is a synonym for <span class='texttt'>A::f</span>;
</span>                    <span class='comment'>// that is, for <span class='texttt'>A::f(int)</span> and <span class='texttt'>A::f(char)</span>.
</span>  f('a');           <span class='comment'>// calls <span class='texttt'>f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-12'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-12'>12</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Partial specializations of class templates are found by looking up the
primary class template and then considering all partial specializations
of that template. If a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a class
template, partial specializations introduced after the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> are effectively visible because the primary
template is visible (<a href='temp.class.spec'>[temp.class.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-13'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-13'>13</a></div><p >Since a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a declaration, the restrictions
on declarations of the same name in the same declarative
region (<a href='basic.scope'>[basic.scope]</a>) also apply to <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  int x;
}

namespace B {
  int i;
  struct g { };
  struct x { };
  void f(int);
  void f(double);
  void g(char);     <span class='comment'>// OK: hides <span class='texttt'>struct g</span>
</span>}

void func() {
  int i;
  using B::i;       <span class='comment'>// error: <span class='texttt'>i</span> declared twice
</span>  void f(char);
  using B::f;       <span class='comment'>// OK: each <span class='texttt'>f</span> is a function
</span>  f(3.5);           <span class='comment'>// calls <span class='texttt'>B::f(double)</span>
</span>  using B::g;
  g('a');           <span class='comment'>// calls <span class='texttt'>B::g(char)</span>
</span>  struct g g1;      <span class='comment'>// <span class='texttt'>g1</span> has class type <span class='texttt'>B::g</span>
</span>  using B::x;
  using A::x;       <span class='comment'>// OK: hides <span class='texttt'>struct B::x</span>
</span>  x = 99;           <span class='comment'>// assigns to <span class='texttt'>A::x</span>
</span>  struct x x1;      <span class='comment'>// <span class='texttt'>x1</span> has class type <span class='texttt'>B::x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-14'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-14'>14</a></div><p >If a function declaration in namespace scope or block scope has the same
name and the same parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>) as
a function introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, and the
declarations do not declare the same function, the program is
ill-formed. If a function template declaration in namespace scope has
the same name, parameter-type-list, return type, and template
parameter list as a function template introduced by a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, the program is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span>
Two <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> may introduce functions with the same
name and the same parameter-type-list. If, for a call to an unqualified
function name, function overload resolution selects the functions
introduced by such <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>, the function call is
ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace B {
  void f(int);
  void f(double);
}
namespace C {
  void f(int);
  void f(double);
  void f(char);
}

void h() {
  using B::f;       <span class='comment'>// <span class='texttt'>B::f(int)</span> and <span class='texttt'>B::f(double)</span>
</span>  using C::f;       <span class='comment'>// <span class='texttt'>C::f(int)</span>, <span class='texttt'>C::f(double)</span>, and <span class='texttt'>C::f(char)</span>
</span>  f('h');           <span class='comment'>// calls <span class='texttt'>C::f(char)</span>
</span>  f(1);             <span class='comment'>// error: ambiguous: <span class='texttt'>B::f(int)</span> or <span class='texttt'>C::f(int)</span>?
</span>  void f(int);      <span class='comment'>// error: <span class='texttt'>f(int)</span> conflicts with <span class='texttt'>C::f(int)</span> and <span class='texttt'>B::f(int)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-15'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-15'>15</a></div><p ><span class='indexparent'><a class='index' id='name_hiding,using-declaration_and'></a></span>When a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> brings declarations from a base class into
a derived class, member functions and member function templates in
the derived class override and/or hide member functions and member
function templates with the same name,
parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>), cv-qualification, and <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (if any) in a base
class (rather than conflicting).
Such hidden or overridden declarations are excluded from the set of
declarations introduced by the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct B {
  virtual void f(int);
  virtual void f(char);
  void g(int);
  void h(int);
};

struct D : B {
  using B::f;
  void f(int);      <span class='comment'>// OK: <span class='texttt'>D::f(int)</span> overrides <span class='texttt'>B::f(int)</span>;
</span>
  using B::g;
  void g(char);     <span class='comment'>// OK
</span>
  using B::h;
  void h(int);      <span class='comment'>// OK: <span class='texttt'>D::h(int)</span> hides <span class='texttt'>B::h(int)</span>
</span>};

void k(D* p){
  p-&gt;f(1);          <span class='comment'>// calls <span class='texttt'>D::f(int)</span>
</span>  p-&gt;f('a');        <span class='comment'>// calls <span class='texttt'>B::f(char)</span>
</span>  p-&gt;g(1);          <span class='comment'>// calls <span class='texttt'>B::g(int)</span>
</span>  p-&gt;g('a');        <span class='comment'>// calls <span class='texttt'>D::g(char)</span>
</span>}

struct B1 {
  B1(int);
};

struct B2 {
  B2(int);
};

struct D1 : B1, B2 {
  using B1::B1;
  using B2::B2;
};
D1 d1(0);    <span class='comment'>// ill-formed: ambiguous
</span>
struct D2 : B1, B2 {
  using B1::B1;
  using B2::B2;
  D2(int);   <span class='comment'>// OK: <span class='texttt'>D2::D2(int)</span> hides <span class='texttt'>B1::B1(int)</span> and <span class='texttt'>B2::B2(int)</span>
</span>};
D2 d2(0);    <span class='comment'>// calls <span class='texttt'>D2::D2(int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-16'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-16'>16</a></div><p ><span class='indexparent'><a class='index' id='overloading,using-declaration_and'></a></span>For the purpose of overload resolution, the functions that are
introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> into a derived class
are treated as though they were members of the derived class. In
particular, the implicit <span class='texttt'>this</span> parameter shall be treated as if
it were a pointer to the derived class rather than to the base class.
This has no effect on the type of the function, and in all other
respects the function remains a member of the base class.
Likewise, constructors that are introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
are treated as though they were constructors of the derived class
when looking up the constructors of the derived class (<a href='class.qual'>[class.qual]</a>)
or forming a set of overload candidates (<a href='over.match.ctor'>[over.match.ctor]</a>, <a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.list'>[over.match.list]</a>).
If such a constructor is selected to perform the initialization
of an object of class type, all subobjects other than the base class
from which the constructor originated
are implicitly initialized (<a href='class.inhctor.init'>[class.inhctor.init]</a>).</p></div><div class='para' id='namespace.udecl-17'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-17'>17</a></div><p ><span class='indexparent'><a class='index' id='access_control,using-declaration_and'></a></span>In a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that does not name a constructor,
all members of the set of introduced declarations shall be accessible.
In a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that names a constructor,
no access check is performed.
In particular, if a derived class uses a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> to access a member of a base class, the
member name shall be accessible. If the name is that of an overloaded
member function, then all functions named shall be accessible. The base
class members mentioned by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall be
visible in the scope of at least one of the direct base classes of the
class where the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is specified. [&nbsp;<i>Note:</i><span class='space'></span>
Because a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> designates a base class member
(and not a member subobject or a member function of a base class
subobject), a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> cannot be used to resolve
inherited member ambiguities. For example,</p><pre class='codeblock'>
struct A { int x(); };
struct B : A { };
struct C : A {
  using A::x;
  int x(int);
};

struct D : B, C {
  using C::x;
  int x(double);
};
int f(D* d) {
  return d-&gt;x();    <span class='comment'>// ambiguous: <span class='texttt'>B::x</span> or <span class='texttt'>C::x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-18'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-18'>18</a></div><p >A synonym created by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> has the usual
accessibility for a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>.
A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that names a constructor does not
create a synonym; instead, the additional constructors
are accessible if they would be accessible
when used to construct an object of the corresponding base class,
and the accessibility of the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is ignored.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class A {
private:
    void f(char);
public:
    void f(int);
protected:
    void g();
};

class B : public A {
  using A::f;       <span class='comment'>// error: <span class='texttt'>A::f(char)</span> is inaccessible
</span>public:
  using A::g;       <span class='comment'>// <span class='texttt'>B::g</span> is a public synonym for <span class='texttt'>A::g</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-19'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-19'>19</a></div><p >If a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> uses the keyword <span class='texttt'>typename</span> and
specifies a dependent name (<a href='temp.dep'>[temp.dep]</a>), the name introduced by the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is treated as a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>).<span class='indexparent'><a class='index' id='using-declaration'></a></span></p></div></div><div id='namespace.udir'><h3 ><a class='secnum' href='#namespace.udir' style='min-width:103pt'>7.3.4</a> Using directive <a class='abbr_ref' href='namespace.udir'>[namespace.udir]</a></h3><p ><span class='indexparent'><a class='index' id='using-directive'></a></span></p><pre class='bnf'><a id='nt:using-directive'>using-directive:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>using  namespace</span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> <span class='terminal'>;</span></pre><div class='para' id='namespace.udir-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-1'>1</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> shall not appear in class scope, but may
appear in namespace scope or in block scope.
[&nbsp;<i>Note:</i><span class='space'></span>
When looking up a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> in a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>, only namespace names are considered,
see <a href='basic.lookup.udir'>[basic.lookup.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.</p></div><div class='para' id='namespace.udir-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-2'>2</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> specifies that the names in the nominated
namespace can be used in the scope in which the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> appears after the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.
During unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the names
appear as if they were declared in the nearest enclosing namespace which
contains both the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> and the nominated
namespace.
[&nbsp;<i>Note:</i><span class='space'></span>
In this context, “contains” means “contains directly or indirectly”.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udir-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-3'>3</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> does not add any members to the declarative
region in which it appears.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  int i;
  namespace B {
    namespace C {
      int i;
    }
    using namespace A::B::C;
    void f1() {
      i = 5;        <span class='comment'>// OK, <span class='texttt'>C::i</span> visible in <span class='texttt'>B</span> and hides <span class='texttt'>A::i</span>
</span>    }
  }
  namespace D {
    using namespace B;
    using namespace C;
    void f2() {
      i = 5;        <span class='comment'>// ambiguous, <span class='texttt'>B::C::i</span> or <span class='texttt'>A::i</span>?
</span>    }
  }
  void f3() {
    i = 5;          <span class='comment'>// uses <span class='texttt'>A::i</span>
</span>  }
}
void f4() {
  i = 5;            <span class='comment'>// ill-formed; neither <span class='texttt'>i</span> is visible
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udir-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-4'>4</a></div><p >For unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> is transitive: if a scope contains a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> that nominates a second namespace that itself
contains <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>, the effect is as if the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> from the second namespace also appeared in
the first.
[&nbsp;<i>Note:</i><span class='space'></span> For qualified lookup, see <a href='namespace.qual'>[namespace.qual]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace M {
  int i;
}

namespace N {
  int i;
  using namespace M;
}

void f() {
  using namespace N;
  i = 7;            <span class='comment'>// error: both <span class='texttt'>M::i</span> and <span class='texttt'>N::i</span> are visible
</span>}
</pre><p >For another example,</p><pre class='codeblock'>
namespace A {
  int i;
}
namespace B {
  int i;
  int j;
  namespace C {
    namespace D {
      using namespace A;
      int j;
      int k;
      int a = i;    <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    }
    using namespace D;
    int k = 89;     <span class='comment'>// no problem yet
</span>    int l = k;      <span class='comment'>// ambiguous: <span class='texttt'>C::k</span> or <span class='texttt'>D::k</span>
</span>    int m = i;      <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    int n = j;      <span class='comment'>// <span class='texttt'>D::j</span> hides <span class='texttt'>B::j</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udir-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-5'>5</a></div><p >If a namespace is extended (<a href='namespace.def'>[namespace.def]</a>) after a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> for that namespace is given, the additional
members of the extended namespace and the members of namespaces
nominated by <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the
extending <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> can be used after the
extending <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i>.</p></div><div class='para' id='namespace.udir-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-6'>6</a></div><p >If name lookup finds a declaration for a name in two different
namespaces, and the declarations do not declare the same entity and do
not declare functions, the use of the name is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, the name of a variable, function or enumerator does not
hide the name of a class or enumeration declared in a different
namespace. For example,</p><pre class='codeblock'>
namespace A {
  class X { };
  extern "C"   int g();
  extern "C++" int h();
}
namespace B {
  void X(int);
  extern "C"   int g();
  extern "C++" int h(int);
}
using namespace A;
using namespace B;

void f() {
  X(1);             <span class='comment'>// error: name <span class='texttt'>X</span> found in two namespaces
</span>  g();              <span class='comment'>// OK: name <span class='texttt'>g</span> refers to the same entity
</span>  h();              <span class='comment'>// OK: overload resolution selects <span class='texttt'>A::h</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udir-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-7'>7</a></div><p ><span class='indexparent'><a class='index' id='overloading,using_directive_and'></a></span>During overload resolution, all functions from the transitive search are
considered for argument matching. The set of declarations found by the
transitive search is unordered.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, the order in which namespaces were considered and the
relationships among the namespaces implied by the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> do not cause preference to be given to any
of the declarations found by the search.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An ambiguity exists if the best match finds two functions with the same
signature, even if one is in a namespace reachable through
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the namespace of the other.<a class='footnotenum' href='#footnote-97'>97</a>
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace D {
  int d1;
  void f(char);
}
using namespace D;

int d1;             <span class='comment'>// OK: no conflict with <span class='texttt'>D::d1</span>
</span>
namespace E {
  int e;
  void f(int);
}

namespace D {       <span class='comment'>// namespace extension
</span>  int d2;
  using namespace E;
  void f(int);
}

void f() {
  d1++;             <span class='comment'>// error: ambiguous <span class='texttt'>::d1</span> or <span class='texttt'>D::d1</span>?
</span>  ::d1++;           <span class='comment'>// OK
</span>  D::d1++;          <span class='comment'>// OK
</span>  d2++;             <span class='comment'>// OK: <span class='texttt'>D::d2</span>
</span>  e++;              <span class='comment'>// OK: <span class='texttt'>E::e</span>
</span>  f(1);             <span class='comment'>// error: ambiguous: <span class='texttt'>D::f(int)</span> or <span class='texttt'>E::f(int)</span>?
</span>  f('a');           <span class='comment'>// OK: <span class='texttt'>D::f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='using-directive'></a></span><span class='indexparent'><a class='index' id='namespaces'></a></span></p></div><div class='footnote' id='footnote-97'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-97'>97)</a></div><p >During
name lookup in a class hierarchy, some ambiguities may be
resolved by considering whether one member hides the other along some
paths (<a href='class.member.lookup'>[class.member.lookup]</a>). There is no such disambiguation when
considering the set of names found as a result of following
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>.</p></div></div></div><div id='dcl.asm'><h2 ><a class='secnum' href='#dcl.asm' style='min-width:88pt'>7.4</a> The <span class='texttt'>asm</span> declaration <a class='abbr_ref' href='dcl.asm'>[dcl.asm]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,asm'></a></span><span class='indexparent'><a class='index' id='assembler'></a></span><span class='indexparent'><a class='index' id='asm,implementation-defined'></a></span></p><div class='para' id='dcl.asm-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.asm-1'>1</a></div><p >An <span class='texttt'>asm</span> declaration has the form</p><pre class='bnf'><a id='nt:asm-definition'>asm-definition:</a>
    <span class='terminal'>asm (</span> <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <span class='terminal'>) ;</span></pre><p >The <span class='texttt'>asm</span> declaration is conditionally-supported; its meaning is
<span class='indexparent'><a class='index' id='meaning_of_asm_declaration'></a></span>implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span>
Typically it is used to pass information through the implementation to
an assembler.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='dcl.link'><h2 ><a class='secnum' href='#dcl.link' style='min-width:88pt'>7.5</a> Linkage specifications <a class='abbr_ref' href='dcl.link'>[dcl.link]</a></h2><p ><span class='indexparent'><a class='index' id='specification,linkage'></a></span></p><div class='para' id='dcl.link-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-1'>1</a></div><p >All function types, function names with external linkage, and variable
names with external linkage have a <i>language linkage</i>.
[&nbsp;<i>Note:</i><span class='space'></span>
Some of the properties associated with an entity with language linkage
are specific to each implementation and are not described here. For
example, a particular language linkage may be associated with a
particular form of representing names of objects and functions with
external linkage, or with a particular calling convention, etc.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The default language linkage of all function types, function names, and
variable names is C++ language linkage. Two function types with
different language linkages are distinct types even if they are
otherwise identical.</p></div><div class='para' id='dcl.link-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-2'>2</a></div><p >Linkage (<a href='basic.link'>[basic.link]</a>) between C++ and  non-C++ code fragments can
be achieved using a <i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i>:</p><p ><span class='indexparent'><a class='index' id='linkage-specification'></a></span><span class='indexparent'><a class='index' id='specification,linkage,extern'></a></span></p><pre class='bnf'><a id='nt:linkage-specification'>linkage-specification:</a>
    <span class='terminal'>extern</span> <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <span class='terminal'>{</span> <i ><a href='dcl.dcl#nt:declaration-seq'>declaration-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span>
    <span class='terminal'>extern</span> <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i></pre><p >The <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> indicates the required language linkage.
This International Standard specifies the semantics for the
<i ><a href='lex.string#nt:string-literal'>string-literals</a></i> <span class='texttt'>"C"</span> and <span class='texttt'>"C++"</span>. Use of a
<i ><a href='lex.string#nt:string-literal'>string-literal</a></i> other than <span class='texttt'>"C"</span> or <span class='texttt'>"C++"</span> is
conditionally-supported, with <span class='indexparent'><a class='index' id='semantics_of_linkage_specifiers'></a></span>implementation-defined semantics.
[&nbsp;<i>Note:</i><span class='space'></span>
Therefore, a linkage-specification with a <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> that
is unknown to the implementation requires a diagnostic.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
It is recommended that the spelling of the <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> be
taken from the document defining that language. For example, <span class='texttt'>Ada</span>
(not <span class='texttt'>ADA</span>) and <span class='texttt'>Fortran</span> or <span class='texttt'>FORTRAN</span>, depending on
the vintage.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.link-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-3'>3</a></div><p ><span class='indexparent'><a class='index' id='specification,linkage,implementation-defined'></a></span>Every implementation shall provide for linkage to functions written in
the C programming language,
<span class='indexparent'><a class='index' id='C,linkage_to'></a></span><span class='texttt'>"C"</span>, and linkage to C++ functions, <span class='texttt'>"C++"</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
complex sqrt(complex);          <span class='comment'>// C++ linkage by default
</span>extern "C" {
  double sqrt(double);          <span class='comment'>// C linkage
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.link-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-4'>4</a></div><p ><span class='indexparent'><a class='index' id='specification,linkage,nesting'></a></span>Linkage specifications nest. When linkage specifications nest, the
innermost one determines the language linkage. A linkage specification
does not establish a scope. A <i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i> shall
occur only in namespace scope (<a href='basic.scope'>[basic.scope]</a>). In a
<i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i>, the specified language linkage applies
to the function types of all function declarators, function names with
external linkage, and variable names with external linkage declared
within the <i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" void f1(void(*pf)(int));
                                <span class='comment'>// the name <span class='texttt'>f1</span> and its function type have C language
</span>                                <span class='comment'>// linkage; <span class='texttt'>pf</span> is a pointer to a C function
</span>extern "C" typedef void FUNC();
FUNC f2;                        <span class='comment'>// the name <span class='texttt'>f2</span> has C++ language linkage and the
</span>                                <span class='comment'>// function's type has C language linkage
</span>extern "C" FUNC f3;             <span class='comment'>// the name of function <span class='texttt'>f3</span> and the function's type
</span>                                <span class='comment'>// have C language linkage
</span>void (*pf2)(FUNC*);             <span class='comment'>// the name of the variable <span class='texttt'>pf2</span> has C++ linkage and
</span>                                <span class='comment'>// the type of <span class='texttt'>pf2</span> is pointer to C++ function that
</span>                                <span class='comment'>// takes one parameter of type pointer to C function
</span>extern "C" {
  static void f4();             <span class='comment'>// the name of the function f4 has
</span>                                <span class='comment'>// internal linkage (not C language
</span>                                <span class='comment'>// linkage) and the function's type
</span>                                <span class='comment'>// has C language linkage.
</span>}

extern "C" void f5() {
  extern void f4();             <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>}

extern void f4();               <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>
void f6() {
  extern void f4();             <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='class,linkage_specification'></a></span>A C language linkage is ignored
in determining the language linkage of
the names of class members and the
function type of class member functions.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" typedef void FUNC_c();
class C {
  void mf1(FUNC_c*);            <span class='comment'>// the name of the function <span class='texttt'>mf1</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage; the
</span>                                <span class='comment'>// parameter has type pointer to C function
</span>  FUNC_c mf2;                   <span class='comment'>// the name of the function <span class='texttt'>mf2</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage
</span>  static FUNC_c* q;             <span class='comment'>// the name of the data member <span class='texttt'>q</span> has C++ language
</span>                                <span class='comment'>// linkage and the data member's type is pointer to
</span>                                <span class='comment'>// C function
</span>};

extern "C" {
  class X {
    void mf();                  <span class='comment'>// the name of the function <span class='texttt'>mf</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage
</span>    void mf2(void(*)());        <span class='comment'>// the name of the function <span class='texttt'>mf2</span> has C++ language
</span>                                <span class='comment'>// linkage; the parameter has type pointer to
</span>                                <span class='comment'>// C function
</span>  };
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.link-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-5'>5</a></div><p >If two declarations declare functions with the same name and
parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>) to be members of the same
namespace or declare objects with the same name to be members of the same
namespace and the declarations give the names different language linkages, the
program is ill-formed; no diagnostic is required if the declarations appear in
different translation units.
<span class='indexparent'><a class='index' id='consistency,linkage_specification'></a></span>Except for functions with C++ linkage, a function declaration without a
linkage specification shall not precede the first linkage specification
for that function. A function can be declared without a linkage
specification after an explicit linkage specification has been seen; the
linkage explicitly specified in the earlier declaration is not affected
by such a function declaration.</p></div><div class='para' id='dcl.link-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-6'>6</a></div><p ><span class='indexparent'><a class='index' id='function,linkage_specification_overloaded'></a></span>At most one function with a particular name can have C language linkage.
Two declarations for a function with C language linkage with the same
function name (ignoring the namespace names that qualify it) that appear
in different namespace scopes refer to the same function. Two
declarations for a variable with C language linkage with the same name
(ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same variable.
An entity with C language linkage shall not be declared with the same name
as a variable in global scope, unless both declarations denote the same entity;
no diagnostic is required if the declarations appear in different translation units.
A variable with C language linkage shall not be declared with the same name as a
function with C language linkage (ignoring the namespace names that qualify the
respective names); no diagnostic is required if the declarations appear in
different translation units.
[&nbsp;<i>Note:</i><span class='space'></span>
Only
one definition for an entity with a given name
with C language linkage may appear in the
program (see <a href='basic.def.odr'>[basic.def.odr]</a>);
this implies that such an entity
must not be defined in more
than one namespace scope.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x;
namespace A {
  extern "C" int f();
  extern "C" int g() { return 1; }
  extern "C" int h();
  extern "C" int x();               <span class='comment'>// ill-formed: same name as global-space object <span class='texttt'>x</span>
</span>}

namespace B {
  extern "C" int f();               <span class='comment'>// <span class='texttt'>A::f</span> and <span class='texttt'>B::f</span> refer to the same function
</span>  extern "C" int g() { return 1; }  <span class='comment'>// ill-formed, the function <span class='texttt'>g</span>
</span>                                    <span class='comment'>// with C language linkage has two definitions
</span>}

int A::f() { return 98; }           <span class='comment'>//definition for the function <span class='texttt'>f</span> with C language linkage
</span>extern "C" int h() { return 97; }   <span class='comment'>// definition for the function <span class='texttt'>h</span> with C language linkage
</span>                                    <span class='comment'>// <span class='texttt'>A::h</span> and <span class='texttt'>::h</span> refer to the same function
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.link-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-7'>7</a></div><p >A declaration directly contained in a
<i ><a href='dcl.link#nt:linkage-specification'>linkage-specification</a></i>
is treated as if it contains the
<span class='texttt'>extern</span>
specifier (<a href='dcl.stc'>[dcl.stc]</a>) for the purpose of determining the linkage of the
declared name and whether it is a definition. Such a declaration shall
not specify a storage class.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" double f();
static double f();                  <span class='comment'>// error
</span>extern "C" int i;                   <span class='comment'>// declaration
</span>extern "C" {
  int i;                            <span class='comment'>// definition
</span>}
extern "C" static void g();         <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.link-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Because the language linkage is part of a function type, when
indirecting through a pointer to C function, the function to
which the resulting lvalue refers is considered a C function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.link-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.link-9'>9</a></div><p ><span class='indexparent'><a class='index' id='object,linkage_specification'></a></span><span class='indexparent'><a class='index' id='linkage,implementation-defined_object'></a></span>Linkage from C++ to objects defined in other languages and to objects
defined in C++ from other languages is implementation-defined and
language-dependent. Only where the object layout strategies of two
language implementations are similar enough can such linkage be
achieved.<span class='indexparent'><a class='index' id='specification,linkage'></a></span></p></div></div><div id='dcl.attr'><h2 ><a class='secnum' href='#dcl.attr' style='min-width:88pt'>7.6</a> Attributes <a class='abbr_ref' href='dcl.attr'>[dcl.attr]</a></h2><p ><span class='indexparent'><a class='index' id='attribute'></a></span></p><div id='dcl.attr.grammar'><h3 ><a class='secnum' href='#dcl.attr.grammar' style='min-width:103pt'>7.6.1</a> Attribute syntax and semantics <a class='abbr_ref' href='dcl.attr.grammar'>[dcl.attr.grammar]</a></h3><div class='para' id='dcl.attr.grammar-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-1'>1</a></div><p ><span class='indexparent'><a class='index' id='attribute,syntax_and_semantics'></a></span>Attributes specify additional information for various source constructs
such as types, variables, names, blocks, or translation units.</p><pre class='bnf'><a id='nt:attribute-specifier-seq'>attribute-specifier-seq:</a>
  <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier'>attribute-specifier</a></i></pre><pre class='bnf'><a id='nt:attribute-specifier'>attribute-specifier:</a>
  <span class='terminal'>[</span> <span class='terminal'>[</span> <i ><a href='dcl.attr.grammar#nt:attribute-using-prefix'>attribute-using-prefix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> <span class='terminal'>]</span> <span class='terminal'>]</span>
  <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i></pre><pre class='bnf'><a id='nt:alignment-specifier'>alignment-specifier:</a>
  <span class='terminal'>alignas (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
  <span class='terminal'>alignas (</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:attribute-using-prefix'>attribute-using-prefix:</a>
  <span class='terminal'>using</span> <i ><a href='dcl.attr.grammar#nt:attribute-namespace'>attribute-namespace</a></i> <span class='terminal'>:</span></pre><pre class='bnf'><a id='nt:attribute-list'>attribute-list:</a>
  <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i> <span class='terminal'>...</span>
  <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i> <span class='terminal'>...</span></pre><pre class='bnf'><a id='nt:attribute'>attribute:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:attribute-token'>attribute-token:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-scoped-token'>attribute-scoped-token</a></i></pre><pre class='bnf'><a id='nt:attribute-scoped-token'>attribute-scoped-token:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-namespace'>attribute-namespace</a></i> <span class='terminal'>::</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:attribute-namespace'>attribute-namespace:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:attribute-argument-clause'>attribute-argument-clause:</a>
    <span class='terminal'>(</span> <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:balanced-token-seq'>balanced-token-seq:</a>
    <i ><a href='dcl.attr.grammar#nt:balanced-token'>balanced-token</a></i>
    <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i> <i ><a href='dcl.attr.grammar#nt:balanced-token'>balanced-token</a></i></pre><pre class='bnf'><a id='nt:balanced-token'>balanced-token:</a>
    <span class='terminal'>(</span> <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
    <span class='terminal'>[</span> <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>]</span>
    <span class='terminal'>{</span> <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span>
    <span class='textnormal'>any <span class='grammarterm'>token</span> other than a parenthesis, a bracket, or a brace</span></pre></div><div class='para' id='dcl.attr.grammar-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-2'>2</a></div><p >If an <i ><a href='dcl.attr.grammar#nt:attribute-specifier'>attribute-specifier</a></i>
contains an <i ><a href='dcl.attr.grammar#nt:attribute-using-prefix'>attribute-using-prefix</a></i>,
the <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> following that <i ><a href='dcl.attr.grammar#nt:attribute-using-prefix'>attribute-using-prefix</a></i>
shall not contain an <i ><a href='dcl.attr.grammar#nt:attribute-scoped-token'>attribute-scoped-token</a></i>
and every <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> in that <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i>
is treated as if
its <i ><a href='lex.name#nt:identifier'>identifier</a></i> were prefixed with <span class='texttt'>N::</span>,
where <span class='texttt'>N</span> is the <i ><a href='dcl.attr.grammar#nt:attribute-namespace'>attribute-namespace</a></i>
specified in the <i ><a href='dcl.attr.grammar#nt:attribute-using-prefix'>attribute-using-prefix</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
This rule imposes no constraints on how
an <i ><a href='dcl.attr.grammar#nt:attribute-using-prefix'>attribute-using-prefix</a></i>
affects the tokens in an <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
[[using CC: opt(1), debug]]        <span class='comment'>// same as <span class='texttt'>[[CC::opt(1), CC::debug]]</span>
</span>  void f() {}
[[using CC: opt(1)]] [[CC::debug]] <span class='comment'>// same as <span class='texttt'>[[CC::opt(1)]] [[CC::debug]]</span>
</span>  void g() {}
[[using CC: CC::opt(1)]]           <span class='comment'>// error: cannot combine <span class='texttt'>using</span> and scoped attribute token
</span>  void h() {}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.attr.grammar-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> For each individual attribute, the form of the
<i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i> will be specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.grammar-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-4'>4</a></div><p >In an <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i>, an ellipsis may appear only if that
<i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i>'s specification permits it. An <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i> followed
by an ellipsis is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).
An <i ><a href='dcl.attr.grammar#nt:attribute-specifier'>attribute-specifier</a></i> that contains no <i ><a href='dcl.attr.grammar#nt:attribute'>attributes</a></i> has no
effect. The order in which the <span class='grammarterm'>attribute-tokens</span> appear in an
<i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> is not significant. If a
keyword (<a href='lex.key'>[lex.key]</a>)
or an alternative token (<a href='lex.digraph'>[lex.digraph]</a>) that satisfies the syntactic requirements
of an <i ><a href='lex.name#nt:identifier'>identifier</a></i> (<a href='lex.name'>[lex.name]</a>) is
contained in
an <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i>, it is considered an identifier. No name
lookup (<a href='basic.lookup'>[basic.lookup]</a>) is performed on any of the identifiers contained in an
<i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i>. The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> determines additional
requirements on the <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> (if any).</p></div><div class='para' id='dcl.attr.grammar-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-5'>5</a></div><p >Each <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> is said to <a id='appertain'><i>appertain</i></a> to some entity or
statement, identified by the syntactic context where it appears
(Clause <a href='stmt.stmt'>[stmt.stmt]</a>, Clause <a href='dcl.dcl'>[dcl.dcl]</a>,
Clause <a href='dcl.decl'>[dcl.decl]</a>). If an <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> that appertains to some
entity or statement contains an <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i> that
is not allowed to apply to that
entity or statement, the program is ill-formed. If an <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
appertains to a friend declaration (<a href='class.friend'>[class.friend]</a>), that declaration shall be a
definition. No <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> shall appertain to an explicit
instantiation (<a href='temp.explicit'>[temp.explicit]</a>).</p></div><div class='para' id='dcl.attr.grammar-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-6'>6</a></div><p >For an <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i>
(including an <i ><a href='dcl.attr.grammar#nt:attribute-scoped-token'>attribute-scoped-token</a></i>)
not specified in this International Standard, the
behavior is <span class='indexparent'><a class='index' id='behavior_of_non-standard_attributes'></a></span>implementation-defined.
Any <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> that is not recognized by the implementation
is ignored.
[&nbsp;<i>Note:</i><span class='space'></span>
Each implementation should choose a distinctive name for the
<i ><a href='dcl.attr.grammar#nt:attribute-namespace'>attribute-namespace</a></i> in an <i ><a href='dcl.attr.grammar#nt:attribute-scoped-token'>attribute-scoped-token</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.grammar-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.grammar-7'>7</a></div><p >Two consecutive left square bracket tokens shall appear only
when introducing an <i ><a href='dcl.attr.grammar#nt:attribute-specifier'>attribute-specifier</a></i> or
within the <i ><a href='dcl.attr.grammar#nt:balanced-token-seq'>balanced-token-seq</a></i> of
an <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span> If two consecutive left square brackets appear
where an <i ><a href='dcl.attr.grammar#nt:attribute-specifier'>attribute-specifier</a></i> is not allowed, the program is ill-formed even
if the brackets match an alternative grammar production. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int p[10];
void f() {
  int x = 42, y[5];
  int(p[[x] { return x; }()]);  <span class='comment'>// error: invalid attribute on a nested
</span>                                <span class='comment'>// <span class='grammarterm'>declarator-id</span> and not a function-style cast of
</span>                                <span class='comment'>// an element of <span class='texttt'>p</span>.
</span>  y[[] { return 2; }()] = 2;    <span class='comment'>// error even though attributes are not allowed
</span>                                <span class='comment'>// in this context.
</span>  int i [[vendor::attr([[]])]]; <span class='comment'>// well-formed implementation-defined attribute.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.align'><h3 ><a class='secnum' href='#dcl.align' style='min-width:103pt'>7.6.2</a> Alignment specifier <a class='abbr_ref' href='dcl.align'>[dcl.align]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,alignment'></a></span></p><div class='para' id='dcl.align-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-1'>1</a></div><p >An <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i>
may be applied to a variable
or to a class data member, but it shall not be applied to a bit-field, a function
parameter, or an <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> (<a href='except.handle'>[except.handle]</a>).
An <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> may also be applied to the declaration or
definition of a class (in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) or
<i ><a href='class#nt:class-head'>class-head</a></i> (Clause <a href='class'>[class]</a>), respectively) and to the
declaration or definition of an enumeration (in an
<i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> or <i ><a href='dcl.enum#nt:enum-head'>enum-head</a></i>,
respectively (<a href='dcl.enum'>[dcl.enum]</a>)).
An <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> with an ellipsis is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).</p></div><div class='para' id='dcl.align-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-2'>2</a></div><p >When the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> is of the form
<span class='texttt'>alignas(</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='texttt'>)</span>:</p><ul ><li ><p >the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be an integral constant expression</p></li><li ><p >if the constant expression does not evaluate to an alignment
value (<a href='basic.align'>[basic.align]</a>), or evaluates to an extended alignment and
the implementation does not support that alignment in the context of the
declaration, the program is ill-formed.
</p></li></ul></div><div class='para' id='dcl.align-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-3'>3</a></div><p >When the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> is of the form
<span class='texttt'>alignas(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='texttt'>)</span>, it shall have the same
effect as <span class='texttt'>alignas(<span class='discretionary'></span>alignof(</span><i ><a href='dcl.name#nt:type-id'>type-id</a></i><span class='texttt'>))</span> (<a href='expr.alignof'>[expr.alignof]</a>).</p></div><div class='para' id='dcl.align-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-4'>4</a></div><p >The alignment requirement of an entity is the strictest non-zero alignment
specified by its <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifiers</a></i>, if any;
otherwise, the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifiers</a></i> have no effect.</p></div><div class='para' id='dcl.align-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-5'>5</a></div><p >The combined effect of all <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifiers</a></i> in a declaration shall not
specify an alignment that is less strict than the alignment that would
be required for the entity being declared if all <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifiers</a></i>
appertaining to that entity
were omitted.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct alignas(8) S {};
struct alignas(1) U {
  S s;
};   <span class='comment'>// Error: <span class='texttt'>U</span> specifies an alignment that is less strict than
</span>     <span class='comment'>// if the <span class='texttt'>alignas(1)</span> were omitted.
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.align-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-6'>6</a></div><p >If the defining declaration of an entity has an
<i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i>, any non-defining
declaration of that entity shall either specify equivalent alignment or have no
<i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i>.
Conversely, if any declaration of an entity has an
<i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i>,
every defining
declaration of that entity shall specify an equivalent alignment.
No diagnostic is required if declarations of an entity have
different <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifiers</a></i>
in different translation units.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// Translation unit #1:
</span>struct S { int x; } s, *p = &amp;s;

<span class='comment'>// Translation unit #2:
</span>struct alignas(16) S;           <span class='comment'>// error: definition of <span class='texttt'>S</span> lacks alignment; no
</span>extern S* p;                    <span class='comment'>// diagnostic required
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.align-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-7'>7</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span> An aligned buffer with an alignment requirement
of <span class='texttt'>A</span> and holding <span class='texttt'>N</span> elements of type <span class='texttt'>T</span>
can be declared as:</p><pre class='codeblock'>
alignas(T) alignas(A) T buffer[N];
</pre><p >Specifying <span class='texttt'>alignas(T)</span> ensures
that the final requested alignment will not be weaker than <span class='texttt'>alignof(T)</span>,
and therefore the program will not be ill-formed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.align-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.align-8'>8</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
alignas(double) void f();                         <span class='comment'>// error: alignment applied to function
</span>alignas(double) unsigned char c[sizeof(double)];  <span class='comment'>// array of characters, suitably aligned for a <span class='texttt'>double</span>
</span>extern unsigned char c[sizeof(double)];           <span class='comment'>// no <span class='texttt'>alignas</span> necessary
</span>alignas(float)
  extern unsigned char c[sizeof(double)];         <span class='comment'>// error: different alignment in declaration
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.attr.depend'><h3 ><a class='secnum' href='#dcl.attr.depend' style='min-width:103pt'>7.6.3</a> Carries dependency attribute <a class='abbr_ref' href='dcl.attr.depend'>[dcl.attr.depend]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,carries_dependency'></a></span></p><div class='para' id='dcl.attr.depend-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>carries_dependency</span> specifies
dependency propagation into and out of functions. It shall appear at most once
in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> and no
<i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> shall be present. The attribute may be
applied to the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> in a function declaration or lambda, in
which case it specifies that the initialization of the parameter carries a
dependency to (<a href='intro.multithread'>[intro.multithread]</a>) each lvalue-to-rvalue
conversion (<a href='conv.lval'>[conv.lval]</a>) of that object. The attribute may also be applied
to the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of a function declaration, in which case it
specifies that the return value, if any, carries a dependency to the evaluation
of the function call expression.</p></div><div class='para' id='dcl.attr.depend-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-2'>2</a></div><p >The first declaration of a function shall specify the <span class='texttt'>carries_dependency</span> attribute for its
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> if any declaration of the function specifies the
<span class='texttt'>carries_dependency</span> attribute. Furthermore, the first declaration of a function shall specify
the <span class='texttt'>carries_dependency</span> attribute for a parameter if any declaration of that function
specifies the <span class='texttt'>carries_dependency</span> attribute for that parameter. If a function or one of its
parameters is declared with the <span class='texttt'>carries_dependency</span> attribute in its first declaration in one
translation unit and the same function or one of its parameters is declared without the
<span class='texttt'>carries_dependency</span> attribute in its first declaration in another translation unit, the
program is ill-formed; no diagnostic required.</p></div><div class='para' id='dcl.attr.depend-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> The <span class='texttt'>carries_dependency</span> attribute does not change the meaning of the
program, but may result in generation of more efficient code. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.depend-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>/* Translation unit A. */</span>

struct foo { int* a; int* b; };
std::atomic&lt;struct foo *&gt; foo_head[10];
int foo_array[10][10];

[[carries_dependency]] struct foo* f(int i) {
  return foo_head[i].load(memory_order_consume);
}

int g(int* x, int* y [[carries_dependency]]) {
  return kill_dependency(foo_array[*x][*y]);
}

<span class='comment'>/* Translation unit B. */</span>

[[carries_dependency]] struct foo* f(int i);
int g(int* x, int* y [[carries_dependency]]);

int c = 3;

void h(int i) {
  struct foo* p;

  p = f(i);
  do_something_with(g(&amp;c, p-&gt;a));
  do_something_with(g(p-&gt;a, &amp;c));
}
</pre></div><div class='para' id='dcl.attr.depend-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-5'>5</a></div><p >The <span class='texttt'>carries_dependency</span> attribute on function <span class='texttt'>f</span> means that the
return value carries a dependency out of <span class='texttt'>f</span>, so that the implementation
need not constrain ordering upon return from <span class='texttt'>f</span>. Implementations of
<span class='texttt'>f</span> and its caller may choose to preserve dependencies instead of emitting
hardware memory ordering instructions (a.k.a. fences).</p></div><div class='para' id='dcl.attr.depend-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.depend-6'>6</a></div><p >Function <span class='texttt'>g</span>'s second parameter has a <span class='texttt'>carries_dependency</span> attribute,
but its first parameter does not. Therefore, function <span class='texttt'>h</span>'s first call to
<span class='texttt'>g</span> carries a dependency into <span class='texttt'>g</span>, but its second call does not. The
implementation might need to insert a fence prior to the second call to
<span class='texttt'>g</span>.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='attribute'></a></span><span class='indexparent'><a class='index' id='declaration'></a></span></p></div></div><div id='dcl.attr.deprecated'><h3 ><a class='secnum' href='#dcl.attr.deprecated' style='min-width:103pt'>7.6.4</a> Deprecated attribute <a class='abbr_ref' href='dcl.attr.deprecated'>[dcl.attr.deprecated]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,deprecated'></a></span></p><div class='para' id='dcl.attr.deprecated-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.deprecated-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>deprecated</span> can be used to mark names and entities
whose use is still allowed, but is discouraged for some reason. [&nbsp;<i>Note:</i><span class='space'></span> in particular,
<span class='texttt'>deprecated</span> is appropriate for names and entities that are deemed obsolescent or
unsafe. <i>&nbsp;—&nbsp;end note</i>&nbsp;] It shall appear at most once in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i>. An
<i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> may be present and, if present, it shall have the form:</p><pre class='codeblock'>
( <span class='grammarterm'>string-literal</span> )
</pre><p >[&nbsp;<i>Note:</i><span class='space'></span> the <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> in the <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i>
could be used to explain the rationale for deprecation and/or to suggest a replacing entity.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.deprecated-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.deprecated-2'>2</a></div><p >The attribute may be applied to the declaration of
a class,
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>,
a variable,
a non-static data member,
a function,
a namespace,
an enumeration,
an enumerator, or
a template specialization.</p></div><div class='para' id='dcl.attr.deprecated-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.deprecated-3'>3</a></div><p >A name or entity declared without the <span class='texttt'>deprecated</span> attribute can later be re-declared
with the attribute and vice-versa. [&nbsp;<i>Note:</i><span class='space'></span> Thus, an entity initially declared without the
attribute can be marked as deprecated by a subsequent redeclaration. However, after an entity
is marked as deprecated, later redeclarations do not un-deprecate the entity. <i>&nbsp;—&nbsp;end note</i>&nbsp;] 
Redeclarations using different forms of the attribute (with or without the
<i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> or with different
<i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clauses</a></i>) are allowed.</p></div><div class='para' id='dcl.attr.deprecated-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.deprecated-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Implementations may use the <span class='texttt'>deprecated</span> attribute to produce a diagnostic
message in case the program refers to a name or entity other than to declare it, after a
declaration that specifies the attribute. The diagnostic message may include the text provided
within the <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> of any <span class='texttt'>deprecated</span> attribute applied
to the name or entity. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='dcl.attr.fallthrough'><h3 ><a class='secnum' href='#dcl.attr.fallthrough' style='min-width:103pt'>7.6.5</a> Fallthrough attribute <a class='abbr_ref' href='dcl.attr.fallthrough'>[dcl.attr.fallthrough]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,fallthrough'></a></span></p><div class='para' id='dcl.attr.fallthrough-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.fallthrough-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>fallthrough</span>
may be applied to a null statement (<a href='stmt.expr'>[stmt.expr]</a>);
<span class='indexparent'><a class='index' id='statement,fallthrough'></a></span>
such a statement is a fallthrough statement.
The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>fallthrough</span>
shall appear at most once in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> and
no <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> shall be present.
A fallthrough statement may only appear within
an enclosing <span class='texttt'>switch</span> statement (<a href='stmt.switch'>[stmt.switch]</a>).
The next statement that would be executed after a fallthrough statement
shall be a labeled statement whose label is a case label or
default label for the same <span class='texttt'>switch</span> statement.
The program is ill-formed if there is no such statement.</p></div><div class='para' id='dcl.attr.fallthrough-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.fallthrough-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The use of a fallthrough statement is intended to suppress
a warning that an implementation might otherwise issue
for a case or default label that is reachable
from another case or default label along some path of execution.
Implementations are encouraged to issue a warning
if a fallthrough statement is not dynamically reachable.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.fallthrough-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.fallthrough-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
void f(int n) {
  void g(), h(), i();
  switch (n) {
  case 1:
  case 2:
    g();
    [[fallthrough]];
  case 3: <span class='comment'>// warning on fallthrough discouraged
</span>    h();
  case 4: <span class='comment'>// implementation may warn on fallthrough
</span>    i();
    [[fallthrough]]; <span class='comment'>// ill-formed
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.attr.unused'><h3 ><a class='secnum' href='#dcl.attr.unused' style='min-width:103pt'>7.6.6</a> Maybe unused attribute <a class='abbr_ref' href='dcl.attr.unused'>[dcl.attr.unused]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,maybe_unused'></a></span></p><div class='para' id='dcl.attr.unused-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.unused-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>maybe_unused</span>
indicates that a name or entity is possibly intentionally unused.
It shall appear at most once in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> and
no <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> shall be present.</p></div><div class='para' id='dcl.attr.unused-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.unused-2'>2</a></div><p >The attribute may be applied to the declaration of a class,
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>, a variable, a non-static data member,
a function, an enumeration, or an enumerator.</p></div><div class='para' id='dcl.attr.unused-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.unused-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For an entity marked <span class='texttt'>maybe_unused</span>, implementations
are encouraged not to emit a warning that the entity is unused, or
that the entity is used despite the presence of the attribute.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.unused-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.unused-4'>4</a></div><p >A name or entity declared without the <span class='texttt'>maybe_unused</span> attribute
can later be redeclared with the attribute
and vice versa.
An entity is considered marked
after the first declaration that marks it.</p></div><div class='para' id='dcl.attr.unused-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.unused-5'>5</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
[[maybe_unused]] void f([[maybe_unused]] bool thing1,
                        [[maybe_unused]] bool thing2) {
  [[maybe_unused]] bool b = thing1 &amp;&amp; thing2;
  assert(b);
}
</pre><p >Implementations are encouraged not to warn that <span class='texttt'>b</span> is unused,
whether or not <span class='texttt'>NDEBUG</span> is defined.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.attr.nodiscard'><h3 ><a class='secnum' href='#dcl.attr.nodiscard' style='min-width:103pt'>7.6.7</a> Nodiscard attribute <a class='abbr_ref' href='dcl.attr.nodiscard'>[dcl.attr.nodiscard]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,nodiscard'></a></span></p><div class='para' id='dcl.attr.nodiscard-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.nodiscard-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>nodiscard</span>
may be applied to the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>
in a function declaration or to the declaration of a class or enumeration.
It shall appear at most once in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> and
no <i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> shall be present.</p></div><div class='para' id='dcl.attr.nodiscard-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.nodiscard-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A nodiscard call is a function call expression that
calls a function previously declared <span class='texttt'>nodiscard</span>, or
whose return type is a possibly cv-qualified class or enumeration type
marked <span class='texttt'>nodiscard</span>. Appearance of a nodiscard call as
a potentially-evaluated discarded-value expression (Clause <a href='expr'>[expr]</a>)
is discouraged unless explicitly cast to <span class='texttt'>void</span>.
Implementations are encouraged to issue a warning in such cases.
This is typically because discarding the return value
of a nodiscard call has surprising consequences.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.nodiscard-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.nodiscard-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct [[nodiscard]] error_info { <span class='comment'>/*...*/</span> };
error_info enable_missile_safety_mode();
void launch_missiles();
void test_missiles() {
  enable_missile_safety_mode(); <span class='comment'>// warning encouraged
</span>  launch_missiles();
}
error_info &amp;foo();
void f() { foo(); } <span class='comment'>// reference type, warning not encouraged
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.attr.noreturn'><h3 ><a class='secnum' href='#dcl.attr.noreturn' style='min-width:103pt'>7.6.8</a> Noreturn attribute <a class='abbr_ref' href='dcl.attr.noreturn'>[dcl.attr.noreturn]</a></h3><p ><span class='indexparent'><a class='index' id='attribute,noreturn'></a></span></p><div class='para' id='dcl.attr.noreturn-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.noreturn-1'>1</a></div><p >The <i ><a href='dcl.attr.grammar#nt:attribute-token'>attribute-token</a></i> <span class='texttt'>noreturn</span> specifies that a function does not return. It
shall appear at most once in each <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> and no
<i ><a href='dcl.attr.grammar#nt:attribute-argument-clause'>attribute-argument-clause</a></i> shall be present. The attribute may be applied to the
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> in a function declaration. The first declaration of a function shall
specify the <span class='texttt'>noreturn</span> attribute if any declaration of that function specifies the
<span class='texttt'>noreturn</span> attribute. If a function is declared with the <span class='texttt'>noreturn</span> attribute in one
translation unit and the same function is declared without the <span class='texttt'>noreturn</span> attribute in another
translation unit, the program is ill-formed; no diagnostic required.</p></div><div class='para' id='dcl.attr.noreturn-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.noreturn-2'>2</a></div><p >If a function <span class='texttt'>f</span> is called where <span class='texttt'>f</span> was previously declared with the <span class='texttt'>noreturn</span>
attribute and <span class='texttt'>f</span> eventually returns, the behavior is undefined. [&nbsp;<i>Note:</i><span class='space'></span> The function may
terminate by throwing an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> Implementations are encouraged to issue a
warning if a function marked <span class='texttt'>[[noreturn]]</span> might return. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.attr.noreturn-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.attr.noreturn-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
[[ noreturn ]] void f() {
  throw "error";        <span class='comment'>// OK
</span>}

[[ noreturn ]] void q(int i) { <span class='comment'>// behavior is undefined if called with an argument <span class='texttt'>&lt;= 0</span>
</span>  if (i &gt; 0)
    throw "positive";
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div></div></div></body></html>