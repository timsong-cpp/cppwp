<!DOCTYPE html><html lang='en'><head><title>[intro.progress]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>1</a> General <a class='abbr_ref' href='./#intro'>[intro]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>1.10</a> Multi-threaded executions and data races <a class='abbr_ref' href='intro.multithread#intro.progress'>[intro.multithread]</a></h2><div id='intro.progress'><h3 ><a class='secnum' style='min-width:103pt'>1.10.2</a> Forward progress <a class='abbr_ref'>[intro.progress]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1473'>#</a></div><p >The implementation may assume that any thread will eventually do one of the 
following:
</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >terminate,
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >make a call to a library I/O function,
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >read or modify a volatile object, or
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >perform a synchronization operation or an atomic operation.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> This is intended to allow compiler transformations such as removal of
empty loops, even when termination cannot be proven. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1485'>#</a></div><p >Executions of atomic functions
that are either defined to be lock-free (<a href='atomics.flag'>[atomics.flag]</a>)
or indicated as lock-free (<a href='atomics.lockfree'>[atomics.lockfree]</a>)
are <a class='hidden_link' href='#def:lock-free_execution' id='def:lock-free_execution'><i>lock-free executions</i></a>.
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >If there is only one thread that is not blocked (<a href='defns.block'>[defns.block]</a>)
  in a standard library function,
  a lock-free execution in that thread shall complete.
  [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
    Concurrently executing threads
    may prevent progress of a lock-free execution.
    For example,
    this situation can occur
    with load-locked store-conditional implementations.
    This property is sometimes termed obstruction-free.
  <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >When one or more lock-free executions run concurrently,
  at least one should complete.
  [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
    It is difficult for some implementations
    to provide absolute guarantees to this effect,
    since repeated and particularly inopportune interference
    from other threads
    may prevent forward progress,
    e.g.,
    by repeatedly stealing a cache line
    for unrelated purposes
    between load-locked and store-conditional instructions.
    Implementations should ensure
    that such effects cannot indefinitely delay progress
    under expected operating conditions,
    and that such anomalies
    can therefore safely be ignored by programmers.
    Outside this International Standard,
    this property is sometimes termed lock-free.
  <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1526'>#</a></div><p >During the execution of a thread of execution, each of the following is termed
an <a class='hidden_link' href='#def:execution_step' id='def:execution_step'><i>execution step</i></a>:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >termination of the thread of execution,
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >access to a volatile object, or
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >completion of a call to a library I/O function, a
      synchronization operation, or an atomic operation.
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1536'>#</a></div><p >An invocation of a standard library function that blocks (<a href='defns.block'>[defns.block]</a>)
is considered to continuously execute execution steps while waiting for the
condition that it blocks on to be satisfied.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
A library I/O function that blocks until the I/O operation is complete can
be considered to continuously check whether the operation is complete. Each
such check might consist of one or more execution steps, for example using
observable behavior of the abstract machine.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1547'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Because of this and the preceding requirement regarding what threads of execution
have to perform eventually, it follows that no thread of execution can execute
forever without an execution step occurring.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1554'>#</a></div><p >A thread of execution <a class='hidden_link' href='#def:make_progress,thread' id='def:make_progress,thread'><i>makes progress</i></a>
when an execution step occurs or a
lock-free execution does not complete because there are other concurrent threads
that are not blocked in a standard library function (see above).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1560'>#</a></div><p ><span class='indexparent'><a class='index' id='forward_progress_guarantees,concurrent'></a></span>For a thread of execution providing <a class='hidden_link' href='#def:concurrent_forward_progress_guarantees' id='def:concurrent_forward_progress_guarantees'><i>concurrent forward progress guarantees</i></a>,
the implementation ensures that the thread will eventually make progress for as
long as it has not terminated.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This is required regardless of whether or not other threads of executions (if any)
have been or are making progress. To eventually fulfill this requirement means that
this will happen in an unspecified but finite amount of time.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1571'>#</a></div><p >It is <span class='indexparent'><a class='index' id='whether_the_thread_that_executes_main_and_the_threads_created_by_std::thread_provide_concurrent_forward_progress_guarantees'></a></span>implementation-defined whether the
implementation-created thread of execution that executes
<span class='texttt'>main</span> (<a href='basic.start.main'>[basic.start.main]</a>) and the threads of execution created by
<span class='texttt'>std&#x200b;::&#x200b;thread</span> (<a href='thread.thread.class'>[thread.thread.class]</a>) provide concurrent forward progress
guarantees.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
General-purpose implementations are encouraged to provide these guarantees.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1582'>#</a></div><p ><span class='indexparent'><a class='index' id='forward_progress_guarantees,parallel'></a></span>For a thread of execution providing <a class='hidden_link' href='#def:parallel_forward_progress_guarantees' id='def:parallel_forward_progress_guarantees'><i>parallel forward progress guarantees</i></a>,
the implementation is not required to ensure that the thread will eventually make
progress if it has not yet executed any execution step; once this thread has
executed a step, it provides concurrent forward progress guarantees.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1589'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This does not specify a requirement for when to start this thread of execution,
which will typically be specified by the entity that creates this thread of
execution. For example, a thread of execution that provides concurrent forward
progress guarantees and executes tasks from a set of tasks in an arbitrary order,
one after the other, satisfies the requirements of parallel forward progress for
these tasks.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1599'>#</a></div><p ><span class='indexparent'><a class='index' id='forward_progress_guarantees,weakly_parallel'></a></span>For a thread of execution providing <a class='hidden_link' href='#def:weakly_parallel_forward_progress_guarantees' id='def:weakly_parallel_forward_progress_guarantees'><i>weakly parallel forward progress
guarantees</i></a>, the implementation does not ensure that the thread will eventually
make progress.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1605'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Threads of execution providing weakly parallel forward progress guarantees cannot
be expected to make progress regardless of whether other threads make progress or
not; however, blocking with forward progress guarantee delegation, as defined below,
can be used to ensure that such threads of execution make progress eventually.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1613'>#</a></div><p >Concurrent forward progress guarantees are stronger than parallel forward progress
guarantees, which in turn are stronger than weakly parallel forward progress
guarantees.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
For example, some kinds of synchronization between threads of execution may only
make progress if the respective threads of execution provide parallel forward progress
guarantees, but will fail to make progress under weakly parallel guarantees.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1623'>#</a></div><p ><span class='indexparent'><a class='index' id='forward_progress_guarantees,delegation_of'></a></span>When a thread of execution <i>P</i> is specified to <a class='hidden_link' href='#def:block_with_forward_progress_guarantee_delegation' id='def:block_with_forward_progress_guarantee_delegation'><i>block with forward
progress guarantee delegation</i></a> on the completion of a set <i>S</i> of threads
of execution, then throughout the whole time of <i>P</i> being blocked on
<i>S</i>, the implementation shall ensure that the forward progress guarantees
provided by at least one thread of execution in <i>S</i> is at least as strong
as <i>P</i>'s forward progress guarantees.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
It is unspecified which thread or threads of execution in <i>S</i> are chosen
and for which number of execution steps. The strengthening is not permanent and
not necessarily in place for the rest of the lifetime of the affected thread of
execution. As long as <i>P</i> is blocked, the implementation has to eventually
select and potentially strengthen a thread of execution in <i>S</i>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
Once a thread of execution in <i>S</i> terminates, it is removed from <i>S</i>.
Once <i>S</i> is empty, <i>P</i> is unblocked.</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1641'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
A thread of execution <i>B</i> thus can temporarily provide an effectively
stronger forward progress guarantee for a certain amount of time, due to a
second thread of execution <i>A</i> being blocked on it with forward
progress guarantee delegation. In turn, if <i>B</i> then blocks with
forward progress guarantee delegation on <i>C</i>, this may also temporarily
provide a stronger forward progress guarantee to <i>C</i>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1651'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
If all threads of execution in <i>S</i> finish executing (e.g., they terminate
and do not use blocking synchronization incorrectly), then <i>P</i>'s execution
of the operation that blocks with forward progress guarantee delegation will not
result in <i>P</i>'s progress guarantee being effectively weakened.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1659'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This does not remove any constraints regarding blocking synchronization for
threads of execution providing parallel or weakly parallel forward progress
guarantees because the implementation is not required to strengthen a particular
thread of execution whose too-weak progress guarantee is preventing overall progress.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/intro.tex#L1667'>#</a></div><p >An implementation should ensure that the last value (in modification order)
assigned by an atomic or synchronization operation will become visible to all
other threads in a finite period of time.<span class='indexparent'><a class='index' id='operation,atomic'></a></span><span class='indexparent'><a class='index' id='threads,multiple'></a></span></p></div></div></div></body></html>