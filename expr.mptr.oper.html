<!DOCTYPE html><html lang='en'><head><title>[expr.mptr.oper]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><div id='expr.mptr.oper'><h2 ><a class='secnum' style='min-width:88pt'>5.5</a> Pointer-to-member operators <a class='abbr_ref'>[expr.mptr.oper]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3848'>#</a></div><p ><span class='indexparent'><a class='index' id='expression,pointer-to-member'></a></span><span class='indexparent'><a class='index' id='pointer_to_member'></a></span><span class='indexparent'><a class='index' id='operator,pointer_to_member'></a></span><span class='indexparent'><a class='index' id='.*'></a></span><span class='indexparent'><a class='index' id='operator,pointer_to_member'></a></span><span class='indexparent'><a class='index' id='->*'></a></span>The pointer-to-member operators <span class='texttt'>-&gt;*</span> and <span class='texttt'>.*</span> group
left-to-right.</p><pre class='bnf'><a class='nontermdef' id='nt:pm-expression'>pm-expression:</a>
&#9;<i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
&#9;<i ><a href='expr.mptr.oper#nt:pm-expression'>pm-expression</a></i> <span class='terminal'>.*</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
&#9;<i ><a href='expr.mptr.oper#nt:pm-expression'>pm-expression</a></i> <span class='terminal'>-&gt;*</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3865'>#</a></div><p >The binary operator <span class='texttt'>.*</span> binds its second operand, which shall be
of type “pointer to member of <span class='texttt'>T</span>” to its first operand, which shall be
a glvalue
of
class <span class='texttt'>T</span> or of a class of which <span class='texttt'>T</span> is an unambiguous and
accessible base class. The result is an object or a function of the type
specified by the second operand.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3874'>#</a></div><p >The binary operator <span class='texttt'>-&gt;*</span> binds its second operand, which shall be
of type “pointer to member of <span class='texttt'>T</span>” to its first operand, which shall be of
type “pointer to <span class='texttt'>U</span>”
where <span class='texttt'>U</span> is either <span class='texttt'>T</span> or
a class of which <span class='texttt'>T</span>
is an unambiguous and accessible base class.
The expression <span class='texttt'>E1-&gt;*E2</span> is converted into the equivalent form
<span class='texttt'>(*(E1)).*E2</span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3884'>#</a></div><p >Abbreviating <span class='term'>pm-expression</span><span class='texttt'>.*</span><a class='hidden_link' href='#def:cast-expression' id='def:cast-expression'><i>cast-expression</i></a> as <span class='texttt'>E1.*E2</span>, <span class='texttt'>E1</span>
is called the <a class='hidden_link' href='#def:object_expression' id='def:object_expression'><i>object expression</i></a>.
If the dynamic type of <span class='texttt'>E1</span> does not
contain the member to which
<span class='texttt'>E2</span> refers, the behavior is undefined.
Otherwise, the expression <span class='texttt'>E1</span> is sequenced before the expression <span class='texttt'>E2</span>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3892'>#</a></div><p >The restrictions on <i>cv-</i>qualification, and the manner in which
the <i>cv-</i>qualifiers of the operands are combined to produce the
<i>cv-</i>qualifiers of the result, are the same as the rules for
<span class='texttt'>E1.E2</span> given in <a href='expr.ref'>[expr.ref]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
It is not possible to use a pointer to member that refers to a
<span class='texttt'>mutable</span> member to modify a <span class='texttt'>const</span> class object. For
example,</p><pre class='codeblock'>
struct S {
  S() : i(0) { }
  mutable int i;
};
void f(){
const S cs;
int S::* pm = &amp;S::i;            <span class='comment'>// <span class='texttt'>pm</span> refers to <span class='texttt'>mutable</span> member <span class='texttt'>S::i</span>
</span>cs.*pm = 88;                    <span class='comment'>// ill-formed: <span class='texttt'>cs</span> is a <span class='texttt'>const</span> object
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/expressions.tex#L3916'>#</a></div><p ><span class='indexparent'><a class='index' id='function,pointer_to_member'></a></span>If the result of <span class='texttt'>.*</span> or <span class='texttt'>-&gt;*</span> is a function, then that
result can be used only as the operand for the function call operator
<span class='texttt'>()</span>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
(ptr_to_obj-&gt;*ptr_to_mfct)(10);</pre><p >calls the member function denoted by <span class='texttt'>ptr_to_mfct</span> for the object
pointed to by <span class='texttt'>ptr_to_obj</span>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
In a <span class='texttt'>.*</span> expression whose object expression is an rvalue, the program is
ill-formed if the second operand is a pointer to member function with
<i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> <span class='texttt'>&amp;</span>.
In a <span class='texttt'>.*</span>
expression whose object expression is an lvalue, the program is ill-formed if the second
operand is a pointer to member function with <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> <span class='texttt'>&amp;&amp;</span>.
The result of a <span class='texttt'>.*</span> expression
whose second operand is a pointer to a data member is an lvalue if the first
operand is an lvalue and an xvalue otherwise. The result of a <span class='texttt'>.*</span> expression whose
second operand is a pointer to a member function is a prvalue.
If the second operand is the null
pointer to member value (<a href='conv.mem'>[conv.mem]</a>), the behavior is undefined.</p></div></div></div></body></html>