<!DOCTYPE html><html lang='en'><head><title>[over.built]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Serif'/><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans'/><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans+Mono'/><link rel='icon' href='icon.png'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Normal'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='normative-only.css' title='Notes and examples hidden'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:50pt'>12</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:65pt'>12.5</a> Built-in operators <a class='abbr_ref'>[over.built]</a></h2><div class='texpara'><a class='index' id=':overloading,built-in_operators_and'></a></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3605'>#</a></div><div class='texpara'><div id='1.sentence-1' class='sentence'>The candidate operator functions that represent the built-in operators
defined in <a href='expr.compound' title='7.6&emsp;Compound expressions'>[expr.<span class='shy'></span>compound]</a> are specified in this subclause<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>These candidate
functions participate in the operator overload resolution process as
described in <a href='over.match.oper' title='12.2.2.3&emsp;Operators in expressions'>[over.<span class='shy'></span>match.<span class='shy'></span>oper]</a> and are used for no other purpose<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='note-1' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-1'>1</a></i>:&ensp;<div id='1.sentence-3' class='sentence'>Because built-in operators take only operands with non-class type,
and operator overload resolution occurs only when an operand expression
originally has class or enumeration type,
operator overload resolution can resolve to a built-in operator only
when an operand has a class type that has a user-defined conversion to
a non-class type appropriate for the operator, or when an operand has
an enumeration type that can be converted to a type appropriate
for the operator<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>Also note that some of the candidate operator functions given in this subclause are
more permissive than the built-in operators themselves<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>As
described in <a href='over.match.oper' title='12.2.2.3&emsp;Operators in expressions'>[over.<span class='shy'></span>match.<span class='shy'></span>oper]</a>, after a built-in operator is selected
by overload resolution the expression is subject to the requirements for
the built-in operator given in <a href='expr.compound' title='7.6&emsp;Compound expressions'>[expr.<span class='shy'></span>compound]</a>, and therefore to any
additional semantic constraints given there<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>In some cases, user-written candidates
with the same name and parameter types as a built-in
candidate operator function cause the built-in operator function
to not be included in the set of candidate functions<a class='hidden_link' href='#1.sentence-6'>.</a></div> —&nbsp;<i>end note</i>]</div></div></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3633'>#</a></div><div class='texpara'><div id='2.sentence-1' class='sentence'><a class='index' id=':type,integral,promoted'></a><a class='index' id=':type,arithmetic,promoted'></a>In this subclause, the term
<a class='hidden_link' href='#def:promoted_integral_type' title='12.5&emsp;Built-in operators&emsp;[over.built]'><span id='def:promoted_integral_type'><i >promoted integral type</i></span></a>
is used to refer to those cv-unqualified integral types which are preserved by
integral promotion (<a href='conv.prom' title='7.3.7&emsp;Integral promotions'>[conv.<span class='shy'></span>prom]</a>) (including e.g.
<span class='texttt'><span class='keyword'>int</span></span>
and
<span class='texttt'><span class='keyword'>long</span></span>
but excluding e.g.
<span class='texttt'><span class='keyword'>char</span></span>)<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='note-2' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-2'>2</a></i>:&ensp;<div id='2.sentence-2' class='sentence'>In all cases where a promoted integral type is
required, an operand of unscoped enumeration type will be acceptable by way of the
integral promotions<a class='hidden_link' href='#2.sentence-2'>.</a></div> —&nbsp;<i>end note</i>]</div></div></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3651'>#</a></div><div class='texpara'><div id='3.sentence-1' class='sentence'>In the remainder of this subclause, <i >vq</i> represents either
<span class='texttt'><span class='keyword'>volatile</span></span> or no cv-qualifier<a class='hidden_link' href='#3.sentence-1'>.</a></div></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3655'>#</a></div><div class='texpara'><div id='4.sentence-1' class='sentence'>For every pair
(<span class='texttt'><i >T</i></span>,
<i >vq</i>),
where
<span class='texttt'><i >T</i></span>
is a cv-unqualified arithmetic type other than <span class='texttt'><span class='keyword'>bool</span></span>
or a cv-unqualified pointer to (possibly cv-qualified) object type,
there exist candidate operator functions of the form
<span class='codeblock'><i >vq</i> <i >T</i><span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >vq</i> <i >T</i><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<i >T</i> <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >vq</i> <i >T</i><span class='operator'>&amp;</span>, <span class='keyword'>int</span><span class='parenthesis'>)</span>;
<i >vq</i> <i >T</i><span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >vq</i> <i >T</i><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<i >T</i> <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >vq</i> <i >T</i><span class='operator'>&amp;</span>, <span class='keyword'>int</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3671'>#</a></div><div class='texpara'><div id='5.sentence-1' class='sentence'>For every (possibly cv-qualified) object type <span class='texttt'><i >T</i></span> and
for every function type <span class='texttt'><i >T</i></span>
that has neither <a href='dcl.decl.general#nt:cv-qualifier' title='9.3.1&emsp;General&emsp;[dcl.decl.general]'><span id='ntref:cv-qualifier'><span class='textsf'><i >cv-qualifier</i></span></span></a><i >s</i> nor a <a href='dcl.decl.general#nt:ref-qualifier' title='9.3.1&emsp;General&emsp;[dcl.decl.general]'><span id='ntref:ref-qualifier'><span class='textsf'><i >ref-qualifier</i></span></span></a>,
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i><span class='operator'>&amp;</span>    <span class='keyword'>operator</span><span class='operator'>*</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3680'>#</a></div><div class='texpara'><div id='6.sentence-1' class='sentence'>For every type <span class='texttt'><i >T</i></span> there exist candidate operator functions of the form
<span class='codeblock'><i >T</i><span class='operator'>*</span>    <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3686'>#</a></div><div class='texpara'><div id='7.sentence-1' class='sentence'>For every cv-unqualified floating-point or promoted integral type <span class='texttt'><i >T</i></span>,
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i> <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >T</i><span class='parenthesis'>)</span>;
<i >T</i> <span class='keyword'>operator</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3694'>#</a></div><div class='texpara'><div id='8.sentence-1' class='sentence'>For every promoted integral type
<span class='texttt'><i >T</i></span>,
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i> <span class='keyword'>operator</span><span class='operator'>~</span><span class='parenthesis'>(</span><i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3702'>#</a></div><div class='texpara'><div id='9.sentence-1' class='sentence'>For every quintuple
(<span class='texttt'><i >C1</i></span>,
<span class='texttt'><i >C2</i></span>,
<span class='texttt'><i >T</i></span>,
<i >cv1</i>,
<i >cv2</i>),
where
<span class='texttt'><i >C2</i></span>
is a class type,
<span class='texttt'><i >C1</i></span>
is the same type as <span class='texttt'><i >C2</i></span> or is a derived class of <span class='texttt'><i >C2</i></span>, and
<span class='texttt'><i >T</i></span>
is an object type or a function type,
there exist candidate operator functions of the form
<span class='codeblock'><i >cv12</i> <i >T</i><span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span><span class='operator'>*</span><span class='parenthesis'>(</span><i >cv1</i> <i >C1</i><span class='operator'>*</span>, <i >cv2</i> <i >T C2</i><span class='operator'>::</span><span class='operator'>*</span><span class='parenthesis'>)</span>;
</span>
where <i >cv12</i> is the union of <i >cv1</i> and <i >cv2</i><a class='hidden_link' href='#9.sentence-1'>.</a></div> <div id='9.sentence-2' class='sentence'>The return type is shown for exposition only; see <a href='expr.mptr.oper' title='7.6.4&emsp;Pointer-to-member operators'>[expr.<span class='shy'></span>mptr.<span class='shy'></span>oper]</a> for the
determination of the operator's result type<a class='hidden_link' href='#9.sentence-2'>.</a></div></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3724'>#</a></div><div class='texpara'><div id='10.sentence-1' class='sentence'>For every pair of types <span class='texttt'><i >L</i></span> and <span class='texttt'><i >R</i></span>,
where each of <span class='texttt'><i >L</i></span> and <span class='texttt'><i >R</i></span> is a
floating-point or promoted integral type,
there exist candidate operator functions of the form
<span class='codeblock'><i >LR</i>      <span class='keyword'>operator</span><span class='operator'>*</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>/</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>!</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
</span>
where
<span class='texttt'><i >LR</i></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv' title='7.4&emsp;Usual arithmetic conversions'>[expr.<span class='shy'></span>arith.<span class='shy'></span>conv]</a>) between types
<span class='texttt'><i >L</i></span>
and
<span class='texttt'><i >R</i></span><a class='hidden_link' href='#10.sentence-1'>.</a></div></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3748'>#</a></div><div class='texpara'><div id='11.sentence-1' class='sentence'>For every integral type <span class='texttt'><i >T</i></span>
there exists a candidate operator function of the form
<span class='codeblock'>std<span class='operator'>::</span>strong_ordering <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3755'>#</a></div><div class='texpara'><div id='12.sentence-1' class='sentence'>For every pair of floating-point types
<span class='texttt'><i >L</i></span> and <span class='texttt'><i >R</i></span>,
there exists a candidate operator function of the form
<span class='codeblock'>std<span class='operator'>::</span>partial_ordering <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3763'>#</a></div><div class='texpara'><div id='13.sentence-1' class='sentence'>For every cv-qualified or cv-unqualified object type
<span class='texttt'><i >T</i></span>
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i><span class='operator'>*</span>      <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span>, std<span class='operator'>::</span>ptrdiff_t<span class='parenthesis'>)</span>;
<i >T</i><span class='operator'>&amp;</span>      <span class='keyword'>operator</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span>, std<span class='operator'>::</span>ptrdiff_t<span class='parenthesis'>)</span>;
<i >T</i><span class='operator'>*</span>      <span class='keyword'>operator</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span>, std<span class='operator'>::</span>ptrdiff_t<span class='parenthesis'>)</span>;
<i >T</i><span class='operator'>*</span>      <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span>std<span class='operator'>::</span>ptrdiff_t, <i >T</i><span class='operator'>*</span><span class='parenthesis'>)</span>;
<i >T</i><span class='operator'>&amp;</span>      <span class='keyword'>operator</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span><span class='parenthesis'>(</span>std<span class='operator'>::</span>ptrdiff_t, <i >T</i><span class='operator'>*</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3775'>#</a></div><div class='texpara'><div id='14.sentence-1' class='sentence'>For every
<span class='texttt'><i >T</i></span>,
where
<span class='texttt'><i >T</i></span>
is a pointer to object type,
there exist candidate operator functions of the form
<span class='codeblock'>std<span class='operator'>::</span>ptrdiff_t   <span class='keyword'>operator</span><span class='operator'>-</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3786'>#</a></div><div class='texpara'><div id='15.sentence-1' class='sentence'>For every <span class='texttt'><i >T</i></span>, where <span class='texttt'><i >T</i></span> is an enumeration type or a pointer type,
there exist candidate operator functions of the form
<span class='codeblock'><span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>!</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<i >R</i>       <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
</span>
where <span class='texttt'><i >R</i></span> is the result type specified in <a href='expr.spaceship' title='7.6.8&emsp;Three-way comparison operator'>[expr.<span class='shy'></span>spaceship]</a><a class='hidden_link' href='#15.sentence-1'>.</a></div></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3800'>#</a></div><div class='texpara'><div id='16.sentence-1' class='sentence'>For every <span class='texttt'><i >T</i></span>, where <span class='texttt'><i >T</i></span>
is a pointer-to-member type or <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>nullptr_<span class='shy'></span>t</span>,
there exist candidate operator functions of the form
<span class='codeblock'><span class='keyword'>bool</span> <span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span> <span class='keyword'>operator</span><span class='operator'>!</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3809'>#</a></div><div class='texpara'><div id='17.sentence-1' class='sentence'>For every pair of promoted integral types
<span class='texttt'><i >L</i></span>
and
<span class='texttt'><i >R</i></span>,
there exist candidate operator functions of the form
<span class='codeblock'><i >LR</i>      <span class='keyword'>operator</span><span class='operator'>%</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>&amp;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>^</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >LR</i>      <span class='keyword'>operator</span><span class='operator'>|</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >L</i>       <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
<i >L</i>       <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
</span>
where
<span class='texttt'><i >LR</i></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv' title='7.4&emsp;Usual arithmetic conversions'>[expr.<span class='shy'></span>arith.<span class='shy'></span>conv]</a>) between types
<span class='texttt'><i >L</i></span>
and
<span class='texttt'><i >R</i></span><a class='hidden_link' href='#17.sentence-1'>.</a></div></div></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3830'>#</a></div><div class='texpara'><div id='18.sentence-1' class='sentence'>For every triple
(<span class='texttt'><i >L</i></span>, <i >vq</i>, <span class='texttt'><i >R</i></span>),
where <span class='texttt'><i >L</i></span> is an arithmetic type,
and <span class='texttt'><i >R</i></span> is a floating-point or promoted integral type,
there exist candidate operator functions of the form
<span class='codeblock'><i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>*</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>/</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3844'>#</a></div><div class='texpara'><div id='19.sentence-1' class='sentence'>For every pair (<span class='texttt'><i >T</i></span>, <i >vq</i>),
where <span class='texttt'><i >T</i></span> is any type,
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>, <i >T</i><span class='operator'>*</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3852'>#</a></div><div class='texpara'><div id='20.sentence-1' class='sentence'>For every pair
(<span class='texttt'><i >T</i></span>,
<i >vq</i>),
where
<span class='texttt'><i >T</i></span>
is an enumeration or pointer-to-member type,
there exist candidate operator functions of the form
<span class='codeblock'><i >vq</i> <i >T</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >T</i><span class='operator'>&amp;</span>, <i >T</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3864'>#</a></div><div class='texpara'><div id='21.sentence-1' class='sentence'>For every pair
(<span class='texttt'><i >T</i></span>,
<i >vq</i>),
where
<span class='texttt'><i >T</i></span>
is a cv-qualified or cv-unqualified object type,
there exist candidate operator functions of the form
<span class='codeblock'><i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>+</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>, std<span class='operator'>::</span>ptrdiff_t<span class='parenthesis'>)</span>;
<i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>-</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >T</i><span class='operator'>*</span><i >vq</i><span class='operator'>&amp;</span>, std<span class='operator'>::</span>ptrdiff_t<span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3877'>#</a></div><div class='texpara'><div id='22.sentence-1' class='sentence'>For every triple
(<span class='texttt'><i >L</i></span>,
<i >vq</i>,
<span class='texttt'><i >R</i></span>),
where
<span class='texttt'><i >L</i></span>
is an integral type, and
<span class='texttt'><i >R</i></span>
is a promoted integral type,
there exist candidate operator functions of the form
<span class='codeblock'><i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>%</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='anglebracket'>&gt;</span><span class='anglebracket'>&gt;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>&amp;</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>^</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
<i >vq</i> <i >L</i><span class='operator'>&amp;</span>   <span class='keyword'>operator</span><span class='operator'>|</span><span class='operator'>=</span><span class='parenthesis'>(</span><i >vq</i> <i >L</i><span class='operator'>&amp;</span>, <i >R</i><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3897'>#</a></div><div class='texpara'><div id='23.sentence-1' class='sentence'>There also exist candidate operator functions of the form
<span class='codeblock'><span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>!</span><span class='parenthesis'>(</span><span class='keyword'>bool</span><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>(</span><span class='keyword'>bool</span>, <span class='keyword'>bool</span><span class='parenthesis'>)</span>;
<span class='keyword'>bool</span>    <span class='keyword'>operator</span><span class='operator'>|</span><span class='operator'>|</span><span class='parenthesis'>(</span><span class='keyword'>bool</span>, <span class='keyword'>bool</span><span class='parenthesis'>)</span>;
</span></div></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3905'>#</a></div><div class='texpara'><div id='24.sentence-1' class='sentence'>For every pair of types <span class='texttt'><i >L</i></span> and <span class='texttt'><i >R</i></span>,
where each of <span class='texttt'><i >L</i></span> and <span class='texttt'><i >R</i></span> is a
floating-point or promoted integral type,
there exist candidate operator functions of the form
<span class='codeblock'><i >LR</i>      <span class='keyword'>operator</span><span class='operator'>?</span><span class='operator'>:</span><span class='parenthesis'>(</span><span class='keyword'>bool</span>, <i >L</i>, <i >R</i><span class='parenthesis'>)</span>;
</span>
where
<span class='texttt'><i >LR</i></span>
is the result of the usual arithmetic conversions (<a href='expr.arith.conv' title='7.4&emsp;Usual arithmetic conversions'>[expr.<span class='shy'></span>arith.<span class='shy'></span>conv]</a>) between types
<span class='texttt'><i >L</i></span>
and
<span class='texttt'><i >R</i></span><a class='hidden_link' href='#24.sentence-1'>.</a></div> <div id='note-3' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-3'>3</a></i>:&ensp;<div id='24.sentence-2' class='sentence'>As with all these descriptions of candidate functions, this declaration serves
only to describe the built-in operator for purposes of overload resolution<a class='hidden_link' href='#24.sentence-2'>.</a></div> <div id='24.sentence-3' class='sentence'>The operator
“<span class='texttt'><span class='operator'>?</span><span class='operator'>:</span></span>”
cannot be overloaded<a class='hidden_link' href='#24.sentence-3'>.</a></div> —&nbsp;<i>end note</i>]</div></div></div></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='sourceLinkParent'><a class='sourceLink' href='http://github.com/timsong-cpp/draft/tree/dbd2450ef21216a8eff8e7c454db6c4e1683bbf5/source/overloading.tex#L3927'>#</a></div><div class='texpara'><div id='25.sentence-1' class='sentence'>For every type
<span class='texttt'><i >T</i></span>,
where
<span class='texttt'><i >T</i></span>
is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator
functions of the form
<span class='codeblock'><i >T</i>       <span class='keyword'>operator</span><span class='operator'>?</span><span class='operator'>:</span><span class='parenthesis'>(</span><span class='keyword'>bool</span>, <i >T</i>, <i >T</i><span class='parenthesis'>)</span>;
</span>
</div></div></div></div></body></html>