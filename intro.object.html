<!DOCTYPE html><html lang='en'><head><title>[intro.object]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>1</a> General <a class='abbr_ref' href='./#intro'>[intro]</a></h1><div id='intro.object'><h2 ><a class='secnum' style='min-width:88pt'>1.8</a> The C++ object model <a class='abbr_ref'>[intro.object]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L535'>#</a></div><p ><span class='indexparent'><a class='index' id='object_model'></a></span>The constructs in a C++ program create, destroy, refer to, access, and
manipulate objects.
An <a class='hidden_link' href='#def:object' id='def:object'><i>object</i></a> is created
by a definition (<a href='basic.def'>[basic.def]</a>),
by a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>),
when implicitly changing the active member of a union (<a href='class.union'>[class.union]</a>),
or
when a temporary object is created (<a href='conv.rval'>[conv.rval]</a>, <a href='class.temporary'>[class.temporary]</a>). 
An object occupies a region of storage
in its period of construction (<a href='class.cdtor'>[class.cdtor]</a>),
throughout its lifetime (<a href='basic.life'>[basic.life]</a>),
and
in its period of destruction (<a href='class.cdtor'>[class.cdtor]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> A function is not an object, regardless of whether or not it
occupies storage in the way that objects do. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
The properties of an
object are determined when the object is created. An object can have a
name (Clause <a href='basic'>[basic]</a>). An object has a storage
duration (<a href='basic.stc'>[basic.stc]</a>) which influences its
lifetime (<a href='basic.life'>[basic.life]</a>). An object has a
type (<a href='basic.types'>[basic.types]</a>). The term <a class='hidden_link' href='#def:object_type' id='def:object_type'><i>object type</i></a> refers to
the type with which the object is created.
Some objects are
polymorphic (<a href='class.virtual'>[class.virtual]</a>); the implementation
generates information associated with each such object that makes it
possible to determine that object's type during program execution. For
other objects, the interpretation of the values found therein is
determined by the type of the <i ><a href='expr.comma#nt:expression'>expression</a></i>s (Clause <a href='expr'>[expr]</a>)
used to access them.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L567'>#</a></div><p ><span class='indexparent'><a class='index' id='subobject'></a></span>Objects can contain other objects, called <a class='hidden_link' href='#def:subobject' id='def:subobject'><i>subobjects</i></a>.
A subobject can be
a <a class='hidden_link' href='#def:member_subobject' id='def:member_subobject'><i>member subobject</i></a> (<a href='class.mem'>[class.mem]</a>), a <a class='hidden_link' href='#def:base_class_subobject' id='def:base_class_subobject'><i>base class subobject</i></a>
(Clause <a href='class.derived'>[class.derived]</a>), or an array element.
<span class='indexparent'><a class='index' id='object,complete'></a></span>An object that is not a subobject of any other object is called a <a class='hidden_link' href='#def:complete_object' id='def:complete_object'><i>complete
object</i></a>.
If an object is created
in storage associated with a member subobject or array element <span class='textit'>e</span>
(which may or may not be within its lifetime),
the created object
is a subobject of <span class='textit'>e</span>'s containing object if:
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >the lifetime of <span class='textit'>e</span>'s containing object has begun and not ended, and
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >the storage for the new object exactly overlays the storage location associated with <span class='textit'>e</span>, and
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >the new object is of the same type as <span class='textit'>e</span> (ignoring cv-qualification).
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
If the subobject contains a reference member or a <span class='texttt'>const</span> subobject,
the name of the original subobject cannot be used to access the new object (<a href='basic.life'>[basic.life]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          <span class='comment'>// OK, creates new subobject of <span class='tcode_in_codeblock'>u</span> (<a href='class.union'>[class.union]</a>)
</span>  X *p = new (&amp;u.x) X {2};            <span class='comment'>// OK, creates new subobject of <span class='tcode_in_codeblock'>u</span>
</span>  assert(p-&gt;n == 2);                  <span class='comment'>// OK
</span>  assert(*std::launder(&amp;u.x.n) == 2); <span class='comment'>// OK
</span>  assert(u.x.n == 2);                 <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>u.x</span> does not name new subobject
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L608'>#</a></div><p ><span class='indexparent'><a class='index' id='object,providing_storage_for'></a></span>If a complete object is created (<a href='expr.new'>[expr.new]</a>)
in storage associated with another object <span class='textit'>e</span>
of type “array of <span class='math'><span class='mathalpha'>N</span></span> <span class='texttt'>unsigned char</span>”,
that array <a class='hidden_link' href='#def:provides_storage' id='def:provides_storage'><i>provides storage</i></a>
for the created object if:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the lifetime of <span class='textit'>e</span> has begun and not ended, and
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >the storage for the new object fits entirely within <span class='textit'>e</span>, and
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >there is no smaller array object that satisfies these constraints.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
If that portion of the array
previously provided storage for another object,
the lifetime of that object ends
because its storage was reused (<a href='basic.life'>[basic.life]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
template&lt;typename ...T&gt;
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion&lt;int, char&gt; au;
  int *p = new (au.data) int;     <span class='comment'>// OK, <span class='tcode_in_codeblock'>au.data</span> provides storage
</span>  char *c = new (au.data) char(); <span class='comment'>// OK, ends lifetime of <span class='tcode_in_codeblock'>*p</span>
</span>  char *d = new (au.data + 1) char();
  return *c + *d; <span class='comment'>// OK
</span>}

struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
A a;
B *b = new (a.a + 8) B;      <span class='comment'>// <span class='tcode_in_codeblock'>a.a</span> provides storage for <span class='tcode_in_codeblock'>*b</span>
</span>int *p = new (b-&gt;b + 4) int; <span class='comment'>// <span class='tcode_in_codeblock'>b-&gt;b</span> provides storage for <span class='tcode_in_codeblock'>*p</span>
</span>                             <span class='comment'>// <span class='tcode_in_codeblock'>a.a</span> does not provide storage for <span class='tcode_in_codeblock'>*p</span> (directly),
</span>                             <span class='comment'>// but <span class='tcode_in_codeblock'>*p</span> is nested within <span class='tcode_in_codeblock'>a</span> (see below)
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L653'>#</a></div><p ><span class='indexparent'><a class='index' id='object,nested_within'></a></span>An object <span class='textit'>a</span> is <a class='hidden_link' href='#def:nested_within' id='def:nested_within'><i>nested within</i></a> another object <span class='textit'>b</span> if:
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p ><span class='textit'>a</span> is a subobject of <span class='textit'>b</span>, or
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p ><span class='textit'>b</span> provides storage for <span class='textit'>a</span>, or
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >there exists an object <span class='textit'>c</span>
where <span class='textit'>a</span> is nested within <span class='textit'>c</span>,
and <span class='textit'>c</span> is nested within <span class='textit'>b</span>.
</p></li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L667'>#</a></div><p >For every object <span class='texttt'>x</span>, there is some object called the
<a class='hidden_link' href='#def:complete_object_of' id='def:complete_object_of'><i>complete object of</i></a> <span class='texttt'>x</span>, determined as follows:
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If <span class='texttt'>x</span> is a complete object, then the complete object
of <span class='texttt'>x</span> is itself.</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >Otherwise, the complete object of <span class='texttt'>x</span> is the complete object
of the (unique) object that contains <span class='texttt'>x</span>.
</p></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L680'>#</a></div><p >If a complete object, a data member (<a href='class.mem'>[class.mem]</a>), or an array element is of
class type, its type is considered the <a class='hidden_link' href='#def:most_derived_class' id='def:most_derived_class'><i>most derived
class</i></a>, to distinguish it from the class type of any base class subobject;
an object of a most derived class type or of a non-class type is called a
<a class='hidden_link' href='#def:most_derived_object' id='def:most_derived_object'><i>most derived object</i></a>.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L687'>#</a></div><p ><span class='indexparent'><a class='index' id='most_derived_object,bit-field'></a></span>Unless it is a bit-field (<a href='class.bit'>[class.bit]</a>), a most derived object shall have a
nonzero size and shall occupy one or more bytes of storage. Base class
subobjects may have zero size. An object of trivially copyable or
standard-layout type (<a href='basic.types'>[basic.types]</a>) shall occupy contiguous bytes of
storage.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L695'>#</a></div><p ><span class='indexparent'><a class='index' id='most_derived_object,bit-field'></a></span><span class='indexparent'><a class='index' id='most_derived_object,zero_size_subobject'></a></span>Unless an object is a bit-field or a base class subobject of zero size, the
address of that object is the address of the first byte it occupies.
Two objects <span class='textit'>a</span> and <span class='textit'>b</span>
with overlapping lifetimes
that are not bit-fields
may have the same address
if one is nested within the other,
or
if at least one is a base class subobject of zero size
and they are of different types;
otherwise, they have distinct addresses.<a class='footnotenum' href='#footnote-5'>5</a></p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &amp;test1 != &amp;test2;      <span class='comment'>// always <span class='tcode_in_codeblock'>true</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/intro.tex#L721'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
C++  provides a variety of fundamental types and several ways of composing
new types from existing types (<a href='basic.types'>[basic.types]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]<span class='indexparent'><a class='index' id='object_model'></a></span></p></div><div class='footnote' id='footnote-5'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-5'>5)</a></div><p >Under the “as-if” rule an
implementation is allowed to store two objects at the same machine address or
not store an object at all if the program cannot observe the
difference (<a href='intro.execution'>[intro.execution]</a>).</p></div></div></div></body></html>