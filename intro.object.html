<!DOCTYPE html><html lang='en'><head><title>[intro.object]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>1</a> General <a class='abbr_ref' href='./#intro'>[intro]</a></h1><div id='intro.object'><h2 ><a class='secnum' style='min-width:88pt'>1.8</a> The C++ object model <a class='abbr_ref'>[intro.object]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='object model'></a></span>The constructs in a C++ program create, destroy, refer to, access, and
manipulate objects.
An <a id='object'><i>object</i></a> is created
by a definition (<a href='basic.def'>[basic.def]</a>),
by a <i ><a href='expr.new#new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>),
when implicitly changing the active member of a union (<a href='class.union'>[class.union]</a>),
or
when a temporary object is created (<a href='conv.rval'>[conv.rval]</a>, <a href='class.temporary'>[class.temporary]</a>). 
An object occupies a region of storage
in its period of construction (<a href='class.cdtor'>[class.cdtor]</a>),
throughout its lifetime (<a href='basic.life'>[basic.life]</a>),
and
in its period of destruction (<a href='class.cdtor'>[class.cdtor]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> A function is not an object, regardless of whether or not it
occupies storage in the way that objects do. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The properties of an
object are determined when the object is created. An object can have a
<i>name</i> (Clause <a href='basic'>[basic]</a>). An object has a <i>storage
duration</i> (<a href='basic.stc'>[basic.stc]</a>) which influences its
<i>lifetime</i> (<a href='basic.life'>[basic.life]</a>). An object has a
<i>type</i> (<a href='basic.types'>[basic.types]</a>). The term <a id='object type'><i>object type</i></a> refers to
the type with which the object is created.
Some objects are
<i>polymorphic</i> (<a href='class.virtual'>[class.virtual]</a>); the implementation
generates information associated with each such object that makes it
possible to determine that object's type during program execution. For
other objects, the interpretation of the values found therein is
determined by the type of the <i ><a href='expr.comma#expression'>expressions</a></i> (Clause <a href='expr'>[expr]</a>)
used to access them.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='subobject'></a></span>Objects can contain other objects, called <a id='subobject'><i>subobjects</i></a>.
A subobject can be
a <a id='member subobject'><i>member subobject</i></a> (<a href='class.mem'>[class.mem]</a>), a <a id='base class subobject'><i>base class subobject</i></a>
(Clause <a href='class.derived'>[class.derived]</a>), or an array element.
<span class='indexparent'><a class='index' id='object!complete'></a></span>An object that is not a subobject of any other object is called a <a id='complete object'><i>complete
object</i></a>.
If an object is created
in storage associated with a member subobject or array element <i>e</i>
(which may or may not be within its lifetime),
the created object
is a subobject of <i>e</i>'s containing object if:
</p><ul ><li ><p >the lifetime of <i>e</i>'s containing object has begun and not ended, and
</p></li><li ><p >the storage for the new object exactly overlays the storage location associated with <i>e</i>, and
</p></li><li ><p >the new object is of the same type as <i>e</i> (ignoring cv-qualification).
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
If the subobject contains a reference member or a <span class='texttt'>const</span> subobject,
the name of the original subobject cannot be used to access the new object (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          <span class='comment'>// OK, creates new subobject of <span class='texttt'>u</span> (<a href='class.union'>[class.union]</a>)
</span>  X *p = new (&amp;u.x) X {2};            <span class='comment'>// OK, creates new subobject of <span class='texttt'>u</span>
</span>  assert(p-&gt;n == 2);                  <span class='comment'>// OK
</span>  assert(*std::launder(&amp;u.x.n) == 2); <span class='comment'>// OK
</span>  assert(u.x.n == 2);                 <span class='comment'>// undefined behavior, <span class='texttt'>u.x</span> does not name new subobject
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='object!providing storage for'></a></span>If a complete object is created (<a href='expr.new'>[expr.new]</a>)
in storage associated with another object <i>e</i>
of type “array of <span class='math'><span class='mathalpha'>N</span></span> <span class='texttt'>unsigned char</span>”,
that array <a id='provides storage'><i>provides storage</i></a>
for the created object if:
</p><ul ><li ><p >the lifetime of <i>e</i> has begun and not ended, and
</p></li><li ><p >the storage for the new object fits entirely within <i>e</i>, and
</p></li><li ><p >there is no smaller array object that satisfies these constraints.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
If that portion of the array
previously provided storage for another object,
the lifetime of that object ends
because its storage was reused (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename ...T&gt;
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion&lt;int, char&gt; au;
  int *p = new (au.data) int;     <span class='comment'>// OK, <span class='texttt'>au.data</span> provides storage
</span>  char *c = new (au.data) char(); <span class='comment'>// OK, ends lifetime of <span class='texttt'>*p</span>
</span>  char *d = new (au.data + 1) char();
  return *c + *d; <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='object!nested within'></a></span>An object <i>a</i> is <a id='nested within'><i>nested within</i></a> another object <i>b</i> if:
</p><ul ><li ><p ><i>a</i> is a subobject of <i>b</i>, or
</p></li><li ><p ><i>b</i> provides storage for <i>a</i>, or
</p></li><li ><p >there exists an object <i>c</i>
where <i>a</i> is nested within <i>c</i>,
and <i>c</i> is nested within <i>b</i>.
</p></li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For every object <span class='texttt'>x</span>, there is some object called the
<a id='complete object of'><i>complete object of</i></a> <span class='texttt'>x</span>, determined as follows:</p><ul ><li ><p >If <span class='texttt'>x</span> is a complete object, then <span class='texttt'>x</span> is the complete
object of <span class='texttt'>x</span>.</p></li><li ><p >Otherwise, the complete object of <span class='texttt'>x</span> is the complete object
of the (unique) object that contains <span class='texttt'>x</span>.</p></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If a complete object, a data member (<a href='class.mem'>[class.mem]</a>), or an array element is of
class type, its type is considered the <a id='most derived class'><i>most derived
class</i></a>, to distinguish it from the class type of any base class subobject;
an object of a most derived class type or of a non-class type is called a
<a id='most derived object'><i>most derived object</i></a>.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='most derived object!bit-field'></a></span>Unless it is a bit-field (<a href='class.bit'>[class.bit]</a>), a most derived object shall have a
non-zero size and shall occupy one or more bytes of storage. Base class
subobjects may have zero size. An object of trivially copyable or
standard-layout type (<a href='basic.types'>[basic.types]</a>) shall occupy contiguous bytes of
storage.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='most derived object!bit-field'></a></span><span class='indexparent'><a class='index' id='most derived object!zero size subobject'></a></span>Unless an object is a bit-field or a base class subobject of zero size, the
address of that object is the address of the first byte it occupies.
Two objects <i>a</i> and <i>b</i>
with overlapping lifetimes
that are not bit-fields
may have the same address
if one is nested within the other,
or
if at least one is a base class subobject of zero size
and they are of different types;
otherwise, they have distinct addresses.<a class='footnotenum' href='#footnote-4'>4</a></p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &amp;test1 != &amp;test2;      <span class='comment'>// always true
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> 
C++  provides a variety of fundamental types and several ways of composing
new types from existing types (<a href='basic.types'>[basic.types]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='object model'></a></span></p></div><div class='footnote' id='footnote-4'><div class='marginalizedparent'><a class='marginalized' href='#footnote-4'>4)</a></div><p >Under the “as-if” rule an
implementation is allowed to store two objects at the same machine address or
not store an object at all if the program cannot observe the
difference (<a href='intro.execution'>[intro.execution]</a>).</p></div></div></div></body></html>