<!DOCTYPE html><html lang='en'><head><title>[expr.prim.lambda]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.1</a> Primary expressions <a class='abbr_ref' href='expr.prim#lambda'>[expr.prim]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>8.1.5</a> Lambda expressions <a class='abbr_ref'>[expr.prim.lambda]</a></h3><span class='indexparent'><a class='index' id=':expression,lambda'></a></span><pre class='bnf'><a class='nontermdef' id='nt:lambda-expression'>lambda-expression:</a>
&#9;<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
&#9;<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> <span class='texttt'>&lt;</span> <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> <span class='texttt'>&gt;</span> <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
</pre><pre class='bnf'><a class='nontermdef' id='nt:lambda-introducer'>lambda-introducer:</a>
&#9;<span class='terminal'>[</span> <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>]</span>
</pre><pre class='bnf'><a class='nontermdef' id='nt:lambda-declarator'>lambda-declarator:</a>
&#9;<span class='terminal'>(</span> <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> <span class='terminal'>)</span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
&#9;<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L668'>#</a></div><div id='1.sentence-1' class='sentence'>Lambda expressions provide a concise way to create simple function objects<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
void abssort(float* x, unsigned N) {
  std::sort(x, x + N, [](float a, float b) { return std::abs(a) &lt; std::abs(b); });
}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L680'>#</a></div><div id='2.sentence-1' class='sentence'>A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> is a prvalue
whose result object is called the <a class='hidden_link' href='#def:closure_object' id='def:closure_object'><i >closure object</i></a><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>A
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> shall not appear in an
<a href='expr#def:unevaluated_operand'>unevaluated operand</a>, in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>,
in an <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>,
in a typedef declaration, or in the declaration of a function or function
template outside its function body and default arguments<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-3' class='sentence'>The intention is to prevent lambdas from appearing in a signature<a class='hidden_link' href='#2.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='2.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-4' class='sentence'>A closure object behaves like a <a href='function.objects'>function
object</a><a class='hidden_link' href='#2.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L695'>#</a></div><div id='3.sentence-1' class='sentence'>In the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>,
each <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
shall either be <span class='texttt'>mutable</span> or <span class='texttt'>constexpr</span><a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L700'>#</a></div><div id='4.sentence-1' class='sentence'>If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> does not include a
<i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>, it is as if the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> were
<span class='texttt'>()</span><a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>The lambda return type is <span class='texttt'>auto</span>, which is replaced by the
type specified by the
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> if provided and/or deduced from
<span class='texttt'>return</span> statements as described in <a href='dcl.spec.auto'>[dcl.spec.auto]</a><a class='hidden_link' href='#4.sentence-2'>.</a></div> <div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto x1 = [](int i){ return i; };     <span class='comment'>// OK: return type is <span class='tcode_in_codeblock'>int</span>
</span>auto x2 = []{ return { 1, 2 }; };     <span class='comment'>// error: deducing return type from <span class='grammarterm'>braced-init-list</span>
</span>int j;
auto x3 = []()-&gt;auto&amp;&amp; { return j; }; <span class='comment'>// OK: return type is <span class='tcode_in_codeblock'>int&amp;</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L717'>#</a></div><div id='5.sentence-1' class='sentence'>A lambda is a <a class='hidden_link' href='#def:generic_lambda' id='def:generic_lambda'><i >generic lambda</i></a>
if the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> appears as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i><span class='textit'>s</span> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>,
or if the lambda has a <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i><a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
int i = [](int i, auto a) { return i; }(3, 4);         <span class='comment'>// OK: a generic lambda
</span>int j = []&lt;class T&gt;(T t, int i) { return i; }(3, 4);   <span class='comment'>// OK: a generic lambda
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div id='closure' class='section'><h4 ><a class='secnum' href='#closure' style='min-width:118pt'>8.1.5.1</a> Closure types <a class='abbr_ref' href='expr.prim.lambda.closure'>[expr.prim.lambda.closure]</a></h4><div class='para' id='closure-1'><div class='marginalizedparent'><a class='marginalized' href='#closure-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L732'>#</a></div><div id='closure-1.sentence-1' class='sentence'>The type of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (which is also the type of the
closure object) is a unique, unnamed non-union class type,
called the <a class='hidden_link' href='#def:closure_type' id='def:closure_type'><i >closure type</i></a>,
whose properties are described below<a class='hidden_link' href='#closure-1.sentence-1'>.</a></div></div><div class='para' id='closure-2'><div class='marginalizedparent'><a class='marginalized' href='#closure-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L738'>#</a></div><div id='closure-2.sentence-1' class='sentence'>The closure type is declared in the smallest block
scope, class scope, or namespace scope that contains the corresponding
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#closure-2.sentence-1'>.</a></div> <div id='closure-2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#closure-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='closure-2.sentence-4' class='sentence'>This determines the set of namespaces and
classes associated with the closure type (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)<a class='hidden_link' href='#closure-2.sentence-4'>.</a></div> <div id='closure-2.sentence-5' class='sentence'>The parameter
types of a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> do not affect these associated namespaces and
classes<a class='hidden_link' href='#closure-2.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='closure-2.sentence-2' class='sentence'> The closure type is not an aggregate type (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>)<a class='hidden_link' href='#closure-2.sentence-2'>.</a></div> <div id='closure-2.sentence-3' class='sentence'>An implementation may define the closure type differently from what
is described below provided this does not alter the observable behavior of the program
other than by changing:</div><div id='closure-2.sentence-6' class='sentence'><ul class='itemize'><li id='closure-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#closure-2.1'>(2.1)</a></div><div id='closure-2.1.sentence-1' class='sentence'>the size and/or alignment of the closure type,</div></li><li id='closure-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#closure-2.2'>(2.2)</a></div><div id='closure-2.2.sentence-1' class='sentence'>whether the closure type is <a href='class#def:trivially_copyable_class'>trivially copyable</a>,</div></li><li id='closure-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#closure-2.3'>(2.3)</a></div><div id='closure-2.3.sentence-1' class='sentence'>whether the closure type is a <a href='class#def:standard-layout_class'>standard-layout class</a>,
or</div></li><li id='closure-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#closure-2.4'>(2.4)</a></div><div id='closure-2.4.sentence-1' class='sentence'>whether the closure type is a <a href='class#def:POD_class'>POD class</a><a class='hidden_link' href='#closure-2.4.sentence-1'>.</a></div></li></ul></div><div id='closure-2.sentence-7' class='sentence'>An implementation shall not add members of rvalue reference type to the closure
type<a class='hidden_link' href='#closure-2.sentence-7'>.</a></div></div><div class='para' id='closure-3'><div class='marginalizedparent'><a class='marginalized' href='#closure-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L763'>#</a></div><div id='closure-3.sentence-1' class='sentence'>The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a public
inline <a href='over.call'>function call operator</a> whose parameters and return type
are described by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>
respectively<a class='hidden_link' href='#closure-3.sentence-1'>.</a></div> <div id='closure-3.sentence-2' class='sentence'>For a generic lambda, the closure type has a public inline function call
operator <a href='temp.mem'>member template</a> whose
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> consists of
the specified <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>, if any,
to which is appended one invented type
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> for each occurrence of <span class='texttt'>auto</span> in the
lambda's <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>, in order of appearance<a class='hidden_link' href='#closure-3.sentence-2'>.</a></div> <div id='closure-3.sentence-3' class='sentence'>The invented type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> is a parameter pack if
the corresponding <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> declares a function
parameter pack (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#closure-3.sentence-3'>.</a></div> <div id='closure-3.sentence-4' class='sentence'>The return type and function parameters of the
function call operator template are derived from the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> and
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> by replacing each occurrence of
<span class='texttt'>auto</span> in the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i><span class='textit'>s</span> of the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> with the name of the corresponding
invented <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><a class='hidden_link' href='#closure-3.sentence-4'>.</a></div> <div id='closure-3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto glambda = [](auto a, auto&amp;&amp; b) { return a &lt; b; };
bool b = glambda(3, 3.14);                             <span class='comment'>// OK
</span>
auto vglambda = [](auto printer) {
  return [=](auto&amp;&amp; ... ts) {                          <span class='comment'>// OK: <span class='tcode_in_codeblock'>ts</span> is a function parameter pack
</span>    printer(std::forward&lt;decltype(ts)&gt;(ts)...);

    return [=]() {
      printer(ts ...);
    };
  };
};
auto p = vglambda( [](auto v1, auto v2, auto v3)
                   { std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3; } );
auto q = p(1, 'a', 3.14);                              <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span>q();                                                   <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-4'><div class='marginalizedparent'><a class='marginalized' href='#closure-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L806'>#</a></div><div id='closure-4.sentence-1' class='sentence'>The function call operator or operator template is declared
<span class='texttt'>const</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>) if and only if the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is not
followed by <span class='texttt'>mutable</span><a class='hidden_link' href='#closure-4.sentence-1'>.</a></div> <div id='closure-4.sentence-2' class='sentence'>It is neither virtual nor declared <span class='texttt'>volatile</span><a class='hidden_link' href='#closure-4.sentence-2'>.</a></div> <div id='closure-4.sentence-3' class='sentence'>Any
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> specified on a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
applies to the corresponding function call operator or operator template<a class='hidden_link' href='#closure-4.sentence-3'>.</a></div> <div id='closure-4.sentence-4' class='sentence'>An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> appertains
to the type of the corresponding function call operator or operator template<a class='hidden_link' href='#closure-4.sentence-4'>.</a></div> <div id='closure-4.sentence-5' class='sentence'>The function call operator or any given operator template specialization
is a constexpr function if either
the corresponding <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is followed by <span class='texttt'>constexpr</span>, or
it satisfies the requirements for a <a href='dcl.constexpr'>constexpr</a> function<a class='hidden_link' href='#closure-4.sentence-5'>.</a></div> <div id='closure-4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#closure-4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='closure-4.sentence-6' class='sentence'>Names referenced in
the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> are looked up in the context in which the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appears<a class='hidden_link' href='#closure-4.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='closure-4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto ID = [](auto a) { return a; };
static_assert(ID(3) == 3); <span class='comment'>// OK
</span>
struct NonLiteral {
  NonLiteral(int n) : n(n) { }
  int n;
};
static_assert(ID(NonLiteral{3}).n == 3); <span class='comment'>// ill-formed
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-5'><div class='marginalizedparent'><a class='marginalized' href='#closure-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L836'>#</a></div><div id='closure-5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto monoid = [](auto v) { return [=] { return v; }; };
auto add = [](auto m1) constexpr {
  auto ret = m1();
  return [=](auto m2) mutable {
    auto m1val = m1();
    auto plus = [=](auto m2val) mutable constexpr
                   { return m1val += m2val; };
    ret = plus(m2());
    return monoid(ret);
  };
};
constexpr auto zero = monoid(0);
constexpr auto one = monoid(1);
static_assert(add(one)(zero)() == one()); <span class='comment'>// OK
</span>
<span class='comment'>// Since <span class='tcode_in_codeblock'>two</span> below is not declared <span class='tcode_in_codeblock'>constexpr</span>, an evaluation of its <span class='tcode_in_codeblock'>constexpr</span> member function call operator
</span><span class='comment'>// cannot perform an lvalue-to-rvalue conversion on one of its subobjects (that represents its capture)
</span><span class='comment'>// in a constant expression.
</span>auto two = monoid(2);
assert(two() == 2); <span class='comment'>// OK, not a constant expression.
</span>static_assert(add(one)(one)() == two()); <span class='comment'>// ill-formed: <span class='tcode_in_codeblock'>two()</span> is not a constant expression
</span>static_assert(add(one)(one)() == monoid(2)()); <span class='comment'>// OK
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-6'><div class='marginalizedparent'><a class='marginalized' href='#closure-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L864'>#</a></div><div id='closure-6.sentence-1' class='sentence'>The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> with no
<i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>
has a conversion function to pointer to
function with C++ language <a href='dcl.link'>linkage</a> having
the same parameter and return types as the closure type's function call operator<a class='hidden_link' href='#closure-6.sentence-1'>.</a></div> <div id='closure-6.sentence-2' class='sentence'>The conversion is to “pointer to <span class='texttt'>noexcept</span> function”
if the function call operator
has a non-throwing exception specification<a class='hidden_link' href='#closure-6.sentence-2'>.</a></div> <div id='closure-6.sentence-3' class='sentence'>The value returned by this conversion function
is the address of a function <span class='texttt'>F</span> that, when invoked,
has the same effect as invoking the closure type's function call operator<a class='hidden_link' href='#closure-6.sentence-3'>.</a></div> <div id='closure-6.sentence-4' class='sentence'><span class='texttt'>F</span> is a constexpr function
if the function call operator is a constexpr function<a class='hidden_link' href='#closure-6.sentence-4'>.</a></div> <div id='closure-6.sentence-5' class='sentence'>For a generic lambda with no <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>, the closure type has a
conversion function template to
pointer to function<a class='hidden_link' href='#closure-6.sentence-5'>.</a></div> <div id='closure-6.sentence-6' class='sentence'>The conversion function template has the same invented
template parameter list, and the pointer to function has the same
parameter types, as the function call operator template<a class='hidden_link' href='#closure-6.sentence-6'>.</a></div> <div id='closure-6.sentence-7' class='sentence'>The return type of
the pointer to function shall behave as if it were a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> denoting the return type of the corresponding
function call operator template specialization<a class='hidden_link' href='#closure-6.sentence-7'>.</a></div></div><div class='para' id='closure-7'><div class='marginalizedparent'><a class='marginalized' href='#closure-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L887'>#</a></div><div id='closure-7.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#closure-7.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='closure-7.sentence-1' class='sentence'>If the generic lambda has no <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> or
the <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> contains a placeholder type, return type
deduction of the corresponding function call operator template specialization
has to be done<a class='hidden_link' href='#closure-7.sentence-1'>.</a></div> <div id='closure-7.sentence-2' class='sentence'>The corresponding specialization is that instantiation of the
function call operator template with the same template arguments as those
deduced for the conversion function template<a class='hidden_link' href='#closure-7.sentence-2'>.</a></div> <div id='closure-7.sentence-3' class='sentence'>Consider the following:
<pre class='codeblock'>
auto glambda = [](auto a) { return a; };
int (*fp)(int) = glambda;</pre>
The behavior of the conversion function of <span class='texttt'>glambda</span> above is like
that of the following conversion function:
<pre class='codeblock'>
struct Closure {
  template&lt;class T&gt; auto operator()(T t) const { ... }
  template&lt;class T&gt; static auto lambda_call_operator_invoker(T a) {
    <span class='comment'>// forwards execution to <span class='tcode_in_codeblock'>operator()(a)</span> and therefore has
</span>    <span class='comment'>// the same return type deduced
</span>    ...
  }
  template&lt;class T&gt; using fptr_t =
     decltype(lambda_call_operator_invoker(declval&lt;T&gt;())) (*)(T);

  template&lt;class T&gt; operator fptr_t&lt;T&gt;() const
    { return &amp;lambda_call_operator_invoker; }
};</pre></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> <div id='closure-7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f1(int (*)(int))   { }
void f2(char (*)(int))  { }

void g(int (*)(int))    { }  <span class='comment'>// #1
</span>void g(char (*)(char))  { }  <span class='comment'>// #2
</span>
void h(int (*)(int))    { }  <span class='comment'>// #3
</span>void h(char (*)(int))   { }  <span class='comment'>// #4
</span>
auto glambda = [](auto a) { return a; };
f1(glambda);  <span class='comment'>// OK
</span>f2(glambda);  <span class='comment'>// error: ID is not convertible
</span>g(glambda);   <span class='comment'>// error: ambiguous
</span>h(glambda);   <span class='comment'>// OK: calls #3 since it is convertible from ID
</span>int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; <span class='comment'>// OK
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-8'><div class='marginalizedparent'><a class='marginalized' href='#closure-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L938'>#</a></div><div id='closure-8.sentence-1' class='sentence'>The value returned by any given specialization of this conversion function
template is the address of a function <span class='texttt'>F</span> that, when invoked, has the same
effect as invoking the generic lambda's corresponding function call operator
template specialization<a class='hidden_link' href='#closure-8.sentence-1'>.</a></div> <div id='closure-8.sentence-2' class='sentence'><span class='texttt'>F</span> is a constexpr function
if the corresponding specialization is a constexpr function<a class='hidden_link' href='#closure-8.sentence-2'>.</a></div> <div id='closure-8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#closure-8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='closure-8.sentence-3' class='sentence'>This will result in the implicit instantiation of the generic lambda's body<a class='hidden_link' href='#closure-8.sentence-3'>.</a></div> <div id='closure-8.sentence-4' class='sentence'>The instantiated generic lambda's return type and parameter types shall match
the return type and parameter types of the pointer to function<a class='hidden_link' href='#closure-8.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='closure-8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto GL = [](auto a) { std::cout &lt;&lt; a; return a; };
int (*GL_int)(int) = GL;  <span class='comment'>// OK: through conversion function template
</span>GL_int(3);                <span class='comment'>// OK: same as <span class='tcode_in_codeblock'>GL(3)</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-9'><div class='marginalizedparent'><a class='marginalized' href='#closure-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L958'>#</a></div><div id='closure-9.sentence-1' class='sentence'>The conversion function or conversion function template is public,
constexpr, non-virtual, non-explicit, const, and has a non-throwing <a href='except.spec'>exception
specification</a><a class='hidden_link' href='#closure-9.sentence-1'>.</a></div> <div id='closure-9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto Fwd = [](int (*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };

static_assert(Fwd(C,3) == 3); <span class='comment'>// OK
</span>
<span class='comment'>// No specialization of the function call operator template can be constexpr (due to the local static).
</span>auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC,3) == 3); <span class='comment'>// ill-formed
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-10'><div class='marginalizedparent'><a class='marginalized' href='#closure-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L975'>#</a></div><div id='closure-10.sentence-1' class='sentence'>The <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> yields the
<i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>) of the function call operator, but for
purposes of <a href='basic.lookup'>name lookup</a>, determining the type and value of
<a href='class.this'><span class='texttt'>this</span></a> and transforming <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i><span class='textit'>s</span>
referring to non-static class members into class member access expressions using
<span class='texttt'>(*this)</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>), the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> is
considered in the context of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#closure-10.sentence-1'>.</a></div> <div id='closure-10.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#closure-10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct S1 {
  int x, y;
  int operator()(int);
  void f() {
    [=]()-&gt;int {
      return operator()(this-&gt;x + y); <span class='comment'>// equivalent to <span class='tcode_in_codeblock'>S1&#x200b;::&#x200b;operator()(this-&gt;x + (*this).y)</span>
</span>                                      <span class='comment'>// <span class='tcode_in_codeblock'>this</span> has type <span class='tcode_in_codeblock'>S1*</span>
</span>    };
  }
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='closure-10.sentence-2' class='sentence'>
Further, a variable <span class='texttt'>_&shy;_&shy;func_&shy;_&shy;</span> is implicitly defined at the beginning of
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>,
with semantics as described in <a href='dcl.fct.def.general'>[dcl.fct.def.general]</a><a class='hidden_link' href='#closure-10.sentence-2'>.</a></div></div><div class='para' id='closure-11'><div class='marginalizedparent'><a class='marginalized' href='#closure-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1001'>#</a></div><div id='closure-11.sentence-1' class='sentence'>The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has no
default constructor and a deleted copy assignment operator<a class='hidden_link' href='#closure-11.sentence-1'>.</a></div> <div id='closure-11.sentence-2' class='sentence'>It has a
defaulted copy constructor and a defaulted move constructor (<a href='class.copy'>[class.copy]</a>)<a class='hidden_link' href='#closure-11.sentence-2'>.</a></div> <div id='closure-11.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#closure-11.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='closure-11.sentence-3' class='sentence'>These special member functions are implicitly defined as
usual, and might therefore be defined as deleted<a class='hidden_link' href='#closure-11.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='closure-12'><div class='marginalizedparent'><a class='marginalized' href='#closure-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1008'>#</a></div><div id='closure-12.sentence-1' class='sentence'>The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has an
implicitly-declared destructor (<a href='class.dtor'>[class.dtor]</a>)<a class='hidden_link' href='#closure-12.sentence-1'>.</a></div></div><div class='para' id='closure-13'><div class='marginalizedparent'><a class='marginalized' href='#closure-13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1012'>#</a></div><div id='closure-13.sentence-1' class='sentence'>A member of a closure type shall not be
explicitly instantiated (<a href='temp.explicit'>[temp.explicit]</a>),
explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>), or
named in a <span class='texttt'>friend</span> declaration (<a href='class.friend'>[class.friend]</a>)<a class='hidden_link' href='#closure-13.sentence-1'>.</a></div></div></div><div id='capture' class='section'><h4 ><a class='secnum' href='#capture' style='min-width:118pt'>8.1.5.2</a> Captures <a class='abbr_ref' href='expr.prim.lambda.capture'>[expr.prim.lambda.capture]</a></h4><pre class='bnf'><a class='nontermdef' id='nt:lambda-capture'>lambda-capture:</a>
&#9;<i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i>
&#9;<i ><a href='expr.prim.lambda.capture#nt:capture-list'>capture-list</a></i>
&#9;<i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> <span class='terminal'>,</span> <i ><a href='expr.prim.lambda.capture#nt:capture-list'>capture-list</a></i>
</pre><pre class='bnf'><a class='nontermdef' id='nt:capture-default'>capture-default:</a>
&#9;<span class='terminal'>&amp;</span>
&#9;<span class='terminal'>=</span>
</pre><pre class='bnf'><a class='nontermdef' id='nt:capture-list'>capture-list:</a>
&#9;<i ><a href='expr.prim.lambda.capture#nt:capture'>capture</a></i> <span class='terminal'>...</span><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
&#9;<i ><a href='expr.prim.lambda.capture#nt:capture-list'>capture-list</a></i> <span class='terminal'>,</span> <i ><a href='expr.prim.lambda.capture#nt:capture'>capture</a></i> <span class='terminal'>...</span><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
</pre><pre class='bnf'><a class='nontermdef' id='nt:capture'>capture:</a>
&#9;<i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i>
&#9;<i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i>
</pre><pre class='bnf'><a class='nontermdef' id='nt:simple-capture'>simple-capture:</a>
&#9;<i ><a href='lex.name#nt:identifier'>identifier</a></i>
&#9;<span class='terminal'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
&#9;<span class='terminal'>this</span>
&#9;<span class='terminal'>* this</span>
</pre><pre class='bnf'><a class='nontermdef' id='nt:init-capture'>init-capture:</a>
&#9;<i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.init#nt:initializer'>initializer</a></i>
&#9;<span class='terminal'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.init#nt:initializer'>initializer</a></i>
</pre><div class='para' id='capture-1'><div class='marginalizedparent'><a class='marginalized' href='#capture-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1059'>#</a></div><div id='capture-1.sentence-1' class='sentence'>The body of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> may refer to variables
with automatic storage duration and the <span class='texttt'>*this</span> object (if any)
of enclosing block scopes by capturing those entities, as described
below<a class='hidden_link' href='#capture-1.sentence-1'>.</a></div></div><div class='para' id='capture-2'><div class='marginalizedparent'><a class='marginalized' href='#capture-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1065'>#</a></div><div id='capture-2.sentence-1' class='sentence'>If a <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i> includes a <i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> that
is <span class='texttt'>&amp;</span>, no identifier in a <i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> of that
<i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i> shall be preceded
by <span class='texttt'>&amp;</span><a class='hidden_link' href='#capture-2.sentence-1'>.</a></div> <div id='capture-2.sentence-2' class='sentence'>If a <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i> includes a
<i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> that is <span class='texttt'>=</span>, each
<i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> of that <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i> shall
be of the form
“<span class='texttt'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>”,
“<span class='texttt'>this</span>”,
or “<span class='texttt'>* this</span>”<a class='hidden_link' href='#capture-2.sentence-2'>.</a></div> <div id='capture-2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-2.sentence-4' class='sentence'>The form <span class='texttt'>[&amp;,this]</span> is redundant but accepted
for compatibility with ISO C++ 2014<a class='hidden_link' href='#capture-2.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-2.sentence-3' class='sentence'>
Ignoring appearances in
<i ><a href='dcl.init#nt:initializer'>initializer</a></i><span class='textit'>s</span> of <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i><span class='textit'>s</span>, an identifier or
<span class='texttt'>this</span> shall not appear more than once in a
<i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i><a class='hidden_link' href='#capture-2.sentence-3'>.</a></div> <div id='capture-2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct S2 { void f(int i); };
void S2::f(int i) {
  [&amp;, i]{ };        <span class='comment'>// OK
</span>  [&amp;, this, i]{ };  <span class='comment'>// OK, equivalent to <span class='tcode_in_codeblock'>[&amp;, i]</span>
</span>  [&amp;, &amp;i]{ };       <span class='comment'>// error: <span class='tcode_in_codeblock'>i</span> preceded by <span class='tcode_in_codeblock'>&amp;</span> when <span class='tcode_in_codeblock'>&amp;</span> is the default
</span>  [=, *this]{ };    <span class='comment'>// OK
</span>  [=, this]{ };     <span class='comment'>// OK, equivalent to <span class='tcode_in_codeblock'>[=]</span>
</span>  [i, i]{ };        <span class='comment'>// error: <span class='tcode_in_codeblock'>i</span> repeated
</span>  [this, *this]{ }; <span class='comment'>// error: <span class='tcode_in_codeblock'>this</span> appears twice
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-3'><div class='marginalizedparent'><a class='marginalized' href='#capture-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1097'>#</a></div><div id='capture-3.sentence-1' class='sentence'>A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> whose smallest enclosing scope is a <a href='basic.scope.block'>block
scope</a> is a <a class='hidden_link' href='#def:local_lambda_expression' id='def:local_lambda_expression'><i >local lambda expression</i></a>; any other
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> shall not have a <i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> or
<i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> in its
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i><a class='hidden_link' href='#capture-3.sentence-1'>.</a></div> <div id='capture-3.sentence-2' class='sentence'>The <a class='hidden_link' href='#def:reaching_scope' id='def:reaching_scope'><i >reaching scope</i></a> of a local lambda expression
is the set of enclosing scopes up to and including the innermost enclosing function and
its parameters<a class='hidden_link' href='#capture-3.sentence-2'>.</a></div> <div id='capture-3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-3.sentence-3' class='sentence'>This reaching scope includes any intervening
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><span class='textit'>s</span><a class='hidden_link' href='#capture-3.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-4'><div class='marginalizedparent'><a class='marginalized' href='#capture-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1107'>#</a></div><div id='capture-4.sentence-1' class='sentence'>The <i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> is looked up using the
usual rules for <a href='basic.lookup.unqual'>unqualified name lookup</a>; each such lookup
shall find an entity<a class='hidden_link' href='#capture-4.sentence-1'>.</a></div> <div id='capture-4.sentence-2' class='sentence'>An entity that is designated by a
<i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i>
is said to be <a class='hidden_link' href='#def:explicitly_captured' id='def:explicitly_captured'><i >explicitly captured</i></a>, and shall be <span class='texttt'>*this</span>
(when the <i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i>
is “<span class='texttt'>this</span>” or “<span class='texttt'>* this</span>”) or
a variable with automatic storage duration declared in
the reaching scope of the local lambda expression<a class='hidden_link' href='#capture-4.sentence-2'>.</a></div></div><div class='para' id='capture-5'><div class='marginalizedparent'><a class='marginalized' href='#capture-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1118'>#</a></div><div id='capture-5.sentence-1' class='sentence'>If an <i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> appears
as the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of a parameter of
the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>'s <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>,
the program is ill-formed<a class='hidden_link' href='#capture-5.sentence-1'>.</a></div> <div id='capture-5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f() {
  int x = 0;
  auto g = [x](int x) { return 0; }    <span class='comment'>// error: parameter and <span class='grammarterm'>simple-capture</span> have the same name
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-6'><div class='marginalizedparent'><a class='marginalized' href='#capture-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1132'>#</a></div><div id='capture-6.sentence-1' class='sentence'>An <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i> behaves as if it declares and explicitly captures a
variable of
the form “<span class='texttt'>auto</span> <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i> <span class='texttt'>;</span>”
whose declarative region is the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>, except that:
<ul class='itemize'><li id='capture-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-6.1'>(6.1)</a></div><div id='capture-6.1.sentence-1' class='sentence'>if the capture is by copy (see below), the non-static data member
declared for the capture and the variable are treated as two different ways
of referring to the same object, which has the lifetime of the non-static
data member, and no additional copy and destruction is performed, and</div></li><li id='capture-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-6.2'>(6.2)</a></div><div id='capture-6.2.sentence-1' class='sentence'>if the capture is by reference, the variable's lifetime ends when the
closure object's lifetime ends<a class='hidden_link' href='#capture-6.2.sentence-1'>.</a></div></li></ul></div> <div id='capture-6.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-6.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-6.sentence-2' class='sentence'>This enables an <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i> like
“<span class='texttt'>x = std&#x200b;::&#x200b;move(x)</span>”; the second “<span class='texttt'>x</span>” must bind to a
declaration in the surrounding context<a class='hidden_link' href='#capture-6.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
int x = 4;
auto y = [&amp;r = x, x = x+1]()-&gt;int {
            r += 2;
            return x+2;
         }();  <span class='comment'>// Updates <span class='tcode_in_codeblock'>&#x200b;::&#x200b;x</span> to 6, and initializes <span class='tcode_in_codeblock'>y</span> to 7.
</span>
auto z = [a = 42](int a) { return 1; } <span class='comment'>// error: parameter and local variable have the same name
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-7'><div class='marginalizedparent'><a class='marginalized' href='#capture-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1163'>#</a></div><div id='capture-7.sentence-1' class='sentence'>A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> with an associated
<i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> that does not explicitly capture <span class='texttt'>*this</span> or
a variable with automatic storage duration (this excludes any <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that has been found to refer to an <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i>'s associated
<span class='indexparent'><a class='index' id=':implicit_capture,definition_of'></a></span>non-static data member), is said to <a class='hidden_link' href='#def:capture,implicit' id='def:capture,implicit'><i >implicitly capture</i></a>
the entity (i.e.,
<span class='texttt'>*this</span> or a variable) if the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>:
<ul class='itemize'><li id='capture-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-7.1'>(7.1)</a></div><div id='capture-7.1.sentence-1' class='sentence'><a href='basic.def.odr'>odr-uses</a> the entity (in the case of a variable),</div></li><li id='capture-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-7.2'>(7.2)</a></div><div id='capture-7.2.sentence-1' class='sentence'><a href='basic.def.odr'>odr-uses</a> <span class='texttt'>this</span>
(in the case of the object designated by <span class='texttt'>*this</span>), or</div></li><li id='capture-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-7.3'>(7.3)</a></div><div id='capture-7.3.sentence-1' class='sentence'>names the entity in a <a href='basic.def.odr#def:potentially_evaluated'>potentially evaluated</a>
expression where the enclosing full-expression depends on
a generic lambda parameter declared within the reaching scope of the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#capture-7.3.sentence-1'>.</a></div></li></ul></div> <div id='capture-7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f(int, const int (&amp;)[2] = {})    { }   <span class='comment'>// #1
</span>void f(const int&amp;, const int (&amp;)[1])  { }   <span class='comment'>// #2
</span>void test() {
  const int x = 17;
  auto g = [](auto a) {
    f(x);                       <span class='comment'>// OK: calls #1, does not capture <span class='tcode_in_codeblock'>x</span>
</span>  };

  auto g2 = [=](auto a) {
    int selector[sizeof(a) == 1 ? 1 : 2]{};
    f(x, selector);             <span class='comment'>// OK: is a dependent expression, so captures <span class='tcode_in_codeblock'>x</span>
</span>  };
}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-7.sentence-2' class='sentence'>
All such implicitly captured
entities shall be declared within the reaching scope of the lambda expression<a class='hidden_link' href='#capture-7.sentence-2'>.</a></div> <div id='capture-7.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-7.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-7.sentence-3' class='sentence'>The implicit capture of an entity by a nested
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> can cause its implicit capture by the containing
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (see below)<a class='hidden_link' href='#capture-7.sentence-3'>.</a></div> <div id='capture-7.sentence-4' class='sentence'>Implicit odr-uses of <span class='texttt'>this</span> can result
in implicit capture<a class='hidden_link' href='#capture-7.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-8'><div class='marginalizedparent'><a class='marginalized' href='#capture-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1205'>#</a></div><div id='capture-8.sentence-1' class='sentence'>An entity is <a class='hidden_link' href='#def:captured' id='def:captured'><i >captured</i></a> if it is captured explicitly or implicitly<a class='hidden_link' href='#capture-8.sentence-1'>.</a></div> <div id='capture-8.sentence-2' class='sentence'>An entity
captured by a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> is <a href='basic.def.odr'>odr-used</a> in the scope
containing the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#capture-8.sentence-2'>.</a></div> <div id='capture-8.sentence-3' class='sentence'>If <span class='texttt'>*this</span> is captured by a local
lambda expression, its nearest enclosing function shall be a non-static member function<a class='hidden_link' href='#capture-8.sentence-3'>.</a></div> <div id='capture-8.sentence-4' class='sentence'>If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> or an instantiation of the function call
operator template of a generic lambda <a href='basic.def.odr'>odr-uses</a> <span class='texttt'>this</span> or a variable with automatic storage duration from its reaching scope, that
entity shall be captured by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#capture-8.sentence-4'>.</a></div> <div id='capture-8.sentence-5' class='sentence'>If a
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> captures an entity and that entity is not defined or
captured in the immediately enclosing lambda expression or function, the program is
ill-formed<a class='hidden_link' href='#capture-8.sentence-5'>.</a></div> <div id='capture-8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <span class='indexparent'><a class='index' id=':Bond,James_Bond'></a></span><pre class='codeblock'>
void f1(int i) {
  int const N = 20;
  auto m1 = [=]{
    int const M = 30;
    auto m2 = [i]{
      int x[N][M];          <span class='comment'>// OK: <span class='tcode_in_codeblock'>N</span> and <span class='tcode_in_codeblock'>M</span> are not odr-used
</span>      x[0][0] = i;          <span class='comment'>// OK: <span class='tcode_in_codeblock'>i</span> is explicitly captured by <span class='tcode_in_codeblock'>m2</span> and implicitly captured by <span class='tcode_in_codeblock'>m1</span>
</span>    };
  };
  struct s1 {
    int f;
    void work(int n) {
      int m = n*n;
      int j = 40;
      auto m3 = [this,m] {
        auto m4 = [&amp;,j] {   <span class='comment'>// error: <span class='tcode_in_codeblock'>j</span> not captured by <span class='tcode_in_codeblock'>m3</span>
</span>          int x = n;        <span class='comment'>// error: <span class='tcode_in_codeblock'>n</span> implicitly captured by <span class='tcode_in_codeblock'>m4</span> but not captured by <span class='tcode_in_codeblock'>m3</span>
</span>          x += m;           <span class='comment'>// OK: <span class='tcode_in_codeblock'>m</span> implicitly captured by <span class='tcode_in_codeblock'>m4</span> and explicitly captured by <span class='tcode_in_codeblock'>m3</span>
</span>          x += i;           <span class='comment'>// error: <span class='tcode_in_codeblock'>i</span> is outside of the reaching scope
</span>          x += f;           <span class='comment'>// OK: <span class='tcode_in_codeblock'>this</span> captured implicitly by <span class='tcode_in_codeblock'>m4</span> and explicitly by <span class='tcode_in_codeblock'>m3</span>
</span>        };
      };
    }
  };
}

struct s2 {
  double ohseven = .007;
  auto f() {
    return [this] {
      return [*this] {
          return ohseven;   <span class='comment'>// OK
</span>      }
    }();
  }
  auto g() {
    return [] {
      return [*this] { };   <span class='comment'>// error: <span class='tcode_in_codeblock'>*this</span> not captured by outer <span class='grammarterm'>lambda-expression</span>
</span>    }();
  }
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-9'><div class='marginalizedparent'><a class='marginalized' href='#capture-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1263'>#</a></div><div id='capture-9.sentence-1' class='sentence'>A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appearing in a default argument shall not
implicitly or explicitly capture any entity<a class='hidden_link' href='#capture-9.sentence-1'>.</a></div> <div id='capture-9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f2() {
  int i = 1;
  void g1(int = ([i]{ return i; })());          <span class='comment'>// ill-formed
</span>  void g2(int = ([i]{ return 0; })());          <span class='comment'>// ill-formed
</span>  void g3(int = ([=]{ return i; })());          <span class='comment'>// ill-formed
</span>  void g4(int = ([=]{ return 0; })());          <span class='comment'>// OK
</span>  void g5(int = ([]{ return sizeof i; })());    <span class='comment'>// OK
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-10'><div class='marginalizedparent'><a class='marginalized' href='#capture-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1279'>#</a></div><div id='capture-10.sentence-1' class='sentence'>An entity is <a class='hidden_link' href='#def:captured,by_copy' id='def:captured,by_copy'><i >captured by copy</i></a> if
<ul class='itemize'><li id='capture-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-10.1'>(10.1)</a></div><div id='capture-10.1.sentence-1' class='sentence'>it is implicitly captured,
the <i ><a href='expr.prim.lambda.capture#nt:capture-default'>capture-default</a></i> is <span class='texttt'>=</span>, and
the captured entity is not <span class='texttt'>*this</span>, or</div></li><li id='capture-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-10.2'>(10.2)</a></div><div id='capture-10.2.sentence-1' class='sentence'>it is explicitly captured with a capture that is not of the form
<span class='texttt'>this</span>,
<span class='texttt'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>, or
<span class='texttt'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='dcl.init#nt:initializer'>initializer</a></i><a class='hidden_link' href='#capture-10.2.sentence-1'>.</a></div></li></ul></div> <div id='capture-10.sentence-2' class='sentence'>
For each entity captured by copy, an
unnamed non-static data member is declared in the closure type<a class='hidden_link' href='#capture-10.sentence-2'>.</a></div> <div id='capture-10.sentence-3' class='sentence'>The declaration order of
these members is unspecified<a class='hidden_link' href='#capture-10.sentence-3'>.</a></div> <div id='capture-10.sentence-4' class='sentence'>The type of such a data member is
the referenced type if the entity is a reference to an object,
an lvalue reference to the referenced function type if the entity is a reference to a function, or
the type of the corresponding captured entity otherwise<a class='hidden_link' href='#capture-10.sentence-4'>.</a></div> <div id='capture-10.sentence-5' class='sentence'>A member of an anonymous union shall not be captured by copy<a class='hidden_link' href='#capture-10.sentence-5'>.</a></div></div><div class='para' id='capture-11'><div class='marginalizedparent'><a class='marginalized' href='#capture-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1300'>#</a></div><div id='capture-11.sentence-1' class='sentence'>Every <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> within the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of a
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> that is an <a href='basic.def.odr'>odr-use</a> of an
entity captured by copy is transformed into an access to the corresponding unnamed data
member of the closure type<a class='hidden_link' href='#capture-11.sentence-1'>.</a></div> <div id='capture-11.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-11.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-11.sentence-4' class='sentence'>An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> that is not an odr-use refers to
the original entity, never to a member of the closure type<a class='hidden_link' href='#capture-11.sentence-4'>.</a></div> <div id='capture-11.sentence-5' class='sentence'>Furthermore, such
an <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> does not cause the implicit capture of the
entity<a class='hidden_link' href='#capture-11.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-11.sentence-2' class='sentence'>
If <span class='texttt'>*this</span> is captured by copy, each odr-use of <span class='texttt'>this</span> is
transformed into a pointer to the corresponding unnamed data member of the closure type,
<a href='expr.cast'>cast</a> to the type of <span class='texttt'>this</span><a class='hidden_link' href='#capture-11.sentence-2'>.</a></div> <div id='capture-11.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-11.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-11.sentence-6' class='sentence'>The cast ensures that the
transformed expression is a prvalue<a class='hidden_link' href='#capture-11.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-11.sentence-3' class='sentence'>
An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> within
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
that is an odr-use of a reference captured by reference
refers to the entity to which the captured reference is bound and
not to the captured reference<a class='hidden_link' href='#capture-11.sentence-3'>.</a></div> <div id='capture-11.note-3' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-11.note-3'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-11.sentence-7' class='sentence'>The validity of such captures is determined by
the lifetime of the object to which the reference refers,
not by the lifetime of the reference itself<a class='hidden_link' href='#capture-11.sentence-7'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-11.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-11.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f(const int*);
void g() {
  const int N = 10;
  [=] {
    int arr[N];     <span class='comment'>// OK: not an odr-use, refers to automatic variable
</span>    f(&amp;N);          <span class='comment'>// OK: causes <span class='tcode_in_codeblock'>N</span> to be captured; <span class='tcode_in_codeblock'>&amp;N</span> points to
</span>                    <span class='comment'>// the corresponding member of the closure type
</span>  };
}
auto h(int &amp;r) {
  return [&amp;] {
    ++r;            <span class='comment'>// Valid after <span class='tcode_in_codeblock'>h</span> returns if the lifetime of the
</span>                    <span class='comment'>// object to which <span class='tcode_in_codeblock'>r</span> is bound has not ended
</span>  };
}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-12'><div class='marginalizedparent'><a class='marginalized' href='#capture-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1341'>#</a></div><div id='capture-12.sentence-1' class='sentence'>An entity is <a class='hidden_link' href='#def:captured,by_reference' id='def:captured,by_reference'><i >captured by reference</i></a> if it is implicitly or explicitly
captured but not captured by copy<a class='hidden_link' href='#capture-12.sentence-1'>.</a></div> <div id='capture-12.sentence-2' class='sentence'>It is unspecified whether additional unnamed
non-static data members are declared in the closure type for entities captured by
reference<a class='hidden_link' href='#capture-12.sentence-2'>.</a></div> <div id='capture-12.sentence-3' class='sentence'>If declared, such non-static data members shall be of literal type<a class='hidden_link' href='#capture-12.sentence-3'>.</a></div> <div id='capture-12.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-12.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='comment'>// The inner closure type must be a literal type regardless of how reference captures are represented.
</span>static_assert([](int n) { return [&amp;n] { return ++n; }(); }(3) == 4);</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='capture-12.sentence-4' class='sentence'>
A bit-field or a member of an anonymous union shall not be captured by reference<a class='hidden_link' href='#capture-12.sentence-4'>.</a></div></div><div class='para' id='capture-13'><div class='marginalizedparent'><a class='marginalized' href='#capture-13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1355'>#</a></div><div id='capture-13.sentence-1' class='sentence'>If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> <span class='texttt'>m2</span> captures an entity and that entity is
captured by an immediately enclosing <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
<span class='texttt'>m1</span>, then
<span class='texttt'>m2</span>'s capture is transformed as follows:</div><div id='capture-13.sentence-2' class='sentence'><ul class='itemize'><li id='capture-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-13.1'>(13.1)</a></div><div id='capture-13.1.sentence-1' class='sentence'>if <span class='texttt'>m1</span> captures the entity by copy,
<span class='texttt'>m2</span> captures the corresponding
non-static data member of <span class='texttt'>m1</span>'s closure type;</div></li><li id='capture-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#capture-13.2'>(13.2)</a></div><div id='capture-13.2.sentence-1' class='sentence'>if <span class='texttt'>m1</span> captures the entity by reference,
<span class='texttt'>m2</span> captures the same
entity captured by <span class='texttt'>m1</span><a class='hidden_link' href='#capture-13.2.sentence-1'>.</a></div></li></ul></div> <div id='capture-13.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-13.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='capture-13.sentence-3' class='sentence'>The nested lambda expressions and invocations below will output
<span class='texttt'>123234</span><a class='hidden_link' href='#capture-13.sentence-3'>.</a></div> <pre class='codeblock'>
int a = 1, b = 1, c = 1;
auto m1 = [a, &amp;b, &amp;c]() mutable {
  auto m2 = [a, b, &amp;c]() mutable {
    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
    a = 4; b = 4; c = 4;
  };
  a = 3; b = 3; c = 3;
  m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-14'><div class='marginalizedparent'><a class='marginalized' href='#capture-14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1388'>#</a></div><div id='capture-14.sentence-1' class='sentence'>Every occurrence of <span class='texttt'>decltype((x))</span> where <span class='texttt'>x</span> is a possibly
parenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> that names an entity of automatic storage
duration is treated as if <span class='texttt'>x</span> were transformed into an access to a corresponding
data member of the closure type that would have been declared if <span class='texttt'>x</span> were an odr-use of
the denoted entity<a class='hidden_link' href='#capture-14.sentence-1'>.</a></div> <div id='capture-14.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-14.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f3() {
  float x, &amp;r = x;
  [=] {                     <span class='comment'>// <span class='tcode_in_codeblock'>x</span> and <span class='tcode_in_codeblock'>r</span> are not captured (appearance in a <span class='tcode_in_codeblock'>decltype</span> operand is not an odr-use)
</span>    decltype(x) y1;         <span class='comment'>// <span class='tcode_in_codeblock'>y1</span> has type <span class='tcode_in_codeblock'>float</span>
</span>    decltype((x)) y2 = y1;  <span class='comment'>// <span class='tcode_in_codeblock'>y2</span> has type <span class='tcode_in_codeblock'>float const&amp;</span> because this lambda is not <span class='tcode_in_codeblock'>mutable</span> and <span class='tcode_in_codeblock'>x</span> is an lvalue
</span>    decltype(r) r1 = y1;    <span class='comment'>// <span class='tcode_in_codeblock'>r1</span> has type <span class='tcode_in_codeblock'>float&amp;</span> (transformation not considered)
</span>    decltype((r)) r2 = y2;  <span class='comment'>// <span class='tcode_in_codeblock'>r2</span> has type <span class='tcode_in_codeblock'>float const&amp;</span>
</span>  };
}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-15'><div class='marginalizedparent'><a class='marginalized' href='#capture-15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1408'>#</a></div><div id='capture-15.sentence-1' class='sentence'>When the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> is evaluated, the entities that are
captured by copy are used to direct-initialize each corresponding non-static data member
of the resulting closure object, and the non-static data members corresponding to the
<i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i><span class='textit'>s</span> are initialized as indicated by the corresponding
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> (which may be copy- or direct-initialization)<a class='hidden_link' href='#capture-15.sentence-1'>.</a></div> <div id='capture-15.sentence-2' class='sentence'>(For array members, the array elements are
direct-initialized in increasing subscript order<a class='hidden_link' href='#capture-15.sentence-2'>.</a>)</div> <div id='capture-15.sentence-3' class='sentence'>These initializations are performed
in the (unspecified) order in which the non-static data members are declared<a class='hidden_link' href='#capture-15.sentence-3'>.</a></div> <div id='capture-15.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-15.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-15.sentence-4' class='sentence'>This ensures that the destructions will occur in the reverse order of the constructions<a class='hidden_link' href='#capture-15.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-16'><div class='marginalizedparent'><a class='marginalized' href='#capture-16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1419'>#</a></div><div id='capture-16.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#capture-16.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='capture-16.sentence-1' class='sentence'>If a non-reference entity is implicitly or explicitly captured by reference,
invoking the function call operator of the corresponding <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
after the lifetime of the entity has ended is likely to result in undefined behavior<a class='hidden_link' href='#capture-16.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='capture-17'><div class='marginalizedparent'><a class='marginalized' href='#capture-17'>17</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/a8b3d85744b0ee0bdaf100ded65ee1a76babe6ae/source/expressions.tex#L1425'>#</a></div><div id='capture-17.sentence-1' class='sentence'>A <i ><a href='expr.prim.lambda.capture#nt:simple-capture'>simple-capture</a></i> followed by an ellipsis is a <a href='temp.variadic#def:pack_expansion'>pack expansion</a><a class='hidden_link' href='#capture-17.sentence-1'>.</a></div> <div id='capture-17.sentence-2' class='sentence'>An <i ><a href='expr.prim.lambda.capture#nt:init-capture'>init-capture</a></i> followed by an
ellipsis is ill-formed<a class='hidden_link' href='#capture-17.sentence-2'>.</a></div> <div id='capture-17.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#capture-17.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class... Args&gt;
void f(Args... args) {
  auto lm = [&amp;, args...] { return g(args...); };
  lm();
}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  </div></div></div></body></html>