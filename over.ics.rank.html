<!DOCTYPE html><html lang='en'><head><title>[over.ics.rank]</title><meta charset='UTF-8'><link rel='stylesheet' type='text/css' href='14882.css'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Serif'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans'><link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css2?family=Noto+Sans+Mono'><link rel='icon' href='icon.png'><link rel='stylesheet' type='text/css' href='expanded.css' title='Normal'><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'><link rel='alternate stylesheet' type='text/css' href='normative-only.css' title='Notes and examples hidden'></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:50pt'>12</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:65pt'>12.2</a> Overload resolution <a class='abbr_ref' href='over.match#over.ics.rank'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:80pt'>12.2.4</a> Best viable function <a class='abbr_ref' href='over.match.best#over.ics.rank'>[over.match.best]</a></h3><h4 ><a class='secnum' style='min-width:95pt'>12.2.4.3</a> Ranking implicit conversion sequences <a class='abbr_ref'>[over.ics.rank]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9b8a5e51752efe9edd7a447e96ffab0f3313accc/source/overloading.tex#L2646'>#</a></div><div class='texpara'><div id='1.sentence-1' class='sentence'>This subclause defines a partial ordering of implicit conversion
sequences based on the relationships
<a class='hidden_link' href='#def:conversion_sequence,better' title='12.2.4.3&emsp;Ranking implicit conversion sequences&emsp;[over.ics.rank]'><span id='def:conversion_sequence,better'><i >better conversion sequence</i></span></a>
and
<a class='hidden_link' href='#def:conversion,better' title='12.2.4.3&emsp;Ranking implicit conversion sequences&emsp;[over.ics.rank]'><span id='def:conversion,better'><i >better conversion</i></span></a><a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>If an implicit conversion sequence S1 is
defined by these rules to be a better conversion sequence than
S2, then it is also the case that S2 is a
<a class='hidden_link' href='#def:conversion_sequence,worse' title='12.2.4.3&emsp;Ranking implicit conversion sequences&emsp;[over.ics.rank]'><span id='def:conversion_sequence,worse'><i >worse conversion sequence</i></span></a>
than S1<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>If conversion sequence S1 is neither better
than nor worse than conversion sequence S2, S1 and S2 are said to
be
<a class='hidden_link' href='#def:conversion_sequence,indistinguishable' title='12.2.4.3&emsp;Ranking implicit conversion sequences&emsp;[over.ics.rank]'><span id='def:conversion_sequence,indistinguishable'><i >indistinguishable conversion sequences</i></span></a><a class='hidden_link' href='#1.sentence-3'>.</a></div></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9b8a5e51752efe9edd7a447e96ffab0f3313accc/source/overloading.tex#L2662'>#</a></div><div class='texpara'><div id='2.sentence-1' class='sentence'>When comparing the basic forms of implicit conversion sequences
(as defined in <a href='over.best.ics' title='12.2.4.2&emsp;Implicit conversion sequences'>[over.<span class='shy'></span>best.<span class='shy'></span>ics]</a>)
<ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#2.1'>(2.1)</a></div>a <a href='over.ics.scs' title='12.2.4.2.2&emsp;Standard conversion sequences&emsp;[over.ics.scs]'>standard conversion sequence</a> is a better
conversion sequence than a user-defined conversion sequence
or an ellipsis conversion sequence, and</li><li id='2.2'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#2.2'>(2.2)</a></div>a <a href='over.ics.user' title='12.2.4.2.3&emsp;User-defined conversion sequences&emsp;[over.ics.user]'>user-defined conversion sequence</a> is a
better conversion sequence than an <a href='over.ics.ellipsis' title='12.2.4.2.4&emsp;Ellipsis conversion sequences&emsp;[over.ics.ellipsis]'>ellipsis conversion
sequence</a><a class='hidden_link' href='#2.sentence-1'>.</a></li></ul></div></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9b8a5e51752efe9edd7a447e96ffab0f3313accc/source/overloading.tex#L2676'>#</a></div><div class='texpara'><div id='3.sentence-1' class='sentence'>Two implicit conversion sequences of the same form are
indistinguishable conversion sequences unless one of the
following rules applies:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#3.1'>(3.1)</a></div><div class='texpara'><div id='3.1.sentence-1' class='sentence'>List-initialization sequence <span class='texttt'>L1</span> is a better conversion sequence than
list-initialization sequence <span class='texttt'>L2</span> if
<ul class='itemize'><li id='3.1.1'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.1.1'>(3.1.1)</a></div><span class='texttt'>L1</span> converts to <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>initializer_<span class='shy'></span>list<span class='anglebracket'>&lt;</span>X<span class='anglebracket'>&gt;</span></span> for some <span class='texttt'>X</span> and
<span class='texttt'>L2</span> does not, or, if not that,</li><li id='3.1.2'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.1.2'>(3.1.2)</a></div><span class='texttt'>L1</span> and <span class='texttt'>L2</span> convert to arrays of the same element type, and
either the number of elements <span class='math'><span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span></span></span></span></span> initialized by <span class='texttt'>L1</span>
is less than the number of elements <span class='math'><span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">2</span></span></span></span></span></span></span></span> initialized by <span class='texttt'>L2</span>, or
<span class='math'><span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">1</span></span></span></span><span class="mjx-mo MJXc-space3"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.077em; padding-bottom: 0.298em;">=</span></span><span class="mjx-msubsup MJXc-space3"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">n</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.372em;">2</span></span></span></span></span></span></span></span> and
<span class='texttt'>L2</span> converts to an array of unknown bound and <span class='texttt'>L1</span> does not,</li></ul>
even if one of the other rules in this paragraph would otherwise apply<a class='hidden_link' href='#3.1.sentence-1'>.</a></div> <div id='example-1' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-1'>1</a></i>:&ensp;<span class='codeblock'><span class='keyword'>void</span> f1<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;                                   <span class='comment'>// #1</span>
<span class='keyword'>void</span> f1<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span><span class='keyword'>long</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;           <span class='comment'>// #2</span>
<span class='keyword'>void</span> g1<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span> f1<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>42</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>                         <span class='comment'>// chooses #2</span>

<span class='keyword'>void</span> f2<span class='parenthesis'>(</span>std<span class='operator'>::</span>pair<span class='anglebracket'>&lt;</span><span class='keyword'>const</span> <span class='keyword'>char</span><span class='operator'>*</span>, <span class='keyword'>const</span> <span class='keyword'>char</span><span class='operator'>*</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;   <span class='comment'>// #3</span>
<span class='keyword'>void</span> f2<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span>std<span class='operator'>::</span>string<span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;    <span class='comment'>// #4</span>
<span class='keyword'>void</span> g2<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span> f2<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>"foo"</span>,<span class='literal'>"bar"</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>                <span class='comment'>// chooses #4</span>
</span> —&nbsp;<i>end example</i>]</div></div> <div id='example-2' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-2'>2</a></i>:&ensp;<span class='codeblock'><span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span>    <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span> <span class='parenthesis'>)</span>;         <span class='comment'>// #1</span>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>double</span> <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span> <span class='parenthesis'>)</span>;         <span class='comment'>// #2</span>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span>    <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='literal'>2</span><span class='squarebracket'>]</span><span class='parenthesis'>)</span>;         <span class='comment'>// #3</span>

f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;           <span class='comment'>// Calls #1: Better than #2 due to conversion, better than #3 due to bounds</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;         <span class='comment'>// Calls #2: Identity conversion is better than floating-integral conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span>, <span class='literal'>2.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;    <span class='comment'>// Calls #2: Identity conversion is better than floating-integral conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1</span>, <span class='literal'>2</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// Calls #3: Converting to array of known bound is better than to unknown bound,</span>
                    <span class='comment'>// and an identity conversion is better than floating-integral conversion</span>
</span> —&nbsp;<i>end example</i>]</div></div></div></li><li id='3.2'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#3.2'>(3.2)</a></div><div class='texpara'><div id='3.2.sentence-1' class='sentence'>Standard conversion sequence
<span class='texttt'>S1</span>
is a better conversion
sequence than standard conversion sequence
<span class='texttt'>S2</span>
if
<ul class='itemize'><li id='3.2.1'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.1'>(3.2.1)</a></div><a class='index' id=':subsequence_rule,overloading'></a><span class='texttt'>S1</span>
is a proper subsequence of
<span class='texttt'>S2</span>
(comparing the conversion sequences in the canonical form defined
by <a href='over.ics.scs' title='12.2.4.2.2&emsp;Standard conversion sequences'>[over.<span class='shy'></span>ics.<span class='shy'></span>scs]</a>, excluding any Lvalue Transformation;
the identity conversion sequence is considered to be a
subsequence of any non-identity conversion sequence)
or, if not that,</li><li id='3.2.2'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.2'>(3.2.2)</a></div>the rank of
<span class='texttt'>S1</span>
is better than the rank of
<span class='texttt'>S2</span>,
or
<span class='texttt'>S1</span>
and
<span class='texttt'>S2</span>
have the same rank and are distinguishable by the rules
in the paragraph below,
or, if not that,</li><li id='3.2.3'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.3'>(3.2.3)</a></div><span class='texttt'>S1</span> and <span class='texttt'>S2</span> include reference bindings (<a href='dcl.init.ref' title='9.5.4&emsp;References'>[dcl.<span class='shy'></span>init.<span class='shy'></span>ref]</a>) and
neither refers to an implicit object parameter of a non-static member function
declared without a <a href='dcl.decl.general#nt:ref-qualifier' title='9.3.1&emsp;General&emsp;[dcl.decl.general]'><span id='ntref:ref-qualifier'><span class='textsf'><i >ref-qualifier</i></span></span></a>,
and <span class='texttt'>S1</span> binds an rvalue reference to an
rvalue and <span class='texttt'>S2</span> binds an lvalue reference
<div id='example-3' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-3'>3</a></i>:&ensp;<span class='codeblock'><span class='keyword'>int</span> i;
<span class='keyword'>int</span> f1<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span> f2<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> j <span class='operator'>=</span> g<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                   <span class='comment'>// calls <span class='tcode_in_codeblock'>g(const int&amp;)</span></span>
<span class='keyword'>int</span> k <span class='operator'>=</span> g<span class='parenthesis'>(</span>f1<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;                <span class='comment'>// calls <span class='tcode_in_codeblock'>g(const int&amp;&amp;)</span></span>
<span class='keyword'>int</span> l <span class='operator'>=</span> g<span class='parenthesis'>(</span>f2<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;                <span class='comment'>// calls <span class='tcode_in_codeblock'>g(const int&amp;&amp;)</span></span>

<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  A<span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span><span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
  <span class='keyword'>void</span> p<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>&amp;</span>;
  <span class='keyword'>void</span> p<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>&amp;</span><span class='operator'>&amp;</span>;
<span class='curlybracket'>}</span>;
A<span class='operator'>&amp;</span> <span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span><span class='parenthesis'>(</span>A<span class='operator'>&amp;</span><span class='operator'>&amp;</span>, <span class='keyword'>char</span><span class='parenthesis'>)</span>;
A<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span> <span class='literal'>1</span>;                       <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;<span id=':operator'><span class='tcode_in_codeblock'>operator</span></span>&lt;&lt;(int)</span></span>
A<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span> <span class='literal'>'c'</span>;                     <span class='comment'>// calls <span class='tcode_in_codeblock'><span id=':operator_'><span class='tcode_in_codeblock'>operator</span></span>&lt;&lt;(A&amp;&amp;, char)</span></span>
A a;
a <span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span> <span class='literal'>1</span>;                         <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;<span id=':operator__'><span class='tcode_in_codeblock'>operator</span></span>&lt;&lt;(int)</span></span>
a <span class='anglebracket'>&lt;</span><span class='anglebracket'>&lt;</span> <span class='literal'>'c'</span>;                       <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;<span id=':operator___'><span class='tcode_in_codeblock'>operator</span></span>&lt;&lt;(int)</span></span>
A<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='operator'>.</span>p<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;                        <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;p()&amp;&amp;</span></span>
a<span class='operator'>.</span>p<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;                          <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;p()&amp;</span></span>
</span> —&nbsp;<i>end example</i>]</div></div>
or, if not that,</li><li id='3.2.4'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.4'>(3.2.4)</a></div><span class='texttt'>S1</span> and <span class='texttt'>S2</span> include reference bindings (<a href='dcl.init.ref' title='9.5.4&emsp;References'>[dcl.<span class='shy'></span>init.<span class='shy'></span>ref]</a>) and
<span class='texttt'>S1</span> binds an lvalue reference to an lvalue of function type and
<span class='texttt'>S2</span> binds an rvalue reference to an lvalue of function type
<div id='example-4' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-4'>4</a></i>:&ensp;<span class='codeblock'><span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>void</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;               <span class='comment'>// #1</span>
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>void</span><span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='parenthesis'>)</span>;              <span class='comment'>// #2</span>
<span class='keyword'>void</span> g<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i1 <span class='operator'>=</span> f<span class='parenthesis'>(</span>g<span class='parenthesis'>)</span>;                  <span class='comment'>// calls #1</span>
</span> —&nbsp;<i>end example</i>]</div></div>
or, if not that,</li><li id='3.2.5'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.5'>(3.2.5)</a></div><span class='texttt'>S1</span> and <span class='texttt'>S2</span> differ only
in their qualification conversion (<a href='conv.qual' title='7.3.6&emsp;Qualification conversions'>[conv.<span class='shy'></span>qual]</a>) and
yield similar types <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively
(where a standard conversion sequence that is a reference binding
is considered to yield the cv-unqualified referenced type),
where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are not the same type, and
<span class='texttt'><span class='keyword'>const</span> T2</span> is reference-compatible with <span class='texttt'>T1</span> (<a href='dcl.init.ref' title='9.5.4&emsp;References'>[dcl.<span class='shy'></span>init.<span class='shy'></span>ref]</a>)
<div id='example-5' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-5'>5</a></i>:&ensp;<span class='codeblock'><span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>volatile</span> <span class='keyword'>int</span> <span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span> <span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i;
<span class='keyword'>int</span> j <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='operator'>&amp;</span>i<span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f(const int*)</span></span>
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span><span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>volatile</span> <span class='keyword'>int</span><span class='operator'>*</span> <span class='keyword'>const</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span><span class='operator'>*</span> p;
<span class='keyword'>int</span> k <span class='operator'>=</span> g<span class='parenthesis'>(</span>p<span class='parenthesis'>)</span>;                   <span class='comment'>// calls <span class='tcode_in_codeblock'>g(const int*)</span></span>
</span> —&nbsp;<i>end example</i>]</div></div>
or, if not that,</li><li id='3.2.6'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.6'>(3.2.6)</a></div><span class='texttt'>S1</span>
and
<span class='texttt'>S2</span>
bind “reference to <span class='texttt'>T1</span>” and “reference to <span class='texttt'>T2</span>”,
respectively (<a href='dcl.init.ref' title='9.5.4&emsp;References'>[dcl.<span class='shy'></span>init.<span class='shy'></span>ref]</a>),
where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are not the same type, and
<span class='texttt'>T2</span> is reference-compatible with <span class='texttt'>T1</span>
<div id='example-6' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-6'>6</a></i>:&ensp;<span class='codeblock'><span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>int</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> g<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;

<span class='keyword'>int</span> i;
<span class='keyword'>int</span> j <span class='operator'>=</span> f<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                   <span class='comment'>// calls <span class='tcode_in_codeblock'>f(int &amp;)</span></span>
<span class='keyword'>int</span> k <span class='operator'>=</span> g<span class='parenthesis'>(</span>i<span class='parenthesis'>)</span>;                   <span class='comment'>// ambiguous</span>

<span class='keyword'>struct</span> X <span class='curlybracket'>{</span>
  <span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='keyword'>const</span>;
  <span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>void</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> X<span class='operator'>&amp;</span> a, X b<span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  a<span class='operator'>.</span>f<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;                        <span class='comment'>// calls <span class='tcode_in_codeblock'>X&#x200b;::&#x200b;f() const</span></span>
  b<span class='operator'>.</span>f<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;                        <span class='comment'>// calls <span class='tcode_in_codeblock'>X&#x200b;::&#x200b;f()</span></span>
<span class='curlybracket'>}</span>

<span class='keyword'>int</span> h<span class='parenthesis'>(</span><span class='keyword'>int</span> <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> h<span class='parenthesis'>(</span><span class='keyword'>int</span> <span class='parenthesis'>(</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span><span class='squarebracket'>[</span><span class='literal'>1</span><span class='squarebracket'>]</span><span class='parenthesis'>)</span>;
<span class='keyword'>void</span> g2<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>int</span> a<span class='squarebracket'>[</span><span class='literal'>1</span><span class='squarebracket'>]</span>;
  h<span class='parenthesis'>(</span>a<span class='parenthesis'>)</span>;                         <span class='comment'>// calls <span class='tcode_in_codeblock'>h(int (&amp;)[1])</span></span>
<span class='curlybracket'>}</span>
</span> —&nbsp;<i>end example</i>]</div></div>
or, if not that,</li><li id='3.2.7'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#3.2.7'>(3.2.7)</a></div><span class='texttt'>S1</span> and <span class='texttt'>S2</span>
bind the same reference type “reference to <span class='texttt'>T</span>” and
have source types <span class='texttt'>V1</span> and <span class='texttt'>V2</span>, respectively,
where the standard conversion sequence from <span class='texttt'>V1<span class='operator'>*</span></span> to <span class='texttt'>T<span class='operator'>*</span></span>
is better than the standard conversion sequence from <span class='texttt'>V2<span class='operator'>*</span></span> to <span class='texttt'>T<span class='operator'>*</span></span><a class='hidden_link' href='#3.2.sentence-1'>.</a> <div class='texpara'><div id='example-7' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-7'>7</a></i>:&ensp;<span class='codeblock'><span class='keyword'>struct</span> Z <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;

<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> Z<span class='operator'>&amp;</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  <span class='keyword'>operator</span> <span class='keyword'>const</span> Z<span class='operator'>&amp;</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;          <span class='comment'>// #1</span>
<span class='curlybracket'>}</span>;

<span class='keyword'>struct</span> B <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> Z<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  <span class='keyword'>operator</span> <span class='keyword'>const</span> Z<span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;         <span class='comment'>// #2</span>
<span class='curlybracket'>}</span>;

<span class='keyword'>const</span> Z<span class='operator'>&amp;</span> r1 <span class='operator'>=</span> A<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;              <span class='comment'>// OK, uses #1</span>
<span class='keyword'>const</span> Z<span class='operator'>&amp;</span><span class='operator'>&amp;</span> r2 <span class='operator'>=</span> B<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;             <span class='comment'>// OK, uses #2</span>
</span> —&nbsp;<i>end example</i>]</div></div></div></li></ul></div></div></li><li id='3.3'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#3.3'>(3.3)</a></div><div class='texpara'><div id='3.3.sentence-1' class='sentence'>User-defined conversion sequence
<span class='texttt'>U1</span>
is a better conversion sequence than another user-defined conversion
sequence
<span class='texttt'>U2</span>
if they contain the same user-defined conversion function or
constructor or they initialize the same class in an aggregate
initialization and in either case the second standard conversion
sequence of
<span class='texttt'>U1</span>
is better than
the second standard conversion sequence of
<span class='texttt'>U2</span><a class='hidden_link' href='#3.3.sentence-1'>.</a></div> <div id='example-8' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-8'>8</a></i>:&ensp;<span class='codeblock'><span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> <span class='keyword'>short</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span> a;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>float</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span>a<span class='parenthesis'>)</span>;                   <span class='comment'>// calls <span class='tcode_in_codeblock'>f(int)</span>, because <span class='tcode_in_codeblock'>short</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>int</span> is</span>
                                <span class='comment'>// better than <span class='tcode_in_codeblock'>short</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>float</span>.</span>
</span> —&nbsp;<i>end example</i>]</div></div></div></li></ul></div></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9b8a5e51752efe9edd7a447e96ffab0f3313accc/source/overloading.tex#L2913'>#</a></div><div class='texpara'><div id='4.sentence-1' class='sentence'>Standard conversion sequences are ordered by their ranks: an Exact Match is a
better conversion than a Promotion, which is a better conversion than
a Conversion<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>Two conversion sequences with the same rank are indistinguishable unless
one of the following rules applies:
<ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#4.1'>(4.1)</a></div><div class='texpara'><div id='4.1.sentence-1' class='sentence'>A conversion that does not convert a pointer or a pointer to member
to
<span class='texttt'><span class='keyword'>bool</span></span>
is better than one that does<a class='hidden_link' href='#4.1.sentence-1'>.</a></div></div></li><li id='4.2'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#4.2'>(4.2)</a></div><div class='texpara'><div id='4.2.sentence-1' class='sentence'>A conversion that promotes an enumeration whose underlying type is fixed to its underlying
type is better than one that promotes to the promoted underlying type, if the two are
different<a class='hidden_link' href='#4.2.sentence-1'>.</a></div></div></li><li id='4.3'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#4.3'>(4.3)</a></div><div class='texpara'><div id='4.3.sentence-1' class='sentence'>A conversion in either direction
between floating-point type <span class='texttt'>FP1</span> and floating-point type <span class='texttt'>FP2</span>
is better than a conversion in the same direction
between <span class='texttt'>FP1</span> and arithmetic type <span class='texttt'>T3</span> if
<ul class='itemize'><li id='4.3.1'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.3.1'>(4.3.1)</a></div>the floating-point conversion rank (<a href='conv.rank' title='6.8.6&emsp;Conversion ranks'>[conv.<span class='shy'></span>rank]</a>) of <span class='texttt'>FP1</span>
is equal to the rank of <span class='texttt'>FP2</span>, and</li><li id='4.3.2'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.3.2'>(4.3.2)</a></div><span class='texttt'>T3</span> is not a floating-point type, or
<span class='texttt'>T3</span> is a floating-point type
whose rank is not equal to the rank of <span class='texttt'>FP1</span>, or
the floating-point conversion subrank (<a href='conv.rank' title='6.8.6&emsp;Conversion ranks'>[conv.<span class='shy'></span>rank]</a>) of <span class='texttt'>FP2</span>
is greater than the subrank of <span class='texttt'>T3</span><a class='hidden_link' href='#4.3.sentence-1'>.</a> <div class='texpara'><div id='example-9' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-9'>9</a></i>:&ensp;<span class='codeblock'><span class='keyword'>int</span> f<span class='parenthesis'>(</span>std<span class='operator'>::</span>float32_t<span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span>std<span class='operator'>::</span>float64_t<span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span><span class='keyword'>long</span> <span class='keyword'>long</span><span class='parenthesis'>)</span>;
<span class='keyword'>float</span> x;
std<span class='operator'>::</span>float16_t y;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span>x<span class='parenthesis'>)</span>;           <span class='comment'>// calls <span class='tcode_in_codeblock'>f(std&#x200b;::&#x200b;float32_<span class='shy'></span>t)</span> on implementations where</span>
                        <span class='comment'>// <span class='tcode_in_codeblock'>float</span> and <span class='tcode_in_codeblock'>std&#x200b;::&#x200b;float32_<span class='shy'></span>t</span> have equal conversion ranks</span>
<span class='keyword'>int</span> j <span class='operator'>=</span> f<span class='parenthesis'>(</span>y<span class='parenthesis'>)</span>;           <span class='comment'>// error: ambiguous, no equal conversion rank</span>
</span> —&nbsp;<i>end example</i>]</div></div></div></li></ul></div></div></li><li id='4.4'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#4.4'>(4.4)</a></div><div class='texpara'><div id='4.4.sentence-1' class='sentence'>If class
<span class='texttt'>B</span>
is derived directly or indirectly from class
<span class='texttt'>A</span>,
conversion of
<span class='texttt'>B<span class='operator'>*</span></span>
to
<span class='texttt'>A<span class='operator'>*</span></span>
is better than conversion of
<span class='texttt'>B<span class='operator'>*</span></span>
to
<span class='texttt'><span id=':void'><span class='texttt'><span class='keyword'>void</span></span></span><span class='operator'>*</span></span>,
and conversion of
<span class='texttt'>A<span class='operator'>*</span></span>
to
<span class='texttt'><span id=':void_'><span class='texttt'><span class='keyword'>void</span></span></span><span class='operator'>*</span></span>
is better than conversion
of
<span class='texttt'>B<span class='operator'>*</span></span>
to
<span class='texttt'><span id=':void__'><span class='texttt'><span class='keyword'>void</span></span></span><span class='operator'>*</span></span><a class='hidden_link' href='#4.4.sentence-1'>.</a></div></div></li><li id='4.5'><div class='marginalizedparent' style='left:-27mm'><a class='marginalized' href='#4.5'>(4.5)</a></div><div class='texpara'><div id='4.5.sentence-1' class='sentence'>If class
<span class='texttt'>B</span>
is derived directly or indirectly from class
<span class='texttt'>A</span>
and class
<span class='texttt'>C</span>
is derived directly or indirectly from
<span class='texttt'>B</span>,
<ul class='itemize'><li id='4.5.1'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.1'>(4.5.1)</a></div>conversion of
<span class='texttt'>C<span class='operator'>*</span></span>
to
<span class='texttt'>B<span class='operator'>*</span></span>
is better than conversion of
<span class='texttt'>C<span class='operator'>*</span></span>
to
<span class='texttt'>A<span class='operator'>*</span></span>,
<div id='example-10' class='example'><div class='texpara'>[<i>Example&nbsp;<a href='#example-10'>10</a></i>:&ensp;<span class='codeblock'><span class='keyword'>struct</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> B <span class='operator'>:</span> <span class='keyword'>public</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> C <span class='operator'>:</span> <span class='keyword'>public</span> B <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
C<span class='operator'>*</span> pc;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span>A<span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span>B<span class='operator'>*</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span>pc<span class='parenthesis'>)</span>;                  <span class='comment'>// calls <span class='tcode_in_codeblock'>f(B*)</span></span>
</span> —&nbsp;<i>end example</i>]</div></div></li><li id='4.5.2'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.2'>(4.5.2)</a></div>binding of an expression of type
<span class='texttt'>C</span>
to a reference to type
<span class='texttt'>B</span>
is better than binding an expression of type
<span class='texttt'>C</span>
to a reference to type
<span class='texttt'>A</span>,</li><li id='4.5.3'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.3'>(4.5.3)</a></div>conversion of
<span class='texttt'>A<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
to
<span class='texttt'>B<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
is better than conversion of
<span class='texttt'>A<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
to
<span class='texttt'>C<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>,</li><li id='4.5.4'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.4'>(4.5.4)</a></div>conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>B</span>
is better than conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>A</span>,</li><li id='4.5.5'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.5'>(4.5.5)</a></div>conversion of
<span class='texttt'>B<span class='operator'>*</span></span>
to
<span class='texttt'>A<span class='operator'>*</span></span>
is better than conversion of
<span class='texttt'>C<span class='operator'>*</span></span>
to
<span class='texttt'>A<span class='operator'>*</span></span>,</li><li id='4.5.6'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.6'>(4.5.6)</a></div>binding of an expression of type
<span class='texttt'>B</span>
to a reference to type
<span class='texttt'>A</span>
is better than binding an expression of type
<span class='texttt'>C</span>
to a
reference to type
<span class='texttt'>A</span>,</li><li id='4.5.7'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.7'>(4.5.7)</a></div>conversion of
<span class='texttt'>B<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
to
<span class='texttt'>C<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
is better than conversion
of
<span class='texttt'>A<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>
to
<span class='texttt'>C<span class='operator'>&#x200b;::&#x200b;</span><span class='operator'>*</span></span>,
and</li><li id='4.5.8'><div class='marginalizedparent' style='left:-36mm'><a class='marginalized' href='#4.5.8'>(4.5.8)</a></div>conversion of
<span class='texttt'>B</span>
to
<span class='texttt'>A</span>
is better than conversion of
<span class='texttt'>C</span>
to
<span class='texttt'>A</span><a class='hidden_link' href='#4.5.sentence-1'>.</a></li></ul></div></div><div class='texpara'><div id='note-1' class='note'><div class='texpara'>[<i>Note&nbsp;<a href='#note-1'>1</a></i>:&ensp;<div id='4.5.sentence-2' class='sentence'>Compared conversion sequences will have different source types only in the
context of comparing the second standard conversion sequence of an
initialization by user-defined conversion (see <a href='over.match.best' title='12.2.4&emsp;Best viable function'>[over.<span class='shy'></span>match.<span class='shy'></span>best]</a>); in
all other contexts, the source types will be the same and the target
types will be different<a class='hidden_link' href='#4.5.sentence-2'>.</a></div> —&nbsp;<i>end note</i>]</div></div></div></li></ul></div> </div></div></div></body></html>