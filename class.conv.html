<!DOCTYPE html><html lang='en'><head><title>[class.conv]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.conv'><h2 ><a class='secnum' style='min-width:88pt'>12.3</a> Conversions <a class='abbr_ref'>[class.conv]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L659'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,class'></a></span><span class='indexparent'><a class='index' id='conversion,user-defined'></a></span><span class='indexparent'><a class='index' id='constructor,_conversion_by'></a></span><span class='indexparent'><a class='index' id='conversion_function'></a></span><span class='indexparent'><a class='index' id='conversion,implicit'></a></span>Type conversions of class objects can be specified by constructors and
by conversion functions.
These conversions are called
<a class='hidden_link' href='#def:user-defined_conversions' id='def:user-defined_conversions'><i>user-defined conversions</i></a>
and are used for implicit type conversions (Clause <a href='conv'>[conv]</a>),
for initialization (<a href='dcl.init'>[dcl.init]</a>),
and for explicit type conversions (<a href='expr.cast'>[expr.cast]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L673'>#</a></div><p >User-defined conversions are applied only where they are unambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>, <a href='class.conv.fct'>[class.conv.fct]</a>).
Conversions obey the access control rules (Clause <a href='class.access'>[class.access]</a>).
Access control is applied after ambiguity resolution (<a href='basic.lookup'>[basic.lookup]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L678'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
See <a href='over.match'>[over.match]</a> for a discussion of the use of conversions in function calls
as well as examples below.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L684'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,implicit_user-defined'></a></span>At most one user-defined conversion (constructor or conversion function)
is implicitly applied to a single value.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct X {
  operator int();
};

struct Y {
  operator X();
};

Y a;
int b = a;          <span class='comment'>// error, <span class='texttt'>a.operator X().operator int()</span> not tried
</span>int c = X(a);       <span class='comment'>// OK: <span class='texttt'>a.operator X().operator int()</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L704'>#</a></div><p >User-defined conversions are used implicitly only if they are unambiguous.
<span class='indexparent'><a class='index' id='name_hiding,user-defined_conversion_and'></a></span>A conversion function in a derived class does not hide a conversion function
in a base class unless the two functions convert to the same type.
Function overload resolution (<a href='over.match.best'>[over.match.best]</a>) selects the best
conversion function to perform the conversion.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct X {
  operator int();
};

struct Y : X {
    operator char();
};

void f(Y&amp; a) {
  if (a) {          <span class='comment'>// ill-formed: <span class='texttt'>X&#x200b;::&#x200b;operator int()</span> or <span class='texttt'>Y&#x200b;::&#x200b;operator char()</span>
</span>  }
}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div id='ctor'><h3 ><a class='secnum' href='#ctor' style='min-width:103pt'>12.3.1</a> Conversion by constructor <a class='abbr_ref' href='class.conv.ctor'>[class.conv.ctor]</a></h3><p ><span class='indexparent'><a class='index' id='conversion,user-defined'></a></span>
</p><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L731'>#</a></div><p >A constructor declared without the
<i ><a href='dcl.fct.spec#nt:function-specifier'>function-specifier</a></i>
<span class='texttt'>explicit</span>
specifies a conversion from
the types of its parameters (if any)
to the type of its class.
Such a constructor is called a
<span class='indexparent'><a class='index' id='constructor,converting'></a></span><a class='hidden_link' href='#def:converting_constructor' id='def:converting_constructor'><i>converting constructor</i></a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><p ><span class='indexparent'><a class='index' id='Jessie'></a></span></p><pre class='codeblock'>
struct X {
    X(int);
    X(const char*, int =0);
    X(int, int);
};

void f(X arg) {
  X a = 1;          <span class='comment'>// <span class='texttt'>a = X(1)</span>
</span>  X b = "Jessie";   <span class='comment'>// <span class='texttt'>b = X("Jessie",0)</span>
</span>  a = 2;            <span class='comment'>// <span class='texttt'>a = X(2)</span>
</span>  f(3);             <span class='comment'>// <span class='texttt'>f(X(3))</span>
</span>  f({1, 2});        <span class='comment'>// <span class='texttt'>f(X(1,2))</span>
</span>}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L761'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
An explicit constructor constructs objects just like non-explicit
constructors, but does so only where the direct-initialization syntax (<a href='dcl.init'>[dcl.init]</a>)
or where casts (<a href='expr.static.cast'>[expr.static.cast]</a>, <a href='expr.cast'>[expr.cast]</a>) are explicitly
used; see also <a href='over.match.copy'>[over.match.copy]</a>.
A default constructor may be an explicit constructor; such a constructor
will be used to perform default-initialization
or value-initialization (<a href='dcl.init'>[dcl.init]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct Z {
  explicit Z();
  explicit Z(int);
  explicit Z(int, int);
};

Z a;                            <span class='comment'>// OK: default-initialization performed
</span>Z b{};                          <span class='comment'>// OK: direct initialization syntax used
</span>Z c = {};                       <span class='comment'>// error: copy-list-initialization
</span>Z a1 = 1;                       <span class='comment'>// error: no implicit conversion
</span>Z a3 = Z(1);                    <span class='comment'>// OK: direct initialization syntax used
</span>Z a2(1);                        <span class='comment'>// OK: direct initialization syntax used
</span>Z* p = new Z(1);                <span class='comment'>// OK: direct initialization syntax used
</span>Z a4 = (Z)1;                    <span class='comment'>// OK: explicit cast used
</span>Z a5 = static_cast&lt;Z&gt;(1);       <span class='comment'>// OK: explicit cast used
</span>Z a6 = { 3, 4 };                <span class='comment'>// error: no implicit conversion
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L792'>#</a></div><p >A
non-explicit
copy/move constructor (<a href='class.copy'>[class.copy]</a>) is a converting constructor.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
An implicitly-declared copy/move constructor is not an explicit constructor;
it may be called for implicit type conversions.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='fct'><h3 ><a class='secnum' href='#fct' style='min-width:103pt'>12.3.2</a> Conversion functions <a class='abbr_ref' href='class.conv.fct'>[class.conv.fct]</a></h3><p ><span class='indexparent'><a class='index' id='function,conversion'></a></span><span class='indexparent'><a class='index' id='fundamental_type_conversion'></a></span><span class='indexparent'><a class='index' id='conversion,user-defined'></a></span>
</p><div class='para' id='fct-1'><div class='marginalizedparent'><a class='marginalized' href='#fct-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L806'>#</a></div><p >A member function of a class <span class='texttt'>X</span> having no parameters with a name of the form</p><pre class='bnf'><a class='nontermdef' id='nt:conversion-function-id'>conversion-function-id:</a>
&#9;<span class='terminal'>operator</span> <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
</pre><pre class='bnf'><a class='nontermdef' id='nt:conversion-type-id'>conversion-type-id:</a>
&#9;<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> <i ><a href='class.conv.fct#nt:conversion-declarator'>conversion-declarator</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
</pre><pre class='bnf'><a class='nontermdef' id='nt:conversion-declarator'>conversion-declarator:</a>
&#9;<i ><a href='dcl.decl#nt:ptr-operator'>ptr-operator</a></i> <i ><a href='class.conv.fct#nt:conversion-declarator'>conversion-declarator</a></i><span id="MathJax-Element-1-Frame" class="mjx-chtml"><span id="MJXc-Node-1" class="mjx-math"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-4" class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-5" class="mjx-texatom" style=""><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span id="MJXc-Node-8" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span id="MJXc-Node-9" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span>
</pre><p >specifies a conversion from
<span class='texttt'>X</span>
to the type specified by the
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>.
Such functions are called <a class='hidden_link' href='#def:conversion_function' id='def:conversion_function'><i>conversion function</i></a>s.
A <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a conversion function (if any) shall be neither
a <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> nor <span class='texttt'>static</span>.
<span class='indexparent'><a class='index' id='conversion,type_of'></a></span>The type of the conversion function (<a href='dcl.fct'>[dcl.fct]</a>) is
“function taking no parameter returning
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>”.
A conversion function is never used to convert a (possibly cv-qualified) object
to the (possibly cv-qualified) same object type (or a reference to it),
to a (possibly cv-qualified) base class of that type (or a reference to it),
or to (possibly cv-qualified) void.<a class='footnotenum' href='#footnote-117'>117</a>
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct X {
  operator int();
  operator auto() -&gt; short;     <span class='comment'>// error: trailing return type
</span>};

void f(X a) {
  int i = int(a);
  i = (int)a;
  i = a;
}</pre><p >In all three cases the value assigned will be converted by
<span class='texttt'>X&#x200b;::&#x200b;operator int()</span>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='fct-2'><div class='marginalizedparent'><a class='marginalized' href='#fct-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L861'>#</a></div><p >A conversion function may be explicit (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>), in which case it is only considered as a user-defined conversion for direct-initialization (<a href='dcl.init'>[dcl.init]</a>). Otherwise, user-defined conversions are not restricted to use in assignments and initializations.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
class Y { };
struct Z {
  explicit operator Y() const;
};

void h(Z z) {
  Y y1(z);          <span class='comment'>// OK: direct-initialization
</span>  Y y2 = z;         <span class='comment'>// ill-formed: copy-initialization
</span>  Y y3 = (Y)z;      <span class='comment'>// OK: cast notation
</span>}

void g(X a, X b) {
  int i = (a) ? 1+a : 0;
  int j = (a&amp;&amp;b) ? a+b : i;
  if (a) {
  }
}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='fct-3'><div class='marginalizedparent'><a class='marginalized' href='#fct-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L885'>#</a></div><p >The
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
shall not represent a function type nor an array type.
The
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
in a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>
is the longest sequence of
tokens that could possibly form a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This prevents ambiguities between the declarator operator <span class='texttt'>*</span> and its expression
counterparts.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
&amp;ac.operator int*i; <span class='comment'>// syntax error:
</span>                    <span class='comment'>// parsed as: <span class='texttt'>&amp;(ac.operator int *)i</span>
</span>                    <span class='comment'>// not as: <span class='texttt'>&amp;(ac.operator int)*i</span>
</span></pre><p >The <span class='texttt'>*</span> is the pointer declarator and not the multiplication operator.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
This rule also prevents ambiguities for attributes. 
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
operator int [[noreturn]] ();   <span class='comment'>// error: <span class='texttt'>noreturn</span> attribute applied to a type
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='fct-4'><div class='marginalizedparent'><a class='marginalized' href='#fct-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L914'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,inheritance_of_user-defined'></a></span>Conversion functions are inherited.</p></div><div class='para' id='fct-5'><div class='marginalizedparent'><a class='marginalized' href='#fct-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L918'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,virtual_user-defined'></a></span>Conversion functions can be virtual.</p></div><div class='para' id='fct-6'><div class='marginalizedparent'><a class='marginalized' href='#fct-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/special.tex#L922'>#</a></div><p ><span class='indexparent'><a class='index' id='conversion,deduced_return_type_of_user-defined'></a></span>A conversion function template shall not have a
deduced return type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct S {
  operator auto() const { return 10; }      <span class='comment'>// OK
</span>  template&lt;class T&gt;
  operator auto() const { return 1.2; }     <span class='comment'>// error: conversion function template
</span>};</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-117'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-117'>117)</a></div><p >These conversions are considered
as standard conversions for the purposes of overload resolution (<a href='over.best.ics'>[over.best.ics]</a>, <a href='over.ics.ref'>[over.ics.ref]</a>) and therefore initialization (<a href='dcl.init'>[dcl.init]</a>) and explicit casts (<a href='expr.static.cast'>[expr.static.cast]</a>). A conversion to <span class='texttt'>void</span> does not invoke any conversion function (<a href='expr.static.cast'>[expr.static.cast]</a>).
Even though never directly called to perform a conversion,
such conversion functions can be declared and can potentially
be reached through a call to a virtual conversion function in a base class.</p></div></div></div></div></body></html>