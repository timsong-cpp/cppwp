<!DOCTYPE html><html lang='en'><head><title>[dcl.type.cv]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.type.cv'>[dcl.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type#cv'>[dcl.type]</a></h3><div id='dcl.type.cv'><h4 ><a class='secnum' style='min-width:118pt'>7.1.7.1</a> The <span class='grammarterm'>cv-qualifiers</span> <a class='abbr_ref'>[dcl.type.cv]</a></h4><p ><span class='indexparent'><a class='index' id='specifier!cv-qualifier'></a></span><span class='indexparent'><a class='index' id='initialization!const'></a></span><span class='indexparent'><a class='index' id='type~specifier!const'></a></span><span class='indexparent'><a class='index' id='type~specifier!volatile'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >There are two <span class='grammarterm'>cv-qualifiers</span>, <span class='texttt'>const</span> and
<span class='texttt'>volatile</span>. Each <i ><a href='dcl.decl#cv-qualifier'>cv-qualifier</a></i> shall appear at most once in
a <i ><a href='dcl.decl#cv-qualifier-seq'>cv-qualifier-seq</a></i>. If a <i ><a href='dcl.decl#cv-qualifier'>cv-qualifier</a></i> appears in a
<i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i>, the <i ><a href='dcl.decl#init-declarator-list'>init-declarator-list</a></i>
or <i ><a href='class.mem#member-declarator-list'>member-declarator-list</a></i> of
the declaration shall not be empty.
[&nbsp;<i>Note:</i><span class='space'></span>
<a href='basic.type.qualifier'>[basic.type.qualifier]</a> and <a href='dcl.fct'>[dcl.fct]</a> describe how cv-qualifiers affect object and
function types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Redundant cv-qualifications are ignored. [&nbsp;<i>Note:</i><span class='space'></span> For example,
these could be introduced by typedefs.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Declaring a variable <span class='texttt'>const</span> can affect its linkage (<a href='dcl.stc'>[dcl.stc]</a>)
and its usability in constant expressions (<a href='expr.const'>[expr.const]</a>). As
described in <a href='dcl.init'>[dcl.init]</a>, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
[&nbsp;<i>Note:</i><span class='space'></span>
Cv-qualifiers are supported by the type system so that they cannot be
subverted without casting (<a href='expr.const.cast'>[expr.const.cast]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='const~object!undefined change~to'></a></span>Except that any class member declared <span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>)
can be modified, any attempt to modify a <span class='texttt'>const</span> object during its
lifetime (<a href='basic.life'>[basic.life]</a>) results in undefined behavior.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
const int ci = 3;               <span class='comment'>// cv-qualified (initialized as required)
</span>ci = 4;                         <span class='comment'>// ill-formed: attempt to modify <span class='texttt'>const</span>
</span>
int i = 2;                      <span class='comment'>// not cv-qualified
</span>const int* cip;                 <span class='comment'>// pointer to <span class='texttt'>const int</span>
</span>cip = &amp;i;                       <span class='comment'>// OK: cv-qualified access path to unqualified
</span>*cip = 4;                       <span class='comment'>// ill-formed: attempt to modify through ptr to <span class='texttt'>const</span>
</span>
int* ip;
ip = const_cast&lt;int*&gt;(cip);     <span class='comment'>// cast needed to convert <span class='texttt'>const int*</span> to <span class='texttt'>int*</span>
</span>*ip = 4;                        <span class='comment'>// defined: <span class='texttt'>*ip</span> points to <span class='texttt'>i</span>, a non-<span class='texttt'>const</span> object
</span>
const int* ciq = new const int (3);     <span class='comment'>// initialized as required
</span>int* iq = const_cast&lt;int*&gt;(ciq);        <span class='comment'>// cast required
</span>*iq = 4;                                <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> object
</span></pre></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For another example</p><pre class='codeblock'>
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                        <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>y.x.j++;                        <span class='comment'>// ill-formed: <span class='texttt'>const</span>-qualified member modified
</span>Y* p = const_cast&lt;Y*&gt;(&amp;y);      <span class='comment'>// cast away const-ness of <span class='texttt'>y</span>
</span>p-&gt;x.i = 99;                    <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>p-&gt;x.j = 99;                    <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> member
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >What constitutes an access to an object that has volatile-qualified type is
<span class='indexparent'><a class='index' id='what constitutes an access to an object that has volatile-qualified type'></a></span>implementation-defined.
If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of a glvalue with a
non-volatile-qualified type, the behavior is undefined.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='type~specifier!volatile'></a></span><span class='indexparent'><a class='index' id='volatile!implementation-defined'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
<span class='texttt'>volatile</span> is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
Furthermore, for some implementations, <span class='texttt'>volatile</span> might indicate that
special hardware instructions are required to access the object.
See <a href='intro.execution'>[intro.execution]</a> for detailed semantics. In general, the
semantics of <span class='texttt'>volatile</span> are intended to be the same in C++ as
they are in C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>