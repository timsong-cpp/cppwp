<!DOCTYPE html><html lang='en'><head><title>[iterator.stdtraits]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>9.6</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives#iterator.stdtraits'>[iterator.primitives]</a></h2><div id='iterator.stdtraits'><h3 ><a class='secnum' style='min-width:103pt'>9.6.2</a> Standard iterator traits <a class='abbr_ref'>[iterator.stdtraits]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >To facilitate interoperability between new code using iterators conforming to this document
and older code using iterators that conform to the iterator
requirements specified in ISO/IEC 14882, three specializations of <span class='texttt'>std::iterator_traits</span>
are provided to map the newer iterator categories and associated types to the older ones.</p><pre class='codeblock'>
namespace std {
  template &lt;experimental::ranges::Iterator Out&gt;
  struct iterator_traits&lt;Out&gt; {
    using difference_type   = experimental::ranges::difference_type_t&lt;Out&gt;;
    using value_type        = <i><span class='texttt'>see below</span></i>;
    using reference         = <i><span class='texttt'>see below</span></i>;
    using pointer           = <i><span class='texttt'>see below</span></i>;
    using iterator_category = std::output_iterator_tag;
  };
}
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The nested type <span class='texttt'>value_type</span> is computed as follows:
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >If
      <span class='texttt'>Out::value_type</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;Out&gt;::value_type</span> is <span class='texttt'>Out::value_type</span>.
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;Out&gt;::value_type</span> is <span class='texttt'>void</span>.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The nested type <span class='texttt'>reference</span> is computed as follows:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If
      <span class='texttt'>Out::reference</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;Out&gt;::reference</span> is <span class='texttt'>Out::reference</span>.
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;Out&gt;::reference</span> is <span class='texttt'>void</span>.
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The nested type <span class='texttt'>pointer</span> is computed as follows:
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >If
      <span class='texttt'>Out::pointer</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;Out&gt;::pointer</span> is <span class='texttt'>Out::pointer</span>.
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;Out&gt;::pointer</span> is <span class='texttt'>void</span>.
</p></li></ul><pre class='codeblock'>
namespace std {
  template &lt;experimental::ranges::InputIterator In&gt;
  struct iterator_traits&lt;In&gt; { };

  template &lt;experimental::ranges::InputIterator In&gt;
    requires experimental::ranges::Sentinel&lt;In, In&gt;
  struct iterator_traits&lt;In&gt; {
    using difference_type   = experimental::ranges::difference_type_t&lt;In&gt;;
    using value_type        = experimental::ranges::value_type_t&lt;In&gt;;
    using reference         = <i><span class='texttt'>see below</span></i>;
    using pointer           = <i><span class='texttt'>see below</span></i>;
    using iterator_category = <i><span class='texttt'>see below</span></i>;
  };
}
</pre></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The nested type <span class='texttt'>reference</span> is computed as follows:
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If
      <span class='texttt'>In::reference</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;In&gt;::reference</span> is <span class='texttt'>In::reference</span>.
</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::reference</span> is
      <span class='texttt'>experimental::ranges::reference_t&lt;In&gt;</span>.
</p></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The nested type <span class='texttt'>pointer</span> is computed as follows:
</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >If
      <span class='texttt'>In::pointer</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;In&gt;::pointer</span> is <span class='texttt'>In::pointer</span>.
</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::pointer</span> is
      <span class='texttt'>experimental::ranges::iterator_traits&lt;In&gt;::pointer</span>.
</p></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Let type <span class='texttt'>C</span> be <span class='texttt'>experimental::ranges::</span><span class='texttt'>iterator_category_t</span><span class='texttt'>&lt;In&gt;</span>.
The nested type <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is computed as
follows:
</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >If <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>std::input_iterator_tag</span> or
      <span class='texttt'>std::output_iterator_tag</span>, <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span>
      is <span class='texttt'>C</span>.
</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >Otherwise, if <span class='texttt'>experimental::ranges::reference_t&lt;In&gt;</span> is not a reference type,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::input_iterator_tag</span>.
</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::random_access_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::random_access_iterator_tag</span>.
</p></li><li id='7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.4'>(7.4)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::bidirectional_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::bidirectional_iterator_tag</span>.
</p></li><li id='7.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.5'>(7.5)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::forward_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::forward_iterator_tag</span>.
</p></li><li id='7.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.6'>(7.6)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::input_iterator_tag</span>.
</p></li></ul></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i> Some implementations may find it necessary to add additional constraints to
these partial specializations to prevent them from being considered for types that
conform to the iterator requirements specified in ISO/IEC 14882.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>