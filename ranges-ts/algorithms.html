<!DOCTYPE html><html lang='en'><head><title>[algorithms]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='algorithms'><h1 ><a class='secnum' style='min-width:73pt'>11</a> Algorithms library <a class='abbr_ref' href='./#algorithms'>[algorithms]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>11.1</a> General <a class='abbr_ref' href='algorithms.general'>[algorithms.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes components that C++ programs may use to perform
algorithmic operations on containers (Clause   ISO/IEC 14882:2014 &sect;<a href='../n4140/containers'>[containers]</a>) and other sequences.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The following subclauses describe components for
non-modifying sequence operations,
modifying sequence operations,
and sorting and related operations,
as summarized in Table <a href='#tab:algorithms.summary'>[tab:algorithms.summary]</a>.</p><div class='numberedTable' id='tab:algorithms.summary'>Table <a href='#tab:algorithms.summary'>11</a> â€” Algorithms library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='alg.nonmodifying'>[alg.nonmodifying]</a> </td><td class='left'> Non-modifying sequence operations  </td><td class='left'>           </td></tr><tr ><td class='left'>
<a href='alg.modifying.operations'>[alg.modifying.operations]</a> </td><td class='left'> Mutating sequence operations </td><td class='left'> <span class='texttt'>&lt;experimental/ranges/algorithm&gt;</span> </td></tr><tr ><td class='left'>
<a href='alg.sorting'>[alg.sorting]</a> </td><td class='left'> Sorting and related operations      </td><td class='left'>           </td></tr></table></div><p ><b>Header <span class='texttt'>&lt;experimental/ranges/algorithm&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='experimental/ranges/algorithm'></a></span>
</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  namespace tag {
    <span class='comment'>// <a href='alg.tagspec'>[alg.tagspec]</a>, tag specifiers (See <a href='taggedtup.tagged'>[taggedtup.tagged]</a>):
</span>    struct in;
    struct in1;
    struct in2;
    struct out;
    struct out1;
    struct out2;
    struct fun;
    struct min;
    struct max;
    struct begin;
    struct end;
  }

  <span class='comment'>// <a href='alg.nonmodifying'>[alg.nonmodifying]</a>, non-modifying sequence operations:
</span>  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    bool all_of(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    bool all_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    bool any_of(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    bool any_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    bool none_of(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    bool none_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
    tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
      for_each(I first, S last, Fun f, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectInvocable&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Fun&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::fun(Fun)&gt;
      for_each(Rng&amp;&amp; rng, Fun f, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
    requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
    I find(I first, S last, const T&amp; value, Proj proj = Proj{});

  template &lt;InputRange Rng, class T, class Proj = identity&gt;
    requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
    safe_iterator_t&lt;Rng&gt;
      find(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    I find_if(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    safe_iterator_t&lt;Rng&gt;
      find_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    safe_iterator_t&lt;Rng&gt;
      find_if_not(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
      Sentinel&lt;I2&gt; S2, class Proj = identity,
      IndirectRelation&lt;I2, projected&lt;I1, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    I1
      find_end(I1 first1, S1 last1, I2 first2, S2 last2,
               Pred pred = Pred{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng1, ForwardRange Rng2, class Proj = identity,
      IndirectRelation&lt;iterator_t&lt;Rng2&gt;,
        projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    safe_iterator_t&lt;Rng1&gt;
      find_end(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{}, Proj proj = Proj{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    I1
      find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                    Pred pred = Pred{},
                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, ForwardRange Rng2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
        projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    safe_iterator_t&lt;Rng1&gt;
      find_first_of(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2,
                    Pred pred = Pred{},
                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    I
      adjacent_find(I first, S last, Pred pred = Pred{},
                    Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      adjacent_find(Rng&amp;&amp; rng, Pred pred = Pred{}, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
    requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
    difference_type_t&lt;I&gt;
      count(I first, S last, const T&amp; value, Proj proj = Proj{});

  template &lt;InputRange Rng, class T, class Proj = identity&gt;
    requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
    difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
      count(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    difference_type_t&lt;I&gt;
      count_if(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
      count_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
        projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
    tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
                tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
      mismatch(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      class Pred = equal_to&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
               Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, class Pred = equal_to&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
    bool equal(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});


  template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
      Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;, class Proj1 = identity,
      class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                        Pred pred = Pred{},
                        Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
    bool is_permutation(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
                        Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
      Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    I1
      search(I1 first1, S1 last1, I2 first2, S2 last2,
             Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
    safe_iterator_t&lt;Rng1&gt;
      search(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T,
      class Pred = equal_to&lt;&gt;, class Proj = identity&gt;
    requires IndirectlyComparable&lt;I, const T*, Pred, Proj&gt;
    I
      search_n(I first, S last, difference_type_t&lt;I&gt; count,
               const T&amp; value, Pred pred = Pred{},
               Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Pred = equal_to&lt;&gt;,
      class Proj = identity&gt;
    requires IndirectlyComparable&lt;iterator_t&lt;Rng&gt;, const T*, Pred, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      search_n(Rng&amp;&amp; rng, difference_type_t&lt;iterator_t&lt;Rng&gt;&gt; count,
               const T&amp; value, Pred pred = Pred{}, Proj proj = Proj{});

  <span class='comment'>// <a href='alg.modifying.operations'>[alg.modifying.operations]</a>, modifying sequence operations:
</span>  <span class='comment'>// <a href='alg.copy'>[alg.copy]</a>, copy:
</span>  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      copy(I first, S last, O result);

  template &lt;InputRange Rng, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      copy(Rng&amp;&amp; rng, O result);

  template &lt;InputIterator I, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      copy_n(I first, difference_type_t&lt;I&gt; n, O result);

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});

  template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt;
    tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
      copy_backward(I1 first, S1 last, I2 result);

  template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, I&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
      copy_backward(Rng&amp;&amp; rng, I result);

  <span class='comment'>// <a href='alg.move'>[alg.move]</a>, move:
</span>  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
    requires IndirectlyMovable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      move(I first, S last, O result);

  template &lt;InputRange Rng, WeaklyIncrementable O&gt;
    requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      move(Rng&amp;&amp; rng, O result);

  template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
    requires IndirectlyMovable&lt;I1, I2&gt;
    tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
      move_backward(I1 first, S1 last, I2 result);

  template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
    requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, I&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
      move_backward(Rng&amp;&amp; rng, I result);

  template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2&gt;
    requires IndirectlySwappable&lt;I1, I2&gt;
    tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
      swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);

  template &lt;ForwardRange Rng1, ForwardRange Rng2&gt;
    requires IndirectlySwappable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt;
    tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
      swap_ranges(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2);

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
      CopyConstructible F, class Proj = identity&gt;
    requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I, Proj&gt;)&gt;&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      transform(I first, S last, O result, F op, Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O, CopyConstructible F,
      class Proj = identity&gt;
    requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
      projected&lt;iterator_t&lt;R&gt;, Proj&gt;)&gt;&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      transform(Rng&amp;&amp; rng, O result, F op, Proj proj = Proj{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
      class Proj2 = identity&gt;
    requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I1, Proj1&gt;,
      projected&lt;I2, Proj2&gt;)&gt;&gt;
    tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
      transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
      CopyConstructible F, class Proj1 = identity, class Proj2 = identity&gt;
    requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
      projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;, projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;)&gt;&gt;
    tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
                 tag::in2(safe_iterator_t&lt;Rng2&gt;),
                 tag::out(O)&gt;
      transform(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, class Proj = identity&gt;
    requires Writable&lt;I, const T2&amp;&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
    I
      replace(I first, S last, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

  template &lt;InputRange Rng, class T1, class T2, class Proj = identity&gt;
    requires Writable&lt;iterator_t&lt;Rng&gt;, const T2&amp;&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
    safe_iterator_t&lt;Rng&gt;
      replace(Rng&amp;&amp; rng, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Writable&lt;I, const T&amp;&gt;
    I
      replace_if(I first, S last, Pred pred, const T&amp; new_value, Proj proj = Proj{});

  template &lt;InputRange Rng, class T, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires Writable&lt;iterator_t&lt;Rng&gt;, const T&amp;&gt;
    safe_iterator_t&lt;Rng&gt;
      replace_if(Rng&amp;&amp; rng, Pred pred, const T&amp; new_value, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
      class Proj = identity&gt;
    requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                   Proj proj = Proj{});

  template &lt;InputRange Rng, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
      class Proj = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      replace_copy(Rng&amp;&amp; rng, O result, const T1&amp; old_value, const T2&amp; new_value,
                   Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, OutputIterator&lt;const T&amp;&gt; O,
      class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                      Proj proj = Proj{});

  template &lt;InputRange Rng, class T, OutputIterator&lt;const T&amp;&gt; O, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      replace_copy_if(Rng&amp;&amp; rng, O result, Pred pred, const T&amp; new_value,
                      Proj proj = Proj{});

  template &lt;class T, OutputIterator&lt;const T&amp;&gt; O, Sentinel&lt;O&gt; S&gt;
    O fill(O first, S last, const T&amp; value);

  template &lt;class T, OutputRange&lt;const T&amp;&gt; Rng&gt;
    safe_iterator_t&lt;Rng&gt;
      fill(Rng&amp;&amp; rng, const T&amp; value);

  template &lt;class T, OutputIterator&lt;const T&amp;&gt; O&gt;
    O fill_n(O first, difference_type_t&lt;O&gt; n, const T&amp; value);

  template &lt;Iterator O, Sentinel&lt;O&gt; S, CopyConstructible F&gt;
      requires Callable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
    O generate(O first, S last, F gen);

  template &lt;class Rng, CopyConstructible F&gt;
      requires Callable&lt;F&amp;&gt; &amp;&amp; OutputRange&lt;Rng, result_of_t&lt;F&amp;()&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      generate(Rng&amp;&amp; rng, F gen);

  template &lt;Iterator O, CopyConstructible F&gt;
      requires Callable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
    O generate_n(O first, difference_type_t&lt;O&gt; n, F gen);

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
    requires Permutable&lt;I&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
    I remove(I first, S last, const T&amp; value, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Proj = identity&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
    safe_iterator_t&lt;Rng&gt;
      remove(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
    I remove_if(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      remove_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class T,
      class Proj = identity&gt;
    requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      remove_copy(I first, S last, O result, const T&amp; value, Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O, class T, class Proj = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
      IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      remove_copy(Rng&amp;&amp; rng, O result, const T&amp; value, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
      class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      remove_copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
    requires Permutable&lt;I&gt;
    I unique(I first, S last, R comp = R{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      unique(Rng&amp;&amp; rng, R comp = R{}, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
      class Proj = identity, IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
    requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
      (ForwardIterator&lt;I&gt; ||
       (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;I&gt;, value_type_t&lt;O&gt;&gt;) ||
       IndirectlyCopyableStorable&lt;I, O&gt;)
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      unique_copy(I first, S last, O result, R comp = R{}, Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
      IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
      (ForwardIterator&lt;iterator_t&lt;Rng&gt;&gt; ||
       (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;, value_type_t&lt;O&gt;&gt;) ||
       IndirectlyCopyableStorable&lt;iterator_t&lt;Rng&gt;, O&gt;)
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      unique_copy(Rng&amp;&amp; rng, O result, R comp = R{}, Proj proj = Proj{});

  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S&gt;
    requires Permutable&lt;I&gt;
    I reverse(I first, S last);

  template &lt;BidirectionalRange Rng&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      reverse(Rng&amp;&amp; rng);

  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt; reverse_copy(I first, S last, O result);

  template &lt;BidirectionalRange Rng, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      reverse_copy(Rng&amp;&amp; rng, O result);

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S&gt;
    requires Permutable&lt;I&gt;
    tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
      rotate(I first, I middle, S last);

  template &lt;ForwardRange Rng&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
                tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
      rotate(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle);

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;I, O&gt;
    tagged_pair&lt;tag::in(I), tag::out(O)&gt;
      rotate_copy(I first, I middle, S last, O result);

  template &lt;ForwardRange Rng, WeaklyIncrementable O&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
    tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
      rotate_copy(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, O result);

  <span class='comment'>// <a href='alg.random.shuffle'>[alg.random.shuffle]</a>, shuffle:
</span>  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Gen&gt;
    requires Permutable&lt;I&gt; &amp;&amp;
      UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
      ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
    I shuffle(I first, S last, Gen&amp;&amp; g);

  template &lt;RandomAccessRange Rng, class Gen&gt;
    requires Permutable&lt;I&gt; &amp;&amp;
      UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
      ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      shuffle(Rng&amp;&amp; rng, Gen&amp;&amp; g);

  <span class='comment'>// <a href='alg.partitions'>[alg.partitions]</a>, partitions:
</span>  template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    bool
      is_partitioned(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
    I partition(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
    I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;BidirectionalRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      stable_partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O1, WeaklyIncrementable O2,
      class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;I, O1&gt; &amp;&amp; IndirectlyCopyable&lt;I, O2&gt;
    tagged_tuple&lt;tag::in(I), tag::out1(O1), tag::out2(O2)&gt;
      partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                     Proj proj = Proj{});

  template &lt;InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,
      class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp;
      IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O2&gt;
    tagged_tuple&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out1(O1), tag::out2(O2)&gt;
      partition_copy(Rng&amp;&amp; rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    I partition_point(I first, S last, Pred pred, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
    safe_iterator_t&lt;Rng&gt;
      partition_point(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

  <span class='comment'>// <a href='alg.sorting'>[alg.sorting]</a>, sorting and related operations:
</span>  <span class='comment'>// <a href='alg.sort'>[alg.sort]</a>, sorting:
</span>  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      stable_sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      partial_sort(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                   Proj proj = Proj{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
      class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
        IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
    I2
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, RandomAccessRange Rng2, class Comp = less&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt; &amp;&amp;
        Sortable&lt;iterator_t&lt;Rng2&gt;, Comp, Proj2&gt; &amp;&amp;
        IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
          projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt;
    safe_iterator_t&lt;Rng2&gt;
      partial_sort_copy(Rng1&amp;&amp; rng, Rng2&amp;&amp; result_rng, Comp comp = Comp{},
                        Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      is_sorted(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      is_sorted_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      nth_element(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; nth, Comp comp = Comp{}, Proj proj = Proj{});

  <span class='comment'>// <a href='alg.binary.search'>[alg.binary.search]</a>, binary search:
</span>  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I
      lower_bound(I first, S last, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      lower_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I
      upper_bound(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      upper_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
      equal_range(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
                tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
      equal_range(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      binary_search(I first, S last, const T&amp; value, Comp comp = Comp{},
                    Proj proj = Proj{});

  template &lt;ForwardRange Rng, class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      binary_search(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{},
                    Proj proj = Proj{});

  <span class='comment'>// <a href='alg.merge'>[alg.merge]</a>, merge:
</span>  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity,
      class Proj2 = identity&gt;
    requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
      merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
            Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O, class Comp = less&lt;&gt;,
      class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
                 tag::in2(safe_iterator_t&lt;Rng2&gt;),
                 tag::out(O)&gt;
      merge(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
            Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I
      inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      inplace_merge(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                    Proj proj = Proj{});

  <span class='comment'>// <a href='alg.set.operations'>[alg.set.operations]</a>, set operations:
</span>  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
        projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      includes(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
      set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
      class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
                 tag::in2(safe_iterator_t&lt;Rng2&gt;),
                 tag::out(O)&gt;
      set_union(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
    O
      set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
      class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
    O
      set_intersection(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
    tagged_pair&lt;tag::in1(I1), tag::out(O)&gt;
      set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
      class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
    tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::out(O)&gt;
      set_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
      set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                               Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                               Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
      class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
    tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
                 tag::in2(safe_iterator_t&lt;Rng2&gt;),
                 tag::out(O)&gt;
      set_symmetric_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
                               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  <span class='comment'>// <a href='alg.heap.operations'>[alg.heap.operations]</a>, heap operations:
</span>  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I push_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      push_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      pop_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      make_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    I sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    safe_iterator_t&lt;Rng&gt;
      sort_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      is_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;RandomAccessRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      is_heap_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  <span class='comment'>// <a href='alg.min.max'>[alg.min.max]</a>, minimum and maximum:
</span>  template &lt;class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;Copyable T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
    value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
      min(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;Copyable T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
    value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
      max(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;class T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr tagged_pair&lt;tag::min(const T&amp;), tag::max(const T&amp;)&gt;
      minmax(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;Copyable T, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    constexpr tagged_pair&lt;tag::min(T), tag::max(T)&gt;
      minmax(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;InputRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
    tagged_pair&lt;tag::min(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;),
                tag::max(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;)&gt;
      minmax(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      min_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    safe_iterator_t&lt;Rng&gt;
      max_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    tagged_pair&lt;tag::min(I), tag::max(I)&gt;
      minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;ForwardRange Rng, class Proj = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
    tagged_pair&lt;tag::min(safe_iterator_t&lt;Rng&gt;),
                tag::max(safe_iterator_t&lt;Rng&gt;)&gt;
      minmax_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
        projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
    bool
      lexicographical_compare(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

  <span class='comment'>// <a href='alg.permutation.generators'>[alg.permutation.generators]</a>, permutations:
</span>  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    bool next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    bool
      next_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    bool prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

  template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
      class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
    bool
      prev_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
}}}}
</pre></div><div class='para' id='general-3'><div class='marginalizedparent'><a class='marginalized' href='#general-3'>3</a></div><p >All of the algorithms are separated from the particular implementations of data structures and are
parameterized by iterator types.
Because of this, they can work with program-defined data structures, as long
as these data structures have iterator types satisfying the assumptions on the algorithms.</p></div><div class='para' id='general-4'><div class='marginalizedparent'><a class='marginalized' href='#general-4'>4</a></div><p >For purposes of determining the existence of data races, algorithms shall
not modify objects referenced through an iterator argument unless the
specification requires such modification.</p></div><div class='para' id='general-5'><div class='marginalizedparent'><a class='marginalized' href='#general-5'>5</a></div><p >Both in-place and copying versions are provided for certain
algorithms.<a class='footnotenum' href='#footnote-4'>4</a>
When such a version is provided for <i>algorithm</i> it is called
<i>algorithm<span class='texttt'>_copy</span></i>. Algorithms that take predicates end with the
suffix <span class='texttt'>_if</span> (which follows the suffix <span class='texttt'>_copy</span>).</p></div><div class='para' id='general-6'><div class='marginalizedparent'><a class='marginalized' href='#general-6'>6</a></div><p >[&nbsp;<i>Note:</i>
Unless otherwise specified, algorithms that take function objects as arguments
are permitted to copy those function objects freely. Programmers for whom object
identity is important should consider using a wrapper class that points to a
noncopied implementation object such as <span class='texttt'>reference_wrapper&lt;T&gt;</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/refwrap'>[refwrap]</a>), or some equivalent solution.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='general-7'><div class='marginalizedparent'><a class='marginalized' href='#general-7'>7</a></div><p >In the description of the algorithms operators
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
are used for some of the iterator categories for which
they do not have to be defined.
In these cases the semantics of
<span class='texttt'>a+n</span>
is the same as that of</p><pre class='codeblock'>
X tmp = a;
advance(tmp, n);
return tmp;
</pre><p >and that of
<span class='texttt'>b-a</span>
is the same as of</p><pre class='codeblock'>
return distance(a, b);
</pre></div><div class='para' id='general-8'><div class='marginalizedparent'><a class='marginalized' href='#general-8'>8</a></div><p >In the description of algorithm return values, sentinel values are sometimes
returned where an iterator is expected. In these cases, the semantics are as
if the sentinel is converted into an iterator as follows:</p><pre class='codeblock'>
I tmp = first;
while(tmp != last)
  ++tmp;
return tmp;
</pre></div><div class='para' id='general-9'><div class='marginalizedparent'><a class='marginalized' href='#general-9'>9</a></div><p >Overloads of algorithms that take <span class='texttt'>Range</span> arguments (<a href='ranges.range'>[ranges.range]</a>)
behave as if they are implemented by calling <span class='texttt'>begin</span> and <span class='texttt'>end</span> on
the <span class='texttt'>Range</span> and dispatching to the overload that takes separate
iterator and sentinel arguments.</p></div><div class='para' id='general-10'><div class='marginalizedparent'><a class='marginalized' href='#general-10'>10</a></div><p >The number and order of template parameters for algorithm declarations
is unspecified, except where explicitly stated otherwise.</p></div><div class='footnote' id='footnote-4'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-4'>4)</a></div><p >The decision whether to include a copying version was
usually based on complexity considerations. When the cost of doing the operation
dominates the cost of copy, the copying version is not included. For example,
<span class='texttt'>sort_copy</span> is not included because the cost of sorting is much more
significant, and users might as well do <span class='texttt'>copy</span> followed by <span class='texttt'>sort</span>.</p></div></div><div id='alg.tagspec'><h2 ><a class='secnum' href='#alg.tagspec' style='min-width:88pt'>11.2</a> Tag specifiers <a class='abbr_ref' href='alg.tagspec'>[alg.tagspec]</a></h2><p ><code class='itemdecl'>
namespace tag {
  struct in { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct in1 { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct in2 { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct out { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct out1 { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct out2 { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct fun { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct min { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct max { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct begin { <span class='comment'>/* <i>implementation-defined</i> */</span> };
  struct end { <span class='comment'>/* <i>implementation-defined</i> */</span> };
}
</code></p><div class='itemdescr'></div><div class='para' id='alg.tagspec-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.tagspec-1'>1</a></div><div class='itemdescr'><p >In the following description, let <span class='texttt'><span class='math'><span class='mathalpha'>X</span></span></span> be the name of a type in the <span class='texttt'>tag</span>
namespace above.</p></div></div><div class='para' id='alg.tagspec-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.tagspec-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>tag::<span class='math'><span class='mathalpha'>X</span></span></span> is a tag specifier (<a href='taggedtup.tagged'>[taggedtup.tagged]</a>) such that
<span class='texttt'><i>TAGGET</i>(<span class='math'><span class='mathalpha'>D</span></span>, tag::<span class='math'><span class='mathalpha'>X</span></span>, <span class='math'><span class='mathalpha'>N</span></span>)</span> names a tagged getter (<a href='taggedtup.tagged'>[taggedtup.tagged]</a>)
with DerivedCharacteristic <span class='texttt'><span class='math'><span class='mathalpha'>D</span></span></span>, ElementIndex <span class='texttt'><span class='math'><span class='mathalpha'>N</span></span></span>, and ElementName <span class='texttt'><span class='math'><span class='mathalpha'>X</span></span></span>.</p></div></div><div class='para' id='alg.tagspec-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.tagspec-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i> <span class='texttt'>tag::in</span> is a type such that <span class='texttt'><i>TAGGET</i>(<span class='math'><span class='mathalpha'>D</span></span>, tag::in, <span class='math'><span class='mathalpha'>N</span></span>)</span>
names a type with the following interface:</p><pre class='codeblock'>
struct __input_getter {
  constexpr decltype(auto) in() &amp;       { return get&lt;<span class='math'><span class='mathalpha'>N</span></span>&gt;(static_cast&lt;<span class='math'><span class='mathalpha'>D</span></span>&amp;&gt;(*this)); }
  constexpr decltype(auto) in() &amp;&amp;      { return get&lt;<span class='math'><span class='mathalpha'>N</span></span>&gt;(static_cast&lt;<span class='math'><span class='mathalpha'>D</span></span>&amp;&amp;&gt;(*this)); }
  constexpr decltype(auto) in() const &amp; { return get&lt;<span class='math'><span class='mathalpha'>N</span></span>&gt;(static_cast&lt;const <span class='math'><span class='mathalpha'>D</span></span>&amp;&gt;(*this)); }
};
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='alg.nonmodifying'><h2 ><a class='secnum' href='#alg.nonmodifying' style='min-width:88pt'>11.3</a> Non-modifying sequence operations <a class='abbr_ref' href='alg.nonmodifying'>[alg.nonmodifying]</a></h2><div id='alg.all_of'><h3 ><a class='secnum' href='#alg.all_of' style='min-width:103pt'>11.3.1</a> All of <a class='abbr_ref' href='alg.all_of'>[alg.all_of]</a></h3><p ><span class='indexparent'><a class='index' id='all_of'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool all_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool all_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.all_of-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.all_of-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if
<span class='texttt'>[first,last)</span> is empty or if
<span class='texttt'>invoke(pred, invoke(proj, *i))</span>
is <span class='texttt'>true</span> for every iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first,last)</span>,
and <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='alg.all_of-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.all_of-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most <span class='texttt'>last - first</span> applications of the predicate
and <span class='texttt'>last - first</span> applications of the projection.
</p></div></div></div><div id='alg.any_of'><h3 ><a class='secnum' href='#alg.any_of' style='min-width:103pt'>11.3.2</a> Any of <a class='abbr_ref' href='alg.any_of'>[alg.any_of]</a></h3><p ><span class='indexparent'><a class='index' id='any_of'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool any_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool any_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.any_of-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.any_of-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>false</span> if <span class='texttt'>[first,last)</span> is empty or
if there is no iterator <span class='texttt'>i</span> in the range
<span class='texttt'>[first,last)</span> such that
<span class='texttt'>invoke(pred, invoke(proj, *i))</span>
is <span class='texttt'>true</span>, and <span class='texttt'>true</span> otherwise.</p></div></div><div class='para' id='alg.any_of-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.any_of-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most <span class='texttt'>last - first</span> applications of the predicate
and <span class='texttt'>last - first</span> applications of the projection.
</p></div></div></div><div id='alg.none_of'><h3 ><a class='secnum' href='#alg.none_of' style='min-width:103pt'>11.3.3</a> None of <a class='abbr_ref' href='alg.none_of'>[alg.none_of]</a></h3><p ><span class='indexparent'><a class='index' id='none_of'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool none_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool none_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.none_of-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.none_of-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if
<span class='texttt'>[first,last)</span> is empty or if
<span class='texttt'>invoke(pred, invoke(proj, *i))</span>
is <span class='texttt'>false</span> for every iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first,last)</span>,
and <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='alg.none_of-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.none_of-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most <span class='texttt'>last - first</span> applications of the predicate
and <span class='texttt'>last - first</span> applications of the projection.
</p></div></div></div><div id='alg.foreach'><h3 ><a class='secnum' href='#alg.foreach' style='min-width:103pt'>11.3.4</a> For each <a class='abbr_ref' href='alg.foreach'>[alg.foreach]</a></h3><p ><span class='indexparent'><a class='index' id='for_each'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
  tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
    for_each(I first, S last, Fun f, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectInvocable&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Fun&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::fun(Fun)&gt;
    for_each(Rng&amp;&amp; rng, Fun f, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.foreach-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.foreach-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>invoke(f, invoke(proj, *i))</span> for every iterator
<span class='texttt'>i</span> in the range
<span class='texttt'>[first,last)</span>,
starting from
<span class='texttt'>first</span>
and proceeding to
<span class='texttt'>last - 1</span>.
[&nbsp;<i>Note:</i> If the result of
<span class='texttt'>invoke(proj, *i)</span> is a mutable reference, <span class='texttt'>f</span> may apply
nonconstant functions.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='alg.foreach-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.foreach-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, std::move(f)}</span>.</p></div></div><div class='para' id='alg.foreach-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.foreach-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Applies <span class='texttt'>f</span> and <span class='texttt'>proj</span>
exactly
<span class='texttt'>last - first</span>
times.</p></div></div><div class='para' id='alg.foreach-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.foreach-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If <span class='texttt'>f</span> returns a result, the result is ignored.</p></div></div><div class='para' id='alg.foreach-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.foreach-5'>5</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The requirements of this algorithm are more strict than those
specified in   ISO/IEC 14882:2014 &sect;<a href='../n4140/alg.foreach'>[alg.foreach]</a>. This algorithm requires <span class='texttt'>Fun</span> to
satisfy <span class='texttt'>CopyConstructible</span>, whereas the algorithm in the C++ Standard
requires only <span class='texttt'>MoveConstructible</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='alg.find'><h3 ><a class='secnum' href='#alg.find' style='min-width:103pt'>11.3.5</a> Find <a class='abbr_ref' href='alg.find'>[alg.find]</a></h3><p ><span class='indexparent'><a class='index' id='find'></a></span><span class='indexparent'><a class='index' id='find_if'></a></span><span class='indexparent'><a class='index' id='find_if_not'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  I find(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  safe_iterator_t&lt;Rng&gt;
    find(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I find_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    find_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    find_if_not(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.find-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.find-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
for which the following corresponding
conditions hold:
<span class='texttt'>invoke(proj, *i) == value</span>,
<span class='texttt'>invoke(pred, invoke(proj, *i)) != false</span>,
<span class='texttt'>invoke(pred, invoke(proj, *i)) == false</span>.
Returns <span class='texttt'>last</span> if no such iterator is found.</p></div></div><div class='para' id='alg.find-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.find-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.
</p></div></div></div><div id='alg.find.end'><h3 ><a class='secnum' href='#alg.find.end' style='min-width:103pt'>11.3.6</a> Find end <a class='abbr_ref' href='alg.find.end'>[alg.find.end]</a></h3><p ><span class='indexparent'><a class='index' id='find_end'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Proj = identity,
    IndirectRelation&lt;I2, projected&lt;I1, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I1
    find_end(I1 first1, S1 last1, I2 first2, S2 last2,
             Pred pred = Pred{}, Proj proj = Proj{});

template &lt;ForwardRange Rng1, ForwardRange Rng2,
    class Proj = identity,
    IndirectRelation&lt;iterator_t&lt;Rng2&gt;,
      projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng1&gt;
    find_end(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.find.end-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.end-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Finds a subsequence of equal values in a sequence.</p></div></div><div class='para' id='alg.find.end-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.end-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The last iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first1,last1 - (last2 - first2))</span>
such that for every non-negative integer
<span class='texttt'>n &lt; (last2 - first2)</span>,
the following condition holds:
<span class='texttt'>invoke(pred, invoke(proj, *(i + n)), *(first2 + n)) != false</span>.
Returns <span class='texttt'>last1</span>
if
<span class='texttt'>[first2,last2)</span> is empty or if
no such iterator is found.</p></div></div><div class='para' id='alg.find.end-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.end-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)</span>
applications of the corresponding predicate and projection.
</p></div></div></div><div id='alg.find.first.of'><h3 ><a class='secnum' href='#alg.find.first.of' style='min-width:103pt'>11.3.7</a> Find first of <a class='abbr_ref' href='alg.find.first.of'>[alg.find.first.of]</a></h3><p ><span class='indexparent'><a class='index' id='find_first_of'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I1
    find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, ForwardRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng1&gt;
    find_first_of(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.find.first.of-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.first.of-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Finds an element that matches one of a set of values.</p></div></div><div class='para' id='alg.find.first.of-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.first.of-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first1,last1)</span>
such that for some
iterator
<span class='texttt'>j</span>
in the range <span class='texttt'>[first2,last2)</span>
the following condition holds:
<span class='texttt'>invoke(pred, invoke(proj1, *i), invoke(proj2, *j)) != false</span>.
Returns <span class='texttt'>last1</span>
if <span class='texttt'>[first2,last2)</span> is empty or if
no such iterator is found.</p></div></div><div class='para' id='alg.find.first.of-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.find.first.of-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last1-first1) * (last2-first2)</span>
applications of the corresponding predicate and the two projections.
</p></div></div></div><div id='alg.adjacent.find'><h3 ><a class='secnum' href='#alg.adjacent.find' style='min-width:103pt'>11.3.8</a> Adjacent find <a class='abbr_ref' href='alg.adjacent.find'>[alg.adjacent.find]</a></h3><p ><span class='indexparent'><a class='index' id='adjacent_find'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I
    adjacent_find(I first, S last, Pred pred = Pred{},
                  Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    adjacent_find(Rng&amp;&amp; rng, Pred pred = Pred{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.adjacent.find-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.adjacent.find-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
such that both
<span class='texttt'>i</span>
and
<span class='texttt'>i + 1</span>
are in
the range
<span class='texttt'>[first,last)</span>
for which
the following corresponding condition holds:
<span class='texttt'>invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))) != false</span>.
Returns <span class='texttt'>last</span>
if no such iterator is found.</p></div></div><div class='para' id='alg.adjacent.find-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.adjacent.find-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
For a nonempty range, exactly
<span class='texttt'>min((i - first) + 1, (last - first) - 1)</span>
applications of the corresponding predicate, where <span class='texttt'>i</span> is
<span class='texttt'>adjacent_find</span>'s
return value, and no more than twice as many applications of the projection.
</p></div></div></div><div id='alg.count'><h3 ><a class='secnum' href='#alg.count' style='min-width:103pt'>11.3.9</a> Count <a class='abbr_ref' href='alg.count'>[alg.count]</a></h3><p ><span class='indexparent'><a class='index' id='count'></a></span><span class='indexparent'><a class='index' id='count_if'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  difference_type_t&lt;I&gt;
    count(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    count(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  difference_type_t&lt;I&gt;
    count_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    count_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.count-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.count-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Returns the number of iterators
<span class='texttt'>i</span>
in the range <span class='texttt'>[first,last)</span>
for which the following corresponding
conditions hold:
<span class='texttt'>invoke(proj, *i) == value, invoke(pred, invoke(proj, *i)) != false</span>.</p></div></div><div class='para' id='alg.count-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.count-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.
</p></div></div></div><div id='mismatch'><h3 ><a class='secnum' href='#mismatch' style='min-width:103pt'>11.3.10</a> Mismatch <a class='abbr_ref' href='mismatch'>[mismatch]</a></h3><p ><span class='indexparent'><a class='index' id='mismatch'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
    mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
    mismatch(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='mismatch-1'><div class='marginalizedparent'><a class='marginalized' href='#mismatch-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pair of iterators
<span class='texttt'>i</span>
and
<span class='texttt'>j</span>
such that
<span class='texttt'>j == first2 + (i - first1)</span>
and
<span class='texttt'>i</span>
is the first iterator
in the range <span class='texttt'>[first1,last1)</span>
for which the following corresponding conditions hold:</p><ul class='itemize'><li id='mismatch-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mismatch-1.1'>(1.1)</a></div><p ><span class='texttt'>j</span> is in the range <span class='texttt'>[first2, last2)</span>.
</p></li><li id='mismatch-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mismatch-1.2'>(1.2)</a></div><p ><span class='texttt'>!(*i == *(first2 + (i - first1)))</span>
</p></li><li id='mismatch-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mismatch-1.3'>(1.3)</a></div><p ><span class='texttt'>invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1)))) == false</span>
</p></li></ul><p >Returns the pair
<span class='texttt'>first1 + min(last1 - first1, last2 - first2)</span>
and
<span class='texttt'>first2 + min(last1 - first1, last2 - first2)</span>
if such an iterator
<span class='texttt'>i</span>
is not found.</p></div></div><div class='para' id='mismatch-2'><div class='marginalizedparent'><a class='marginalized' href='#mismatch-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>last1 - first1</span>
applications of the corresponding predicate and both projections.
</p></div></div></div><div id='alg.equal'><h3 ><a class='secnum' href='#alg.equal' style='min-width:103pt'>11.3.11</a> Equal <a class='abbr_ref' href='alg.equal'>[alg.equal]</a></h3><p ><span class='indexparent'><a class='index' id='equal'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Pred = equal_to&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
             Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  bool equal(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.equal-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.equal-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
If
<span class='texttt'>last1 - first1 != last2 - first2</span>,
return
<span class='texttt'>false</span>.
Otherwise return
<span class='texttt'>true</span>
if for every iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first1,last1)</span>
the following condition holds:
<span class='texttt'>invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1)))) != false</span>.
Otherwise, returns
<span class='texttt'>false</span>.</p></div></div><div class='para' id='alg.equal-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.equal-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
No applications of the corresponding predicate and projections if
<span class='texttt'>SizedSentinel&lt;S1, I1&gt;</span> is satisfied, and
<span class='texttt'>SizedSentinel&lt;S2, I2&gt;</span> is satisfied,
and
<span class='texttt'>last1 - first1 != last2 - first2</span>.
Otherwise, at most
<span class='texttt'>min(last1 - first1, last2 - first2)</span>
applications of the corresponding predicate and projections.
</p></div></div></div><div id='alg.is_permutation'><h3 ><a class='secnum' href='#alg.is_permutation' style='min-width:103pt'>11.3.12</a> Is permutation <a class='abbr_ref' href='alg.is_permutation'>[alg.is_permutation]</a></h3><p ><span class='indexparent'><a class='index' id='is_permutation'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  bool is_permutation(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.is_permutation-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.is_permutation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>last1 - first1 != last2 - first2</span>, return <span class='texttt'>false</span>.
Otherwise return <span class='texttt'>true</span> if there exists a permutation of the elements in the
range <span class='texttt'>[first2,first2 + (last1 - first1))</span>, beginning with
<span class='texttt'>I2 begin</span>, such that
<span class='texttt'>equal(first1, last1, begin, pred, proj1, proj2)</span> returns <span class='texttt'>true</span>
; otherwise, returns <span class='texttt'>false</span>.</p></div></div><div class='para' id='alg.is_permutation-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.is_permutation-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
No applications of the corresponding predicate and projections if
<span class='texttt'>SizedSentinel&lt;S1, I1&gt;</span> is satisfied, and
<span class='texttt'>SizedSentinel&lt;S2, I2&gt;</span> is satisfied,
and <span class='texttt'>last1 - first1 != last2 - first2</span>.
Otherwise, exactly <span class='texttt'>last1 - first1</span> applications of the
corresponding predicate and projections if
<span class='texttt'>equal(first1, last1, first2, last2, pred, proj1, proj2)</span>
would return <span class='texttt'>true</span>; otherwise, at
worst <span class='math'>ÎŸ(<span class='math'><span class='mathalpha'>N</span><sup >2</sup></span>)</span>, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>last1 - first1</span>.
</p></div></div></div><div id='alg.search'><h3 ><a class='secnum' href='#alg.search' style='min-width:103pt'>11.3.13</a> Search <a class='abbr_ref' href='alg.search'>[alg.search]</a></h3><p ><span class='indexparent'><a class='index' id='search'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  I1
    search(I1 first1, S1 last1, I2 first2, S2 last2,
           Pred pred = Pred{},
           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  safe_iterator_t&lt;Rng1&gt;
    search(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Finds a subsequence of equal values in a sequence.</p></div></div><div class='para' id='alg.search-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first1,last1 - (last2-first2))</span>
such that for every non-negative integer
<span class='texttt'>n</span>
less than
<span class='texttt'>last2 - first2</span>
the following condition holds:
</p><pre class='codeblock'>
invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))) != false.
</pre><p >Returns <span class='texttt'>first1</span>
if <span class='texttt'>[first2,last2)</span> is empty,
otherwise returns <span class='texttt'>last1</span>
if no such iterator is found.</p></div></div><div class='para' id='alg.search-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last1 - first1) * (last2 - first2)</span>
applications of the corresponding predicate and projections.
</p></div></div><p ><span class='indexparent'><a class='index' id='search_n'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T,
    class Pred = equal_to&lt;&gt;, class Proj = identity&gt;
  requires IndirectlyComparable&lt;I, const T*, Pred, Proj&gt;
  I
    search_n(I first, S last, difference_type_t&lt;I&gt; count,
             const T&amp; value, Pred pred = Pred{},
             Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Pred = equal_to&lt;&gt;,
    class Proj = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng&gt;, const T*, Pred, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    search_n(Rng&amp;&amp; rng, difference_type_t&lt;iterator_t&lt;Rng&gt;&gt; count,
             const T&amp; value, Pred pred = Pred{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Finds a subsequence of equal values in a sequence.</p></div></div><div class='para' id='alg.search-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first,last-count)</span>
such that for every non-negative integer
<span class='texttt'>n</span>
less than
<span class='texttt'>count</span>
the following condition holds:
<span class='texttt'>invoke(pred, invoke(proj, *(i + n)), value) != false</span>.
Returns <span class='texttt'>last</span>
if no such iterator is found.</p></div></div><div class='para' id='alg.search-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-6'>6</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.
</p></div></div></div></div><div id='alg.modifying.operations'><h2 ><a class='secnum' href='#alg.modifying.operations' style='min-width:88pt'>11.4</a> Mutating sequence operations <a class='abbr_ref' href='alg.modifying.operations'>[alg.modifying.operations]</a></h2><div id='alg.copy'><h3 ><a class='secnum' href='#alg.copy' style='min-width:103pt'>11.4.1</a> Copy <a class='abbr_ref' href='alg.copy'>[alg.copy]</a></h3><p ><span class='indexparent'><a class='index' id='copy'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy(I first, S last, O result);

template &lt;InputRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    copy(Rng&amp;&amp; rng, O result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.copy-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies elements in the range <span class='texttt'>[first,last)</span> into the range
<span class='texttt'>[result,result + (last - first))</span> starting from <span class='texttt'>first</span> and
proceeding to <span class='texttt'>last</span>. For each non-negative integer
<span class='texttt'>n &lt; (last - first)</span>, performs <span class='texttt'>*(result + n) = *(first + n)</span>.</p></div></div><div class='para' id='alg.copy-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>{last, result + (last - first)}</span>.</p></div></div><div class='para' id='alg.copy-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>result</span> shall not be in the range <span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='alg.copy-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>last - first</span> assignments.
</p></div></div><p ><span class='indexparent'><a class='index' id='copy_n'></a></span><code class='itemdecl'>
template &lt;InputIterator I, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy_n(I first, difference_type_t&lt;I&gt; n, O result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.copy-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> For each non-negative integer
<span class='math'><span class='mathalpha'>i</span> &lt; <span class='mathalpha'>n</span></span>, performs <span class='texttt'>*(result + i) = *(first + i)</span>.</p></div></div><div class='para' id='alg.copy-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>{first + n, result + n}</span>.</p></div></div><div class='para' id='alg.copy-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-7'>7</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>n</span> assignments.
</p></div></div><p ><span class='indexparent'><a class='index' id='copy_n'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.copy-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-8'>8</a></div><div class='itemdescr'><p >Let <span class='math'><span class='mathalpha'>N</span></span> be the number of iterators <span class='texttt'>i</span> in the range <span class='texttt'>[first,last)</span>
for which the condition <span class='texttt'>invoke(pred, invoke(proj, *i))</span> holds.</p></div></div><div class='para' id='alg.copy-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> The ranges <span class='texttt'>[first,last)</span> and <span class='texttt'>[result,result + <span class='math'><span class='mathalpha'>N</span></span>)</span> shall not overlap.</p></div></div><div class='para' id='alg.copy-10'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies all of the elements referred to by the iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first,last)</span>
for which <span class='texttt'>invoke(pred, invoke(proj, *i))</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='alg.copy-11'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>{last, result + <span class='math'><span class='mathalpha'>N</span></span>}</span>.</p></div></div><div class='para' id='alg.copy-12'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-12'>12</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>last - first</span> applications of the corresponding predicate and projection.</p></div></div><div class='para' id='alg.copy-13'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-13'>13</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='copy_backward'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
  requires IndirectlyCopyable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
    copy_backward(I1 first, S1 last, I2 result);

template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, I&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
    copy_backward(Rng&amp;&amp; rng, I result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.copy-14'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies elements in the range <span class='texttt'>[first,last)</span>
into the
range <span class='texttt'>[result - (last-first),result)</span>
starting from
<span class='texttt'>last - 1</span>
and proceeding to <span class='texttt'>first</span>.<a class='footnotenum' href='#footnote-5'>5</a>
For each positive integer
<span class='texttt'>n &lt;= (last - first)</span>,
performs
<span class='texttt'>*(result - n) = *(last - n)</span>.</p></div></div><div class='para' id='alg.copy-15'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>result</span>
shall not be in the range
<span class='texttt'>(first,last]</span>.</p></div></div><div class='para' id='alg.copy-16'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result - (last - first)}</span>.</p></div></div><div class='para' id='alg.copy-17'><div class='marginalizedparent'><a class='marginalized' href='#alg.copy-17'>17</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
assignments.
</p></div></div><div class='footnote' id='footnote-5'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-5'>5)</a></div><p ><span class='texttt'>copy_backward</span>
should be used instead of copy when <span class='texttt'>last</span>
is in
the range
<span class='texttt'>[result - (last - first),result)</span>.</p></div></div><div id='alg.move'><h3 ><a class='secnum' href='#alg.move' style='min-width:103pt'>11.4.2</a> Move <a class='abbr_ref' href='alg.move'>[alg.move]</a></h3><p ><span class='indexparent'><a class='index' id='movemove'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyMovable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    move(I first, S last, O result);

template &lt;InputRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    move(Rng&amp;&amp; rng, O result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.move-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Moves elements in the range <span class='texttt'>[first,last)</span>
into the range <span class='texttt'>[result,result + (last - first))</span>
starting from first and proceeding to last.
For each non-negative integer
<span class='texttt'>n &lt; (last-first)</span>,
performs
<span class='texttt'>*(result + n) = ranges::iter_move(first + n)</span>.</p></div></div><div class='para' id='alg.move-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result + (last - first)}</span>.</p></div></div><div class='para' id='alg.move-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>result</span>
shall not be in the range
<span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='alg.move-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
move assignments.
</p></div></div><p ><span class='indexparent'><a class='index' id='move_backward'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
  requires IndirectlyMovable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
    move_backward(I1 first, S1 last, I2 result);

template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
  requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, I&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
    move_backward(Rng&amp;&amp; rng, I result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.move-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Moves elements in the range <span class='texttt'>[first,last)</span>
into the
range <span class='texttt'>[result - (last-first),result)</span>
starting from
<span class='texttt'>last - 1</span>
and proceeding to first.<a class='footnotenum' href='#footnote-6'>6</a>
For each positive integer
<span class='texttt'>n &lt;= (last - first)</span>,
performs
<span class='texttt'>*(result - n) = ranges::iter_move(last - n)</span>.</p></div></div><div class='para' id='alg.move-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>result</span>
shall not be in the range
<span class='texttt'>(first,last]</span>.</p></div></div><div class='para' id='alg.move-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result - (last - first)}</span>.</p></div></div><div class='para' id='alg.move-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.move-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
assignments.
</p></div></div><div class='footnote' id='footnote-6'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-6'>6)</a></div><p ><span class='texttt'>move_backward</span>
should be used instead of move when last
is in
the range
<span class='texttt'>[result - (last - first),result)</span>.</p></div></div><div id='alg.swap'><h3 ><a class='secnum' href='#alg.swap' style='min-width:103pt'>11.4.3</a> swap <a class='abbr_ref' href='alg.swap'>[alg.swap]</a></h3><p ><span class='indexparent'><a class='index' id='swap_ranges'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
    swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);

template &lt;ForwardRange Rng1, ForwardRange Rng2&gt;
  requires IndirectlySwappable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
    swap_ranges(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2);
</code></p><div class='itemdescr'></div><div class='para' id='alg.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.swap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
For each non-negative integer <span class='texttt'>n &lt; min(last1 - first1, last2 - first2)</span>
performs: <br/>
<span class='texttt'>ranges::iter_swap(first1 + n, first2 + n)</span>.</p></div></div><div class='para' id='alg.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The two ranges <span class='texttt'>[first1,last1)</span>
and
<span class='texttt'>[first2,last2)</span>
shall not overlap.
<span class='texttt'>*(first1 + n)</span> shall be swappable with (<a href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a>)
<span class='texttt'>*(first2 + n)</span>.</p></div></div><div class='para' id='alg.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.swap-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{first1 + n, first2 + n}</span>, where
<span class='texttt'>n</span> is <span class='texttt'>min(last1 - first1, last2 - first2)</span>.</p></div></div><div class='para' id='alg.swap-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.swap-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>min(last1 - first1, last2 - first2)</span>
swaps.
</p></div></div></div><div id='alg.transform'><h3 ><a class='secnum' href='#alg.transform' style='min-width:103pt'>11.4.4</a> Transform <a class='abbr_ref' href='alg.transform'>[alg.transform]</a></h3><p ><span class='indexparent'><a class='index' id='transform'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    CopyConstructible F, class Proj = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I, Proj&gt;)&gt;&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    transform(I first, S last, O result, F op, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, CopyConstructible F,
    class Proj = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
    projected&lt;iterator_t&lt;R&gt;, Proj&gt;)&gt;&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    transform(Rng&amp;&amp; rng, O result, F op, Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I1, Proj1&gt;,
    projected&lt;I2, Proj2&gt;)&gt;&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
            F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    CopyConstructible F, class Proj1 = identity, class Proj2 = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
    projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;, projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;)&gt;&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    transform(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
              F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.transform-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-1'>1</a></div><div class='itemdescr'><p >Let <span class='math'><span class='mathalpha'>N</span></span> be <span class='texttt'>(last1 - first1)</span>
for unary transforms, or <span class='texttt'>min(last1 - first1, last2 - first2) for binary
transforms.</span></p></div></div><div class='para' id='alg.transform-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns through every iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[result,result + <span class='math'><span class='mathalpha'>N</span></span>)</span>
a new
corresponding value equal to
<span class='texttt'>invoke(op, invoke(proj, *(first1 + (i - result))))</span>
or
<span class='texttt'>invoke(binary_op, invoke(proj1, *(first1 + (i - result))), invoke(proj2, *(first2 + (i - result))))</span>.</p></div></div><div class='para' id='alg.transform-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>op</span> and <span class='texttt'>binary_op</span>
shall not invalidate iterators or subranges, or modify elements in the ranges
<span class='texttt'>[first1,first1 + <span class='math'><span class='mathalpha'>N</span></span>]</span>,
<span class='texttt'>[first2,first2 + <span class='math'><span class='mathalpha'>N</span></span>]</span>,
and
<span class='texttt'>[result,result + <span class='math'><span class='mathalpha'>N</span></span>]</span>.<a class='footnotenum' href='#footnote-7'>7</a></p></div></div><div class='para' id='alg.transform-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{first1 + <span class='math'><span class='mathalpha'>N</span></span>, result + <span class='math'><span class='mathalpha'>N</span></span>}</span>
 or <span class='texttt'>make_tagged_tuple&lt;tag::in1, tag::in2, tag::out&gt;(first1 + <span class='math'><span class='mathalpha'>N</span></span>, first2 + <span class='math'><span class='mathalpha'>N</span></span>, result + <span class='math'><span class='mathalpha'>N</span></span>)</span>.</p></div></div><div class='para' id='alg.transform-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'><span class='math'><span class='mathalpha'>N</span></span></span>
applications of
<span class='texttt'>op</span> or <span class='texttt'>binary_op</span> and the corresponding projection(s).</p></div></div><div class='para' id='alg.transform-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.transform-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
<span class='texttt'>result</span> may be equal to <span class='texttt'>first1</span>
in case of unary transform,
or to <span class='texttt'>first1</span> or <span class='texttt'>first2</span>
in case of binary transform.
</p></div></div><div class='footnote' id='footnote-7'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-7'>7)</a></div><p >The use of fully
closed ranges is intentional.</p></div></div><div id='alg.replace'><h3 ><a class='secnum' href='#alg.replace' style='min-width:103pt'>11.4.5</a> Replace <a class='abbr_ref' href='alg.replace'>[alg.replace]</a></h3><p ><span class='indexparent'><a class='index' id='replace'></a></span><span class='indexparent'><a class='index' id='replace_if'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, class Proj = identity&gt;
  requires Writable&lt;I, const T2&amp;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
  I
    replace(I first, S last, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

template &lt;InputRange Rng, class T1, class T2, class Proj = identity&gt;
  requires Writable&lt;iterator_t&lt;Rng&gt;, const T2&amp;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
  safe_iterator_t&lt;Rng&gt;
    replace(Rng&amp;&amp; rng, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Writable&lt;I, const T&amp;&gt;
  I
    replace_if(I first, S last, Pred pred, const T&amp; new_value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Writable&lt;iterator_t&lt;Rng&gt;, const T&amp;&gt;
  safe_iterator_t&lt;Rng&gt;
    replace_if(Rng&amp;&amp; rng, Pred pred, const T&amp; new_value, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.replace-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns <span class='texttt'>new_value</span> through each iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first,last)</span>
when the following corresponding conditions hold:
<span class='texttt'>invoke(proj, *i) == old_value</span>,
<span class='texttt'>invoke(pred, invoke(proj, *i)) != false</span>.</p></div></div><div class='para' id='alg.replace-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>last</span>.</p></div></div><div class='para' id='alg.replace-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='replace_copy'></a></span><span class='indexparent'><a class='index' id='replace_copy_if'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                 Proj proj = Proj{});

template &lt;InputRange Rng, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    replace_copy(Rng&amp;&amp; rng, O result, const T1&amp; old_value, const T2&amp; new_value,
                 Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, OutputIterator&lt;const T&amp;&gt; O,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                    Proj proj = Proj{});

template &lt;InputRange Rng, class T, OutputIterator&lt;const T&amp;&gt; O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    replace_copy_if(Rng&amp;&amp; rng, O result, Pred pred, const T&amp; new_value,
                    Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.replace-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges
<span class='texttt'>[first,last)</span>
and
<span class='texttt'>[result,result + (last - first))</span>
shall not overlap.</p></div></div><div class='para' id='alg.replace-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns to every iterator
<span class='texttt'>i</span>
in the
range
<span class='texttt'>[result,result + (last - first))</span>
either
<span class='texttt'>new_value</span>
or
<span class='texttt'>*(first + (i - result))</span>
depending on whether the following corresponding conditions hold:</p><pre class='codeblock'>
invoke(proj, *(first + (i - result))) == old_value
invoke(pred, invoke(proj, *(first + (i - result)))) != false
</pre></div></div><div class='para' id='alg.replace-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result + (last - first)}</span>.</p></div></div><div class='para' id='alg.replace-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-7'>7</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.
</p></div></div></div><div id='alg.fill'><h3 ><a class='secnum' href='#alg.fill' style='min-width:103pt'>11.4.6</a> Fill <a class='abbr_ref' href='alg.fill'>[alg.fill]</a></h3><p ><span class='indexparent'><a class='index' id='fill'></a></span><span class='indexparent'><a class='index' id='fill_n'></a></span><code class='itemdecl'>
template &lt;class T, OutputIterator&lt;const T&amp;&gt; O, Sentinel&lt;O&gt; S&gt;
  O fill(O first, S last, const T&amp; value);

template &lt;class T, OutputRange&lt;const T&amp;&gt; Rng&gt;
  safe_iterator_t&lt;Rng&gt;
    fill(Rng&amp;&amp; rng, const T&amp; value);

template &lt;class T, OutputIterator&lt;const T&amp;&gt; O&gt;
  O fill_n(O first, difference_type_t&lt;O&gt; n, const T&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='alg.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.fill-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>fill</span> assigns <span class='texttt'>value</span> through all the
iterators in the range <span class='texttt'>[first,last)</span>. <span class='texttt'>fill_n</span>
assigns <span class='texttt'>value</span> through all the iterators in the counted range <span class='texttt'>[first,n)</span>
if <span class='texttt'>n</span> is positive, otherwise it does nothing.</p></div></div><div class='para' id='alg.fill-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.fill-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fill</span> returns <span class='texttt'>last</span>. <span class='texttt'>fill_n</span> returns <span class='texttt'>first + n</span>
for non-negative values of <span class='texttt'>n</span> and <span class='texttt'>first</span> for negative values.</p></div></div><div class='para' id='alg.fill-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.fill-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>,
<span class='texttt'>n</span>, or 0 assignments, respectively.
</p></div></div></div><div id='alg.generate'><h3 ><a class='secnum' href='#alg.generate' style='min-width:103pt'>11.4.7</a> Generate <a class='abbr_ref' href='alg.generate'>[alg.generate]</a></h3><p ><span class='indexparent'><a class='index' id='generate'></a></span><span class='indexparent'><a class='index' id='generate_n'></a></span><code class='itemdecl'>
template &lt;Iterator O, Sentinel&lt;O&gt; S, CopyConstructible F&gt;
    requires Callable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
  O generate(O first, S last, F gen);

template &lt;class Rng, CopyConstructible F&gt;
    requires Callable&lt;F&amp;&gt; &amp;&amp; OutputRange&lt;Rng, result_of_t&lt;F&amp;()&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    generate(Rng&amp;&amp; rng, F gen);

template &lt;Iterator O, CopyConstructible F&gt;
    requires Callable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
  O generate_n(O first, difference_type_t&lt;O&gt; n, F gen);
</code></p><div class='itemdescr'></div><div class='para' id='alg.generate-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.generate-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The generate algorithms invoke the function object <span class='texttt'>gen</span> and assign the
return value of <span class='texttt'>gen</span> through all the iterators in the range
<span class='texttt'>[first,last)</span>. The <span class='texttt'>generate_n</span> algorithm invokes the function object
<span class='texttt'>gen</span> and assigns the return value of <span class='texttt'>gen</span> through all the iterators
in the counted range <span class='texttt'>[first,n)</span> if <span class='texttt'>n</span> is positive, otherwise it does
nothing.</p></div></div><div class='para' id='alg.generate-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.generate-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>last</span>, where <span class='texttt'>last</span> is <span class='texttt'>first + max(n, 0)</span> for <span class='texttt'>generate_n</span>.</p></div></div><div class='para' id='alg.generate-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.generate-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly <span class='texttt'>last - first</span> or <span class='texttt'>n</span> evaluations of <span class='texttt'>invoke(gen)</span> and
assignments, respectively.
</p></div></div></div><div id='alg.remove'><h3 ><a class='secnum' href='#alg.remove' style='min-width:103pt'>11.4.8</a> Remove <a class='abbr_ref' href='alg.remove'>[alg.remove]</a></h3><p ><span class='indexparent'><a class='index' id='remove'></a></span><span class='indexparent'><a class='index' id='remove_if'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  I remove(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  safe_iterator_t&lt;Rng&gt;
    remove(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
  I remove_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    remove_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.remove-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Eliminates all the elements referred to by iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first,last)</span>
for which the following corresponding conditions hold:
<span class='texttt'>invoke(proj, *i) == value</span>,
<span class='texttt'>invoke(pred, invoke(proj, *i)) != false</span>.</p></div></div><div class='para' id='alg.remove-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The end of the resulting range.</p></div></div><div class='para' id='alg.remove-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).</p></div></div><div class='para' id='alg.remove-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.</p></div></div><div class='para' id='alg.remove-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-5'>5</a></div><div class='itemdescr'><p ><i>Note:</i> each element in the range <span class='texttt'>[ret,last)</span>, where <span class='texttt'>ret</span> is
the returned value, has a valid but unspecified state, because the algorithms
can eliminate elements by moving from elements that were originally
in that range.
</p></div></div><p ><span class='indexparent'><a class='index' id='remove_copy'></a></span><span class='indexparent'><a class='index' id='remove_copy_if'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class T,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    remove_copy(I first, S last, O result, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class T, class Proj = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    remove_copy(Rng&amp;&amp; rng, O result, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    remove_copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.remove-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges
<span class='texttt'>[first,last)</span>
and
<span class='texttt'>[result,result + (last - first))</span>
shall not overlap.</p></div></div><div class='para' id='alg.remove-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies all the elements referred to by the iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
for which the following corresponding conditions do not hold:
<span class='texttt'>invoke(proj, *i) == value</span>,
<span class='texttt'>invoke(pred, invoke(proj, *i)) != false</span>.</p></div></div><div class='para' id='alg.remove-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pair consisting of <span class='texttt'>last</span> and the end of the resulting range.</p></div></div><div class='para' id='alg.remove-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-9'>9</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
applications of the corresponding predicate and projection.</p></div></div><div class='para' id='alg.remove-10'><div class='marginalizedparent'><a class='marginalized' href='#alg.remove-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).
</p></div></div></div><div id='alg.unique'><h3 ><a class='secnum' href='#alg.unique' style='min-width:103pt'>11.4.9</a> Unique <a class='abbr_ref' href='alg.unique'>[alg.unique]</a></h3><p ><span class='indexparent'><a class='index' id='unique'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires Permutable&lt;I&gt;
  I unique(I first, S last, R comp = R{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    unique(Rng&amp;&amp; rng, R comp = R{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.unique-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
For a nonempty range, eliminates all but the first element from every
consecutive group of equivalent elements referred to by the iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first + 1,last)</span>
for which the following conditions hold:
<span class='texttt'>invoke(proj, *(i - 1)) == invoke(proj, *i)</span>
or
<span class='texttt'>invoke(pred, invoke(proj, *(i - 1)), invoke(proj, *i)) != false</span>.</p></div></div><div class='para' id='alg.unique-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The end of the resulting range.</p></div></div><div class='para' id='alg.unique-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
For nonempty ranges, exactly
<span class='texttt'>(last - first) - 1</span>
applications of the corresponding predicate and no more than twice as many
applications of the projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_copy'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    class Proj = identity, IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    (ForwardIterator&lt;I&gt; ||
     (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;I&gt;, value_type_t&lt;O&gt;&gt;) ||
     IndirectlyCopyableStorable&lt;I, O&gt;)
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    unique_copy(I first, S last, O result, R comp = R{}, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    (ForwardIterator&lt;iterator_t&lt;Rng&gt;&gt; ||
     (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;, value_type_t&lt;O&gt;&gt;) ||
     IndirectlyCopyableStorable&lt;iterator_t&lt;Rng&gt;, O&gt;)
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    unique_copy(Rng&amp;&amp; rng, O result, R comp = R{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.unique-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges
<span class='texttt'>[first,last)</span>
and
<span class='texttt'>[result,result+(last-first))</span>
shall not overlap.</p></div></div><div class='para' id='alg.unique-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies only the first element from every consecutive group of equal elements referred to by
the iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
for which the following corresponding conditions hold:
</p><pre class='codeblock'>
invoke(proj, *i) == invoke(proj, *(i - 1))
</pre><p >or
</p><pre class='codeblock'>
invoke(pred, invoke(proj, *i), invoke(proj, *(i - 1))) != false.
</pre></div></div><div class='para' id='alg.unique-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pair consisting of <span class='texttt'>last</span> and the end of the resulting range.</p></div></div><div class='para' id='alg.unique-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.unique-7'>7</a></div><div class='itemdescr'><p ><i>Complexity:</i>
For nonempty ranges, exactly
<span class='texttt'>last - first - 1</span>
applications of the corresponding predicate and no more than twice as many
applications of the projection.
</p></div></div></div><div id='alg.reverse'><h3 ><a class='secnum' href='#alg.reverse' style='min-width:103pt'>11.4.10</a> Reverse <a class='abbr_ref' href='alg.reverse'>[alg.reverse]</a></h3><p ><span class='indexparent'><a class='index' id='reverse'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S&gt;
  requires Permutable&lt;I&gt;
  I reverse(I first, S last);

template &lt;BidirectionalRange Rng&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    reverse(Rng&amp;&amp; rng);
</code></p><div class='itemdescr'></div><div class='para' id='alg.reverse-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
For each non-negative integer
<span class='texttt'>i &lt; (last - first)/2</span>,
applies
<span class='texttt'>iter_swap</span>
to all pairs of iterators
<span class='texttt'>first + i, (last - i) - 1</span>.</p></div></div><div class='para' id='alg.reverse-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='alg.reverse-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>(last - first)/2</span>
swaps.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse_copy'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt; reverse_copy(I first, S last, O result);

template &lt;BidirectionalRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    reverse_copy(Rng&amp;&amp; rng, O result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.reverse-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies the range
<span class='texttt'>[first,last)</span>
to the range
<span class='texttt'>[result,result+(last-first))</span>
such that
for every non-negative integer
<span class='texttt'>i &lt; (last - first)</span>
the following assignment takes place:
<span class='texttt'>*(result + (last - first) - 1 - i) = *(first + i)</span>.</p></div></div><div class='para' id='alg.reverse-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges
<span class='texttt'>[first,last)</span>
and
<span class='texttt'>[result,result+(last-first))</span>
shall not overlap.</p></div></div><div class='para' id='alg.reverse-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result + (last - first)}</span>.</p></div></div><div class='para' id='alg.reverse-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.reverse-7'>7</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
assignments.
</p></div></div></div><div id='alg.rotate'><h3 ><a class='secnum' href='#alg.rotate' style='min-width:103pt'>11.4.11</a> Rotate <a class='abbr_ref' href='alg.rotate'>[alg.rotate]</a></h3><p ><span class='indexparent'><a class='index' id='rotate'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S&gt;
  requires Permutable&lt;I&gt;
  tagged_pair&lt;tag::begin(I), tag::end(I)&gt; rotate(I first, I middle, S last);

template &lt;ForwardRange Rng&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;), tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
    rotate(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle);
</code></p><div class='itemdescr'></div><div class='para' id='alg.rotate-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
For each non-negative integer
<span class='texttt'>i &lt; (last - first)</span>,
places the element from the position
<span class='texttt'>first + i</span>
into position
<span class='texttt'>first + (i + (last - middle)) % (last - first)</span>.</p></div></div><div class='para' id='alg.rotate-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>{first + (last - middle), last}</span>.</p></div></div><div class='para' id='alg.rotate-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This is a left rotate.</p></div></div><div class='para' id='alg.rotate-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>[first,middle)</span>
and
<span class='texttt'>[middle,last)</span>
shall be valid ranges.</p></div></div><div class='para' id='alg.rotate-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>last - first</span>
swaps.
</p></div></div><p ><span class='indexparent'><a class='index' id='rotate_copy'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    rotate_copy(I first, I middle, S last, O result);

template &lt;ForwardRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    rotate_copy(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, O result);
</code></p><div class='itemdescr'></div><div class='para' id='alg.rotate-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies the range
<span class='texttt'>[first,last)</span>
to the range
<span class='texttt'>[result,result + (last - first))</span>
such that for each non-negative integer
<span class='texttt'>i &lt; (last - first)</span>
the following assignment takes place:
<span class='texttt'>*(result + i) =  *(first +
(i + (middle - first)) % (last - first))</span>.</p></div></div><div class='para' id='alg.rotate-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last, result + (last - first)}</span>.</p></div></div><div class='para' id='alg.rotate-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges
<span class='texttt'>[first,last)</span>
and
<span class='texttt'>[result,result + (last - first))</span>
shall not overlap.</p></div></div><div class='para' id='alg.rotate-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.rotate-9'>9</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>last - first</span>
assignments.
</p></div></div></div><div id='alg.random.shuffle'><h3 ><a class='secnum' href='#alg.random.shuffle' style='min-width:103pt'>11.4.12</a> Shuffle <a class='abbr_ref' href='alg.random.shuffle'>[alg.random.shuffle]</a></h3><p ><span class='indexparent'><a class='index' id='shuffle'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Gen&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
  I shuffle(I first, S last, Gen&amp;&amp; g);

template &lt;RandomAccessRange Rng, class Gen&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    shuffle(Rng&amp;&amp; rng, Gen&amp;&amp; g);
</code></p><div class='itemdescr'></div><div class='para' id='alg.random.shuffle-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.random.shuffle-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Permutes the elements in the range
<span class='texttt'>[first,last)</span>
such that each possible permutation of those elements has equal probability of appearance.</p></div></div><div class='para' id='alg.random.shuffle-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.random.shuffle-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>(last - first) - 1</span>
swaps.</p></div></div><div class='para' id='alg.random.shuffle-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.random.shuffle-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='alg.random.shuffle-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.random.shuffle-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
To the extent that the implementation of this function makes use of random
numbers, the object <span class='texttt'>g</span> shall serve as the implementation's source of
randomness.</p></div></div></div><div id='alg.partitions'><h3 ><a class='secnum' href='#alg.partitions' style='min-width:103pt'>11.4.13</a> Partitions <a class='abbr_ref' href='alg.partitions'>[alg.partitions]</a></h3><p ><span class='indexparent'><a class='index' id='is_partitioned'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool
    is_partitioned(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.partitions-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if
<span class='texttt'>[first,last)</span> is empty or if
<span class='texttt'>[first,last)</span> is partitioned by <span class='texttt'>pred</span> and <span class='texttt'>proj</span>, i.e. if all
iterators <span class='texttt'>i</span> for which
<span class='texttt'>invoke(pred, invoke(proj, *i)) != false</span> come before those that do not,
for every <span class='texttt'>i</span> in <span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='alg.partitions-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear. At most <span class='texttt'>last - first</span> applications of <span class='texttt'>pred</span> and <span class='texttt'>proj</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='partition'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
  I partition(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.partitions-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Permutes the elements in the range <span class='texttt'>[first,last)</span> such that there exists an iterator <span class='texttt'>i</span>
such that for every iterator <span class='texttt'>j</span> in the range <span class='texttt'>[first,i)</span>
<span class='texttt'>invoke(pred, invoke(proj, *j)) != false</span>, and for every iterator <span class='texttt'>k</span> in the
range <span class='texttt'>[i,last)</span>, <span class='texttt'>invoke(pred, invoke(proj, *k)) == false</span>.</p></div></div><div class='para' id='alg.partitions-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator <span class='texttt'>i</span> such that for every iterator <span class='texttt'>j</span> in the range <span class='texttt'>[first,i)</span>
<span class='texttt'>invoke(pred, invoke(proj, *j)) != false</span>,
and for every iterator <span class='texttt'>k</span> in the range <span class='texttt'>[i,last)</span>,
<span class='texttt'>invoke(pred, invoke(proj, *k)) == false</span>.</p></div></div><div class='para' id='alg.partitions-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> If I meets the requirements for a BidirectionalIterator, at most
<span class='texttt'>(last - first) / 2</span> swaps; otherwise at most <span class='texttt'>last - first</span> swaps.
Exactly <span class='texttt'>last - first</span> applications of the predicate and projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='stable_partition'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
  I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    stable_partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.partitions-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Permutes the elements in the range <span class='texttt'>[first,last)</span> such that there exists an iterator <span class='texttt'>i</span>
such that for every iterator <span class='texttt'>j</span> in the range <span class='texttt'>[first,i)</span>
<span class='texttt'>invoke(pred, invoke(proj, *j)) != false</span>, and for every iterator <span class='texttt'>k</span> in the
range <span class='texttt'>[i,last)</span>, <span class='texttt'>invoke(pred, invoke(proj, *k)) == false</span>.</p></div></div><div class='para' id='alg.partitions-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator
<span class='texttt'>i</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,i)</span>,
<span class='texttt'>invoke(pred, invoke(proj, *j)) != false</span>,
and for every iterator
<span class='texttt'>k</span>
in the range
<span class='texttt'>[i,last)</span>,
<span class='texttt'>invoke(pred, invoke(proj, *k)) == false</span>.
The relative order of the elements in both groups is preserved.</p></div></div><div class='para' id='alg.partitions-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last - first) * log(last - first)</span>
swaps, but only linear number of swaps if there is enough extra memory.
Exactly
<span class='texttt'>last - first</span>
applications of the predicate and projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='partition_copy'></a></span><code class='itemdecl'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O1, WeaklyIncrementable O2,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O1&gt; &amp;&amp; IndirectlyCopyable&lt;I, O2&gt;
  tagged_tuple&lt;tag::in(I), tag::out1(O1), tag::out2(O2)&gt;
    partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                   Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,
    class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp;
    IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O2&gt;
  tagged_tuple&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out1(O1), tag::out2(O2)&gt;
    partition_copy(Rng&amp;&amp; rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.partitions-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> The input range shall not overlap with
either of the output ranges.</p></div></div><div class='para' id='alg.partitions-10'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> For each iterator <span class='texttt'>i</span> in <span class='texttt'>[first,last)</span>, copies <span class='texttt'>*i</span> to the output range
beginning with <span class='texttt'>out_true</span> if
<span class='texttt'>invoke(pred, invoke(proj, *i))</span> is <span class='texttt'>true</span>, or to
the output range beginning with <span class='texttt'>out_false</span> otherwise.</p></div></div><div class='para' id='alg.partitions-11'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> A tuple <span class='texttt'>p</span> such that <span class='texttt'>get&lt;0&gt;(p)</span> is <span class='texttt'>last</span>,
<span class='texttt'>get&lt;1&gt;(p)</span> is the end of the output range beginning at <span class='texttt'>out_true</span>,
and <span class='texttt'>get&lt;2&gt;(p)</span> is the end of the output range beginning at <span class='texttt'>out_false</span>.</p></div></div><div class='para' id='alg.partitions-12'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-12'>12</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>last - first</span> applications of <span class='texttt'>pred</span> and <span class='texttt'>proj</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='partition_point'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I partition_point(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    partition_point(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.partitions-13'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>[first,last)</span> shall be partitioned by <span class='texttt'>pred</span> and <span class='texttt'>proj</span>, i.e.
there shall be an iterator <span class='texttt'>mid</span> such that
<span class='texttt'>all_of(first, mid, pred, proj)</span> and <span class='texttt'>none_of(mid, last, pred, proj)</span>
are both true.</p></div></div><div class='para' id='alg.partitions-14'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator <span class='texttt'>mid</span> such that <span class='texttt'>all_of(first, mid, pred, proj)</span> and
<span class='texttt'>none_of(mid, last, pred, proj)</span> are both true.</p></div></div><div class='para' id='alg.partitions-15'><div class='marginalizedparent'><a class='marginalized' href='#alg.partitions-15'>15</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>ÎŸ(<span class='math'><span class="mathrm">log</span>(<span class='texttt'>last - first</span>)</span>)</span> applications of <span class='texttt'>pred</span> and <span class='texttt'>proj</span>.
</p></div></div></div></div><div id='alg.sorting'><h2 ><a class='secnum' href='#alg.sorting' style='min-width:88pt'>11.5</a> Sorting and related operations <a class='abbr_ref' href='alg.sorting'>[alg.sorting]</a></h2><div class='para' id='alg.sorting-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.sorting-1'>1</a></div><p >All the operations in <a href='alg.sorting'>[alg.sorting]</a> take an optional binary callable predicate of type <span class='texttt'>Comp</span> that defaults to <span class='texttt'>less&lt;&gt;</span>.</p></div><div class='para' id='alg.sorting-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.sorting-2'>2</a></div><p ><span class='texttt'>Comp</span>
is a callable object (  ISO/IEC 14882:2014 &sect;<a href='../n4140/func.require'>[func.require]</a>). The return value of the <span class='texttt'>invoke</span> operation applied to
an object of type <span class='texttt'>Comp</span>, when contextually converted to
<span class='texttt'>bool</span> (Clause   ISO/IEC 14882:2014 &sect;<a href='../n4140/conv'>[conv]</a>),
yields <span class='texttt'>true</span> if the first argument of the call
is less than the second, and
<span class='texttt'>false</span>
otherwise.
<span class='texttt'>Comp comp</span>
is used throughout for algorithms assuming an ordering relation.
It is assumed that
<span class='texttt'>comp</span>
will not apply any non-constant function through the dereferenced iterator.</p></div><div class='para' id='alg.sorting-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.sorting-3'>3</a></div><p >A sequence is
<i>sorted with respect to a comparator and projection</i>
<span class='texttt'>comp</span> and <span class='texttt'>proj</span> if for every iterator
<span class='texttt'>i</span>
pointing to the sequence and every non-negative integer
<span class='texttt'>n</span>
such that
<span class='texttt'>i + n</span>
is a valid iterator pointing to an element of the sequence,
<span class='texttt'>invoke(comp, invoke(proj, *(i + n)), invoke(proj, *i)) == false</span>.</p></div><div class='para' id='alg.sorting-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.sorting-4'>4</a></div><p >A sequence
<span class='texttt'>[start,finish)</span>
is
<i>partitioned with respect to an expression</i>
<span class='texttt'>f(e)</span>
if there exists an integer
<span class='texttt'>n</span>
such that for all
<span class='texttt'>0 &lt;= i &lt; distance(start, finish)</span>,
<span class='texttt'>f(*(start + i))</span>
is true if and only if
<span class='texttt'>i &lt; n</span>.</p></div><div class='para' id='alg.sorting-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.sorting-5'>5</a></div><p >In the descriptions of the functions that deal with ordering relationships we frequently use a notion of
equivalence to describe concepts such as stability.
The equivalence to which we refer is not necessarily an
<span class='texttt'>operator==</span>,
but an equivalence relation induced by the strict weak ordering.
That is, two elements
<span class='texttt'>a</span>
and
<span class='texttt'>b</span>
are considered equivalent if and only if
<span class='texttt'>!(a &lt; b) &amp;&amp; !(b &lt; a)</span>.</p></div><div id='alg.sort'><h3 ><a class='secnum' href='#alg.sort' style='min-width:103pt'>11.5.1</a> Sorting <a class='abbr_ref' href='alg.sort'>[alg.sort]</a></h3><div id='sort'><h4 ><a class='secnum' href='#sort' style='min-width:118pt'>11.5.1.1</a> <span class='texttt'>sort</span> <a class='abbr_ref' href='sort'>[sort]</a></h4><p ><span class='indexparent'><a class='index' id='sort'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='sort-1'><div class='marginalizedparent'><a class='marginalized' href='#sort-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sorts the elements in the range
<span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='sort-2'><div class='marginalizedparent'><a class='marginalized' href='#sort-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='sort-3'><div class='marginalizedparent'><a class='marginalized' href='#sort-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
<span class='math'>ÎŸ(<span class='math'><span class='mathalpha'>N</span><span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>)</span>
(where
<span class='texttt'><span class='math'><span class='mathalpha'>N</span></span> == last - first</span>)
comparisons, and twice as many applications of the projection.
</p></div></div></div><div id='stable.sort'><h4 ><a class='secnum' href='#stable.sort' style='min-width:118pt'>11.5.1.2</a> <span class='texttt'>stable_sort</span> <a class='abbr_ref' href='stable.sort'>[stable.sort]</a></h4><p ><span class='indexparent'><a class='index' id='stable_sort'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    stable_sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='stable.sort-1'><div class='marginalizedparent'><a class='marginalized' href='#stable.sort-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sorts the elements in the range <span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='stable.sort-2'><div class='marginalizedparent'><a class='marginalized' href='#stable.sort-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='stable.sort-3'><div class='marginalizedparent'><a class='marginalized' href='#stable.sort-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Let <span class='texttt'><span class='math'><span class='mathalpha'>N</span></span> == last - first</span>.
If enough extra memory is available, <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span> comparisons.
Otherwise, at most <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span><sup >2</sup>(<span class='mathalpha'>N</span>)</span> comparisons.
In either case, twice as many applications of the projection as the number of
comparisons.</p></div></div><div class='para' id='stable.sort-4'><div class='marginalizedparent'><a class='marginalized' href='#stable.sort-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).
</p></div></div></div><div id='partial.sort'><h4 ><a class='secnum' href='#partial.sort' style='min-width:118pt'>11.5.1.3</a> <span class='texttt'>partial_sort</span> <a class='abbr_ref' href='partial.sort'>[partial.sort]</a></h4><p ><span class='indexparent'><a class='index' id='partial_sort'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    partial_sort(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                 Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='partial.sort-1'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Places the first
<span class='texttt'>middle - first</span>
sorted elements from the range
<span class='texttt'>[first,last)</span>
into the range
<span class='texttt'>[first,middle)</span>.
The rest of the elements in the range
<span class='texttt'>[middle,last)</span>
are placed in an unspecified order.
<span class='indexparent'><a class='index' id='unspecified'></a></span>
</p></div></div><div class='para' id='partial.sort-2'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='partial.sort-3'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
It takes approximately
<span class='texttt'>(last - first) * log(middle - first)</span>
comparisons, and exactly twice as many applications of the projection.
</p></div></div></div><div id='partial.sort.copy'><h4 ><a class='secnum' href='#partial.sort.copy' style='min-width:118pt'>11.5.1.4</a> <span class='texttt'>partial_sort_copy</span> <a class='abbr_ref' href='partial.sort.copy'>[partial.sort.copy]</a></h4><p ><span class='indexparent'><a class='index' id='partial_sort_copy'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
      IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
  I2
    partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                      Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, RandomAccessRange Rng2, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt; &amp;&amp;
      Sortable&lt;iterator_t&lt;Rng2&gt;, Comp, Proj2&gt; &amp;&amp;
      IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
        projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt;
  safe_iterator_t&lt;Rng2&gt;
    partial_sort_copy(Rng1&amp;&amp; rng, Rng2&amp;&amp; result_rng, Comp comp = Comp{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='partial.sort.copy-1'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort.copy-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Places the first
<span class='texttt'>min(last - first, result_last - result_first)</span>
sorted elements into the range
<span class='texttt'>[result_first,result_first + min(last - first, result_last - result_first))</span>.</p></div></div><div class='para' id='partial.sort.copy-2'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort.copy-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smaller of:
<span class='texttt'>result_last</span> or
<span class='texttt'>result_first + (last - first)</span>.</p></div></div><div class='para' id='partial.sort.copy-3'><div class='marginalizedparent'><a class='marginalized' href='#partial.sort.copy-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Approximately
<span class='texttt'>(last - first) * log(min(last - first, result_last - result_first))</span>
comparisons, and exactly twice as many applications of the projection.
</p></div></div></div><div id='is.sorted'><h4 ><a class='secnum' href='#is.sorted' style='min-width:118pt'>11.5.1.5</a> <span class='texttt'>is_sorted</span> <a class='abbr_ref' href='is.sorted'>[is.sorted]</a></h4><p ><span class='indexparent'><a class='index' id='is_sorted'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    is_sorted(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='is.sorted-1'><div class='marginalizedparent'><a class='marginalized' href='#is.sorted-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_sorted_until(first, last, comp, proj) == last</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='is_sorted_until'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    is_sorted_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='is.sorted-2'><div class='marginalizedparent'><a class='marginalized' href='#is.sorted-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>distance(first, last) &lt; 2</span>, returns
<span class='texttt'>last</span>. Otherwise, returns
the last iterator <span class='texttt'>i</span> in <span class='texttt'>[first,last]</span> for which the
range <span class='texttt'>[first,i)</span> is sorted.</p></div></div><div class='para' id='is.sorted-3'><div class='marginalizedparent'><a class='marginalized' href='#is.sorted-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear.
</p></div></div></div></div><div id='alg.nth.element'><h3 ><a class='secnum' href='#alg.nth.element' style='min-width:103pt'>11.5.2</a> Nth element <a class='abbr_ref' href='alg.nth.element'>[alg.nth.element]</a></h3><p ><span class='indexparent'><a class='index' id='nth_element'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    nth_element(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; nth, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.nth.element-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.nth.element-1'>1</a></div><div class='itemdescr'><p >After
<span class='texttt'>nth_element</span>
the element in the position pointed to by <span class='texttt'>nth</span>
is the element that would be
in that position if the whole range were sorted, unless <span class='texttt'>nth == last</span>.
Also for every iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,nth)</span>
and every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[nth,last)</span>
it holds that:
<span class='texttt'>invoke(comp, invoke(proj, *j), invoke(proj, *i)) == false</span>.</p></div></div><div class='para' id='alg.nth.element-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.nth.element-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span>.</p></div></div><div class='para' id='alg.nth.element-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.nth.element-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear on average.
</p></div></div></div><div id='alg.binary.search'><h3 ><a class='secnum' href='#alg.binary.search' style='min-width:103pt'>11.5.3</a> Binary search <a class='abbr_ref' href='alg.binary.search'>[alg.binary.search]</a></h3><div class='para' id='alg.binary.search-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.binary.search-1'>1</a></div><p >All of the algorithms in this section are versions of binary search
and assume that the sequence being searched is partitioned with respect to
an expression formed by binding the search key to an argument of the
comparison function and projection.
They work on non-random access iterators minimizing the number of comparisons,
which will be logarithmic for all types of iterators.
They are especially appropriate for random access iterators,
because these algorithms do a logarithmic number of steps
through the data structure.
For non-random access iterators they execute a linear number of steps.</p></div><div id='lower.bound'><h4 ><a class='secnum' href='#lower.bound' style='min-width:118pt'>11.5.3.1</a> <span class='texttt'>lower_bound</span> <a class='abbr_ref' href='lower.bound'>[lower.bound]</a></h4><p ><span class='indexparent'><a class='index' id='lower_bound'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    lower_bound(I first, S last, const T&amp; value, Comp comp = Comp{},
                Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    lower_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='lower.bound-1'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expression
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>.</p></div></div><div class='para' id='lower.bound-2'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The furthermost iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last]</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,i)</span>
the following corresponding condition holds:
<span class='texttt'>invoke(comp, invoke(proj, *j), value) != false</span>.</p></div></div><div class='para' id='lower.bound-3'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>ÎŸ(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='upper.bound'><h4 ><a class='secnum' href='#upper.bound' style='min-width:118pt'>11.5.3.2</a> <span class='texttt'>upper_bound</span> <a class='abbr_ref' href='upper.bound'>[upper.bound]</a></h4><p ><span class='indexparent'><a class='index' id='upper_bound'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    upper_bound(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    upper_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='upper.bound-1'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expression
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='upper.bound-2'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The furthermost iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last]</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,i)</span>
the following corresponding condition holds:
<span class='texttt'>invoke(comp, value, invoke(proj, *j)) == false</span>.</p></div></div><div class='para' id='upper.bound-3'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>ÎŸ(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='equal.range'><h4 ><a class='secnum' href='#equal.range' style='min-width:118pt'>11.5.3.3</a> <span class='texttt'>equal_range</span> <a class='abbr_ref' href='equal.range'>[equal.range]</a></h4><p ><span class='indexparent'><a class='index' id='equal_range'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
    equal_range(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
              tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
    equal_range(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='equal.range-1'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expressions
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
and
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.
Also, for all elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first, last)</span>,
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
shall imply
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='equal.range-2'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
</pre></div></div><div class='para' id='equal.range-3'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'>2 * <span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>ÎŸ(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='binary.search'><h4 ><a class='secnum' href='#binary.search' style='min-width:118pt'>11.5.3.4</a> <span class='texttt'>binary_search</span> <a class='abbr_ref' href='binary.search'>[binary.search]</a></h4><p ><span class='indexparent'><a class='index' id='binary_search'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(I first, S last, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='binary.search-1'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
are partitioned with respect to the expressions
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
and
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.
Also, for all elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first, last)</span>,
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
shall imply
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='binary.search-2'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if there is an iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
that satisfies the corresponding conditions:
<span class='texttt'>
invoke(comp, invoke(proj, *i), value) == false &amp;&amp;
invoke(comp, value, invoke(proj, *i)) == false</span>.</p></div></div><div class='para' id='binary.search-3'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>ÎŸ(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div></div><div id='alg.merge'><h3 ><a class='secnum' href='#alg.merge' style='min-width:103pt'>11.5.4</a> Merge <a class='abbr_ref' href='alg.merge'>[alg.merge]</a></h3><p ><span class='indexparent'><a class='index' id='merge'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    merge(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.merge-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies all the elements of the two ranges <span class='texttt'>[first1,last1)</span> and
<span class='texttt'>[first2,last2)</span> into the range <span class='texttt'>[result,result_last)</span>, where <span class='texttt'>result_last</span>
is <span class='texttt'>result + (last1 - first1) + (last2 - first2)</span>.
If an element <span class='texttt'>a</span> precedes <span class='texttt'>b</span> in an input range,
<span class='texttt'>a</span> is copied into the output range before <span class='texttt'>b</span>. If <span class='texttt'>e1</span> is
an element of <span class='texttt'>[first1,last1)</span> and <span class='texttt'>e2</span> of <span class='texttt'>[first2,last2)</span>,
<span class='texttt'>e2</span> is copied into the output range before <span class='texttt'>e1</span> if and only if
<span class='texttt'>bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))</span> is
<span class='texttt'>true</span>.</p></div></div><div class='para' id='alg.merge-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> The ranges <span class='texttt'>[first1,last1)</span> and <span class='texttt'>[first2,last2)</span> shall be
sorted with respect to <span class='texttt'>comp</span>, <span class='texttt'>proj1</span>, and <span class='texttt'>proj2</span>.
The resulting range shall not overlap with either of the original ranges.</p></div></div><div class='para' id='alg.merge-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>make_tagged_tuple&lt;tag::in1, tag::in2, tag::out&gt;(last1, last2, result_last)</span>.</p></div></div><div class='para' id='alg.merge-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last1 - first1) + (last2 - first2) - 1</span>
applications of the comparison function and each projection.</p></div></div><div class='para' id='alg.merge-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='inplace_merge'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I
    inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    inplace_merge(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                  Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.merge-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Merges two sorted consecutive ranges
<span class='texttt'>[first,middle)</span>
and
<span class='texttt'>[middle,last)</span>,
putting the result of the merge into the range
<span class='texttt'>[first,last)</span>.
The resulting range will be in non-decreasing order;
that is, for every iterator
<span class='texttt'>i</span>
in
<span class='texttt'>[first,last)</span>
other than
<span class='texttt'>first</span>,
the condition
<span class='texttt'>invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1)))</span>
will be false.</p></div></div><div class='para' id='alg.merge-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i>
The ranges <span class='texttt'>[first,middle)</span> and <span class='texttt'>[middle,last)</span> shall be
sorted with respect to <span class='texttt'>comp</span> and <span class='texttt'>proj</span>.</p></div></div><div class='para' id='alg.merge-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='alg.merge-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-9'>9</a></div><div class='itemdescr'><p ><i>Complexity:</i>
When enough additional memory is available,
<span class='texttt'>(last - first) - 1</span>
applications of the comparison function and projection.
If no additional memory is available, an algorithm with complexity
<span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>
(where
<span class='texttt'>N</span>
is equal to
<span class='texttt'>last - first</span>)
may be used.</p></div></div><div class='para' id='alg.merge-10'><div class='marginalizedparent'><a class='marginalized' href='#alg.merge-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i> Stable (  ISO/IEC 14882:2014 &sect;<a href='../n4140/algorithm.stable'>[algorithm.stable]</a>).
</p></div></div></div><div id='alg.set.operations'><h3 ><a class='secnum' href='#alg.set.operations' style='min-width:103pt'>11.5.5</a> Set operations on sorted structures <a class='abbr_ref' href='alg.set.operations'>[alg.set.operations]</a></h3><div class='para' id='alg.set.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.set.operations-1'>1</a></div><p >This section defines all the basic set operations on sorted structures.
They also work with
<span class='texttt'>multiset</span>s (  ISO/IEC 14882:2014 &sect;<a href='../n4140/multiset'>[multiset]</a>)
containing multiple copies of equivalent elements.
The semantics of the set operations are generalized to
<span class='texttt'>multiset</span>s
in a standard way by defining
<span class='texttt'>set_union()</span>
to contain the maximum number of occurrences of every element,
<span class='texttt'>set_intersection()</span>
to contain the minimum, and so on.</p></div><div id='includes'><h4 ><a class='secnum' href='#includes' style='min-width:118pt'>11.5.5.1</a> <span class='texttt'>includes</span> <a class='abbr_ref' href='includes'>[includes]</a></h4><p ><span class='indexparent'><a class='index' id='includes'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    includes(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='includes-1'><div class='marginalizedparent'><a class='marginalized' href='#includes-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if <span class='texttt'>[first2,last2)</span> is empty or
if every element in the range
<span class='texttt'>[first2,last2)</span>
is contained in the range
<span class='texttt'>[first1,last1)</span>.
Returns
<span class='texttt'>false</span>
otherwise.</p></div></div><div class='para' id='includes-2'><div class='marginalizedparent'><a class='marginalized' href='#includes-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * ((last1 - first1) + (last2 - first2)) - 1</span>
applications of the comparison function and projections.
</p></div></div></div><div id='set.union'><h4 ><a class='secnum' href='#set.union' style='min-width:118pt'>11.5.5.2</a> <span class='texttt'>set_union</span> <a class='abbr_ref' href='set.union'>[set.union]</a></h4><p ><span class='indexparent'><a class='index' id='set_union'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    set_union(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='set.union-1'><div class='marginalizedparent'><a class='marginalized' href='#set.union-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a sorted union of the elements from the two ranges;
that is, the set of elements that are present in one or both of the ranges.</p></div></div><div class='para' id='set.union-2'><div class='marginalizedparent'><a class='marginalized' href='#set.union-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The resulting range shall not overlap with either of the original ranges.</p></div></div><div class='para' id='set.union-3'><div class='marginalizedparent'><a class='marginalized' href='#set.union-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>make_tagged_tuple&lt;tag::in1, tag::in2, tag::out&gt;(last1, last2, result + <span class='math'><span class='mathalpha'>n</span></span>)</span>, <br/> where <span class='texttt'><span class='math'><span class='mathalpha'>n</span></span></span> is
the number of elements in the constructed range.</p></div></div><div class='para' id='set.union-4'><div class='marginalizedparent'><a class='marginalized' href='#set.union-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * ((last1 - first1) + (last2 - first2)) - 1</span>
applications of the comparison function and projections.</p></div></div><div class='para' id='set.union-5'><div class='marginalizedparent'><a class='marginalized' href='#set.union-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>[first1,last1)</span> contains <span class='math'><span class='mathalpha'>m</span></span> elements that are equivalent to
each other and <span class='texttt'>[first2,last2)</span> contains <span class='math'><span class='mathalpha'>n</span></span> elements that are equivalent
to them, then all <span class='math'><span class='mathalpha'>m</span></span> elements from the first range shall be copied to the output
range, in order, and then <span class='math'><span class="mathrm">max</span>(<span class='mathalpha'>n</span> - <span class='mathalpha'>m</span>, 0)</span> elements from the second range shall
be copied to the output range, in order.
</p></div></div></div><div id='set.intersection'><h4 ><a class='secnum' href='#set.intersection' style='min-width:118pt'>11.5.5.3</a> <span class='texttt'>set_intersection</span> <a class='abbr_ref' href='set.intersection'>[set.intersection]</a></h4><p ><span class='indexparent'><a class='index' id='set_intersection'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  O
    set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  O
    set_intersection(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='set.intersection-1'><div class='marginalizedparent'><a class='marginalized' href='#set.intersection-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a sorted intersection of the elements from the two ranges;
that is, the set of elements that are present in both of the ranges.</p></div></div><div class='para' id='set.intersection-2'><div class='marginalizedparent'><a class='marginalized' href='#set.intersection-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The resulting range shall not overlap with either of the original ranges.</p></div></div><div class='para' id='set.intersection-3'><div class='marginalizedparent'><a class='marginalized' href='#set.intersection-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
The end of the constructed range.</p></div></div><div class='para' id='set.intersection-4'><div class='marginalizedparent'><a class='marginalized' href='#set.intersection-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * ((last1 - first1) + (last2 - first2)) - 1</span>
applications of the comparison function and projections.</p></div></div><div class='para' id='set.intersection-5'><div class='marginalizedparent'><a class='marginalized' href='#set.intersection-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> If <span class='texttt'>[first1,last1)</span> contains <span class='math'><span class='mathalpha'>m</span></span> elements that are equivalent to
each other and <span class='texttt'>[first2,last2)</span> contains <span class='math'><span class='mathalpha'>n</span></span> elements that are equivalent
to them, the first <span class='math'><span class="mathrm">min</span>(<span class='mathalpha'>m</span>, <span class='mathalpha'>n</span>)</span> elements shall be copied from the first range
to the output range, in order.
</p></div></div></div><div id='set.difference'><h4 ><a class='secnum' href='#set.difference' style='min-width:118pt'>11.5.5.4</a> <span class='texttt'>set_difference</span> <a class='abbr_ref' href='set.difference'>[set.difference]</a></h4><p ><span class='indexparent'><a class='index' id='set_difference'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_pair&lt;tag::in1(I1), tag::out(O)&gt;
    set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                   Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::out(O)&gt;
    set_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                   Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='set.difference-1'><div class='marginalizedparent'><a class='marginalized' href='#set.difference-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies the elements of the range
<span class='texttt'>[first1,last1)</span>
which are not present in the range
<span class='texttt'>[first2,last2)</span>
to the range beginning at
<span class='texttt'>result</span>.
The elements in the constructed range are sorted.</p></div></div><div class='para' id='set.difference-2'><div class='marginalizedparent'><a class='marginalized' href='#set.difference-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The resulting range shall not overlap with either of the original ranges.</p></div></div><div class='para' id='set.difference-3'><div class='marginalizedparent'><a class='marginalized' href='#set.difference-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{last1, result + <span class='math'><span class='mathalpha'>n</span></span>}</span>, where <span class='math'><span class='mathalpha'>n</span></span>
is the number of elements in the constructed range.</p></div></div><div class='para' id='set.difference-4'><div class='marginalizedparent'><a class='marginalized' href='#set.difference-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * ((last1 - first1) + (last2 - first2)) - 1</span>
applications of the comparison function and projections.</p></div></div><div class='para' id='set.difference-5'><div class='marginalizedparent'><a class='marginalized' href='#set.difference-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If
<span class='texttt'>[first1,last1)</span>
contains <span class='math'><span class='mathalpha'>m</span></span>
elements that are equivalent to each other and
<span class='texttt'>[first2,last2)</span>
contains <span class='math'><span class='mathalpha'>n</span></span>
elements that are equivalent to them, the last
<span class='math'><span class="mathrm">max</span>(<span class='mathalpha'>m</span> - <span class='mathalpha'>n</span>, 0)</span>
elements from
<span class='texttt'>[first1,last1)</span>
shall be copied to the output range.
</p></div></div></div><div id='set.symmetric.difference'><h4 ><a class='secnum' href='#set.symmetric.difference' style='min-width:118pt'>11.5.5.5</a> <span class='texttt'>set_symmetric_difference</span> <a class='abbr_ref' href='set.symmetric.difference'>[set.symmetric.difference]</a></h4><p ><span class='indexparent'><a class='index' id='set_symmetric_difference'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                             Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    set_symmetric_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
                             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='set.symmetric.difference-1'><div class='marginalizedparent'><a class='marginalized' href='#set.symmetric.difference-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Copies the elements of the range
<span class='texttt'>[first1,last1)</span>
that are not present in the range
<span class='texttt'>[first2,last2)</span>,
and the elements of the range
<span class='texttt'>[first2,last2)</span>
that are not present in the range
<span class='texttt'>[first1,last1)</span>
to the range beginning at
<span class='texttt'>result</span>.
The elements in the constructed range are sorted.</p></div></div><div class='para' id='set.symmetric.difference-2'><div class='marginalizedparent'><a class='marginalized' href='#set.symmetric.difference-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The resulting range shall not overlap with either of the original ranges.</p></div></div><div class='para' id='set.symmetric.difference-3'><div class='marginalizedparent'><a class='marginalized' href='#set.symmetric.difference-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>make_tagged_tuple&lt;tag::in1, tag::in2, tag::out&gt;(last1, last2, result + <span class='math'><span class='mathalpha'>n</span></span>)</span>, <br/> where <span class='texttt'><span class='math'><span class='mathalpha'>n</span></span></span> is
the number of elements in the constructed range.</p></div></div><div class='para' id='set.symmetric.difference-4'><div class='marginalizedparent'><a class='marginalized' href='#set.symmetric.difference-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * ((last1 - first1) + (last2 - first2)) - 1</span>
applications of the comparison function and projections.</p></div></div><div class='para' id='set.symmetric.difference-5'><div class='marginalizedparent'><a class='marginalized' href='#set.symmetric.difference-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If <span class='texttt'>[first1,last1)</span> contains <span class='math'><span class='mathalpha'>m</span></span> elements that are equivalent to each other and
<span class='texttt'>[first2,last2)</span> contains <span class='math'><span class='mathalpha'>n</span></span> elements that are equivalent to them, then
<span class='math'>|<span class='mathalpha'>m</span> - <span class='mathalpha'>n</span>|</span> of those elements shall be copied to the output range: the last
<span class='math'><span class='mathalpha'>m</span> - <span class='mathalpha'>n</span></span> of these elements from <span class='texttt'>[first1,last1)</span> if <span class='math'><span class='mathalpha'>m</span> &gt; <span class='mathalpha'>n</span></span>, and the last
<span class='math'><span class='mathalpha'>n</span> - <span class='mathalpha'>m</span></span> of these elements from <span class='texttt'>[first2,last2)</span> if <span class='math'><span class='mathalpha'>m</span> &lt; <span class='mathalpha'>n</span></span>.
</p></div></div></div></div><div id='alg.heap.operations'><h3 ><a class='secnum' href='#alg.heap.operations' style='min-width:103pt'>11.5.6</a> Heap operations <a class='abbr_ref' href='alg.heap.operations'>[alg.heap.operations]</a></h3><div class='para' id='alg.heap.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.heap.operations-1'>1</a></div><p >A
<i>heap</i>
is a particular organization of elements in a range between two random access iterators
<span class='texttt'>[a,b)</span>.
Its two key properties are:</p><ul class='description'><li id='alg.heap.operations-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#alg.heap.operations-1.1'>(1.1)</a></div><p >There is no element greater than
<span class='texttt'>*a</span>
in the range and
</p></li><li id='alg.heap.operations-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#alg.heap.operations-1.2'>(1.2)</a></div><p ><span class='texttt'>*a</span>
may be removed by
<span class='texttt'>pop_heap()</span>,
or a new element added by
<span class='texttt'>push_heap()</span>,
in
<span class='math'>ÎŸ(<span class='math'><span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>)</span>
time.
</p></li></ul></div><div class='para' id='alg.heap.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.heap.operations-2'>2</a></div><p >These properties make heaps useful as priority queues.</p></div><div class='para' id='alg.heap.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.heap.operations-3'>3</a></div><p ><span class='texttt'>make_heap()</span>
converts a range into a heap and
<span class='texttt'>sort_heap()</span>
turns a heap into a sorted sequence.</p></div><div id='push.heap'><h4 ><a class='secnum' href='#push.heap' style='min-width:118pt'>11.5.6.1</a> <span class='texttt'>push_heap</span> <a class='abbr_ref' href='push.heap'>[push.heap]</a></h4><p ><span class='indexparent'><a class='index' id='push_heap'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I push_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    push_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='push.heap-1'><div class='marginalizedparent'><a class='marginalized' href='#push.heap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Places the value in the location
<span class='texttt'>last - 1</span>
into the resulting heap
<span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='push.heap-2'><div class='marginalizedparent'><a class='marginalized' href='#push.heap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
The range
<span class='texttt'>[first,last - 1)</span>
shall be a valid heap.</p></div></div><div class='para' id='push.heap-3'><div class='marginalizedparent'><a class='marginalized' href='#push.heap-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='push.heap-4'><div class='marginalizedparent'><a class='marginalized' href='#push.heap-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>log(last - first)</span>
applications of the comparison function and projection.
</p></div></div></div><div id='pop.heap'><h4 ><a class='secnum' href='#pop.heap' style='min-width:118pt'>11.5.6.2</a> <span class='texttt'>pop_heap</span> <a class='abbr_ref' href='pop.heap'>[pop.heap]</a></h4><p ><span class='indexparent'><a class='index' id='pop_heap'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    pop_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='pop.heap-1'><div class='marginalizedparent'><a class='marginalized' href='#pop.heap-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The range
<span class='texttt'>[first,last)</span>
shall be a valid non-empty heap.</p></div></div><div class='para' id='pop.heap-2'><div class='marginalizedparent'><a class='marginalized' href='#pop.heap-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Swaps the value in the location <span class='texttt'>first</span>
with the value in the location
<span class='texttt'>last - 1</span>
and makes
<span class='texttt'>[first,last - 1)</span>
into a heap.</p></div></div><div class='para' id='pop.heap-3'><div class='marginalizedparent'><a class='marginalized' href='#pop.heap-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='pop.heap-4'><div class='marginalizedparent'><a class='marginalized' href='#pop.heap-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2 * log(last - first)</span>
applications of the comparison function and projection.
</p></div></div></div><div id='make.heap'><h4 ><a class='secnum' href='#make.heap' style='min-width:118pt'>11.5.6.3</a> <span class='texttt'>make_heap</span> <a class='abbr_ref' href='make.heap'>[make.heap]</a></h4><p ><span class='indexparent'><a class='index' id='make_heap'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    make_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='make.heap-1'><div class='marginalizedparent'><a class='marginalized' href='#make.heap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a heap out of the range
<span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='make.heap-2'><div class='marginalizedparent'><a class='marginalized' href='#make.heap-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='make.heap-3'><div class='marginalizedparent'><a class='marginalized' href='#make.heap-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>3 * (last - first)</span>
applications of the comparison function and projection.
</p></div></div></div><div id='sort.heap'><h4 ><a class='secnum' href='#sort.heap' style='min-width:118pt'>11.5.6.4</a> <span class='texttt'>sort_heap</span> <a class='abbr_ref' href='sort.heap'>[sort.heap]</a></h4><p ><span class='indexparent'><a class='index' id='sort_heap'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    sort_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='sort.heap-1'><div class='marginalizedparent'><a class='marginalized' href='#sort.heap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Sorts elements in the heap
<span class='texttt'>[first,last)</span>.</p></div></div><div class='para' id='sort.heap-2'><div class='marginalizedparent'><a class='marginalized' href='#sort.heap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> The range <span class='texttt'>[first,last)</span> shall be a valid heap.</p></div></div><div class='para' id='sort.heap-3'><div class='marginalizedparent'><a class='marginalized' href='#sort.heap-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span></p></div></div><div class='para' id='sort.heap-4'><div class='marginalizedparent'><a class='marginalized' href='#sort.heap-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>
comparisons (where
<span class='texttt'>N == last - first</span>), and exactly twice as many applications of the projection.
</p></div></div></div><div id='is.heap'><h4 ><a class='secnum' href='#is.heap' style='min-width:118pt'>11.5.6.5</a> <span class='texttt'>is_heap</span> <a class='abbr_ref' href='is.heap'>[is.heap]</a></h4><p ><span class='indexparent'><a class='index' id='is_heap'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    is_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='is.heap-1'><div class='marginalizedparent'><a class='marginalized' href='#is.heap-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_heap_until(first, last, comp, proj) == last</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='is_heap_until'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    is_heap_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='is.heap-2'><div class='marginalizedparent'><a class='marginalized' href='#is.heap-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>distance(first, last) &lt; 2</span>, returns
<span class='texttt'>last</span>. Otherwise, returns
the last iterator <span class='texttt'>i</span> in <span class='texttt'>[first,last]</span> for which the
range <span class='texttt'>[first,i)</span> is a heap.</p></div></div><div class='para' id='is.heap-3'><div class='marginalizedparent'><a class='marginalized' href='#is.heap-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear.
</p></div></div></div></div><div id='alg.min.max'><h3 ><a class='secnum' href='#alg.min.max' style='min-width:103pt'>11.5.7</a> Minimum and maximum <a class='abbr_ref' href='alg.min.max'>[alg.min.max]</a></h3><p ><span class='indexparent'><a class='index' id='min'></a></span><code class='itemdecl'>
template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smaller value.</p></div></div><div class='para' id='alg.min.max-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Returns the first argument when the arguments are equivalent.
</p></div></div><p ><span class='indexparent'><a class='index' id='min'></a></span><code class='itemdecl'>
template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr T min(initializer_list&lt;T&gt; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    min(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>distance(rng) &gt; 0</span>.</p></div></div><div class='para' id='alg.min.max-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The smallest value in the <span class='texttt'>initializer_list</span> or range.</p></div></div><div class='para' id='alg.min.max-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> Returns a copy of the leftmost argument when several arguments are equivalent to the smallest.
</p></div></div><p ><span class='indexparent'><a class='index' id='max'></a></span><code class='itemdecl'>
template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The larger value.</p></div></div><div class='para' id='alg.min.max-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Returns the first argument when the arguments are equivalent.
</p></div></div><p ><span class='indexparent'><a class='index' id='max'></a></span><code class='itemdecl'>
template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr T max(initializer_list&lt;T&gt; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    max(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>distance(rng) &gt; 0</span>.</p></div></div><div class='para' id='alg.min.max-9'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> The largest value in the <span class='texttt'>initializer_list</span> or range.</p></div></div><div class='para' id='alg.min.max-10'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i> Returns a copy of the leftmost argument when several arguments are equivalent to the largest.
</p></div></div><p ><span class='indexparent'><a class='index' id='minmax'></a></span><code class='itemdecl'>
template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr tagged_pair&lt;tag::min(const T&amp;), tag::max(const T&amp;)&gt;
    minmax(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-11'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{b, a}</span> if <span class='texttt'>b</span> is smaller
than <span class='texttt'>a</span>, and
<span class='texttt'>{a, b}</span> otherwise.</p></div></div><div class='para' id='alg.min.max-12'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-12'>12</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Returns <span class='texttt'>{a, b}</span> when the arguments are equivalent.</p></div></div><div class='para' id='alg.min.max-13'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-13'>13</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly one comparison and exactly two applications of the projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='minmax'></a></span><code class='itemdecl'>
template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr tagged_pair&lt;tag::min(T), tag::max(T)&gt;
    minmax(initializer_list&lt;T&gt; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  tagged_pair&lt;tag::min(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;),
              tag::max(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;)&gt;
    minmax(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-14'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>distance(rng) &gt; 0</span>.</p></div></div><div class='para' id='alg.min.max-15'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>{x, y}</span>, where <span class='texttt'>x</span> has the smallest and <span class='texttt'>y</span> has the
largest value in the <span class='texttt'>initializer_list</span> or range.</p></div></div><div class='para' id='alg.min.max-16'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>x</span> is a copy of the leftmost argument when several arguments are equivalent to
the smallest. <span class='texttt'>y</span> is a copy of the rightmost argument when several arguments are
equivalent to the largest.</p></div></div><div class='para' id='alg.min.max-17'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-17'>17</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most <span class='texttt'>(3/2) * distance(rng)</span>
applications of the corresponding predicate, and at most twice as many applications of the projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='min_element'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    min_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-18'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,last)</span>
the following corresponding condition holds: <br/>
<span class='texttt'>invoke(comp, invoke(proj, *j), invoke(proj, *i)) == false</span>.
Returns
<span class='texttt'>last</span>
if
<span class='texttt'>first == last</span>.</p></div></div><div class='para' id='alg.min.max-19'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-19'>19</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>max((last - first) - 1, 0)</span>
applications of the comparison function and
exactly twice as many applications of the projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_element'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    max_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-20'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,last)</span>
the following corresponding condition holds: <br/>
<span class='texttt'>invoke(comp, invoke(proj, *i), invoke(proj, *j)) == false</span>.
Returns
<span class='texttt'>last</span>
if
<span class='texttt'>first == last</span>.</p></div></div><div class='para' id='alg.min.max-21'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-21'>21</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>max((last - first) - 1, 0)</span>
applications of the comparison function and
exactly twice as many applications of the projection.
</p></div></div><p ><span class='indexparent'><a class='index' id='minmax_element'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::min(I), tag::max(I)&gt;
    minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::min(safe_iterator_t&lt;Rng&gt;),
              tag::max(safe_iterator_t&lt;Rng&gt;)&gt;
    minmax_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.min.max-22'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>{first, first}</span> if <span class='texttt'>[first,last)</span> is empty, otherwise
<span class='texttt'>{m, M}</span>, where <span class='texttt'>m</span> is
the first iterator in <span class='texttt'>[first,last)</span> such that no iterator in the range refers to a smaller
element, and where <span class='texttt'>M</span> is the last iterator in <span class='texttt'>[first,last)</span> such that no iterator
in the range refers to a larger element.</p></div></div><div class='para' id='alg.min.max-23'><div class='marginalizedparent'><a class='marginalized' href='#alg.min.max-23'>23</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<img src='math/8926210919298738295.png' class='mathinlineimg' alt='$max(\lfloor{\frac{3}{2}} (N-1)\rfloor, 0)$'/>
applications of the comparison function and
at most twice as many applications of the projection,
where <span class='math'><span class='mathalpha'>N</span></span> is <span class='texttt'>distance(first, last)</span>.
</p></div></div></div><div id='alg.lex.comparison'><h3 ><a class='secnum' href='#alg.lex.comparison' style='min-width:103pt'>11.5.8</a> Lexicographical comparison <a class='abbr_ref' href='alg.lex.comparison'>[alg.lex.comparison]</a></h3><p ><span class='indexparent'><a class='index' id='lexicographical_compare'></a></span><code class='itemdecl'>
template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                            Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    lexicographical_compare(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
                            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.lex.comparison-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.lex.comparison-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if the sequence of elements defined by the range
<span class='texttt'>[first1,last1)</span>
is lexicographically less than the sequence of elements defined by the range
<span class='texttt'>[first2,last2)</span> and
<span class='texttt'>false</span>
otherwise.</p></div></div><div class='para' id='alg.lex.comparison-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.lex.comparison-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>2*min((last1 - first1), (last2 - first2))</span>
applications of the corresponding comparison and projections.</p></div></div><div class='para' id='alg.lex.comparison-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.lex.comparison-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If two sequences have the same number of elements and their corresponding
elements are equivalent, then neither sequence is lexicographically
less than the other.
If one sequence is a prefix of the other, then the shorter sequence is
lexicographically less than the longer sequence.
Otherwise, the lexicographical comparison of the sequences yields the same
result as the comparison of the first corresponding pair of
elements that are not equivalent.</p><pre class='codeblock'>
for ( ; first1 != last1 &amp;&amp; first2 != last2 ; ++first1, (void) ++first2) {
  if (invoke(comp, invoke(proj1, *first1), invoke(proj2, *first2))) return true;
  if (invoke(comp, invoke(proj2, *first2), invoke(proj1, *first1))) return false;
}
return first1 == last1 &amp;&amp; first2 != last2;
</pre></div></div><div class='para' id='alg.lex.comparison-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.lex.comparison-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> An empty sequence is lexicographically less than any non-empty sequence, but
not less than any empty sequence.</p></div></div></div><div id='alg.permutation.generators'><h3 ><a class='secnum' href='#alg.permutation.generators' style='min-width:103pt'>11.5.9</a> Permutation generators <a class='abbr_ref' href='alg.permutation.generators'>[alg.permutation.generators]</a></h3><p ><span class='indexparent'><a class='index' id='next_permutation'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  bool next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  bool
    next_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.permutation.generators-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.permutation.generators-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Takes a sequence defined by the range
<span class='texttt'>[first,last)</span>
and transforms it into the next permutation.
The next permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
<span class='texttt'>comp</span> and <span class='texttt'>proj</span>.
If such a permutation exists, it returns
<span class='texttt'>true</span>.
Otherwise, it transforms the sequence into the smallest permutation,
that is, the ascendingly sorted one, and returns
<span class='texttt'>false</span>.</p></div></div><div class='para' id='alg.permutation.generators-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.permutation.generators-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last - first)/2</span>
swaps.
</p></div></div><p ><span class='indexparent'><a class='index' id='prev_permutation'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  bool prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  bool
    prev_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='alg.permutation.generators-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.permutation.generators-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Takes a sequence defined by the range
<span class='texttt'>[first,last)</span>
and transforms it into the previous permutation.
The previous permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
<span class='texttt'>comp</span> and <span class='texttt'>proj</span>.</p></div></div><div class='para' id='alg.permutation.generators-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.permutation.generators-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if such a permutation exists.
Otherwise, it transforms the sequence into the largest permutation,
that is, the descendingly sorted one, and returns
<span class='texttt'>false</span>.</p></div></div><div class='para' id='alg.permutation.generators-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.permutation.generators-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='texttt'>(last - first)/2</span>
swaps.
</p></div></div></div></div></div></div></body></html>