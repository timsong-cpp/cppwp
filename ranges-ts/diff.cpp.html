<!DOCTYPE html><html lang='en'><head><title>[diff.cpp]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><div id='diff.cpp'><h2 ><a class='secnum' style='min-width:88pt'>D.1</a> C++ and Ranges <a class='abbr_ref'>[diff.cpp]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This section details the known breaking changes likely to effect user code when being ported to the
version of the Standard Library described in this document.</p></div><div id='algo_return'><h3 ><a class='secnum' href='#algo_return' style='min-width:103pt'>D.1.1</a> Algorithm Return Types <a class='abbr_ref' href='diff.cpp.algo_return'>[diff.cpp.algo_return]</a></h3><div class='para' id='algo_return-1'><div class='marginalizedparent'><a class='marginalized' href='#algo_return-1'>1</a></div><p >The algorithms described in this document permit the type of the end sentinel to differ from the
type of the begin iterator. This is so that the algorithms can operate on ranges for which the
physical end position is not yet known.</p></div><div class='para' id='algo_return-2'><div class='marginalizedparent'><a class='marginalized' href='#algo_return-2'>2</a></div><p >The physical end position of the input range is determined during the execution of many of the
algorithms. Rather than lose that potentially useful information, the design presented here has such
algorithms return the iterator position of the end of the range. In many cases, this is a breaking
change. Some algorithms that return iterators in today's STL are changed to return pairs, and
algorithms that return pairs today are changed to return tuples. This is likely to be the most
noticeable breaking change.</p></div><div class='para' id='algo_return-3'><div class='marginalizedparent'><a class='marginalized' href='#algo_return-3'>3</a></div><p >Alternate designs that were less impactful were considered and dismissed. See Section 3.3.6 in
N4128 (<span class='cite'>niebler2014</span>) for a discussion of the issues.</p></div></div><div id='constraints'><h3 ><a class='secnum' href='#constraints' style='min-width:103pt'>D.1.2</a> Stronger Constraints <a class='abbr_ref' href='diff.cpp.constraints'>[diff.cpp.constraints]</a></h3><div class='para' id='constraints-1'><div class='marginalizedparent'><a class='marginalized' href='#constraints-1'>1</a></div><p >In this proposal, many algorithms and utilities get stricter type checking. For example, algorithms
constrained with <span class='texttt'>LessThanComparable</span> today are constrained by <span class='texttt'>StrictTotallyOrdered</span> in this
document. This concept requires types to provide <i>all</i> the relational operators, not just
<span class='texttt'>operator&lt;</span>.</p></div><div class='para' id='constraints-2'><div class='marginalizedparent'><a class='marginalized' href='#constraints-2'>2</a></div><p >The use of coarser-grained, higher-level concepts in algorithm constraints is to make the type
checks more semantic in nature and less syntactic. It also has the benefit of being less verbose
while giving algorithm implementors greater implementation freedom. This approach is in contrast to
the previous effort to add concepts to the Standard Library in the C++0x timeframe, which saw a
proliferation of small, purely syntactic concepts and algorithm constraints that merely restated the
algorithms' implementation details more verbosely in the algorithms' function signatures.</p></div><div class='para' id='constraints-3'><div class='marginalizedparent'><a class='marginalized' href='#constraints-3'>3</a></div><p >The potential for breakage must be carefully weighed against the integrity and complexity of the
constraints system. The coarseness of the concepts may need to change in response to real-world
usage.</p></div></div><div id='functional'><h3 ><a class='secnum' href='#functional' style='min-width:103pt'>D.1.3</a> Constrained Functional Objects <a class='abbr_ref' href='diff.cpp.functional'>[diff.cpp.functional]</a></h3><div class='para' id='functional-1'><div class='marginalizedparent'><a class='marginalized' href='#functional-1'>1</a></div><p >The algorithm design described in this document assumes that the function objects
<span class='texttt'>std::equal_to</span> and <span class='texttt'>std::less</span> get constraints added to their function call operators.
(The former is constrained with <span class='texttt'>EqualityComparable</span> and the latter with
<span class='texttt'>StrictTotallyOrdered</span>). Similar constraints are added to the other function objects
in <span class='texttt'>&lt;functional&gt;</span>. As with the
coarsely-grained algorithm constraints, these function object constraints are likely to cause
user code to break.</p></div><div class='para' id='functional-2'><div class='marginalizedparent'><a class='marginalized' href='#functional-2'>2</a></div><p >Real-world experience is needed to assess the seriousness of the breakage. From a correctness point
of view, the constraints are logical and valuable, but it's possible that for the sake of
compatibility we provide both constrained and unconstrained functional objects.</p></div></div><div id='defaultconstruct'><h3 ><a class='secnum' href='#defaultconstruct' style='min-width:103pt'>D.1.4</a> Iterators and Default-Constructibility <a class='abbr_ref' href='diff.cpp.defaultconstruct'>[diff.cpp.defaultconstruct]</a></h3><div class='para' id='defaultconstruct-1'><div class='marginalizedparent'><a class='marginalized' href='#defaultconstruct-1'>1</a></div><p >In today's STL, iterators need not be default-constructible. The <span class='texttt'>Iterator</span> concept described
in this document requires default-constructibility. This could potentially cause breakage in users'
code. Also, it makes the implementation of some types of iterators more complicated. Any iterator
that has members that are not default constructible (e.g., an iterator that contains a lambda that
has captured by reference) must take special steps to provide default-constructibility (e.g.,
by wrapping non-default-constructible types in something like <span class='texttt'>std::optional</span>, as specified
in the C++17 Working Draft N4618 &sect;20.6). This can weaken class invariants.</p></div><div class='para' id='defaultconstruct-2'><div class='marginalizedparent'><a class='marginalized' href='#defaultconstruct-2'>2</a></div><p >The guarantee of default-constructibility simplifies the implementation of much iterator- and
range-based code that would otherwise need to wrap iterators in <span class='texttt'>std::optional</span>. But the
needs of backward-compatibliity, the extra complexity to iterator implementors, and the weakened
invariants may prove to be too great a burden.</p></div><div class='para' id='defaultconstruct-3'><div class='marginalizedparent'><a class='marginalized' href='#defaultconstruct-3'>3</a></div><p >We may in fact go even farther and remove the requirement of default-constructibility from the
<span class='texttt'>Semiregular</span> concept. Time and experience will give us guidance here.</p></div></div><div id='iteratortraits'><h3 ><a class='secnum' href='#iteratortraits' style='min-width:103pt'>D.1.5</a> iterator_traits cannot be specialized <a class='abbr_ref' href='diff.cpp.iteratortraits'>[diff.cpp.iteratortraits]</a></h3><div class='para' id='iteratortraits-1'><div class='marginalizedparent'><a class='marginalized' href='#iteratortraits-1'>1</a></div><p >In this STL design, <span class='texttt'>iterator_traits</span> changes from being a class template to being an
alias template. This is to intentionally break any code that tries to specialize it. In its place
are the three class templates <span class='texttt'>difference_type</span>, <span class='texttt'>value_type</span>, and
<span class='texttt'>iterator_category</span>. The need for this traits balkanization is because the associated types
belong to separate concepts: <span class='texttt'>difference_type</span> belongs to <span class='texttt'>WeaklyIncrementable</span>;
<span class='texttt'>value_type</span> belongs to <span class='texttt'>Readable</span>; and <span class='texttt'>iterator_category</span> belongs to
<span class='texttt'>InputIterator</span>.</p></div><div class='para' id='iteratortraits-2'><div class='marginalizedparent'><a class='marginalized' href='#iteratortraits-2'>2</a></div><p >This breakage is intentional and inherent in the decomposition of the iterator concepts established
by the Palo Alto report (<span class='cite'>palo-alto</span>).</p></div></div></div></div></body></html>