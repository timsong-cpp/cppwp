<!DOCTYPE html><html lang='en'><head><title>[meta]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='meta'><h2 ><a class='secnum' style='min-width:88pt'>8.4</a> Metaprogramming and type traits <a class='abbr_ref'>[meta]</a></h2><div id='type.synop'><h3 ><a class='secnum' href='#type.synop' style='min-width:103pt'>8.4.1</a> Header <span class='texttt'>&lt;experimental/ranges/type_traits&gt;</span> synopsis <a class='abbr_ref' href='meta.type.synop'>[meta.type.synop]</a></h3><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties:
</span>  template &lt;class T, class U&gt; struct is_swappable_with;
  template &lt;class T&gt; struct is_swappable;

  template &lt;class T, class U&gt; struct is_nothrow_swappable_with;
  template &lt;class T&gt; struct is_nothrow_swappable;

  template &lt;class T, class U&gt; constexpr bool is_swappable_with_v
    = is_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_swappable_v
    = is_swappable&lt;T&gt;::value;

  template &lt;class T, class U&gt; constexpr bool is_nothrow_swappable_with_v
    = is_nothrow_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_swappable_v
    = is_nothrow_swappable&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations:
</span>  template &lt;class... T&gt; struct common_type;
  template &lt;class T, class U, template &lt;class&gt; class TQual, template &lt;class&gt; class UQual&gt;
    struct basic_common_reference { };
  template &lt;class... T&gt; struct common_reference;
  
  template &lt;class... T&gt;
    using common_type_t = typename common_type&lt;T...&gt;::type;
  template &lt;class... T&gt;
    using common_reference_t = typename common_reference&lt;T...&gt;::type;
}}}}
</pre></div><div id='unary.prop'><h3 ><a class='secnum' href='#unary.prop' style='min-width:103pt'>8.4.2</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h3><div class='para' id='unary.prop-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-1'>1</a></div><p >These templates provide access to some of the more important properties of types.</p></div><div class='para' id='unary.prop-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial specializations
of any of these templates.</p></div><div class='para' id='unary.prop-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this subclause, instantiating
that template with a template argument that is a class template specialization may
result in the implicit instantiation of the template argument if and only if the
semantics of <span class='texttt'>X</span> require that the argument must be a complete type.</p></div><div class='para' id='unary.prop-4'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-4'>4</a></div><p >For the purpose of defining the templates in this subclause, a function call
expression <span class='texttt'>declval&lt;T&gt;()</span> for any type <span class='texttt'>T</span> is considered to be a
trivial (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.types'>[basic.types]</a>,   ISO/IEC 14882:2014 &sect;<a href='../n4140/special'>[special]</a>) function call that is not an
odr-use (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.def.odr'>[basic.def.odr]</a>) of <span class='texttt'>declval</span> in the context of the
corresponding definition notwithstanding the restrictions of (  ISO/IEC 14882:2014 &sect;<a href='../n4140/declval'>[declval]</a>).</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>5</a> — Additional type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Precondition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_swappable_with;</span> </td><td class='left'>
  The expressions <span class='texttt'>ranges::swap(</span><span class='texttt'>declval&lt;T&gt;(),</span><span class='texttt'> declval&lt;U&gt;())</span>
  and <span class='texttt'>ranges::swap(</span><span class='texttt'>declval&lt;U&gt;(),</span><span class='texttt'> declval&lt;T&gt;())</span>
  are each well-formed when treated as an unevaluated operand (Clause   ISO/IEC 14882:2014 &sect;<a href='../n4140/expr'>[expr]</a>).
  Access checking is performed as if in a context unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>.
  Only the validity of the immediate context of the <span class='texttt'>swap</span> expressions is
  considered.
  [&nbsp;<i>Note:</i>
  The compilation of the expressions can result in side effects such as the
  instantiation of class template specializations and function template specializations,
  the generation of implicitly-defined functions, and so on. Such side effects are not
  in the “immediate context” and can result in the program being ill-formed.
  <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>, or
  arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_swappable_with_v&lt;</span><span class='texttt'>T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_swappable_with;</span> </td><td class='left'>
  <span class='texttt'>is_swappable_with_v&lt;T, </span><span class='texttt'>U&gt;</span> is <span class='texttt'>true</span> and
  each <span class='texttt'>swap</span> expression of the definition of
  <span class='texttt'>is_swappable_with&lt;T, U&gt;</span> is known not to throw
  any exceptions (  ISO/IEC 14882:2014 &sect;<a href='../n4140/expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>, or
  arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_nothrow_swappable_</span><span class='texttt'>with_v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr></table></div></div></div><div id='trans.other'><h3 ><a class='secnum' href='#trans.other' style='min-width:103pt'>8.4.3</a> Other transformations <a class='abbr_ref' href='meta.trans.other'>[meta.trans.other]</a></h3><div class='numberedTable' id='tab:type-traits.other'>Table <a href='#tab:type-traits.other'>6</a> — Other transformations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
 <span class='texttt'>template &lt;class... T&gt;</span><br/>
 <span class='texttt'>  struct common_type;</span>
 </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be defined or omitted as specified below.
 If it is omitted, there shall be no member <span class='texttt'>type</span>.
 Each type in the parameter pack <span class='texttt'>T</span> shall be complete or
 (possibly <i>cv</i>) <span class='texttt'>void</span>. A program may specialize this trait if at least one
 template parameter in the specialization depends on a
 user-defined type and <span class='texttt'>sizeof...(T) == 2</span>. [&nbsp;<i>Note:</i> Such
 specializations are needed when only explicit conversions are desired among the
 template arguments.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U,</span><br/>
<span class='texttt'>    template &lt;class&gt; class TQual,</span><br/>
<span class='texttt'>    template &lt;class&gt; class UQual&gt;</span><br/>
<span class='texttt'>  struct basic_common_reference;</span> </td><td class='left'>
The primary template shall have no member typedef
<span class='texttt'>type</span>. A program may specialize this trait if at least one
template parameter in the specialization depends on a user-defined
type. In such a specialization, a member typedef <span class='texttt'>type</span> may be
defined or omitted. If it is omitted, there shall be no member
<span class='texttt'>type</span>.
[&nbsp;<i>Note:</i> Such specializations may be used to influence
the result of <span class='texttt'>common_reference</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class... T&gt;</span><br/>
<span class='texttt'>  struct common_reference;</span> </td><td class='left'>
The member typedef <span class='texttt'>type</span> shall be defined or omitted
as specified below. If it is omitted, there shall be no member
<span class='texttt'>type</span>. Each type in the parameter pack <span class='texttt'>T</span> shall be
complete or (possibly <i>cv</i>) <span class='texttt'>void</span>. </td></tr></table></div><div class='para' id='trans.other-1'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-1'>1</a></div><p >Let <span class='texttt'>CREF(A)</span> be <span class='texttt'>add_lvalue_reference_t&lt;const
remove_reference_t&lt;A&gt;&gt;</span>. Let <span class='texttt'>UNCVREF(A)</span> be
<span class='texttt'>remove_cv_t&lt;remove_reference_t&lt;A&gt;&gt;</span>. Let <span class='texttt'>XREF(A)</span>
denote a unary template <span class='texttt'>T</span> such that <span class='texttt'>T&lt;UNCVREF(A)&gt;</span>
denotes the same type as <span class='texttt'>A</span>. Let <span class='texttt'>COPYCV(FROM, TO)</span> be
an alias for type <span class='texttt'>TO</span> with the addition of <span class='texttt'>FROM</span>'s
top-level <i>cv</i>-qualifiers. [&nbsp;<i>Example:</i> <span class='texttt'>COPYCV(const int,
volatile short)</span> is an alias for <span class='texttt'>const volatile short</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] Let <span class='texttt'>RREF_RES(Z)</span> be
<span class='texttt'>remove_reference_t&lt;Z&gt;&amp;&amp;</span> if <span class='texttt'>Z</span> is a reference type
or <span class='texttt'>Z</span> otherwise. Let <span class='texttt'>COND_RES(X, Y)</span> be
<span class='texttt'>decltype(declval&lt;bool&gt;() ? declval&lt;X(&amp;)()&gt;()() : declval&lt;Y(&amp;)()&gt;()())</span>.
Given types <span class='texttt'>A</span> and <span class='texttt'>B</span>, let <span class='texttt'>X</span> be
<span class='texttt'>remove_reference_t&lt;A&gt;</span>, let <span class='texttt'>Y</span> be
<span class='texttt'>remove_reference_t&lt;B&gt;</span>, and let <span class='texttt'>COMMON_REF(A, B)</span> be:
</p><ul class='itemize'><li id='trans.other-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-1.1'>(1.1)</a></div><p >If <span class='texttt'>A</span> and <span class='texttt'>B</span> are both lvalue reference types,
  <span class='texttt'>COMMON_REF(A, B)</span> is
  <span class='texttt'>COND_RES(COPYCV(X, Y) &amp;, COPYCV(Y, X) &amp;)</span>.
</p></li><li id='trans.other-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-1.2'>(1.2)</a></div><p >Otherwise, let <span class='texttt'>C</span> be
  <span class='texttt'>RREF_RES(COMMON_REF(X&amp;, Y&amp;))</span>. If <span class='texttt'>A</span> and <span class='texttt'>B</span>
  are both rvalue reference types, and <span class='texttt'>C</span> is well-formed,
  and <span class='texttt'>is_convertible&lt;A, C&gt;::value</span> and
  <span class='texttt'>is_convertible&lt;B, C&gt;::value</span> are <span class='texttt'>true</span>, then
  <span class='texttt'>COMMON_REF(A, B)</span> is <span class='texttt'>C</span>.
</p></li><li id='trans.other-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-1.3'>(1.3)</a></div><p >Otherwise, let <span class='texttt'>D</span> be
  <span class='texttt'>COMMON_REF(const X&amp;, Y&amp;)</span>. If <span class='texttt'>A</span> is an rvalue
  reference and <span class='texttt'>B</span> is an lvalue reference and <span class='texttt'>D</span> is
  well-formed and <span class='texttt'>is_convertible&lt;A, D&gt;::value</span> is
  <span class='texttt'>true</span>, then <span class='texttt'>COMMON_REF(A, B)</span> is <span class='texttt'>D</span>.
</p></li><li id='trans.other-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-1.4'>(1.4)</a></div><p >Otherwise, if <span class='texttt'>A</span> is an lvalue reference and <span class='texttt'>B</span>
  is an rvalue reference, then <span class='texttt'>COMMON_REF(A, B)</span> is
  <span class='texttt'>COMMON_REF(B, A)</span>.
</p></li><li id='trans.other-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-1.5'>(1.5)</a></div><p >Otherwise, <span class='texttt'>COMMON_REF(A, B)</span> is
  <span class='texttt'>decay_t&lt;COND_RES(CREF(A), CREF(B))&gt;</span>.
</p></li></ul><p >If any of the types computed above are ill-formed, then
<span class='texttt'>COMMON_REF(A, B)</span> is ill-formed.</p></div><div class='para' id='trans.other-2'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-2'>2</a></div><p >Note A: For the <span class='texttt'>common_type</span> trait applied to a parameter pack
<span class='texttt'>T</span> of types, the member <span class='texttt'>type</span> shall be either defined or not
present as follows:
</p><ul class='itemize'><li id='trans.other-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-2.1'>(2.1)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is zero, there shall be no member <span class='texttt'>type</span>.
</p></li><li id='trans.other-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-2.2'>(2.2)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is one, let T1
  denote the sole type in the pack <span class='texttt'>T</span>. The member typedef <span class='texttt'>type</span>
  shall denote the same type as <span class='texttt'>decay_t&lt;T1&gt;</span>.
</p></li><li id='trans.other-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-2.3'>(2.3)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is two, let <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
  denote the two types in the pack <span class='texttt'>T</span>, and let <span class='texttt'>D1</span> and <span class='texttt'>D2</span>
  be <span class='texttt'>decay_t&lt;T1&gt;</span> and <span class='texttt'>decay_t&lt;T2&gt;</span> respectively. Then
</p><ul class='itemize'><li id='trans.other-2.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-2.3.1'>(2.3.1)</a></div><p >If <span class='texttt'>D1</span> and <span class='texttt'>T1</span> denote the same type and <span class='texttt'>D2</span> and
  <span class='texttt'>T2</span> denote the same type, then
</p><ul class='itemize'><li id='trans.other-2.3.1.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#trans.other-2.3.1.1'>(2.3.1.1)</a></div><p >If <span class='texttt'>std::common_type_t&lt;T1, T2&gt;</span> is well-formed, then the member typedef
  <span class='texttt'>type</span> denotes <span class='texttt'>std::common_type_t&lt;T1, T2&gt;</span>.
</p></li><li id='trans.other-2.3.1.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#trans.other-2.3.1.2'>(2.3.1.2)</a></div><p >If <span class='texttt'>COMMON_REF(T1, T2)</span> is well-formed, then the member typedef
  <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-2.3.1.3'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#trans.other-2.3.1.3'>(2.3.1.3)</a></div><p >Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></li><li id='trans.other-2.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-2.3.2'>(2.3.2)</a></div><p >Otherwise, if <span class='texttt'>common_type_t&lt;D1, D2&gt;</span> is well-formed, then the
  member typedef <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-2.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-2.3.3'>(2.3.3)</a></div><p >Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></li><li id='trans.other-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-2.4'>(2.4)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is greater than two,
  let <span class='texttt'>T1</span>, <span class='texttt'>T2</span>, and <span class='texttt'>Rest</span>,
  respectively, denote the first, second, and (pack of) remaining types
  comprising <span class='texttt'>T</span>. Let <span class='texttt'>C</span> be the type
  <span class='texttt'>common_type_t&lt;T1, T2&gt;</span>. Then:
</p><ul class='itemize'><li id='trans.other-2.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-2.4.1'>(2.4.1)</a></div><p >If there is such a type <span class='texttt'>C</span>, the member typedef
  <span class='texttt'>type</span> shall denote the same type, if any, as
  <span class='texttt'>common_type_t&lt;C, Rest...&gt;</span>.
</p></li><li id='trans.other-2.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-2.4.2'>(2.4.2)</a></div><p >Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></li></ul></div><div class='para' id='trans.other-3'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-3'>3</a></div><p >Note B: Notwithstanding the provisions of   ISO/IEC 14882:2014 &sect;<a href='../n4140/meta.type.synop'>[meta.type.synop]</a>, and
pursuant to   ISO/IEC 14882:2014 &sect;<a href='../n4140/namespace.std'>[namespace.std]</a>,
a program may specialize <span class='texttt'>common_type&lt;T1, T2&gt;</span>
for types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> such that
<span class='texttt'>is_same&lt;T1, decay_t&lt;T1&gt;&gt;::value</span> and
<span class='texttt'>is_same&lt;T2, decay_t&lt;T2&gt;&gt;::value</span> are each <span class='texttt'>true</span>.
[&nbsp;<i>Note:</i> Such specializations are needed when only explicit conversions
are desired between the template arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
Such a specialization need not have a member named <span class='texttt'>type</span>,
but if it does, that member shall be a <span class='grammarterm'>typedef-name</span>
for an accessible and unambiguous <i>cv</i>-unqualified non-reference type <span class='texttt'>C</span>
to which each of the types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> is explicitly convertible.
Moreover, <span class='texttt'>common_type_t&lt;T1, T2&gt;</span> shall denote
the same type, if any, as does <span class='texttt'>common_type_t&lt;T2, T1&gt;</span>.
No diagnostic is required for a violation of this Note's rules.</p></div><div class='para' id='trans.other-4'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-4'>4</a></div><p >For the <span class='texttt'>common_reference</span> trait applied to a parameter pack <span class='texttt'>T</span> of
types, the member <span class='texttt'>type</span> shall be either defined or not present as follows:
</p><ul class='itemize'><li id='trans.other-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-4.1'>(4.1)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is zero, there shall be no member <span class='texttt'>type</span>.
</p></li><li id='trans.other-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-4.2'>(4.2)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is one, let <span class='texttt'>T1</span> denote the sole
  type in the pack <span class='texttt'>T</span>. The member typedef <span class='texttt'>type</span> shall denote the
  same type as <span class='texttt'>T1</span>.
</p></li><li id='trans.other-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-4.3'>(4.3)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is two, let <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
  denote the two types in the pack <span class='texttt'>T</span>. Then
</p><ul class='itemize'><li id='trans.other-4.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.3.1'>(4.3.1)</a></div><p >If <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are reference types and
  <span class='texttt'>COMMON_REF(T1, T2)</span> is well-formed and denotes a reference type
  then the member typedef <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-4.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.3.2'>(4.3.2)</a></div><p >Otherwise, if <span class='texttt'>basic_common_reference&lt;UNCVREF(T1), UNCVREF(T2),
  XREF(T1), XREF(T2)&gt;::type</span> is well-formed, then the member typedef
  <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-4.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.3.3'>(4.3.3)</a></div><p >Otherwise, if <span class='texttt'>COND_RES(T1, T2)</span> is well-formed, then the
  member typedef <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-4.3.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.3.4'>(4.3.4)</a></div><p >Otherwise, if <span class='texttt'>common_type_t&lt;T1, T2&gt;</span> is well-formed, then the
  member typedef <span class='texttt'>type</span> denotes that type.
</p></li><li id='trans.other-4.3.5'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.3.5'>(4.3.5)</a></div><p >Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></li><li id='trans.other-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-4.4'>(4.4)</a></div><p >Otherwise, if <span class='texttt'>sizeof...(T)</span> is greater than two, let <span class='texttt'>T1</span>,
  <span class='texttt'>T2</span>, and <span class='texttt'>Rest</span>, respectively, denote the first, second, and
  (pack of) remaining types comprising <span class='texttt'>T</span>. Let <span class='texttt'>C</span> be the type
  <span class='texttt'>common_reference_t&lt;T1, T2&gt;</span>. Then:
</p><ul class='itemize'><li id='trans.other-4.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.4.1'>(4.4.1)</a></div><p >If there is such a type <span class='texttt'>C</span>, the member typedef <span class='texttt'>type</span> shall
  denote the same type, if any, as <span class='texttt'>common_reference_t&lt;C, Rest...&gt;</span>.
</p></li><li id='trans.other-4.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-4.4.2'>(4.4.2)</a></div><p >Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></li></ul></div><div class='para' id='trans.other-5'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-5'>5</a></div><p >Notwithstanding the provisions of   ISO/IEC 14882:2014 &sect;<a href='../n4140/meta.type.synop'>[meta.type.synop]</a>, and
pursuant to   ISO/IEC 14882:2014 &sect;<a href='../n4140/namespace.std'>[namespace.std]</a>,
a program may specialize <span class='texttt'>basic_common_reference&lt;T, U, TQual, UQual&gt;</span>
for types <span class='texttt'>T</span> and <span class='texttt'>U</span> such that
<span class='texttt'>is_same&lt;T, decay_t&lt;T&gt;&gt;::value</span> and
<span class='texttt'>is_same&lt;U, decay_t&lt;U&gt;&gt;::value</span> are each <span class='texttt'>true</span>.
[&nbsp;<i>Note:</i> Such specializations are needed when only explicit conversions
are desired between the template arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
Such a specialization need not have a member named <span class='texttt'>type</span>,
but if it does, that member shall be a <span class='grammarterm'>typedef-name</span>
for an accessible and unambiguous type <span class='texttt'>C</span>
to which each of the types <span class='texttt'>TQual&lt;T&gt;</span> and <span class='texttt'>UQual&lt;U&gt;</span> is convertible.
Moreover, <span class='texttt'>basic_common_reference&lt;T, U, TQual, UQual&gt;::type</span> shall denote
the same type, if any, as does <span class='texttt'>basic_common_reference&lt;U, T, UQual, TQual&gt;::type</span>.
A program may not specialize <span class='texttt'>basic_common_reference</span> on the third or
fourth parameters, <span class='texttt'>TQual</span> or <span class='texttt'>UQual</span>. No diagnostic is required for
a violation of these rules.</p></div></div></div></div></body></html>