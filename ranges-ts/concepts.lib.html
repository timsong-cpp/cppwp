<!DOCTYPE html><html lang='en'><head><title>[concepts.lib]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='concepts.lib'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Concepts library <a class='abbr_ref' href='./#concepts.lib'>[concepts.lib]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>7.1</a> General <a class='abbr_ref' href='concepts.lib.general'>[concepts.lib.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes library components that C++ programs may use to perform
compile-time validation of template parameters and perform function dispatch
based on properties of types. The purpose of these concepts is to establish
a foundation for equational reasoning in programs.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The following subclauses describe core language concepts,
comparison concepts, object concepts, and function concepts
as summarized in Table <a href='#tab:concepts.lib.summary'>[tab:concepts.lib.summary]</a>.</p><div class='numberedTable' id='tab:concepts.lib.summary'>Table <a href='#tab:concepts.lib.summary'>3</a> — Fundamental concepts library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='concepts.lib.corelang'>[concepts.lib.corelang]</a>   </td><td class='left'> Core language concepts         </td><td class='left'>   <span class='texttt'>&lt;experimental/ranges/concepts&gt;</span>      </td></tr><tr ><td class='left'>
<a href='concepts.lib.compare'>[concepts.lib.compare]</a>    </td><td class='left'> Comparison concepts            </td><td class='left'>                      </td></tr><tr ><td class='left'>
<a href='concepts.lib.object'>[concepts.lib.object]</a>     </td><td class='left'> Object concepts                </td><td class='left'>                      </td></tr><tr ><td class='left'>
<a href='concepts.lib.callable'>[concepts.lib.callable]</a>   </td><td class='left'> Callable concepts              </td><td class='left'>                      </td></tr></table></div></div><div id='general.equality'><h3 ><a class='secnum' href='#general.equality' style='min-width:103pt'>7.1.1</a> Equality Preservation <a class='abbr_ref' href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a></h3><div class='para' id='general.equality-1'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-1'>1</a></div><p >An expression is <i>equality preserving</i> if, given equal inputs, the expression results in
equal outputs. The inputs to an expression are the set of the expression's operands. The
output of an expression is the expression's result and all operands modified by the expression.</p></div><div class='para' id='general.equality-2'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-2'>2</a></div><p >Not all input values must be valid for a given expression; e.g., for integers <span class='texttt'>a</span>
and <span class='texttt'>b</span>, the expression <span class='texttt'>a / b</span> is not well-defined when <span class='texttt'>b</span> is <span class='texttt'>0</span>. This
does not preclude the expression <span class='texttt'>a / b</span> being equality preserving. The
<i>domain</i> of an expression is the set of input values for which the
expression is required to be well-defined.</p></div><div class='para' id='general.equality-3'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-3'>3</a></div><p >Expressions required by this specification to be equality preserving are
further required to be stable: two evaluations of such an expression with the same
input objects must have equal outputs absent any
explicit intervening modification of those input objects.
[&nbsp;<i>Note:</i> This requirement allows generic code to reason
about the current values of objects based on knowledge of the prior values as
observed via equality preserving expressions. It effectively forbids spontaneous
changes to an object, changes to an object from another thread of execution, changes
to an object as side effects of non-modifying expressions, and changes to an object as
side effects of modifying a distinct object if those changes could be observable
to a library function via an equality preserving expression that is required to be
valid for that object. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='general.equality-4'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-4'>4</a></div><p >Expressions declared in a <span class='grammarterm'>requires-expression</span> in this document are
required to be equality preserving, except for those annotated with the comment
“not required to be equality preserving.” An expression so annotated
may be equality preserving, but is not required to be so.</p></div><div class='para' id='general.equality-5'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-5'>5</a></div><p >An expression that may alter the value of one or more of its inputs in a manner
observable to equality preserving expressions is said to modify those inputs.
This document uses a notational convention to specify which expressions declared
in a <span class='grammarterm'>requires-expression</span> modify which inputs: except where otherwise
specified, an expression operand that is a non-constant lvalue or rvalue may be
modified. Operands that are constant lvalues or rvalues must not be modified.</p></div><div class='para' id='general.equality-6'><div class='marginalizedparent'><a class='marginalized' href='#general.equality-6'>6</a></div><p >Where a <span class='grammarterm'>requires-expression</span> declares an expression that is non-modifying
for some constant lvalue operand, additional variations of that expression that accept
a non-constant lvalue or (possibly constant) rvalue for the given operand are also
required except where such an expression variation is explicitly required with
differing semantics. These <i>implicit expression variations</i> must meet the semantic
requirements of the declared expression. The extent to which an implementation
validates the syntax of the variations is unspecified.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool C =
  requires(T a, T b, const T c, const T d) {
    c == d;           <span class='comment'>// #1
</span>    a = std::move(b); <span class='comment'>// #2
</span>    a = c;            <span class='comment'>// #3
</span>  };
</pre><p >Expression #1 does not modify either of its operands, #2 modifies both of its
operands, and #3 modifies only its first operand <span class='texttt'>a</span>.</p><p >Expression #1 implicitly requires additional expression variations that meet the
requirements for <span class='texttt'>c == d</span> (including non-modification), as if the expressions
</p><pre class='codeblock'>
a == d;       a == b;             a == move(b);       a == d;
c == a;       c == move(a);       c == move(d);
move(a) == d; move(a) == b;       move(a) == move(b); move(a) == move(d);
move(c) == b; move(c) == move(b); move(c) == d;       move(c) == move(d);
</pre><p >had been declared as well.</p><p >Expression #3 implicitly requires additional expression variations that meet the
requirements for <span class='texttt'>a = c</span> (including non-modification of the second operand),
as if the expressions <span class='texttt'>a = b</span> and <span class='texttt'>a = move(c)</span> had been declared.
Expression #3 does not implicitly require an expression variation with a
non-constant rvalue second operand, since expression #2 already specifies exactly
such an expression explicitly.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
The following type <span class='texttt'>T</span> meets the explicitly stated syntactic requirements
of concept <span class='texttt'>C</span> above but does not meet the additional implicit requirements:</p><pre class='codeblock'>
struct T {
  bool operator==(const T&amp;) const { return true; }
  bool operator==(T&amp;) = delete;
};
</pre><p ><span class='texttt'>T</span> fails to meet the implicit
requirements of <span class='texttt'>C</span>, so <span class='texttt'>C&lt;T&gt;</span> is not satisfied. Since
implementations are not required to validate the syntax of implicit requirements, it
is unspecified whether or not an implementation diagnoses as ill-formed a program
which requires <span class='texttt'>C&lt;T&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='synopsis'><h2 ><a class='secnum' href='#synopsis' style='min-width:88pt'>7.2</a> Header <span class='texttt'>&lt;experimental/ranges/concepts&gt;</span> synopsis <a class='abbr_ref' href='concepts.lib.synopsis'>[concepts.lib.synopsis]</a></h2><p ><span class='indexparent'><a class='index' id='experimental/ranges/concepts'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  <span class='comment'>// <a href='concepts.lib.corelang'>[concepts.lib.corelang]</a>, core language concepts:
</span>  <span class='comment'>// <a href='concepts.lib.corelang.same'>[concepts.lib.corelang.same]</a>, Same:
</span>  template &lt;class T, class U&gt;
  concept bool Same = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.derived'>[concepts.lib.corelang.derived]</a>, DerivedFrom:
</span>  template &lt;class T, class U&gt;
  concept bool DerivedFrom = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.convertibleto'>[concepts.lib.corelang.convertibleto]</a>, ConvertibleTo:
</span>  template &lt;class T, class U&gt;
  concept bool ConvertibleTo = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.commonref'>[concepts.lib.corelang.commonref]</a>, CommonReference:
</span>  template &lt;class T, class U&gt;
  concept bool CommonReference = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.common'>[concepts.lib.corelang.common]</a>, Common:
</span>  template &lt;class T, class U&gt;
  concept bool Common = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.integral'>[concepts.lib.corelang.integral]</a>, Integral:
</span>  template &lt;class T&gt;
  concept bool Integral = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.signedintegral'>[concepts.lib.corelang.signedintegral]</a>, SignedIntegral:
</span>  template &lt;class T&gt;
  concept bool SignedIntegral = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.unsignedintegral'>[concepts.lib.corelang.unsignedintegral]</a>, UnsignedIntegral:
</span>  template &lt;class T&gt;
  concept bool UnsignedIntegral = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.assignable'>[concepts.lib.corelang.assignable]</a>, Assignable:
</span>  template &lt;class T, class U&gt;
  concept bool Assignable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a>, Swappable:
</span>  template &lt;class T&gt;
  concept bool Swappable = <i><span class='texttt'>see below</span></i>;

  template &lt;class T, class U&gt;
  concept bool SwappableWith = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.destructible'>[concepts.lib.corelang.destructible]</a>, Destructible:
</span>  template &lt;class T&gt;
  concept bool Destructible = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.constructible'>[concepts.lib.corelang.constructible]</a>, Constructible:
</span>  template &lt;class T, class... Args&gt;
  concept bool Constructible = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.defaultconstructible'>[concepts.lib.corelang.defaultconstructible]</a>, DefaultConstructible:
</span>  template &lt;class T&gt;
  concept bool DefaultConstructible = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.moveconstructible'>[concepts.lib.corelang.moveconstructible]</a>, MoveConstructible:
</span>  template &lt;class T&gt;
  concept bool MoveConstructible = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.corelang.copyconstructible'>[concepts.lib.corelang.copyconstructible]</a>, CopyConstructible:
</span>  template &lt;class T&gt;
  concept bool CopyConstructible = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.compare'>[concepts.lib.compare]</a>, comparison concepts:
</span>  <span class='comment'>// <a href='concepts.lib.compare.boolean'>[concepts.lib.compare.boolean]</a>, Boolean:
</span>  template &lt;class B&gt;
  concept bool Boolean = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.compare.equalitycomparable'>[concepts.lib.compare.equalitycomparable]</a>, EqualityComparable:
</span>  template &lt;class T, class U&gt;
  concept bool WeaklyEqualityComparableWith = <i><span class='texttt'>see below</span></i>;

  template &lt;class T&gt;
  concept bool EqualityComparable = <i><span class='texttt'>see below</span></i>;

  template &lt;class T, class U&gt;
  concept bool EqualityComparableWith = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.compare.stricttotallyordered'>[concepts.lib.compare.stricttotallyordered]</a>, StrictTotallyOrdered:
</span>  template &lt;class T&gt;
  concept bool StrictTotallyOrdered = <i><span class='texttt'>see below</span></i>;

  template &lt;class T, class U&gt;
  concept bool StrictTotallyOrderedWith = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.object'>[concepts.lib.object]</a>, object concepts:
</span>  <span class='comment'>// <a href='concepts.lib.object.movable'>[concepts.lib.object.movable]</a>, Movable:
</span>  template &lt;class T&gt;
  concept bool Movable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.object.copyable'>[concepts.lib.object.copyable]</a>, Copyable:
</span>  template &lt;class T&gt;
  concept bool Copyable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.object.semiregular'>[concepts.lib.object.semiregular]</a>, Semiregular:
</span>  template &lt;class T&gt;
  concept bool Semiregular = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.object.regular'>[concepts.lib.object.regular]</a>, Regular:
</span>  template &lt;class T&gt;
  concept bool Regular = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.callable'>[concepts.lib.callable]</a>, callable concepts:
</span>  <span class='comment'>// <a href='concepts.lib.callable.invocable'>[concepts.lib.callable.invocable]</a>, Invocable:
</span>  template &lt;class F, class... Args&gt;
  concept bool Invocable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.callable.regularinvocable'>[concepts.lib.callable.regularinvocable]</a>, RegularInvocable:
</span>  template &lt;class F, class... Args&gt;
  concept bool RegularInvocable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.callable.predicate'>[concepts.lib.callable.predicate]</a>, Predicate:
</span>  template &lt;class F, class... Args&gt;
  concept bool Predicate = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.callable.relation'>[concepts.lib.callable.relation]</a>, Relation:
</span>  template &lt;class R, class T, class U&gt;
  concept bool Relation = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='concepts.lib.callable.strictweakorder'>[concepts.lib.callable.strictweakorder]</a>, StrictWeakOrder:
</span>  template &lt;class R, class T, class U&gt;
  concept bool StrictWeakOrder = <i><span class='texttt'>see below</span></i>;
}}}}
</pre></div><div id='corelang'><h2 ><a class='secnum' href='#corelang' style='min-width:88pt'>7.3</a> Core language concepts <a class='abbr_ref' href='concepts.lib.corelang'>[concepts.lib.corelang]</a></h2><div id='corelang.general'><h3 ><a class='secnum' href='#corelang.general' style='min-width:103pt'>7.3.1</a> General <a class='abbr_ref' href='concepts.lib.corelang.general'>[concepts.lib.corelang.general]</a></h3><div class='para' id='corelang.general-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.general-1'>1</a></div><p >This section contains the definition of concepts corresponding to language features.
These concepts express relationships between types, type classifications, and
fundamental type properties.</p></div></div><div id='corelang.same'><h3 ><a class='secnum' href='#corelang.same' style='min-width:103pt'>7.3.2</a> Concept <span class='texttt'>Same</span> <a class='abbr_ref' href='concepts.lib.corelang.same'>[concepts.lib.corelang.same]</a></h3><p ><span class='indexparent'><a class='index' id='Same'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Same = is_same&lt;T, U&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='corelang.same-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.same-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Same&lt;T, U&gt;</span> and
<span class='texttt'>is_same&lt;T, U&gt;::value</span>.</p></div></div><div class='para' id='corelang.same-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.same-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> For the purposes of constraint checking, <span class='texttt'>Same&lt;T, U&gt;</span> implies
<span class='texttt'>Same&lt;U, T&gt;</span>.
</p></div></div></div><div id='corelang.derived'><h3 ><a class='secnum' href='#corelang.derived' style='min-width:103pt'>7.3.3</a> Concept <span class='texttt'>DerivedFrom</span> <a class='abbr_ref' href='concepts.lib.corelang.derived'>[concepts.lib.corelang.derived]</a></h3><p ><span class='indexparent'><a class='index' id='DerivedFrom'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool DerivedFrom =
  is_base_of&lt;U, T&gt;::value &amp;&amp;
  is_convertible&lt;remove_cv_t&lt;T&gt;*, remove_cv_t&lt;U&gt;*&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='corelang.derived-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.derived-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>DerivedFrom&lt;T, U&gt;</span>
and either <span class='texttt'>is_base_of&lt;U, T&gt;::value</span> or
<span class='texttt'>is_convertible&lt;remove_cv_t&lt;T&gt;*, remove_cv_t&lt;U&gt;*&gt;::value</span>.</p></div></div><div class='para' id='corelang.derived-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.derived-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>DerivedFrom&lt;T, U&gt;</span> is satisfied if and only if <span class='texttt'>T</span> is
publicly and unambiguously derived from <span class='texttt'>U</span>, or <span class='texttt'>T</span> and <span class='texttt'>U</span>
are the same class type ignoring <i>cv</i>-qualifiers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.convertibleto'><h3 ><a class='secnum' href='#corelang.convertibleto' style='min-width:103pt'>7.3.4</a> Concept <span class='texttt'>ConvertibleTo</span> <a class='abbr_ref' href='concepts.lib.corelang.convertibleto'>[concepts.lib.corelang.convertibleto]</a></h3><p ><span class='indexparent'><a class='index' id='ConvertibleTo'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool ConvertibleTo =
  is_convertible&lt;From, To&gt;::value &amp;&amp; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span>  requires(From (&amp;f)()) {
    static_cast&lt;To&gt;(f());
  };
</code></p><div class='itemdescr'></div><div class='para' id='corelang.convertibleto-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.convertibleto-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>test</span> be the invented function:
</p><pre class='codeblock'>
To test(From (&amp;f)()) {
  return f();
}
</pre><p >and let <span class='texttt'>f</span> be a function with no arguments and return type <span class='texttt'>From</span>
such that <span class='texttt'>f()</span> is equality preserving.
<span class='texttt'>ConvertibleTo&lt;From, To&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='corelang.convertibleto-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.convertibleto-1.1'>(1.1)</a></div><p ><span class='texttt'>To</span> is not an object or reference-to-object type, or
<span class='texttt'>static_cast&lt;To&gt;(f())</span> is equal to <span class='texttt'>test(f)</span>.</p></li><li id='corelang.convertibleto-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.convertibleto-1.2'>(1.2)</a></div><p ><span class='texttt'>From</span> is not a reference-to-object type, or</p><ul class='itemize'><li id='corelang.convertibleto-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#corelang.convertibleto-1.2.1'>(1.2.1)</a></div><p >If <span class='texttt'>From</span> is an rvalue reference to a non const-qualified type, the resulting state of the object referenced by <span class='texttt'>f()</span> after either above expression is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).</p></li><li id='corelang.convertibleto-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#corelang.convertibleto-1.2.2'>(1.2.2)</a></div><p >Otherwise, the object referred to by <span class='texttt'>f()</span> is not modified by either above expression.
</p></li></ul></li></ul></div></div><div class='para' id='corelang.convertibleto-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.convertibleto-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>ConvertibleTo&lt;From, To&gt;</span>
and <span class='texttt'>is_convertible&lt;From, To&gt;::value</span>.
</p></div></div></div><div id='corelang.commonref'><h3 ><a class='secnum' href='#corelang.commonref' style='min-width:103pt'>7.3.5</a> Concept <span class='texttt'>CommonReference</span> <a class='abbr_ref' href='concepts.lib.corelang.commonref'>[concepts.lib.corelang.commonref]</a></h3><div class='para' id='corelang.commonref-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.commonref-1'>1</a></div><p >For two types <span class='texttt'>T</span> and <span class='texttt'>U</span>, if <span class='texttt'>common_reference_t&lt;T, U&gt;</span>
is well-formed and denotes a type <span class='texttt'>C</span> such that both
<span class='texttt'>ConvertibleTo&lt;T, C&gt;</span> and <span class='texttt'>ConvertibleTo&lt;U, C&gt;</span> are
satisfied, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common reference
type</i>, <span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or
<span class='texttt'>U</span>, or it could be a different type. <span class='texttt'>C</span> may be a reference
type. <span class='texttt'>C</span> need not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='CommonReference'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool CommonReference =
  Same&lt;common_reference_t&lt;T, U&gt;, common_reference_t&lt;U, T&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;T, common_reference_t&lt;T, U&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;U, common_reference_t&lt;T, U&gt;&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='corelang.commonref-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.commonref-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_reference_t&lt;T, U&gt;</span>. Let <span class='texttt'>t</span> be a
function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>CommonReference&lt;T, U&gt;</span> is satisfied
only if:
</p><ul class='itemize'><li id='corelang.commonref-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.commonref-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if <span class='texttt'>t()</span> is an
  equality preserving expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='corelang.commonref-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.commonref-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if <span class='texttt'>u()</span> is an
  equality preserving expression.
</p></li></ul></div></div><div class='para' id='corelang.commonref-3'><div class='marginalizedparent'><a class='marginalized' href='#corelang.commonref-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>CommonReference</span> by specializing the
<span class='texttt'>basic_common_reference</span> class template (<a href='meta.trans.other'>[meta.trans.other]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.common'><h3 ><a class='secnum' href='#corelang.common' style='min-width:103pt'>7.3.6</a> Concept <span class='texttt'>Common</span> <a class='abbr_ref' href='concepts.lib.corelang.common'>[concepts.lib.corelang.common]</a></h3><div class='para' id='corelang.common-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.common-1'>1</a></div><p >If <span class='texttt'>T</span> and <span class='texttt'>U</span> can both be explicitly converted to some third type,
<span class='texttt'>C</span>, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common type</i>,
<span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or <span class='texttt'>U</span>, or
it could be a different type. <span class='texttt'>C</span> may not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Common'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Common =
  Same&lt;common_type_t&lt;T, U&gt;, common_type_t&lt;U, T&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;T, common_type_t&lt;T, U&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;U, common_type_t&lt;T, U&gt;&gt; &amp;&amp;
  CommonReference&lt;
    add_lvalue_reference_t&lt;const T&gt;,
    add_lvalue_reference_t&lt;const U&gt;&gt; &amp;&amp;
  CommonReference&lt;
    add_lvalue_reference_t&lt;common_type_t&lt;T, U&gt;&gt;,
    common_reference_t&lt;
      add_lvalue_reference_t&lt;const T&gt;,
      add_lvalue_reference_t&lt;const U&gt;&gt;&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='corelang.common-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.common-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_type_t&lt;T, U&gt;</span>. Let
<span class='texttt'>t</span> be a function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>Common&lt;T, U&gt;</span> is satisfied only if:
</p><ul class='itemize'><li id='corelang.common-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.common-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if
  <span class='texttt'>t()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='corelang.common-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.common-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if
  <span class='texttt'>u()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li></ul></div></div><div class='para' id='corelang.common-3'><div class='marginalizedparent'><a class='marginalized' href='#corelang.common-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>Common</span> by specializing the <span class='texttt'>common_type</span>
class template (<a href='meta.unary.prop'>[meta.unary.prop]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='corelang.integral'><h3 ><a class='secnum' href='#corelang.integral' style='min-width:103pt'>7.3.7</a> Concept <span class='texttt'>Integral</span> <a class='abbr_ref' href='concepts.lib.corelang.integral'>[concepts.lib.corelang.integral]</a></h3><p ><span class='indexparent'><a class='index' id='Integral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Integral = is_integral&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='corelang.integral-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.integral-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Integral&lt;T&gt;</span> and
<span class='texttt'>is_integral&lt;T&gt;::value</span>.
</p></div></div></div><div id='corelang.signedintegral'><h3 ><a class='secnum' href='#corelang.signedintegral' style='min-width:103pt'>7.3.8</a> Concept <span class='texttt'>SignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.signedintegral'>[concepts.lib.corelang.signedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='SignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool SignedIntegral = Integral&lt;T&gt; &amp;&amp; is_signed&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='corelang.signedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.signedintegral-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>SignedIntegral&lt;T&gt;</span> and
<span class='texttt'>is_signed&lt;T&gt;::value</span>.</p></div></div><div class='para' id='corelang.signedintegral-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.signedintegral-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>SignedIntegral&lt;T&gt;</span> may be satisfied even for
types that are not signed integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.unsignedintegral'><h3 ><a class='secnum' href='#corelang.unsignedintegral' style='min-width:103pt'>7.3.9</a> Concept <span class='texttt'>UnsignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.unsignedintegral'>[concepts.lib.corelang.unsignedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='UnsignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='corelang.unsignedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.unsignedintegral-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>UnsignedIntegral&lt;T&gt;</span> may be satisfied even for
types that are not unsigned integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.assignable'><h3 ><a class='secnum' href='#corelang.assignable' style='min-width:103pt'>7.3.10</a> Concept <span class='texttt'>Assignable</span> <a class='abbr_ref' href='concepts.lib.corelang.assignable'>[concepts.lib.corelang.assignable]</a></h3><p ><span class='indexparent'><a class='index' id='Assignable'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Assignable =
  is_lvalue_reference&lt;T&gt;::value &amp;&amp; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span>  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  requires(T t, U&amp;&amp; u) {
    { t = std::forward&lt;U&gt;(u) } -&gt; Same&lt;T&gt;&amp;&amp;;
  };
</code></p><div class='itemdescr'></div><div class='para' id='corelang.assignable-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.assignable-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> be an lvalue that refers to an object <span class='texttt'>o</span> such that
<span class='texttt'>decltype((t))</span> is <span class='texttt'>T</span>, and <span class='texttt'>u</span> an expression such that
<span class='texttt'>decltype((u))</span> is <span class='texttt'>U</span>. Let <span class='texttt'>u2</span> be a distinct object that is
equal to <span class='texttt'>u</span>. <span class='texttt'>Assignable&lt;T, U&gt;</span> is satisfied only if</p><ul class='itemize'><li id='corelang.assignable-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.assignable-1.1'>(1.1)</a></div><p ><span class='texttt'>addressof(t = u) == addressof(o)</span>.</p></li><li id='corelang.assignable-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.assignable-1.2'>(1.2)</a></div><p >After evaluating <span class='texttt'>t = u</span>:</p><ul class='itemize'><li id='corelang.assignable-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#corelang.assignable-1.2.1'>(1.2.1)</a></div><p ><span class='texttt'>t</span> is equal to <span class='texttt'>u2</span>, unless <span class='texttt'>u</span> is a non-const xvalue that refers to <span class='texttt'>o</span>.</p></li><li id='corelang.assignable-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#corelang.assignable-1.2.2'>(1.2.2)</a></div><p >If <span class='texttt'>u</span> is a non-<span class='texttt'>const</span> xvalue, the resulting state of the
object to which it refers is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).</p></li><li id='corelang.assignable-1.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#corelang.assignable-1.2.3'>(1.2.3)</a></div><p >Otherwise, if <span class='texttt'>u</span> is a glvalue, the object to which it refers is not
modified.
</p></li></ul></li></ul></div></div><div class='para' id='corelang.assignable-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.assignable-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Assignable&lt;T, U&gt;</span>
and <span class='texttt'>is_lvalue_reference&lt;T&gt;::value</span>.</p></div></div><div class='para' id='corelang.assignable-3'><div class='marginalizedparent'><a class='marginalized' href='#corelang.assignable-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Assignment need not be a total function (<a href='structure.requirements'>[structure.requirements]</a>);
in particular, if assignment to an object <span class='texttt'>x</span> can result in a modification
of some other object <span class='texttt'>y</span>, then <span class='texttt'>x = y</span> is likely not in the domain
of <span class='texttt'>=</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.swappable'><h3 ><a class='secnum' href='#corelang.swappable' style='min-width:103pt'>7.3.11</a> Concept <span class='texttt'>Swappable</span> <a class='abbr_ref' href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a></h3><p ><span class='indexparent'><a class='index' id='Swappable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Swappable =
  requires(T&amp; a, T&amp; b) {
    ranges::swap(a, b);
  };

template &lt;class T, class U&gt;
concept bool SwappableWith =
  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  requires(T&amp;&amp; t, U&amp;&amp; u) {
    ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;T&gt;(t));
    ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;U&gt;(u));
    ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
    ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
  };
</code></p><div class='itemdescr'></div><div class='para' id='corelang.swappable-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.swappable-1'>1</a></div><div class='itemdescr'><p >This subclause provides definitions for swappable types and expressions. In these
definitions, let <span class='texttt'>t</span> denote an expression of type <span class='texttt'>T</span>, and let <span class='texttt'>u</span>
denote an expression of type <span class='texttt'>U</span>.</p></div></div><div class='para' id='corelang.swappable-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.swappable-2'>2</a></div><div class='itemdescr'><p >An object <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable_with' id='def:swappable_with'><i>swappable with</i></a> an object <span class='texttt'>u</span> if and only if
<span class='texttt'>SwappableWith&lt;T, U&gt;</span> is satisfied. <span class='texttt'>SwappableWith&lt;T, U&gt;</span> is satisfied
only if given distinct objects <span class='texttt'>t2</span> equal to <span class='texttt'>t</span>
and <span class='texttt'>u2</span> equal to <span class='texttt'>u</span>, after evaluating either
<span class='texttt'>ranges::swap(t, u)</span> or <span class='texttt'>ranges::swap(u, t)</span>, <span class='texttt'>t2</span> is equal to
<span class='texttt'>u</span> and <span class='texttt'>u2</span> is equal to <span class='texttt'>t</span>.</p></div></div><div class='para' id='corelang.swappable-3'><div class='marginalizedparent'><a class='marginalized' href='#corelang.swappable-3'>3</a></div><div class='itemdescr'><p >An rvalue or lvalue <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable' id='def:swappable'><i>swappable</i></a> if and only if <span class='texttt'>t</span> is
swappable with any rvalue or lvalue, respectively, of type <span class='texttt'>T</span>.</p><p >[&nbsp;<i>Example:</i> User code can ensure that the evaluation of <span class='texttt'>swap</span> calls
is performed in an appropriate context under the various conditions as follows:
</p><pre class='codeblock'>
#include &lt;utility&gt;

<span class='comment'>// Requires: <span class='texttt'>std::forward&lt;T&gt;(t)</span> shall be swappable with <span class='texttt'>std::forward&lt;U&gt;(u)</span>.
</span>template &lt;class T, class U&gt;
void value_swap(T&amp;&amp; t, U&amp;&amp; u) {
  using std::experimental::ranges::swap;
  swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));         <span class='comment'>// OK: uses “swappable with” conditions
</span>                                                        <span class='comment'>// for rvalues and lvalues
</span>}

<span class='comment'>// Requires: lvalues of <span class='texttt'>T</span> shall be swappable.
</span>template &lt;class T&gt;
void lv_swap(T&amp; t1, T&amp; t2) {
  using std::experimental::ranges::swap;
  swap(t1, t2);                                         <span class='comment'>// OK: uses swappable conditions for
</span>}                                                       <span class='comment'>// lvalues of type <span class='texttt'>T</span>
</span>
namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A&amp; a) { return Proxy{ &amp;a }; }

  void swap(A&amp; x, Proxy p) {
    std::experimental::ranges::swap(x.m, p.a-&gt;m);  <span class='comment'>// OK: uses context equivalent to swappable
</span>                                                   <span class='comment'>// conditions for fundamental types
</span>  }
  void swap(Proxy p, A&amp; x) { swap(x, p); }         <span class='comment'>// satisfy symmetry constraint
</span>}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 &amp;&amp; j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 &amp;&amp; a2.m == 5);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='corelang.destructible'><h3 ><a class='secnum' href='#corelang.destructible' style='min-width:103pt'>7.3.12</a> Concept <span class='texttt'>Destructible</span> <a class='abbr_ref' href='concepts.lib.corelang.destructible'>[concepts.lib.corelang.destructible]</a></h3><div class='para' id='corelang.destructible-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.destructible-1'>1</a></div><p >The <span class='texttt'>Destructible</span> concept specifies properties of all types, instances of
which can be destroyed at the end of their lifetime, or reference types.</p><p ><span class='indexparent'><a class='index' id='Destructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Destructible = is_nothrow_destructible&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p></div><div class='itemdescr'></div><div class='para' id='corelang.destructible-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.destructible-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Destructible&lt;T&gt;</span>
and <span class='texttt'>is_nothrow_destructible&lt;T&gt;::value</span>.</p></div></div><div class='para' id='corelang.destructible-3'><div class='marginalizedparent'><a class='marginalized' href='#corelang.destructible-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Unlike the <span class='texttt'>Destructible</span> library concept in the C++
Standard (  ISO/IEC 14882:2014 &sect;<a href='../n4140/utility.arg.requirements'>[utility.arg.requirements]</a>), this concept forbids destructors
that are <span class='texttt'>noexcept(false)</span>, even if non-throwing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='corelang.constructible'><h3 ><a class='secnum' href='#corelang.constructible' style='min-width:103pt'>7.3.13</a> Concept <span class='texttt'>Constructible</span> <a class='abbr_ref' href='concepts.lib.corelang.constructible'>[concepts.lib.corelang.constructible]</a></h3><div class='para' id='corelang.constructible-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.constructible-1'>1</a></div><p >The <span class='texttt'>Constructible</span> concept constrains the initialization of a variable of
a type with a given set of argument types.</p><p ><span class='indexparent'><a class='index' id='Constructible'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
concept bool Constructible =
  Destructible&lt;T&gt; &amp;&amp; is_constructible&lt;T, Args...&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p></div><div class='itemdescr'></div><div class='para' id='corelang.constructible-2'><div class='marginalizedparent'><a class='marginalized' href='#corelang.constructible-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Constructible&lt;T, Args...&gt;</span>
and <span class='texttt'>is_constructible&lt;T, Args...&gt;::value</span>.
</p></div></div></div><div id='corelang.defaultconstructible'><h3 ><a class='secnum' href='#corelang.defaultconstructible' style='min-width:103pt'>7.3.14</a> Concept <span class='texttt'>DefaultConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.defaultconstructible'>[concepts.lib.corelang.defaultconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='DefaultConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool DefaultConstructible = Constructible&lt;T&gt;;
</code></p></div><div id='corelang.moveconstructible'><h3 ><a class='secnum' href='#corelang.moveconstructible' style='min-width:103pt'>7.3.15</a> Concept <span class='texttt'>MoveConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.moveconstructible'>[concepts.lib.corelang.moveconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='MoveConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool MoveConstructible =
  Constructible&lt;T, T&gt; &amp;&amp; ConvertibleTo&lt;T, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='corelang.moveconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.moveconstructible-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>T</span> is an object type, then let <span class='texttt'>rv</span> be an rvalue of type <span class='texttt'>T</span>
and <span class='texttt'>u2</span> a distinct object of type <span class='texttt'>T</span> equal to <span class='texttt'>rv</span>.
<span class='texttt'>MoveConstructible&lt;T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='corelang.moveconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.moveconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = rv;</span>, <span class='texttt'>u</span> is equal to <span class='texttt'>u2</span>.</p></li><li id='corelang.moveconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.moveconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{rv}</span> is equal to <span class='texttt'>u2</span>.</p></li><li id='corelang.moveconstructible-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.moveconstructible-1.3'>(1.3)</a></div><p >If <span class='texttt'>T</span> is not <span class='texttt'>const</span>, <span class='texttt'>rv</span>'s resulting state is valid
but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>); otherwise, it is unchanged.
</p></li></ul></div></div></div><div id='corelang.copyconstructible'><h3 ><a class='secnum' href='#corelang.copyconstructible' style='min-width:103pt'>7.3.16</a> Concept <span class='texttt'>CopyConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.copyconstructible'>[concepts.lib.corelang.copyconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='CopyConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool CopyConstructible =
  MoveConstructible&lt;T&gt; &amp;&amp;
  Constructible&lt;T, T&amp;&gt; &amp;&amp; ConvertibleTo&lt;T&amp;, T&gt; &amp;&amp;
  Constructible&lt;T, const T&amp;&gt; &amp;&amp; ConvertibleTo&lt;const T&amp;, T&gt; &amp;&amp;
  Constructible&lt;T, const T&gt; &amp;&amp; ConvertibleTo&lt;const T, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='corelang.copyconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#corelang.copyconstructible-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>T</span> is an object type, then let <span class='texttt'>v</span> be an lvalue of type (possibly
<span class='texttt'>const</span>) <span class='texttt'>T</span> or an rvalue of type <span class='texttt'>const T</span>.
<span class='texttt'>CopyConstructible&lt;T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='corelang.copyconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.copyconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = v;</span>, <span class='texttt'>u</span> is equal to <span class='texttt'>v</span>.</p></li><li id='corelang.copyconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#corelang.copyconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{v}</span> is equal to <span class='texttt'>v</span>.
</p></li></ul></div></div></div></div><div id='compare'><h2 ><a class='secnum' href='#compare' style='min-width:88pt'>7.4</a> Comparison concepts <a class='abbr_ref' href='concepts.lib.compare'>[concepts.lib.compare]</a></h2><div id='compare.general'><h3 ><a class='secnum' href='#compare.general' style='min-width:103pt'>7.4.1</a> General <a class='abbr_ref' href='concepts.lib.compare.general'>[concepts.lib.compare.general]</a></h3><div class='para' id='compare.general-1'><div class='marginalizedparent'><a class='marginalized' href='#compare.general-1'>1</a></div><p >This section describes concepts that establish relationships and orderings
on values of possibly differing object types.</p></div></div><div id='compare.boolean'><h3 ><a class='secnum' href='#compare.boolean' style='min-width:103pt'>7.4.2</a> Concept <span class='texttt'>Boolean</span> <a class='abbr_ref' href='concepts.lib.compare.boolean'>[concepts.lib.compare.boolean]</a></h3><div class='para' id='compare.boolean-1'><div class='marginalizedparent'><a class='marginalized' href='#compare.boolean-1'>1</a></div><p >The <span class='texttt'>Boolean</span> concept specifies the requirements on a type that is usable in Boolean contexts.</p><p ><span class='indexparent'><a class='index' id='Boolean'></a></span><code class='itemdecl'>
template &lt;class B&gt;
concept bool Boolean =
  Movable&lt;decay_t&lt;B&gt;&gt; &amp;&amp; <span class='comment'>// (see <a href='concepts.lib.object.movable'>[concepts.lib.object.movable]</a>)
</span>  requires(const remove_reference_t&lt;B&gt;&amp; b1,
           const remove_reference_t&lt;B&gt;&amp; b2, const bool a) {
    { b1 }       -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { !b1 }      -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { b1 &amp;&amp; a }  -&gt; Same&lt;bool&gt;&amp;&amp;;
    { b1 || a }  -&gt; Same&lt;bool&gt;&amp;&amp;;
    { b1 &amp;&amp; b2 } -&gt; Same&lt;bool&gt;&amp;&amp;;
    { a &amp;&amp; b2  } -&gt; Same&lt;bool&gt;&amp;&amp;;
    { b1 || b2 } -&gt; Same&lt;bool&gt;&amp;&amp;;
    { a || b2  } -&gt; Same&lt;bool&gt;&amp;&amp;;
    { b1 == b2 } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { b1 == a  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { a == b2  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { b1 != b2 } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { b1 != a  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    { a != b2  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
  };
</code></p></div><div class='para' id='compare.boolean-2'><div class='marginalizedparent'><a class='marginalized' href='#compare.boolean-2'>2</a></div><p >Given <span class='texttt'>const</span> lvalues <span class='texttt'>b1</span> and <span class='texttt'>b2</span> of type
<span class='texttt'>remove_reference_t&lt;B&gt;</span>, then <span class='texttt'>Boolean&lt;B&gt;</span> is satisfied only if</p><ul class='itemize'><li id='compare.boolean-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.boolean-2.1'>(2.1)</a></div><p ><span class='texttt'>bool(b1) == !bool(!b1)</span>.
</p></li><li id='compare.boolean-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.boolean-2.2'>(2.2)</a></div><p ><span class='texttt'>(b1 &amp;&amp; b2)</span>, <span class='texttt'>(b1 &amp;&amp; bool(b2))</span>, and
      <span class='texttt'>(bool(b1) &amp;&amp; b2)</span> are all equal to
      <span class='texttt'>(bool(b1) &amp;&amp; bool(b2))</span>, and have the same short-circuit evaluation.
</p></li><li id='compare.boolean-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.boolean-2.3'>(2.3)</a></div><p ><span class='texttt'>(b1 || b2)</span>, <span class='texttt'>(b1 || bool(b2))</span>, and
      <span class='texttt'>(bool(b1) || b2)</span> are all equal to
      <span class='texttt'>(bool(b1) || bool(b2))</span>, and have the same short-circuit evaluation.
</p></li><li id='compare.boolean-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.boolean-2.4'>(2.4)</a></div><p ><span class='texttt'>bool(b1 == b2)</span>, <span class='texttt'>bool(b1 == bool(b2))</span>, and
      <span class='texttt'>bool(bool(b1) == b2)</span> are all equal to <span class='texttt'>(bool(b1) == bool(b2))</span>.
</p></li><li id='compare.boolean-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.boolean-2.5'>(2.5)</a></div><p ><span class='texttt'>bool(b1 != b2)</span>, <span class='texttt'>bool(b1 != bool(b2))</span>, and
      <span class='texttt'>bool(bool(b1) != b2)</span> are all equal to <span class='texttt'>(bool(b1) != bool(b2))</span>.
</p></li></ul></div><div class='para' id='compare.boolean-3'><div class='marginalizedparent'><a class='marginalized' href='#compare.boolean-3'>3</a></div><p >[&nbsp;<i>Example:</i> The types <span class='texttt'>bool</span>, <span class='texttt'>std::true_type</span>, and
<span class='texttt'>std::bitset&lt;<span class='math'><span class='mathalpha'>N</span></span>&gt;::reference</span> are <span class='texttt'>Boolean</span> types.
Pointers, smart pointers, and types with explicit conversions to <span class='texttt'>bool</span> are
not <span class='texttt'>Boolean</span> types.<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='compare.equalitycomparable'><h3 ><a class='secnum' href='#compare.equalitycomparable' style='min-width:103pt'>7.4.3</a> Concept <span class='texttt'>EqualityComparable</span> <a class='abbr_ref' href='concepts.lib.compare.equalitycomparable'>[concepts.lib.compare.equalitycomparable]</a></h3><p ><span class='indexparent'><a class='index' id='WeaklyEqualityComparableWith'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool WeaklyEqualityComparableWith =
  requires(const remove_reference_t&lt;T&gt;&amp; t,
           const remove_reference_t&lt;U&gt;&amp; u) {
    { t == u } -&gt; Boolean&amp;&amp;;
    { t != u } -&gt; Boolean&amp;&amp;;
    { u == t } -&gt; Boolean&amp;&amp;;
    { u != t } -&gt; Boolean&amp;&amp;;
  };
</code></p><div class='itemdescr'></div><div class='para' id='compare.equalitycomparable-1'><div class='marginalizedparent'><a class='marginalized' href='#compare.equalitycomparable-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> and <span class='texttt'>u</span> be <span class='texttt'>const</span> lvalues of types
<span class='texttt'>remove_reference_t&lt;T&gt;</span> and <span class='texttt'>remove_reference_t&lt;U&gt;</span> respectively.
<span class='texttt'>WeaklyEqualityComparableWith&lt;T, U&gt;</span> is satisfied only if:
</p><ul class='itemize'><li id='compare.equalitycomparable-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-1.1'>(1.1)</a></div><p ><span class='texttt'>t == u</span>, <span class='texttt'>u == t</span>, <span class='texttt'>t != u</span>, and <span class='texttt'>u != t</span>
      have the same domain.
</p></li><li id='compare.equalitycomparable-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-1.2'>(1.2)</a></div><p ><span class='texttt'>bool(u == t) == bool(t == u)</span>.
</p></li><li id='compare.equalitycomparable-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-1.3'>(1.3)</a></div><p ><span class='texttt'>bool(t != u) == !bool(t == u)</span>.
</p></li><li id='compare.equalitycomparable-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-1.4'>(1.4)</a></div><p ><span class='texttt'>bool(u != t) == bool(t != u)</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='EqualityComparable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool EqualityComparable = WeaklyEqualityComparableWith&lt;T, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='compare.equalitycomparable-2'><div class='marginalizedparent'><a class='marginalized' href='#compare.equalitycomparable-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be objects of type <span class='texttt'>T</span>.
<span class='texttt'>EqualityComparable&lt;T&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='compare.equalitycomparable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-2.1'>(2.1)</a></div><p ><span class='texttt'>bool(a == b)</span> if and only if <span class='texttt'>a</span> is equal to <span class='texttt'>b</span>.
</p></li></ul></div></div><div class='para' id='compare.equalitycomparable-3'><div class='marginalizedparent'><a class='marginalized' href='#compare.equalitycomparable-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The requirement that the expression <span class='texttt'>a == b</span> is equality preserving
implies that <span class='texttt'>==</span> is reflexive, transitive, and symmetric.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='EqualityComparableWith'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool EqualityComparableWith =
  EqualityComparable&lt;T&gt; &amp;&amp;
  EqualityComparable&lt;U&gt; &amp;&amp;
  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  EqualityComparable&lt;
    common_reference_t&lt;
      const remove_reference_t&lt;T&gt;&amp;,
      const remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
  WeaklyEqualityComparableWith&lt;T, U&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='compare.equalitycomparable-4'><div class='marginalizedparent'><a class='marginalized' href='#compare.equalitycomparable-4'>4</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> be a <span class='texttt'>const</span> lvalue of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>, <span class='texttt'>u</span> be a
<span class='texttt'>const</span> lvalue of type <span class='texttt'>remove_reference_t&lt;U&gt;</span>, and <span class='texttt'>C</span> be:
</p><pre class='codeblock'>
common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;
</pre><p ><span class='texttt'>EqualityComparableWith&lt;T, U&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='compare.equalitycomparable-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.equalitycomparable-4.1'>(4.1)</a></div><p ><span class='texttt'>bool(t == u) == bool(C(t) == C(u))</span>.
</p></li></ul></div></div></div><div id='compare.stricttotallyordered'><h3 ><a class='secnum' href='#compare.stricttotallyordered' style='min-width:103pt'>7.4.4</a> Concept <span class='texttt'>StrictTotallyOrdered</span> <a class='abbr_ref' href='concepts.lib.compare.stricttotallyordered'>[concepts.lib.compare.stricttotallyordered]</a></h3><p ><span class='indexparent'><a class='index' id='StrictTotallyOrdered'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool StrictTotallyOrdered =
  EqualityComparable&lt;T&gt; &amp;&amp;
  requires(const remove_reference_t&lt;T&gt;&amp; a,
           const remove_reference_t&lt;T&gt;&amp; b) {
    { a &lt; b }  -&gt; Boolean&amp;&amp;;
    { a &gt; b }  -&gt; Boolean&amp;&amp;;
    { a &lt;= b } -&gt; Boolean&amp;&amp;;
    { a &gt;= b } -&gt; Boolean&amp;&amp;;
  };
</code></p><div class='itemdescr'></div><div class='para' id='compare.stricttotallyordered-1'><div class='marginalizedparent'><a class='marginalized' href='#compare.stricttotallyordered-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>a</span>, <span class='texttt'>b</span>, and <span class='texttt'>c</span> be <span class='texttt'>const</span> lvalues of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>.
<span class='texttt'>StrictTotallyOrdered&lt;T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='compare.stricttotallyordered-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-1.1'>(1.1)</a></div><p >Exactly one of <span class='texttt'>bool(a &lt; b)</span>, <span class='texttt'>bool(a &gt; b)</span>, or
      <span class='texttt'>bool(a == b)</span> is <span class='texttt'>true</span>.
</p></li><li id='compare.stricttotallyordered-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-1.2'>(1.2)</a></div><p >If <span class='texttt'>bool(a &lt; b)</span> and <span class='texttt'>bool(b &lt; c)</span>, then
      <span class='texttt'>bool(a &lt; c)</span>.
</p></li><li id='compare.stricttotallyordered-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-1.3'>(1.3)</a></div><p ><span class='texttt'>bool(a &gt; b) == bool(b &lt; a)</span>.
</p></li><li id='compare.stricttotallyordered-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-1.4'>(1.4)</a></div><p ><span class='texttt'>bool(a &lt;= b) == !bool(b &lt; a)</span>.
</p></li><li id='compare.stricttotallyordered-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-1.5'>(1.5)</a></div><p ><span class='texttt'>bool(a &gt;= b) == !bool(a &lt; b)</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool StrictTotallyOrderedWith =
  StrictTotallyOrdered&lt;T&gt; &amp;&amp;
  StrictTotallyOrdered&lt;U&gt; &amp;&amp;
  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  StrictTotallyOrdered&lt;
    common_reference_t&lt;
      const remove_reference_t&lt;T&gt;&amp;,
      const remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
  EqualityComparableWith&lt;T, U&gt; &amp;&amp;
  requires(const remove_reference_t&lt;T&gt;&amp; t,
           const remove_reference_t&lt;U&gt;&amp; u) {
    { t &lt; u }  -&gt; Boolean&amp;&amp;;
    { t &gt; u }  -&gt; Boolean&amp;&amp;;
    { t &lt;= u } -&gt; Boolean&amp;&amp;;
    { t &gt;= u } -&gt; Boolean&amp;&amp;;
    { u &lt; t }  -&gt; Boolean&amp;&amp;;
    { u &gt; t }  -&gt; Boolean&amp;&amp;;
    { u &lt;= t } -&gt; Boolean&amp;&amp;;
    { u &gt;= t } -&gt; Boolean&amp;&amp;;
  };
</code></p><div class='itemdescr'></div><div class='para' id='compare.stricttotallyordered-2'><div class='marginalizedparent'><a class='marginalized' href='#compare.stricttotallyordered-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> be a <span class='texttt'>const</span> lvalue of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>,
<span class='texttt'>u</span> be a <span class='texttt'>const</span> lvalue of type <span class='texttt'>remove_reference_t&lt;U&gt;</span>,
and <span class='texttt'>C</span> be:
</p><pre class='codeblock'>
common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;
</pre><p ><span class='texttt'>StrictTotallyOrderedWith&lt;T, U&gt;</span> is satisfied only if</p><ul class='itemize'><li id='compare.stricttotallyordered-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.1'>(2.1)</a></div><p ><span class='texttt'>bool(t &lt; u) == bool(C(t) &lt; C(u)).</span>
</p></li><li id='compare.stricttotallyordered-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.2'>(2.2)</a></div><p ><span class='texttt'>bool(t &gt; u) == bool(C(t) &gt; C(u)).</span>
</p></li><li id='compare.stricttotallyordered-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.3'>(2.3)</a></div><p ><span class='texttt'>bool(t &lt;= u) == bool(C(t) &lt;= C(u)).</span>
</p></li><li id='compare.stricttotallyordered-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.4'>(2.4)</a></div><p ><span class='texttt'>bool(t &gt;= u) == bool(C(t) &gt;= C(u)).</span>
</p></li><li id='compare.stricttotallyordered-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.5'>(2.5)</a></div><p ><span class='texttt'>bool(u &lt; t) == bool(C(u) &lt; C(t)).</span>
</p></li><li id='compare.stricttotallyordered-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.6'>(2.6)</a></div><p ><span class='texttt'>bool(u &gt; t) == bool(C(u) &gt; C(t)).</span>
</p></li><li id='compare.stricttotallyordered-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.7'>(2.7)</a></div><p ><span class='texttt'>bool(u &lt;= t) == bool(C(u) &lt;= C(t)).</span>
</p></li><li id='compare.stricttotallyordered-2.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#compare.stricttotallyordered-2.8'>(2.8)</a></div><p ><span class='texttt'>bool(u &gt;= t) == bool(C(u) &gt;= C(t)).</span>
</p></li></ul></div></div></div></div><div id='object'><h2 ><a class='secnum' href='#object' style='min-width:88pt'>7.5</a> Object concepts <a class='abbr_ref' href='concepts.lib.object'>[concepts.lib.object]</a></h2><div class='para' id='object-1'><div class='marginalizedparent'><a class='marginalized' href='#object-1'>1</a></div><p >This section describes concepts that specify the basis of the
value-oriented programming style on which the library is based.

</p></div><div id='object.movable'><h3 ><a class='secnum' href='#object.movable' style='min-width:103pt'>7.5.1</a> Concept <span class='texttt'>Movable</span> <a class='abbr_ref' href='concepts.lib.object.movable'>[concepts.lib.object.movable]</a></h3><p ><span class='indexparent'><a class='index' id='Movable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Movable =
  is_object&lt;T&gt;::value &amp;&amp;
  MoveConstructible&lt;T&gt; &amp;&amp;
  Assignable&lt;T&amp;, T&gt; &amp;&amp;
  Swappable&lt;T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='object.movable-1'><div class='marginalizedparent'><a class='marginalized' href='#object.movable-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Movable&lt;T&gt;</span> and
<span class='texttt'>is_object&lt;T&gt;::value</span>.
</p></div></div></div><div id='object.copyable'><h3 ><a class='secnum' href='#object.copyable' style='min-width:103pt'>7.5.2</a> Concept <span class='texttt'>Copyable</span> <a class='abbr_ref' href='concepts.lib.object.copyable'>[concepts.lib.object.copyable]</a></h3><p ><span class='indexparent'><a class='index' id='Copyable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Copyable =
  CopyConstructible&lt;T&gt; &amp;&amp;
  Movable&lt;T&gt; &amp;&amp;
  Assignable&lt;T&amp;, const T&amp;&gt;;
</code></p></div><div id='object.semiregular'><h3 ><a class='secnum' href='#object.semiregular' style='min-width:103pt'>7.5.3</a> Concept <span class='texttt'>Semiregular</span> <a class='abbr_ref' href='concepts.lib.object.semiregular'>[concepts.lib.object.semiregular]</a></h3><p ><span class='indexparent'><a class='index' id='Semiregular'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Semiregular =
  Copyable&lt;T&gt; &amp;&amp;
  DefaultConstructible&lt;T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='object.semiregular-1'><div class='marginalizedparent'><a class='marginalized' href='#object.semiregular-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>Semiregular</span> concept is satisfied by types that
behave similarly to built-in types like <span class='texttt'>int</span>, except that they may not be
comparable with <span class='texttt'>==</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='object.regular'><h3 ><a class='secnum' href='#object.regular' style='min-width:103pt'>7.5.4</a> Concept <span class='texttt'>Regular</span> <a class='abbr_ref' href='concepts.lib.object.regular'>[concepts.lib.object.regular]</a></h3><p ><span class='indexparent'><a class='index' id='Regular'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Regular =
  Semiregular&lt;T&gt; &amp;&amp;
  EqualityComparable&lt;T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='object.regular-1'><div class='marginalizedparent'><a class='marginalized' href='#object.regular-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>Regular</span> concept is satisfied by types that behave
similarly to built-in types like <span class='texttt'>int</span> and that are comparable with <span class='texttt'>==</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div><div id='callable'><h2 ><a class='secnum' href='#callable' style='min-width:88pt'>7.6</a> Callable concepts <a class='abbr_ref' href='concepts.lib.callable'>[concepts.lib.callable]</a></h2><div id='callable.general'><h3 ><a class='secnum' href='#callable.general' style='min-width:103pt'>7.6.1</a> General <a class='abbr_ref' href='concepts.lib.callable.general'>[concepts.lib.callable.general]</a></h3><div class='para' id='callable.general-1'><div class='marginalizedparent'><a class='marginalized' href='#callable.general-1'>1</a></div><p >The concepts in this section describe the requirements on function
objects (<a href='function.objects'>[function.objects]</a>) and their arguments.</p></div></div><div id='callable.invocable'><h3 ><a class='secnum' href='#callable.invocable' style='min-width:103pt'>7.6.2</a> Concept <span class='texttt'>Invocable</span> <a class='abbr_ref' href='concepts.lib.callable.invocable'>[concepts.lib.callable.invocable]</a></h3><div class='para' id='callable.invocable-1'><div class='marginalizedparent'><a class='marginalized' href='#callable.invocable-1'>1</a></div><p >The <span class='texttt'>Invocable</span> concept specifies a relationship between a callable
type (  ISO/IEC 14882:2014 &sect;<a href='../n4140/func.def'>[func.def]</a>) <span class='texttt'>F</span> and a set of argument types <span class='texttt'>Args...</span> which
can be evaluated by the library function <span class='texttt'>invoke</span> (<a href='func.invoke'>[func.invoke]</a>).</p><p ><span class='indexparent'><a class='index' id='Invocable'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt;
concept bool Invocable =
  requires(F&amp;&amp; f, Args&amp;&amp;... args) {
    invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class='comment'>// not required to be equality preserving
</span>  };
</code></p></div><div class='itemdescr'></div><div class='para' id='callable.invocable-2'><div class='marginalizedparent'><a class='marginalized' href='#callable.invocable-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Since the <span class='texttt'>invoke</span> function call
expression is not required to be
equality-preserving (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>), a function that generates random numbers
may satisfy <span class='texttt'>Invocable</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='callable.regularinvocable'><h3 ><a class='secnum' href='#callable.regularinvocable' style='min-width:103pt'>7.6.3</a> Concept <span class='texttt'>RegularInvocable</span> <a class='abbr_ref' href='concepts.lib.callable.regularinvocable'>[concepts.lib.callable.regularinvocable]</a></h3><p ><span class='indexparent'><a class='index' id='RegularInvocable'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt;
concept bool RegularInvocable =
  Invocable&lt;F, Args...&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='callable.regularinvocable-1'><div class='marginalizedparent'><a class='marginalized' href='#callable.regularinvocable-1'>1</a></div><div class='itemdescr'><p >The <span class='texttt'>invoke</span> function call expression shall be equality-preserving and
shall not modify the function object or the arguments (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
[&nbsp;<i>Note:</i> This requirement supersedes the
annotation in the definition of <span class='texttt'>Invocable</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='callable.regularinvocable-2'><div class='marginalizedparent'><a class='marginalized' href='#callable.regularinvocable-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> A random number generator does not satisfy
<span class='texttt'>RegularInvocable</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='callable.regularinvocable-3'><div class='marginalizedparent'><a class='marginalized' href='#callable.regularinvocable-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The distinction between <span class='texttt'>Invocable</span> and
<span class='texttt'>RegularInvocable</span> is purely semantic.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='callable.predicate'><h3 ><a class='secnum' href='#callable.predicate' style='min-width:103pt'>7.6.4</a> Concept <span class='texttt'>Predicate</span> <a class='abbr_ref' href='concepts.lib.callable.predicate'>[concepts.lib.callable.predicate]</a></h3><p ><span class='indexparent'><a class='index' id='Predicate'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt;
concept bool Predicate =
  RegularInvocable&lt;F, Args...&gt; &amp;&amp;
  Boolean&lt;result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;&gt;;
</code></p></div><div id='callable.relation'><h3 ><a class='secnum' href='#callable.relation' style='min-width:103pt'>7.6.5</a> Concept <span class='texttt'>Relation</span> <a class='abbr_ref' href='concepts.lib.callable.relation'>[concepts.lib.callable.relation]</a></h3><p ><span class='indexparent'><a class='index' id='Relation'></a></span><code class='itemdecl'>
template &lt;class R, class T, class U&gt;
concept bool Relation =
  Predicate&lt;R, T, T&gt; &amp;&amp;
  Predicate&lt;R, U, U&gt; &amp;&amp;
  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  Predicate&lt;R,
    common_reference_t&lt;
      const remove_reference_t&lt;T&gt;&amp;,
      const remove_reference_t&lt;U&gt;&amp;&gt;,
    common_reference_t&lt;
      const remove_reference_t&lt;T&gt;&amp;,
      const remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
  Predicate&lt;R, T, U&gt; &amp;&amp;
  Predicate&lt;R, U, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='callable.relation-1'><div class='marginalizedparent'><a class='marginalized' href='#callable.relation-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>r</span> be an expression such that <span class='texttt'>decltype((r))</span> is <span class='texttt'>R</span>,
<span class='texttt'>t</span> be an expression such that <span class='texttt'>decltype((t))</span> is <span class='texttt'>T</span>,
<span class='texttt'>u</span> be an expression such that <span class='texttt'>decltype((u))</span> is <span class='texttt'>U</span>,
and <span class='texttt'>C</span> be <span class='texttt'>common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;,
const remove_reference_t&lt;U&gt;&amp;&gt;</span>.
<span class='texttt'>Relation&lt;R, T, U&gt;</span> is satisfied only if</p><ul class='itemize'><li id='callable.relation-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#callable.relation-1.1'>(1.1)</a></div><p ><span class='texttt'>bool(r(t, u)) == bool(r(C(t), C(u))).</span>
</p></li><li id='callable.relation-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#callable.relation-1.2'>(1.2)</a></div><p ><span class='texttt'>bool(r(u, t)) == bool(r(C(u), C(t))).</span>
</p></li></ul></div></div></div><div id='callable.strictweakorder'><h3 ><a class='secnum' href='#callable.strictweakorder' style='min-width:103pt'>7.6.6</a> Concept <span class='texttt'>StrictWeakOrder</span> <a class='abbr_ref' href='concepts.lib.callable.strictweakorder'>[concepts.lib.callable.strictweakorder]</a></h3><p ><span class='indexparent'><a class='index' id='Relation'></a></span><code class='itemdecl'>
template &lt;class R, class T, class U&gt;
concept bool StrictWeakOrder = Relation&lt;R, T, U&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='callable.strictweakorder-1'><div class='marginalizedparent'><a class='marginalized' href='#callable.strictweakorder-1'>1</a></div><div class='itemdescr'><p >A <span class='texttt'>Relation</span> satisfies <span class='texttt'>StrictWeakOrder</span> only if
it imposes a <i>strict weak ordering</i> on its arguments.</p></div></div><div class='para' id='callable.strictweakorder-2'><div class='marginalizedparent'><a class='marginalized' href='#callable.strictweakorder-2'>2</a></div><div class='itemdescr'><p >The term
<i>strict</i>
refers to the
requirement of an irreflexive relation (<span class='texttt'>!comp(x, x)</span> for all <span class='texttt'>x</span>),
and the term
<i>weak</i>
to requirements that are not as strong as
those for a total ordering,
but stronger than those for a partial
ordering.
If we define
<span class='texttt'>equiv(a, b)</span>
as
<span class='texttt'>!comp(a, b) &amp;&amp; !comp(b, a)</span>,
then the requirements are that
<span class='texttt'>comp</span>
and
<span class='texttt'>equiv</span>
both be transitive  relations:</p><ul class='itemize'><li id='callable.strictweakorder-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#callable.strictweakorder-2.1'>(2.1)</a></div><p ><span class='texttt'>comp(a, b) &amp;&amp; comp(b, c)</span>
implies
<span class='texttt'>comp(a, c)</span>
</p></li><li id='callable.strictweakorder-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#callable.strictweakorder-2.2'>(2.2)</a></div><p ><span class='texttt'>equiv(a, b) &amp;&amp; equiv(b, c)</span>
implies
<span class='texttt'>equiv(a, c)</span>
[&nbsp;<i>Note:</i>
Under these conditions, it can be shown that
</p><ul class='itemize'><li id='callable.strictweakorder-2.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#callable.strictweakorder-2.2.1'>(2.2.1)</a></div><p ><span class='texttt'>equiv</span>
is an equivalence relation
</p></li><li id='callable.strictweakorder-2.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#callable.strictweakorder-2.2.2'>(2.2.2)</a></div><p ><span class='texttt'>comp</span>
induces a well-defined relation on the equivalence
classes determined by
<span class='texttt'>equiv</span>
</p></li><li id='callable.strictweakorder-2.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#callable.strictweakorder-2.2.3'>(2.2.3)</a></div><p >The induced relation is a strict total ordering.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></li></ul></div></div></div></div></div></div></body></html>