<!DOCTYPE html><html lang='en'><head><title>[diff.n3351]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><div id='diff.n3351'><h2 ><a class='secnum' style='min-width:88pt'>D.2</a> Ranges and the Palo Alto TR (N3351) <a class='abbr_ref'>[diff.n3351]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The Palo Alto report (<span class='cite'>palo-alto</span>) presents a comprehensive design for the Standard Template
Library constrained with concepts. It served both as a basis for the Concepts Lite language feature
and for this document. However, this document diverges from the Palo Alto report in small ways. The
differences are in the interests of backwards compatability, to avoid confusing a large installed
base of programmers already familiar with the STL, and to keep the scope of this document as small
as possible. This section describes the ways in which the two suggested designs differ.</p></div><div id='sentinels'><h3 ><a class='secnum' href='#sentinels' style='min-width:103pt'>D.2.1</a> Sentinels <a class='abbr_ref' href='diff.n3351.sentinels'>[diff.n3351.sentinels]</a></h3><div class='para' id='sentinels-1'><div class='marginalizedparent'><a class='marginalized' href='#sentinels-1'>1</a></div><p >In the design presented in this document, the type of a range's end delimiter may differ from the
iterator representing the range's start position. The reasons for this change are described in
N4128 (<span class='cite'>niebler2014</span>). This causes a number of differences from the Palo Alto report:</p><ul class='itemize'><li id='sentinels-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sentinels-1.1'>(1.1)</a></div><p >The algorithms get an additional constraint for the sentinel.
</p></li><li id='sentinels-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sentinels-1.2'>(1.2)</a></div><p >The return types of the algorithms are changed as described above (<a href='diff.cpp.algo_return'>[diff.cpp.algo_return]</a>).
</p></li><li id='sentinels-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sentinels-1.3'>(1.3)</a></div><p >Some algorithms have operational semantics that require them to know the
physical end position (e.g., <span class='texttt'>reverse</span>). Those algorithms must make an <span class='math'>Ο(<span class='math'><span class='mathalpha'>N</span></span>)</span> probe for
the end position before proceeding. This does not change the operational semantics of any code that
is valid today (the probe is unnecessary when the types of the begin and end are the
same), and even when the probe is needed, in no cases does this change the compexity guarantee of
any algorithm.
</p></li></ul></div></div><div id='invok_proj'><h3 ><a class='secnum' href='#invok_proj' style='min-width:103pt'>D.2.2</a> Invocables and Projections <a class='abbr_ref' href='diff.n3351.invok_proj'>[diff.n3351.invok_proj]</a></h3><div class='para' id='invok_proj-1'><div class='marginalizedparent'><a class='marginalized' href='#invok_proj-1'>1</a></div><p >Adobe's Source Libraries <span class='cite'>ASL</span> pioneered the use of <i>callables</i> and
<i>projections</i> in the standard algorithms. Invocables let users pass member pointers
where the algorithms expect callables, saving users the trouble of using a binder or a lambda.
Projections are extra optional arguments that give users a way to trivially transform input data
on the fly during the execution of the algorithms. Neither significantly changes the operational
semantics of the algorithms, but they do change the form of the algorithm constraints. To deal with
the extra complexity of the constraints, the design presented here adds higher-level composite
concepts for concisely expressing the necessary relationships between callables, iterators, and
projections.</p></div></div><div id='distance_type'><h3 ><a class='secnum' href='#distance_type' style='min-width:103pt'>D.2.3</a> No Distinct DistanceType Associated Type <a class='abbr_ref' href='diff.n3351.distance_type'>[diff.n3351.distance_type]</a></h3><div class='para' id='distance_type-1'><div class='marginalizedparent'><a class='marginalized' href='#distance_type-1'>1</a></div><p >In the Palo Alto report, the <span class='texttt'>WeaklyIncrementable</span> concept has an associated type called
<span class='texttt'>DistanceType</span>, and the <span class='texttt'>RandomAccessIterator</span> concepts adds another associated type
called <span class='texttt'>DifferenceType</span>. The latter is required to be convertible to the former, but they are
not required to be the same type. (<span class='texttt'>DifferenceType</span> is required to be a signed integral type,
but <span class='texttt'>DistanceType</span> need not be signed.) Although sensible from a soundness point of view,
the author of this document feels this is potentially a rich source of confusion. This document hews
closer to the current standard by having only one associated type, <span class='texttt'>DifferenceType</span>, and
requiring it to be signed.</p></div></div><div id='distance_algo'><h3 ><a class='secnum' href='#distance_algo' style='min-width:103pt'>D.2.4</a> Distance Primitive is O(1) for Random Access Iterators <a class='abbr_ref' href='diff.n3351.distance_algo'>[diff.n3351.distance_algo]</a></h3><div class='para' id='distance_algo-1'><div class='marginalizedparent'><a class='marginalized' href='#distance_algo-1'>1</a></div><p >In the Palo Alto report, the <span class='texttt'>distance</span> iterator primitive for computing the distance from one
iterator position to another is not implemented in terms of <span class='texttt'>operator-</span> for random access
iterators. <span class='texttt'>distance</span>, according to the report, should always be <span class='math'>Ο(<span class='math'><span class='mathalpha'>N</span></span>)</span>. It reads:</p><p ><div class='quote'>
The standard mandates a different definition for random access iterators:
<span class='texttt'>distance(i, j) == j - i</span>. We see this as a specification error; the guarantees of the
<span class='texttt'>distance</span> operation have been weakened for an iterator specialization.

In our design, we consider the two operations to be distinct.
</div></p><p >The design presented in this document keeps the specialization for random access iterators. To do
otherwise would be to silently break complexity guarantees in an unknown amount of working code.</p><p >To address the concern about weakened guarantees of the <span class='texttt'>distance</span> primitive, the design
presented here requires that random access iterators model
<span class='texttt'>SizedSentinel</span> (<a href='iterators.sizedsentinel'>[iterators.sizedsentinel]</a>). The <span class='texttt'>SizedSentinel</span>
concept requires that <span class='texttt'>b - a</span> return the number of times <span class='texttt'>a</span> would have to be
incremented to make it compare equal to <span class='texttt'>b</span>. Any type purporting to be a random access
iterator that fails to meet that requirement is by definition not a valid random access iterator.</p></div></div><div id='output_iters'><h3 ><a class='secnum' href='#output_iters' style='min-width:103pt'>D.2.5</a> Output Iterators <a class='abbr_ref' href='diff.n3351.output_iters'>[diff.n3351.output_iters]</a></h3><div class='para' id='output_iters-1'><div class='marginalizedparent'><a class='marginalized' href='#output_iters-1'>1</a></div><p >The Palo Alto report does not define concepts for output iterators, making do with
<span class='texttt'>WeaklyIncrementable</span>, <span class='texttt'>Writable</span>, and (where needed) <span class='texttt'>EqualityComparable</span>. The
author of this document sees little downside to grouping these into the familiar
<span class='texttt'>OutputIterator</span> concept. Even if not strictly needed, its absence would be surprising.</p></div></div><div id='no_eop_algos'><h3 ><a class='secnum' href='#no_eop_algos' style='min-width:103pt'>D.2.6</a> No Algorithm Reformulations <a class='abbr_ref' href='diff.n3351.no_eop_algos'>[diff.n3351.no_eop_algos]</a></h3><div class='para' id='no_eop_algos-1'><div class='marginalizedparent'><a class='marginalized' href='#no_eop_algos-1'>1</a></div><p >Between the standardization of the Standard Library and the Palo Alto report, much new research was
done to further generalize the standard algorithms
(see “Element of Programming”, Stepanov, McJones <span class='cite'>Stepanov:2009:EP:1614221</span>). The algorithms
presented in The Palo Alto report reflect the results of that research in the algorithm constraints,
some of which (e.g., <span class='texttt'>sort</span>, <span class='texttt'>inplace_merge</span>) take iterators with weaker categories than
they do in the current standard. The design presented in this document does not reflect those
changes. Although those changes are desirable, generalizing the algorithms as described in The Palo
Alto report feels like it would be best done in a separate proposal.
</p></div></div></div></div></body></html>