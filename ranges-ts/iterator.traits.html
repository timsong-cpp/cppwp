<!DOCTYPE html><html lang='en'><head><title>[iterator.traits]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>9.6</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives#iterator.traits'>[iterator.primitives]</a></h2><div id='iterator.traits'><h3 ><a class='secnum' style='min-width:103pt'>9.6.1</a> Iterator traits <a class='abbr_ref'>[iterator.traits]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The class templates <span class='texttt'>is_indirectly_movable</span>,
<span class='texttt'>is_nothrow_indirectly_movable</span>, <span class='texttt'>is_indirectly_swappable</span>,
and <span class='texttt'>is_nothrow_indirectly_swappable</span> shall be defined as follows:</p><pre class='codeblock'>
template &lt;class In, class Out&gt;
struct is_indirectly_movable : false_type { };

template &lt;class In, class Out&gt;
  requires IndirectlyMovable&lt;In, Out&gt;()
struct is_indirectly_movable&lt;In, Out&gt; : true_type { };

template &lt;class In, class Out&gt;
struct is_nothrow_indirectly_movable : false_type { };

template &lt;class In, class Out&gt;
  requires IndirectlyMovable&lt;In, Out&gt;()
struct is_nothrow_indirectly_movable&lt;In, Out&gt; :
  integral_constant&lt;bool,
    is_nothrow_constructible&lt;value_type_t&lt;In&gt;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;value_type_t&lt;In&gt; &amp;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;reference_t&lt;Out&gt;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;reference_t&lt;Out&gt;, value_type_t&lt;In&gt;&gt;::value&gt;{ };

template &lt;class I1, class I2 = I1&gt;
struct is_indirectly_swappable : false_type { };

template &lt;class I1, class I2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;()
struct is_indirectly_swappable&lt;I1, I2&gt; : true_type { };

template &lt;class I1, class I2 = I1&gt;
struct is_nothrow_indirectly_swappable : false_type { };

template &lt;class I1, class I2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;()
struct is_nothrow_indirectly_swappable&lt;I1, I2&gt; :
  integral_constant&lt;bool,
    noexcept(ranges::iter_swap(declval&lt;I1&amp;&gt;(), declval&lt;I2&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I2&amp;&gt;(), declval&lt;I1&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I1&amp;&gt;(), declval&lt;I1&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I2&amp;&gt;(), declval&lt;I2&amp;&gt;()))&gt;{ };
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For the sake of backwards compatibility, this document specifies the existence of an <span class='texttt'>iterator_traits</span>
alias that collects an iterator's associated types. It is defined as if:</p><p ><span class='indexparent'><a class='index' id='iterator_traits'></a></span></p><pre class='codeblock'>
  template &lt;InputIterator I&gt; struct __pointer_type {        <span class='comment'>// <i>exposition only</i>
</span>    using type = add_pointer_t&lt;reference_t&lt;I&gt;&gt;;
  };
  template &lt;InputIterator I&gt;
    requires requires(I i) { { i.operator-&gt;() } -&gt; auto&amp;&amp;; }
  struct __pointer_type&lt;I&gt; {                                    <span class='comment'>// <i>exposition only</i>
</span>    using type = decltype(declval&lt;I&gt;().operator-&gt;());
  };
  template &lt;class&gt; struct __iterator_traits { };                <span class='comment'>// <i>exposition only</i>
</span>  template &lt;Iterator I&gt; struct __iterator_traits&lt;I&gt; {
    using difference_type = difference_type_t&lt;I&gt;;
    using value_type = void;
    using reference = void;
    using pointer = void;
    using iterator_category = output_iterator_tag;
  };
  template &lt;InputIterator I&gt; struct __iterator_traits&lt;I&gt; {  <span class='comment'>// <i>exposition only</i>
</span>    using difference_type = difference_type_t&lt;I&gt;;
    using value_type = value_type_t&lt;I&gt;;
    using reference = reference_t&lt;I&gt;;
    using pointer = typename __pointer_type&lt;I&gt;::type;
    using iterator_category = iterator_category_t&lt;I&gt;;
  };
  template &lt;class I&gt;
    using iterator_traits = __iterator_traits&lt;I&gt;;
</pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i>
<span class='texttt'>iterator_traits</span> is an alias template
to prevent user code from specializing it.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i>
To implement a generic
<span class='texttt'>reverse</span>
function, a C++ program can do the following:</p><pre class='codeblock'>
template &lt;BidirectionalIterator I&gt;
void reverse(I first, I last) {
  difference_type_t&lt;I&gt; n = distance(first, last);
  --n;
  while(n &gt; 0) {
    value_type_t&lt;I&gt; tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>