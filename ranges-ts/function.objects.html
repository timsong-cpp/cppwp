<!DOCTYPE html><html lang='en'><head><title>[function.objects]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='function.objects'><h2 ><a class='secnum' style='min-width:88pt'>8.3</a> Function objects <a class='abbr_ref'>[function.objects]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><b>Header <span class='texttt'>&lt;experimental/ranges/functional&gt;</span> synopsis</b></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  <span class='comment'>// <a href='func.invoke'>[func.invoke]</a>, invoke:
</span>  template &lt;class F, class... Args&gt;
  result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);

  <span class='comment'>// <a href='comparisons'>[comparisons]</a>, comparisons:
</span>  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct equal_to;

  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct not_equal_to;

  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct greater;

  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct less;

  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct greater_equal;

  template &lt;class T = void&gt;
    requires <i><span class='texttt'>see below</span></i>
  struct less_equal;

  template &lt;&gt; struct equal_to&lt;void&gt;;
  template &lt;&gt; struct not_equal_to&lt;void&gt;;
  template &lt;&gt; struct greater&lt;void&gt;;
  template &lt;&gt; struct less&lt;void&gt;;
  template &lt;&gt; struct greater_equal&lt;void&gt;;
  template &lt;&gt; struct less_equal&lt;void&gt;;

  <span class='comment'>// <a href='func.identity'>[func.identity]</a>, identity:
</span>  struct identity;
}}}}
</pre></div><div id='func.invoke'><h3 ><a class='secnum' href='#func.invoke' style='min-width:103pt'>8.3.1</a> Function template <span class='texttt'>invoke</span> <a class='abbr_ref' href='func.invoke'>[func.invoke]</a></h3><p ><code class='itemdecl'>
template &lt;class F, class... Args&gt;
result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
</code>
</p><div class='itemdescr'></div><div class='para' id='func.invoke-1'><div class='marginalizedparent'><a class='marginalized' href='#func.invoke-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <br/> <span class='texttt'>return <i>INVOKE</i>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/func.require'>[func.require]</a>).
</p></div></div></div><div id='comparisons'><h3 ><a class='secnum' href='#comparisons' style='min-width:103pt'>8.3.2</a> Comparisons <a class='abbr_ref' href='comparisons'>[comparisons]</a></h3><div class='para' id='comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-1'>1</a></div><p >The library provides basic function object classes for all of the comparison
operators in the language (  ISO/IEC 14882:2014 &sect;<a href='../n4140/expr.rel'>[expr.rel]</a>,   ISO/IEC 14882:2014 &sect;<a href='../n4140/expr.eq'>[expr.eq]</a>).</p></div><div class='para' id='comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-2'>2</a></div><p >In this section, <span class='texttt'><i>BUILTIN_PTR_CMP</i>(T, <span class='math'><span class='mathalpha'>op</span></span>, U)</span> for types <span class='texttt'>T</span>
and <span class='texttt'>U</span> and where <span class='math'><span class='mathalpha'>op</span></span> is an equality (  ISO/IEC 14882:2014 &sect;<a href='../n4140/expr.eq'>[expr.eq]</a>) or relational
operator (  ISO/IEC 14882:2014 &sect;<a href='../n4140/expr.rel'>[expr.rel]</a>) is a boolean constant expression.
<span class='texttt'><i>BUILTIN_PTR_CMP</i>(T, <span class='math'><span class='mathalpha'>op</span></span>, U)</span> is <span class='texttt'>true</span> if and only if <span class='math'><span class='mathalpha'>op</span></span>
in the expression <span class='texttt'>declval&lt;T&gt;() <span class='math'><span class='mathalpha'>op</span></span> declval&lt;U&gt;()</span> resolves to a built-in
operator comparing pointers.</p></div><div class='para' id='comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-3'>3</a></div><p >There is an implementation-defined strict total ordering over all pointer values
of a given type. This total ordering is consistent with the partial order imposed
by the builtin operators <span class='texttt'>&lt;</span>, <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, and <span class='texttt'>&gt;=</span>.</p><p ><span class='indexparent'><a class='index' id='equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires EqualityComparable&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, ==, const T&amp;)
struct equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return equal_to&lt;&gt;@{}@(x, y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires EqualityComparable&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, ==, const T&amp;)
struct not_equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return !equal_to&lt;&gt;@{}@(x, y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='greater'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires StrictTotallyOrdered&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, &lt;, const T&amp;)
struct greater {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return less&lt;&gt;@{}@(y, x);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='less'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires StrictTotallyOrdered&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, &lt;, const T&amp;)
struct less {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-7'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return less&lt;&gt;@{}@(x, y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='greater_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires StrictTotallyOrdered&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, &lt;, const T&amp;)
struct greater_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-8'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return !less&lt;&gt;@{}@(x, y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='less_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt;
  requires StrictTotallyOrdered&lt;T&gt; || Same&lt;T, void&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(const T&amp;, &lt;, const T&amp;)
struct less_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-9'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to: <span class='texttt'>return !less&lt;&gt;@{}@(y, x);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct equal_to&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires EqualityComparableWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(T, ==, U)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-10'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> If the expression <span class='texttt'>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</span>
results in a call to a built-in operator <span class='texttt'>==</span> comparing pointers of type
<span class='texttt'>P</span>, the conversion sequences from both <span class='texttt'>T</span> and <span class='texttt'>U</span> to <span class='texttt'>P</span>
shall be equality-preserving (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).</p></div></div><div class='para' id='comparisons-11'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='comparisons-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#comparisons-11.1'>(11.1)</a></div><p >If the expression <span class='texttt'>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</span> results in a
call to a built-in operator <span class='texttt'>==</span> comparing pointers of type <span class='texttt'>P</span>:
returns <span class='texttt'>false</span> if either (the converted value of) <span class='texttt'>t</span> precedes
<span class='texttt'>u</span> or <span class='texttt'>u</span> precedes <span class='texttt'>t</span> in the implementation-defined strict
total order over pointers of type <span class='texttt'>P</span> and otherwise <span class='texttt'>true</span>.</p></li><li id='comparisons-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#comparisons-11.2'>(11.2)</a></div><p >Otherwise, equivalent to: <span class='texttt'>return std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u);</span>
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct not_equal_to&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires EqualityComparableWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(T, ==, U)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-12'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-12'>12</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to:
</p><pre class='codeblock'>
return !equal_to&lt;&gt;{}(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
</pre></div></div><p ><span class='indexparent'><a class='index' id='greater<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires StrictTotallyOrderedWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(U, &lt;, T)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-13'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-13'>13</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to:
</p><pre class='codeblock'>
return less&lt;&gt;{}(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
</pre></div></div><p ><span class='indexparent'><a class='index' id='less<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires StrictTotallyOrderedWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(T, &lt;, U)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-14'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the expression <span class='texttt'>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</span> results in a
call to a built-in operator <span class='texttt'>&lt;</span> comparing pointers of type <span class='texttt'>P</span>, the
conversion sequences from both <span class='texttt'>T</span> and <span class='texttt'>U</span> to <span class='texttt'>P</span> shall be
equality-preserving (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>). For any expressions
<span class='texttt'>ET</span> and <span class='texttt'>EU</span> such that <span class='texttt'>decltype((ET))</span> is <span class='texttt'>T</span> and
<span class='texttt'>decltype((EU))</span> is <span class='texttt'>U</span>, exactly one of <span class='texttt'>less&lt;&gt;{}(ET, EU)</span>,
<span class='texttt'>less&lt;&gt;{}(EU, ET)</span> or <span class='texttt'>equal_to&lt;&gt;{}(ET, EU)</span> shall be
<span class='texttt'>true</span>.</p></div></div><div class='para' id='comparisons-15'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='comparisons-15.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#comparisons-15.1'>(15.1)</a></div><p >If the expression <span class='texttt'>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</span> results in a
call to a built-in operator <span class='texttt'>&lt;</span> comparing pointers of type <span class='texttt'>P</span>:
returns <span class='texttt'>true</span> if (the converted value of) <span class='texttt'>t</span> precedes <span class='texttt'>u</span> in
the implementation-defined strict total order over pointers of type <span class='texttt'>P</span>
and otherwise <span class='texttt'>false</span>.</p></li><li id='comparisons-15.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#comparisons-15.2'>(15.2)</a></div><p >Otherwise, equivalent to: <span class='texttt'>return std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u);</span>
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='greater_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater_equal&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires StrictTotallyOrderedWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(T, &lt;, U)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-16'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-16'>16</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to:
</p><pre class='codeblock'>
return !less&lt;&gt;{}(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
</pre></div></div><p ><span class='indexparent'><a class='index' id='less_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less_equal&lt;void&gt; {
  template &lt;class T, class U&gt;
    requires StrictTotallyOrderedWith&lt;T, U&gt; || <i><span class='texttt'>BUILTIN_PTR_CMP</span></i>(U, &lt;, T)
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-17'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-17'>17</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> has effects equivalent to:
</p><pre class='codeblock'>
return !less&lt;&gt;{}(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
</pre></div></div></div><div id='func.identity'><h3 ><a class='secnum' href='#func.identity' style='min-width:103pt'>8.3.3</a> Class <span class='texttt'>identity</span> <a class='abbr_ref' href='func.identity'>[func.identity]</a></h3><p ><span class='indexparent'><a class='index' id='identity'></a></span><code class='itemdecl'>
struct identity {
  template &lt;class T&gt;
  constexpr T&amp;&amp; operator()(T&amp;&amp; t) const noexcept;

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='func.identity-1'><div class='marginalizedparent'><a class='marginalized' href='#func.identity-1'>1</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t)</span>.</p></div></div></div></div></div></body></html>