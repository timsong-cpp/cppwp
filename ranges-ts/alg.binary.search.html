<!DOCTYPE html><html lang='en'><head><title>[alg.binary.search]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>11</a> Algorithms library <a class='abbr_ref' href='./#algorithms'>[algorithms]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>11.5</a> Sorting and related operations <a class='abbr_ref' href='alg.sorting#alg.binary.search'>[alg.sorting]</a></h2><div id='alg.binary.search'><h3 ><a class='secnum' style='min-width:103pt'>11.5.3</a> Binary search <a class='abbr_ref'>[alg.binary.search]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >All of the algorithms in this section are versions of binary search
and assume that the sequence being searched is partitioned with respect to
an expression formed by binding the search key to an argument of the
comparison function and projection.
They work on non-random access iterators minimizing the number of comparisons,
which will be logarithmic for all types of iterators.
They are especially appropriate for random access iterators,
because these algorithms do a logarithmic number of steps
through the data structure.
For non-random access iterators they execute a linear number of steps.</p></div><div id='lower.bound'><h4 ><a class='secnum' href='#lower.bound' style='min-width:118pt'>11.5.3.1</a> <span class='texttt'>lower_bound</span> <a class='abbr_ref' href='lower.bound'>[lower.bound]</a></h4><p ><span class='indexparent'><a class='index' id='lower_bound'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    lower_bound(I first, S last, const T&amp; value, Comp comp = Comp{},
                Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    lower_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='lower.bound-1'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expression
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>.</p></div></div><div class='para' id='lower.bound-2'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The furthermost iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last]</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,i)</span>
the following corresponding condition holds:
<span class='texttt'>invoke(comp, invoke(proj, *j), value) != false</span>.</p></div></div><div class='para' id='lower.bound-3'><div class='marginalizedparent'><a class='marginalized' href='#lower.bound-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>Ο(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='upper.bound'><h4 ><a class='secnum' href='#upper.bound' style='min-width:118pt'>11.5.3.2</a> <span class='texttt'>upper_bound</span> <a class='abbr_ref' href='upper.bound'>[upper.bound]</a></h4><p ><span class='indexparent'><a class='index' id='upper_bound'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    upper_bound(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    upper_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='upper.bound-1'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expression
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='upper.bound-2'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The furthermost iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last]</span>
such that for every iterator
<span class='texttt'>j</span>
in the range
<span class='texttt'>[first,i)</span>
the following corresponding condition holds:
<span class='texttt'>invoke(comp, value, invoke(proj, *j)) == false</span>.</p></div></div><div class='para' id='upper.bound-3'><div class='marginalizedparent'><a class='marginalized' href='#upper.bound-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>Ο(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='equal.range'><h4 ><a class='secnum' href='#equal.range' style='min-width:118pt'>11.5.3.3</a> <span class='texttt'>equal_range</span> <a class='abbr_ref' href='equal.range'>[equal.range]</a></h4><p ><span class='indexparent'><a class='index' id='equal_range'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
    equal_range(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
              tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
    equal_range(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='equal.range-1'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
shall be partitioned with respect to the expressions
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
and
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.
Also, for all elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first, last)</span>,
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
shall imply
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='equal.range-2'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
</pre></div></div><div class='para' id='equal.range-3'><div class='marginalizedparent'><a class='marginalized' href='#equal.range-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'>2 * <span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>Ο(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div><div id='binary.search'><h4 ><a class='secnum' href='#binary.search' style='min-width:118pt'>11.5.3.4</a> <span class='texttt'>binary_search</span> <a class='abbr_ref' href='binary.search'>[binary.search]</a></h4><p ><span class='indexparent'><a class='index' id='binary_search'></a></span><code class='itemdecl'>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(I first, S last, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});
</code></p><div class='itemdescr'></div><div class='para' id='binary.search-1'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first,last)</span>
are partitioned with respect to the expressions
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
and
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.
Also, for all elements
<span class='texttt'>e</span>
of
<span class='texttt'>[first, last)</span>,
<span class='texttt'>invoke(comp, invoke(proj, e), value)</span>
shall imply
<span class='texttt'>!invoke(comp, value, invoke(proj, e))</span>.</p></div></div><div class='para' id='binary.search-2'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if there is an iterator
<span class='texttt'>i</span>
in the range
<span class='texttt'>[first,last)</span>
that satisfies the corresponding conditions:
<span class='texttt'>
invoke(comp, invoke(proj, *i), value) == false &amp;&amp;
invoke(comp, value, invoke(proj, *i)) == false</span>.</p></div></div><div class='para' id='binary.search-3'><div class='marginalizedparent'><a class='marginalized' href='#binary.search-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
At most
<span class='math'><span class="mathrm">log</span><sub >2</sub>(<span class='texttt'>last - first</span>) + <span class='math'>Ο(<span class='math'>1</span>)</span></span>
applications of the comparison function and projection.
</p></div></div></div></div></div></body></html>