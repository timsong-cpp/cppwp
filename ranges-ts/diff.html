<!DOCTYPE html><html lang='en'><head><title>[diff]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='diff'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><div id='cpp'><h2 ><a class='secnum' href='#cpp' style='min-width:88pt'>D.1</a> C++ and Ranges <a class='abbr_ref' href='diff.cpp'>[diff.cpp]</a></h2><div class='para' id='cpp-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp-1'>1</a></div><p >This section details the known breaking changes likely to effect user code when being ported to the
version of the Standard Library described in this document.</p></div><div id='cpp.algo_return'><h3 ><a class='secnum' href='#cpp.algo_return' style='min-width:103pt'>D.1.1</a> Algorithm Return Types <a class='abbr_ref' href='diff.cpp.algo_return'>[diff.cpp.algo_return]</a></h3><div class='para' id='cpp.algo_return-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.algo_return-1'>1</a></div><p >The algorithms described in this document permit the type of the end sentinel to differ from the
type of the begin iterator. This is so that the algorithms can operate on ranges for which the
physical end position is not yet known.</p></div><div class='para' id='cpp.algo_return-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.algo_return-2'>2</a></div><p >The physical end position of the input range is determined during the execution of many of the
algorithms. Rather than lose that potentially useful information, the design presented here has such
algorithms return the iterator position of the end of the range. In many cases, this is a breaking
change. Some algorithms that return iterators in today's STL are changed to return pairs, and
algorithms that return pairs today are changed to return tuples. This is likely to be the most
noticeable breaking change.</p></div><div class='para' id='cpp.algo_return-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.algo_return-3'>3</a></div><p >Alternate designs that were less impactful were considered and dismissed. See Section 3.3.6 in
N4128 (<span class='cite'>niebler2014</span>) for a discussion of the issues.</p></div></div><div id='cpp.constraints'><h3 ><a class='secnum' href='#cpp.constraints' style='min-width:103pt'>D.1.2</a> Stronger Constraints <a class='abbr_ref' href='diff.cpp.constraints'>[diff.cpp.constraints]</a></h3><div class='para' id='cpp.constraints-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.constraints-1'>1</a></div><p >In this proposal, many algorithms and utilities get stricter type checking. For example, algorithms
constrained with <span class='texttt'>LessThanComparable</span> today are constrained by <span class='texttt'>StrictTotallyOrdered</span> in this
document. This concept requires types to provide <i>all</i> the relational operators, not just
<span class='texttt'>operator&lt;</span>.</p></div><div class='para' id='cpp.constraints-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.constraints-2'>2</a></div><p >The use of coarser-grained, higher-level concepts in algorithm constraints is to make the type
checks more semantic in nature and less syntactic. It also has the benefit of being less verbose
while giving algorithm implementors greater implementation freedom. This approach is in contrast to
the previous effort to add concepts to the Standard Library in the C++0x timeframe, which saw a
proliferation of small, purely syntactic concepts and algorithm constraints that merely restated the
algorithms' implementation details more verbosely in the algorithms' function signatures.</p></div><div class='para' id='cpp.constraints-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.constraints-3'>3</a></div><p >The potential for breakage must be carefully weighed against the integrity and complexity of the
constraints system. The coarseness of the concepts may need to change in response to real-world
usage.</p></div></div><div id='cpp.functional'><h3 ><a class='secnum' href='#cpp.functional' style='min-width:103pt'>D.1.3</a> Constrained Functional Objects <a class='abbr_ref' href='diff.cpp.functional'>[diff.cpp.functional]</a></h3><div class='para' id='cpp.functional-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.functional-1'>1</a></div><p >The algorithm design described in this document assumes that the function objects
<span class='texttt'>std::equal_to</span> and <span class='texttt'>std::less</span> get constraints added to their function call operators.
(The former is constrained with <span class='texttt'>EqualityComparable</span> and the latter with
<span class='texttt'>StrictTotallyOrdered</span>). Similar constraints are added to the other function objects
in <span class='texttt'>&lt;functional&gt;</span>. As with the
coarsely-grained algorithm constraints, these function object constraints are likely to cause
user code to break.</p></div><div class='para' id='cpp.functional-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.functional-2'>2</a></div><p >Real-world experience is needed to assess the seriousness of the breakage. From a correctness point
of view, the constraints are logical and valuable, but it's possible that for the sake of
compatibility we provide both constrained and unconstrained functional objects.</p></div></div><div id='cpp.defaultconstruct'><h3 ><a class='secnum' href='#cpp.defaultconstruct' style='min-width:103pt'>D.1.4</a> Iterators and Default-Constructibility <a class='abbr_ref' href='diff.cpp.defaultconstruct'>[diff.cpp.defaultconstruct]</a></h3><div class='para' id='cpp.defaultconstruct-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.defaultconstruct-1'>1</a></div><p >In today's STL, iterators need not be default-constructible. The <span class='texttt'>Iterator</span> concept described
in this document requires default-constructibility. This could potentially cause breakage in users'
code. Also, it makes the implementation of some types of iterators more complicated. Any iterator
that has members that are not default constructible (e.g., an iterator that contains a lambda that
has captured by reference) must take special steps to provide default-constructibility (e.g.,
by wrapping non-default-constructible types in something like <span class='texttt'>std::optional</span>, as specified
in the C++17 Working Draft N4618 &sect;20.6). This can weaken class invariants.</p></div><div class='para' id='cpp.defaultconstruct-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.defaultconstruct-2'>2</a></div><p >The guarantee of default-constructibility simplifies the implementation of much iterator- and
range-based code that would otherwise need to wrap iterators in <span class='texttt'>std::optional</span>. But the
needs of backward-compatibility, the extra complexity to iterator implementors, and the weakened
invariants may prove to be too great a burden.</p></div><div class='para' id='cpp.defaultconstruct-3'><div class='marginalizedparent'><a class='marginalized' href='#cpp.defaultconstruct-3'>3</a></div><p >We may in fact go even farther and remove the requirement of default-constructibility from the
<span class='texttt'>Semiregular</span> concept. Time and experience will give us guidance here.</p></div></div><div id='cpp.iteratortraits'><h3 ><a class='secnum' href='#cpp.iteratortraits' style='min-width:103pt'>D.1.5</a> iterator_traits cannot be specialized <a class='abbr_ref' href='diff.cpp.iteratortraits'>[diff.cpp.iteratortraits]</a></h3><div class='para' id='cpp.iteratortraits-1'><div class='marginalizedparent'><a class='marginalized' href='#cpp.iteratortraits-1'>1</a></div><p >In this STL design, <span class='texttt'>iterator_traits</span> changes from being a class template to being an
alias template. This is to intentionally break any code that tries to specialize it. In its place
are the three class templates <span class='texttt'>difference_type</span>, <span class='texttt'>value_type</span>, and
<span class='texttt'>iterator_category</span>. The need for this traits balkanization is because the associated types
belong to separate concepts: <span class='texttt'>difference_type</span> belongs to <span class='texttt'>WeaklyIncrementable</span>;
<span class='texttt'>value_type</span> belongs to <span class='texttt'>Readable</span>; and <span class='texttt'>iterator_category</span> belongs to
<span class='texttt'>InputIterator</span>.</p></div><div class='para' id='cpp.iteratortraits-2'><div class='marginalizedparent'><a class='marginalized' href='#cpp.iteratortraits-2'>2</a></div><p >This breakage is intentional and inherent in the decomposition of the iterator concepts established
by the Palo Alto report (<span class='cite'>palo-alto</span>).</p></div></div></div><div id='n3351'><h2 ><a class='secnum' href='#n3351' style='min-width:88pt'>D.2</a> Ranges and the Palo Alto TR (N3351) <a class='abbr_ref' href='diff.n3351'>[diff.n3351]</a></h2><div class='para' id='n3351-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351-1'>1</a></div><p >The Palo Alto report (<span class='cite'>palo-alto</span>) presents a comprehensive design for the Standard Template
Library constrained with concepts. It served both as a basis for the Concepts Lite language feature
and for this document. However, this document diverges from the Palo Alto report in small ways. The
differences are in the interests of backwards compatability, to avoid confusing a large installed
base of programmers already familiar with the STL, and to keep the scope of this document as small
as possible. This section describes the ways in which the two suggested designs differ.</p></div><div id='n3351.sentinels'><h3 ><a class='secnum' href='#n3351.sentinels' style='min-width:103pt'>D.2.1</a> Sentinels <a class='abbr_ref' href='diff.n3351.sentinels'>[diff.n3351.sentinels]</a></h3><div class='para' id='n3351.sentinels-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.sentinels-1'>1</a></div><p >In the design presented in this document, the type of a range's end delimiter may differ from the
iterator representing the range's start position. The reasons for this change are described in
N4128 (<span class='cite'>niebler2014</span>). This causes a number of differences from the Palo Alto report:</p><ul class='itemize'><li id='n3351.sentinels-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#n3351.sentinels-1.1'>(1.1)</a></div><p >The algorithms get an additional constraint for the sentinel.
</p></li><li id='n3351.sentinels-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#n3351.sentinels-1.2'>(1.2)</a></div><p >The return types of the algorithms are changed as described above (<a href='diff.cpp.algo_return'>[diff.cpp.algo_return]</a>).
</p></li><li id='n3351.sentinels-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#n3351.sentinels-1.3'>(1.3)</a></div><p >Some algorithms have operational semantics that require them to know the
physical end position (e.g., <span class='texttt'>reverse</span>). Those algorithms must make an <span class='math'>Ο(<span class='math'><span class='mathalpha'>N</span></span>)</span> probe for
the end position before proceeding. This does not change the operational semantics of any code that
is valid today (the probe is unnecessary when the types of the begin and end are the
same), and even when the probe is needed, in no cases does this change the compexity guarantee of
any algorithm.
</p></li></ul></div></div><div id='n3351.invok_proj'><h3 ><a class='secnum' href='#n3351.invok_proj' style='min-width:103pt'>D.2.2</a> Invocables and Projections <a class='abbr_ref' href='diff.n3351.invok_proj'>[diff.n3351.invok_proj]</a></h3><div class='para' id='n3351.invok_proj-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.invok_proj-1'>1</a></div><p >Adobe's Source Libraries <span class='cite'>ASL</span> pioneered the use of <i>callables</i> and
<i>projections</i> in the standard algorithms. Invocables let users pass member pointers
where the algorithms expect callables, saving users the trouble of using a binder or a lambda.
Projections are extra optional arguments that give users a way to trivially transform input data
on the fly during the execution of the algorithms. Neither significantly changes the operational
semantics of the algorithms, but they do change the form of the algorithm constraints. To deal with
the extra complexity of the constraints, the design presented here adds higher-level composite
concepts for concisely expressing the necessary relationships between callables, iterators, and
projections.</p></div></div><div id='n3351.distance_type'><h3 ><a class='secnum' href='#n3351.distance_type' style='min-width:103pt'>D.2.3</a> No Distinct DistanceType Associated Type <a class='abbr_ref' href='diff.n3351.distance_type'>[diff.n3351.distance_type]</a></h3><div class='para' id='n3351.distance_type-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.distance_type-1'>1</a></div><p >In the Palo Alto report, the <span class='texttt'>WeaklyIncrementable</span> concept has an associated type called
<span class='texttt'>DistanceType</span>, and the <span class='texttt'>RandomAccessIterator</span> concepts adds another associated type
called <span class='texttt'>DifferenceType</span>. The latter is required to be convertible to the former, but they are
not required to be the same type. (<span class='texttt'>DifferenceType</span> is required to be a signed integral type,
but <span class='texttt'>DistanceType</span> need not be signed.) Although sensible from a soundness point of view,
the author of this document feels this is potentially a rich source of confusion. This document hews
closer to the current standard by having only one associated type, <span class='texttt'>DifferenceType</span>, and
requiring it to be signed.</p></div></div><div id='n3351.distance_algo'><h3 ><a class='secnum' href='#n3351.distance_algo' style='min-width:103pt'>D.2.4</a> Distance Primitive is <span class='math'>Ο(<span class='math'>1</span>)</span> for Random Access Iterators <a class='abbr_ref' href='diff.n3351.distance_algo'>[diff.n3351.distance_algo]</a></h3><div class='para' id='n3351.distance_algo-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.distance_algo-1'>1</a></div><p >In the Palo Alto report, the <span class='texttt'>distance</span> iterator primitive for computing the distance from one
iterator position to another is not implemented in terms of <span class='texttt'>operator-</span> for random access
iterators. <span class='texttt'>distance</span>, according to the report, should always be <span class='math'>Ο(<span class='math'><span class='mathalpha'>N</span></span>)</span>. It reads:</p><p ><div class='quote'>
The standard mandates a different definition for random access iterators:
<span class='texttt'>distance(i, j) == j - i</span>. We see this as a specification error; the guarantees of the
<span class='texttt'>distance</span> operation have been weakened for an iterator specialization.

In our design, we consider the two operations to be distinct.
</div></p><p >The design presented in this document keeps the specialization for random access iterators. To do
otherwise would be to silently break complexity guarantees in an unknown amount of working code.</p><p >To address the concern about weakened guarantees of the <span class='texttt'>distance</span> primitive, the design
presented here requires that random access iterators model
<span class='texttt'>SizedSentinel</span> (<a href='iterators.sizedsentinel'>[iterators.sizedsentinel]</a>). The <span class='texttt'>SizedSentinel</span>
concept requires that <span class='texttt'>b - a</span> return the number of times <span class='texttt'>a</span> would have to be
incremented to make it compare equal to <span class='texttt'>b</span>. Any type purporting to be a random access
iterator that fails to meet that requirement is by definition not a valid random access iterator.</p></div></div><div id='n3351.output_iters'><h3 ><a class='secnum' href='#n3351.output_iters' style='min-width:103pt'>D.2.5</a> Output Iterators <a class='abbr_ref' href='diff.n3351.output_iters'>[diff.n3351.output_iters]</a></h3><div class='para' id='n3351.output_iters-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.output_iters-1'>1</a></div><p >The Palo Alto report does not define concepts for output iterators, making do with
<span class='texttt'>WeaklyIncrementable</span>, <span class='texttt'>Writable</span>, and (where needed) <span class='texttt'>EqualityComparable</span>. The
author of this document sees little downside to grouping these into the familiar
<span class='texttt'>OutputIterator</span> concept. Even if not strictly needed, its absence would be surprising.</p></div></div><div id='n3351.no_eop_algos'><h3 ><a class='secnum' href='#n3351.no_eop_algos' style='min-width:103pt'>D.2.6</a> No Algorithm Reformulations <a class='abbr_ref' href='diff.n3351.no_eop_algos'>[diff.n3351.no_eop_algos]</a></h3><div class='para' id='n3351.no_eop_algos-1'><div class='marginalizedparent'><a class='marginalized' href='#n3351.no_eop_algos-1'>1</a></div><p >Between the standardization of the Standard Library and the Palo Alto report, much new research was
done to further generalize the standard algorithms
(see “Element of Programming”, Stepanov, McJones <span class='cite'>Stepanov:2009:EP:1614221</span>). The algorithms
presented in The Palo Alto report reflect the results of that research in the algorithm constraints,
some of which (e.g., <span class='texttt'>sort</span>, <span class='texttt'>inplace_merge</span>) take iterators with weaker categories than
they do in the current standard. The design presented in this document does not reflect those
changes. Although those changes are desirable, generalizing the algorithms as described in The Palo
Alto report feels like it would be best done in a separate proposal.
</p></div></div></div></div></div></body></html>