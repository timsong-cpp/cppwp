<!DOCTYPE html><html lang='en'><head><title>[concepts.lib.corelang]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Concepts library <a class='abbr_ref' href='./#concepts.lib'>[concepts.lib]</a></h1><div id='concepts.lib.corelang'><h2 ><a class='secnum' style='min-width:88pt'>7.3</a> Core language concepts <a class='abbr_ref'>[concepts.lib.corelang]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>7.3.1</a> In general <a class='abbr_ref' href='concepts.lib.corelang.general'>[concepts.lib.corelang.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This section contains the definition of concepts corresponding to language features.
These concepts express relationships between types, type classifications, and
fundamental type properties.</p></div></div><div id='same'><h3 ><a class='secnum' href='#same' style='min-width:103pt'>7.3.2</a> Concept <span class='texttt'>Same</span> <a class='abbr_ref' href='concepts.lib.corelang.same'>[concepts.lib.corelang.same]</a></h3><p ><span class='indexparent'><a class='index' id='Same'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Same = is_same&lt;T, U&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='same-1'><div class='marginalizedparent'><a class='marginalized' href='#same-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Same&lt;T, U&gt;</span> and
<span class='texttt'>is_same&lt;T, U&gt;::value</span>.</p></div></div><div class='para' id='same-2'><div class='marginalizedparent'><a class='marginalized' href='#same-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> For the purposes of constraint checking, <span class='texttt'>Same&lt;T, U&gt;</span> implies
<span class='texttt'>Same&lt;U, T&gt;</span>.
</p></div></div></div><div id='derived'><h3 ><a class='secnum' href='#derived' style='min-width:103pt'>7.3.3</a> Concept <span class='texttt'>DerivedFrom</span> <a class='abbr_ref' href='concepts.lib.corelang.derived'>[concepts.lib.corelang.derived]</a></h3><p ><span class='indexparent'><a class='index' id='DerivedFrom'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool DerivedFrom =
  is_base_of&lt;U, T&gt;::value &amp;&amp;
  is_convertible&lt;remove_cv_t&lt;T&gt;*, remove_cv_t&lt;U&gt;*&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='derived-1'><div class='marginalizedparent'><a class='marginalized' href='#derived-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>DerivedFrom&lt;T, U&gt;</span>
and either <span class='texttt'>is_base_of&lt;U, T&gt;::value</span> or
<span class='texttt'>is_convertible&lt;remove_cv_t&lt;T&gt;*, remove_cv_t&lt;U&gt;*&gt;::value</span>.</p></div></div><div class='para' id='derived-2'><div class='marginalizedparent'><a class='marginalized' href='#derived-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>DerivedFrom&lt;T, U&gt;</span> is satisfied if and only if <span class='texttt'>T</span> is
publicly and unambiguously derived from <span class='texttt'>U</span>, or <span class='texttt'>T</span> and <span class='texttt'>U</span>
are the same class type ignoring <i>cv</i>-qualifiers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='convertibleto'><h3 ><a class='secnum' href='#convertibleto' style='min-width:103pt'>7.3.4</a> Concept <span class='texttt'>ConvertibleTo</span> <a class='abbr_ref' href='concepts.lib.corelang.convertibleto'>[concepts.lib.corelang.convertibleto]</a></h3><p ><span class='indexparent'><a class='index' id='ConvertibleTo'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool ConvertibleTo =
  is_convertible&lt;From, To&gt;::value &amp;&amp; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span>  requires(From (&amp;f)()) {
    static_cast&lt;To&gt;(f());
  };
</code></p><div class='itemdescr'></div><div class='para' id='convertibleto-1'><div class='marginalizedparent'><a class='marginalized' href='#convertibleto-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>test</span> be the invented function:
</p><pre class='codeblock'>
To test(From (&amp;f)()) {
  return f();
}
</pre><p >and let <span class='texttt'>f</span> be a function with no arguments and return type <span class='texttt'>From</span>
such that <span class='texttt'>f()</span> is equality preserving.
<span class='texttt'>ConvertibleTo&lt;From, To&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='convertibleto-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#convertibleto-1.1'>(1.1)</a></div><p ><span class='texttt'>To</span> is not an object or reference-to-object type, or
<span class='texttt'>static_cast&lt;To&gt;(f())</span> is equal to <span class='texttt'>test(f)</span>.</p></li><li id='convertibleto-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#convertibleto-1.2'>(1.2)</a></div><p ><span class='texttt'>From</span> is not a reference-to-object type, or</p><ul class='itemize'><li id='convertibleto-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#convertibleto-1.2.1'>(1.2.1)</a></div><p >If <span class='texttt'>From</span> is an rvalue reference to a non const-qualified type, the resulting state of the object referenced by <span class='texttt'>f()</span> after either above expression is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).</p></li><li id='convertibleto-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#convertibleto-1.2.2'>(1.2.2)</a></div><p >Otherwise, the object referred to by <span class='texttt'>f()</span> is not modified by either above expression.
</p></li></ul></li></ul></div></div><div class='para' id='convertibleto-2'><div class='marginalizedparent'><a class='marginalized' href='#convertibleto-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>ConvertibleTo&lt;From, To&gt;</span>
and <span class='texttt'>is_convertible&lt;From, To&gt;::value</span>.
</p></div></div></div><div id='commonref'><h3 ><a class='secnum' href='#commonref' style='min-width:103pt'>7.3.5</a> Concept <span class='texttt'>CommonReference</span> <a class='abbr_ref' href='concepts.lib.corelang.commonref'>[concepts.lib.corelang.commonref]</a></h3><div class='para' id='commonref-1'><div class='marginalizedparent'><a class='marginalized' href='#commonref-1'>1</a></div><p >For two types <span class='texttt'>T</span> and <span class='texttt'>U</span>, if <span class='texttt'>common_reference_t&lt;T, U&gt;</span>
is well-formed and denotes a type <span class='texttt'>C</span> such that both
<span class='texttt'>ConvertibleTo&lt;T, C&gt;</span> and <span class='texttt'>ConvertibleTo&lt;U, C&gt;</span> are
satisfied, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common reference
type</i>, <span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or
<span class='texttt'>U</span>, or it could be a different type. <span class='texttt'>C</span> may be a reference
type. <span class='texttt'>C</span> need not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='CommonReference'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool CommonReference =
  Same&lt;common_reference_t&lt;T, U&gt;, common_reference_t&lt;U, T&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;T, common_reference_t&lt;T, U&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;U, common_reference_t&lt;T, U&gt;&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='commonref-2'><div class='marginalizedparent'><a class='marginalized' href='#commonref-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_reference_t&lt;T, U&gt;</span>. Let <span class='texttt'>t</span> be a
function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>CommonReference&lt;T, U&gt;</span> is satisfied
only if:
</p><ul class='itemize'><li id='commonref-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#commonref-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if <span class='texttt'>t()</span> is an
  equality preserving expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='commonref-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#commonref-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if <span class='texttt'>u()</span> is an
  equality preserving expression.
</p></li></ul></div></div><div class='para' id='commonref-3'><div class='marginalizedparent'><a class='marginalized' href='#commonref-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>CommonReference</span> by specializing the
<span class='texttt'>basic_common_reference</span> class template (<a href='meta.trans.other'>[meta.trans.other]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='common'><h3 ><a class='secnum' href='#common' style='min-width:103pt'>7.3.6</a> Concept <span class='texttt'>Common</span> <a class='abbr_ref' href='concepts.lib.corelang.common'>[concepts.lib.corelang.common]</a></h3><div class='para' id='common-1'><div class='marginalizedparent'><a class='marginalized' href='#common-1'>1</a></div><p >If <span class='texttt'>T</span> and <span class='texttt'>U</span> can both be explicitly converted to some third type,
<span class='texttt'>C</span>, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common type</i>,
<span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or <span class='texttt'>U</span>, or
it could be a different type. <span class='texttt'>C</span> may not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Common'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Common =
  Same&lt;common_type_t&lt;T, U&gt;, common_type_t&lt;U, T&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;T, common_type_t&lt;T, U&gt;&gt; &amp;&amp;
  ConvertibleTo&lt;U, common_type_t&lt;T, U&gt;&gt; &amp;&amp;
  CommonReference&lt;
    add_lvalue_reference_t&lt;const T&gt;,
    add_lvalue_reference_t&lt;const U&gt;&gt; &amp;&amp;
  CommonReference&lt;
    add_lvalue_reference_t&lt;common_type_t&lt;T, U&gt;&gt;,
    common_reference_t&lt;
      add_lvalue_reference_t&lt;const T&gt;,
      add_lvalue_reference_t&lt;const U&gt;&gt;&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='common-2'><div class='marginalizedparent'><a class='marginalized' href='#common-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_type_t&lt;T, U&gt;</span>. Let
<span class='texttt'>t</span> be a function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>Common&lt;T, U&gt;</span> is satisfied only if:
</p><ul class='itemize'><li id='common-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if
  <span class='texttt'>t()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='common-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if
  <span class='texttt'>u()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li></ul></div></div><div class='para' id='common-3'><div class='marginalizedparent'><a class='marginalized' href='#common-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>Common</span> by specializing the <span class='texttt'>common_type</span>
class template (<a href='meta.unary.prop'>[meta.unary.prop]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='integral'><h3 ><a class='secnum' href='#integral' style='min-width:103pt'>7.3.7</a> Concept <span class='texttt'>Integral</span> <a class='abbr_ref' href='concepts.lib.corelang.integral'>[concepts.lib.corelang.integral]</a></h3><p ><span class='indexparent'><a class='index' id='Integral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Integral = is_integral&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='integral-1'><div class='marginalizedparent'><a class='marginalized' href='#integral-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Integral&lt;T&gt;</span> and
<span class='texttt'>is_integral&lt;T&gt;::value</span>.
</p></div></div></div><div id='signedintegral'><h3 ><a class='secnum' href='#signedintegral' style='min-width:103pt'>7.3.8</a> Concept <span class='texttt'>SignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.signedintegral'>[concepts.lib.corelang.signedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='SignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool SignedIntegral = Integral&lt;T&gt; &amp;&amp; is_signed&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p><div class='itemdescr'></div><div class='para' id='signedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#signedintegral-1'>1</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>SignedIntegral&lt;T&gt;</span> and
<span class='texttt'>is_signed&lt;T&gt;::value</span>.</p></div></div><div class='para' id='signedintegral-2'><div class='marginalizedparent'><a class='marginalized' href='#signedintegral-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>SignedIntegral&lt;T&gt;</span> may be satisfied even for
types that are not signed integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='unsignedintegral'><h3 ><a class='secnum' href='#unsignedintegral' style='min-width:103pt'>7.3.9</a> Concept <span class='texttt'>UnsignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.unsignedintegral'>[concepts.lib.corelang.unsignedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='UnsignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='unsignedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#unsignedintegral-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>UnsignedIntegral&lt;T&gt;</span> may be satisfied even for
types that are not unsigned integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='assignable'><h3 ><a class='secnum' href='#assignable' style='min-width:103pt'>7.3.10</a> Concept <span class='texttt'>Assignable</span> <a class='abbr_ref' href='concepts.lib.corelang.assignable'>[concepts.lib.corelang.assignable]</a></h3><p ><span class='indexparent'><a class='index' id='Assignable'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Assignable =
  is_lvalue_reference&lt;T&gt;::value &amp;&amp; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span>  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  requires(T t, U&amp;&amp; u) {
    { t = std::forward&lt;U&gt;(u) } -&gt; Same&lt;T&gt;&amp;&amp;;
  };
</code></p><div class='itemdescr'></div><div class='para' id='assignable-1'><div class='marginalizedparent'><a class='marginalized' href='#assignable-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> be an lvalue that refers to an object <span class='texttt'>o</span> such that
<span class='texttt'>decltype((t))</span> is <span class='texttt'>T</span>, and <span class='texttt'>u</span> an expression such that
<span class='texttt'>decltype((u))</span> is <span class='texttt'>U</span>. Let <span class='texttt'>u2</span> be a distinct object that is
equal to <span class='texttt'>u</span>. <span class='texttt'>Assignable&lt;T, U&gt;</span> is satisfied only if</p><ul class='itemize'><li id='assignable-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assignable-1.1'>(1.1)</a></div><p ><span class='texttt'>addressof(t = u) == addressof(o)</span>.</p></li><li id='assignable-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assignable-1.2'>(1.2)</a></div><p >After evaluating <span class='texttt'>t = u</span>:</p><ul class='itemize'><li id='assignable-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#assignable-1.2.1'>(1.2.1)</a></div><p ><span class='texttt'>t</span> is equal to <span class='texttt'>u2</span>, unless <span class='texttt'>u</span> is a non-const xvalue that refers to <span class='texttt'>o</span>.</p></li><li id='assignable-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#assignable-1.2.2'>(1.2.2)</a></div><p >If <span class='texttt'>u</span> is a non-<span class='texttt'>const</span> xvalue, the resulting state of the
object to which it refers is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).</p></li><li id='assignable-1.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#assignable-1.2.3'>(1.2.3)</a></div><p >Otherwise, if <span class='texttt'>u</span> is a glvalue, the object to which it refers is not
modified.
</p></li></ul></li></ul></div></div><div class='para' id='assignable-2'><div class='marginalizedparent'><a class='marginalized' href='#assignable-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Assignable&lt;T, U&gt;</span>
and <span class='texttt'>is_lvalue_reference&lt;T&gt;::value</span>.</p></div></div><div class='para' id='assignable-3'><div class='marginalizedparent'><a class='marginalized' href='#assignable-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Assignment need not be a total function (<a href='structure.requirements'>[structure.requirements]</a>);
in particular, if assignment to an object <span class='texttt'>x</span> can result in a modification
of some other object <span class='texttt'>y</span>, then <span class='texttt'>x = y</span> is likely not in the domain
of <span class='texttt'>=</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='swappable'><h3 ><a class='secnum' href='#swappable' style='min-width:103pt'>7.3.11</a> Concept <span class='texttt'>Swappable</span> <a class='abbr_ref' href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a></h3><p ><span class='indexparent'><a class='index' id='Swappable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Swappable =
  requires(T&amp; a, T&amp; b) {
    ranges::swap(a, b);
  };

template &lt;class T, class U&gt;
concept bool SwappableWith =
  CommonReference&lt;
    const remove_reference_t&lt;T&gt;&amp;,
    const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
  requires(T&amp;&amp; t, U&amp;&amp; u) {
    ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;T&gt;(t));
    ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;U&gt;(u));
    ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
    ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
  };
</code></p><div class='itemdescr'></div><div class='para' id='swappable-1'><div class='marginalizedparent'><a class='marginalized' href='#swappable-1'>1</a></div><div class='itemdescr'><p >This subclause provides definitions for swappable types and expressions. In these
definitions, let <span class='texttt'>t</span> denote an expression of type <span class='texttt'>T</span>, and let <span class='texttt'>u</span>
denote an expression of type <span class='texttt'>U</span>.</p></div></div><div class='para' id='swappable-2'><div class='marginalizedparent'><a class='marginalized' href='#swappable-2'>2</a></div><div class='itemdescr'><p >An object <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable_with' id='def:swappable_with'><i>swappable with</i></a> an object <span class='texttt'>u</span> if and only if
<span class='texttt'>SwappableWith&lt;T, U&gt;</span> is satisfied. <span class='texttt'>SwappableWith&lt;T, U&gt;</span> is satisfied
only if given distinct objects <span class='texttt'>t2</span> equal to <span class='texttt'>t</span>
and <span class='texttt'>u2</span> equal to <span class='texttt'>u</span>, after evaluating either
<span class='texttt'>ranges::swap(t, u)</span> or <span class='texttt'>ranges::swap(u, t)</span>, <span class='texttt'>t2</span> is equal to
<span class='texttt'>u</span> and <span class='texttt'>u2</span> is equal to <span class='texttt'>t</span>.</p></div></div><div class='para' id='swappable-3'><div class='marginalizedparent'><a class='marginalized' href='#swappable-3'>3</a></div><div class='itemdescr'><p >An rvalue or lvalue <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable' id='def:swappable'><i>swappable</i></a> if and only if <span class='texttt'>t</span> is
swappable with any rvalue or lvalue, respectively, of type <span class='texttt'>T</span>.</p><p >[&nbsp;<i>Example:</i> User code can ensure that the evaluation of <span class='texttt'>swap</span> calls
is performed in an appropriate context under the various conditions as follows:
</p><pre class='codeblock'>
#include &lt;utility&gt;

<span class='comment'>// Requires: <span class='texttt'>std::forward&lt;T&gt;(t)</span> shall be swappable with <span class='texttt'>std::forward&lt;U&gt;(u)</span>.
</span>template &lt;class T, class U&gt;
void value_swap(T&amp;&amp; t, U&amp;&amp; u) {
  using std::experimental::ranges::swap;
  swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));         <span class='comment'>// OK: uses “swappable with” conditions
</span>                                                        <span class='comment'>// for rvalues and lvalues
</span>}

<span class='comment'>// Requires: lvalues of <span class='texttt'>T</span> shall be swappable.
</span>template &lt;class T&gt;
void lv_swap(T&amp; t1, T&amp; t2) {
  using std::experimental::ranges::swap;
  swap(t1, t2);                                         <span class='comment'>// OK: uses swappable conditions for
</span>}                                                       <span class='comment'>// lvalues of type <span class='texttt'>T</span>
</span>
namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A&amp; a) { return Proxy{ &amp;a }; }

  void swap(A&amp; x, Proxy p) {
    std::experimental::ranges::swap(x.m, p.a-&gt;m);  <span class='comment'>// OK: uses context equivalent to swappable
</span>                                                   <span class='comment'>// conditions for fundamental types
</span>  }
  void swap(Proxy p, A&amp; x) { swap(x, p); }         <span class='comment'>// satisfy symmetry constraint
</span>}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 &amp;&amp; j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 &amp;&amp; a2.m == 5);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='destructible'><h3 ><a class='secnum' href='#destructible' style='min-width:103pt'>7.3.12</a> Concept <span class='texttt'>Destructible</span> <a class='abbr_ref' href='concepts.lib.corelang.destructible'>[concepts.lib.corelang.destructible]</a></h3><div class='para' id='destructible-1'><div class='marginalizedparent'><a class='marginalized' href='#destructible-1'>1</a></div><p >The <span class='texttt'>Destructible</span> concept specifies properties of all types, instances of
which can be destroyed at the end of their lifetime, or reference types.</p><p ><span class='indexparent'><a class='index' id='Destructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Destructible = is_nothrow_destructible&lt;T&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p></div><div class='itemdescr'></div><div class='para' id='destructible-2'><div class='marginalizedparent'><a class='marginalized' href='#destructible-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Destructible&lt;T&gt;</span>
and <span class='texttt'>is_nothrow_destructible&lt;T&gt;::value</span>.</p></div></div><div class='para' id='destructible-3'><div class='marginalizedparent'><a class='marginalized' href='#destructible-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Unlike the <span class='texttt'>Destructible</span> library concept in the C++
Standard (  ISO/IEC 14882:2014 &sect;<a href='../n4140/utility.arg.requirements'>[utility.arg.requirements]</a>), this concept forbids destructors
that are <span class='texttt'>noexcept(false)</span>, even if non-throwing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='constructible'><h3 ><a class='secnum' href='#constructible' style='min-width:103pt'>7.3.13</a> Concept <span class='texttt'>Constructible</span> <a class='abbr_ref' href='concepts.lib.corelang.constructible'>[concepts.lib.corelang.constructible]</a></h3><div class='para' id='constructible-1'><div class='marginalizedparent'><a class='marginalized' href='#constructible-1'>1</a></div><p >The <span class='texttt'>Constructible</span> concept constrains the initialization of a variable of
a type with a given set of argument types.</p><p ><span class='indexparent'><a class='index' id='Constructible'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
concept bool Constructible =
  Destructible&lt;T&gt; &amp;&amp; is_constructible&lt;T, Args...&gt;::value; <span class='comment'>// <i><span class='texttt'>see below</span></i>
</span></code></p></div><div class='itemdescr'></div><div class='para' id='constructible-2'><div class='marginalizedparent'><a class='marginalized' href='#constructible-2'>2</a></div><div class='itemdescr'><p >There need not be any subsumption relationship between <span class='texttt'>Constructible&lt;T, Args...&gt;</span>
and <span class='texttt'>is_constructible&lt;T, Args...&gt;::value</span>.
</p></div></div></div><div id='defaultconstructible'><h3 ><a class='secnum' href='#defaultconstructible' style='min-width:103pt'>7.3.14</a> Concept <span class='texttt'>DefaultConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.defaultconstructible'>[concepts.lib.corelang.defaultconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='DefaultConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool DefaultConstructible = Constructible&lt;T&gt;;
</code></p></div><div id='moveconstructible'><h3 ><a class='secnum' href='#moveconstructible' style='min-width:103pt'>7.3.15</a> Concept <span class='texttt'>MoveConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.moveconstructible'>[concepts.lib.corelang.moveconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='MoveConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool MoveConstructible =
  Constructible&lt;T, T&gt; &amp;&amp; ConvertibleTo&lt;T, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='moveconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#moveconstructible-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>T</span> is an object type, then let <span class='texttt'>rv</span> be an rvalue of type <span class='texttt'>T</span>
and <span class='texttt'>u2</span> a distinct object of type <span class='texttt'>T</span> equal to <span class='texttt'>rv</span>.
<span class='texttt'>MoveConstructible&lt;T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='moveconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#moveconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = rv;</span>, <span class='texttt'>u</span> is equal to <span class='texttt'>u2</span>.</p></li><li id='moveconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#moveconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{rv}</span> is equal to <span class='texttt'>u2</span>.</p></li><li id='moveconstructible-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#moveconstructible-1.3'>(1.3)</a></div><p >If <span class='texttt'>T</span> is not <span class='texttt'>const</span>, <span class='texttt'>rv</span>'s resulting state is valid
but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>); otherwise, it is unchanged.
</p></li></ul></div></div></div><div id='copyconstructible'><h3 ><a class='secnum' href='#copyconstructible' style='min-width:103pt'>7.3.16</a> Concept <span class='texttt'>CopyConstructible</span> <a class='abbr_ref' href='concepts.lib.corelang.copyconstructible'>[concepts.lib.corelang.copyconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='CopyConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool CopyConstructible =
  MoveConstructible&lt;T&gt; &amp;&amp;
  Constructible&lt;T, T&amp;&gt; &amp;&amp; ConvertibleTo&lt;T&amp;, T&gt; &amp;&amp;
  Constructible&lt;T, const T&amp;&gt; &amp;&amp; ConvertibleTo&lt;const T&amp;, T&gt; &amp;&amp;
  Constructible&lt;T, const T&gt; &amp;&amp; ConvertibleTo&lt;const T, T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='copyconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#copyconstructible-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>T</span> is an object type, then let <span class='texttt'>v</span> be an lvalue of type (possibly
<span class='texttt'>const</span>) <span class='texttt'>T</span> or an rvalue of type <span class='texttt'>const T</span>.
<span class='texttt'>CopyConstructible&lt;T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='copyconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copyconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = v;</span>, <span class='texttt'>u</span> is equal to <span class='texttt'>v</span>.</p></li><li id='copyconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copyconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{v}</span> is equal to <span class='texttt'>v</span>.
</p></li></ul></div></div></div></div></div></body></html>