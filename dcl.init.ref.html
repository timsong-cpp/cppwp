<!DOCTYPE html><html lang='en'><head><title>[dcl.init.ref]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.6</a> Initializers <a class='abbr_ref' href='dcl.init#ref'>[dcl.init]</a></h2><div id='dcl.init.ref'><h3 ><a class='secnum' style='min-width:103pt'>8.6.3</a> References <a class='abbr_ref'>[dcl.init.ref]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,reference'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A variable whose declared type is
“reference to type <span class='texttt'>T</span>” (<a href='dcl.ref'>[dcl.ref]</a>)
shall be initialized.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int g(int) noexcept;
void f() {
  int i;
  int&amp; r = i;                   <span class='comment'>// <span class='texttt'>r</span> refers to <span class='texttt'>i</span>
</span>  r = 1;                        <span class='comment'>// the value of <span class='texttt'>i</span> becomes <span class='texttt'>1</span>
</span>  int* p = &amp;r;                  <span class='comment'>// <span class='texttt'>p</span> points to <span class='texttt'>i</span>
</span>  int&amp; rr = r;                  <span class='comment'>// <span class='texttt'>rr</span> refers to what <span class='texttt'>r</span> refers to, that is, to <span class='texttt'>i</span>
</span>  int (&amp;rg)(int) = g;           <span class='comment'>// <span class='texttt'>rg</span> refers to the function <span class='texttt'>g</span>
</span>  rg(i);                        <span class='comment'>// calls function <span class='texttt'>g</span>
</span>  int a[3];
  int (&amp;ra)[3] = a;             <span class='comment'>// <span class='texttt'>ra</span> refers to the array <span class='texttt'>a</span>
</span>  ra[1] = i;                    <span class='comment'>// modifies <span class='texttt'>a[1]</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A reference cannot be changed to refer to another object after initialization.
<span class='indexparent'><a class='index' id='assignment,reference'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
Assignment to a reference assigns to the object referred to by the reference (<a href='expr.ass'>[expr.ass]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='argument_passing,reference_and'></a></span>Argument passing (<a href='expr.call'>[expr.call]</a>)
<span class='indexparent'><a class='index' id='return,reference_and'></a></span>and function value return (<a href='stmt.return'>[stmt.return]</a>) are initializations.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The initializer can be omitted for a reference only in a parameter declaration
(<a href='dcl.fct'>[dcl.fct]</a>), in the declaration of a function return type, in the declaration of
a class member within its class definition (<a href='class.mem'>[class.mem]</a>), and where the
<span class='texttt'>extern</span>
specifier is explicitly used.
<span class='indexparent'><a class='index' id='declaration,extern'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int&amp; r1;                        <span class='comment'>// error: initializer missing
</span>extern int&amp; r2;                 <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Given types “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” and “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>”,
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-related</i> to
<span class='indexparent'><a class='index' id='reference-related'></a></span>“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span> is the same type as <span class='texttt'>T2</span>, or
<span class='texttt'>T1</span> is a base class of <span class='texttt'>T2</span>.
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-compatible</i>
<span class='indexparent'><a class='index' id='reference-compatible'></a></span>with “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
</p><ul ><li ><p ><span class='texttt'>T1</span> is reference-related to <span class='texttt'>T2</span>, or
</p></li><li ><p ><span class='texttt'>T2</span> is “<span class='texttt'>noexcept</span> function” and <span class='texttt'>T1</span> is “function”,
where the function types are otherwise the same,
</p></li></ul><p >and
<i>cv1</i>
is the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>,
a program that necessitates such a binding is ill-formed if
<span class='texttt'>T1</span>
is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>)
base class of
<span class='texttt'>T2</span>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A reference to type “<i>cv1</i> <span class='texttt'>T1</span>” is initialized by
an expression of type “<i>cv2</i> <span class='texttt'>T2</span>” as follows:<span class='indexparent'><a class='index' id='binding,reference'></a></span></p><ul ><li ><p >If the reference is an lvalue reference and the initializer expression</p><ul ><li ><p >is an lvalue (but is not a
bit-field), and
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>”, or
</p></li><li ><p >has a class type (i.e.,
<span class='texttt'>T2</span>
is a class type), where <span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>, and can be converted
to an lvalue of type “<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”, where
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”<a class='footnotenum' href='#footnote-106'>106</a>
(this conversion is selected by enumerating the applicable conversion
functions (<a href='over.match.ref'>[over.match.ref]</a>) and choosing the best one through overload
resolution (<a href='over.match'>[over.match]</a>)),
</p></li></ul><p >then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
[&nbsp;<i>Note:</i><span class='space'></span>
The usual lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer
(<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
double d = 2.0;
double&amp; rd = d;                 <span class='comment'>// <span class='texttt'>rd</span> refers to <span class='texttt'>d</span>
</span>const double&amp; rcd = d;          <span class='comment'>// <span class='texttt'>rcd</span> refers to <span class='texttt'>d</span>
</span>
struct A { };
struct B : A { operator int&amp;(); } b;
A&amp; ra = b;                      <span class='comment'>// <span class='texttt'>ra</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>const A&amp; rca = b;               <span class='comment'>// <span class='texttt'>rca</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>int&amp; ir = B();                  <span class='comment'>// <span class='texttt'>ir</span> refers to the result of <span class='texttt'>B::operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
<i>cv1</i>
shall be
<span class='texttt'>const</span>), or the reference shall be an rvalue reference.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
double&amp; rd2 = 2.0;              <span class='comment'>// error: not an lvalue and reference not <span class='texttt'>const</span>
</span>int  i = 2;
double&amp; rd3 = i;                <span class='comment'>// error: type mismatch and reference not <span class='texttt'>const</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><ul ><li ><p >If the initializer expression</p><ul ><li ><p >is an rvalue (but not a bit-field) or function lvalue and
“<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv2</i> <span class='texttt'>T2</span>”, or</p></li><li ><p >has a class type (i.e., <span class='texttt'>T2</span> is a class type), where <span class='texttt'>T1</span>
is not reference-related to <span class='texttt'>T2</span>, and can be converted to
an rvalue or function lvalue of type “<i>cv3</i> <span class='texttt'>T3</span>”,
where “<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv3</i> <span class='texttt'>T3</span>” (see <a href='over.match.ref'>[over.match.ref]</a>),</p></li></ul><p >then the reference is bound to the value of the initializer expression in the first
case and to the result of the conversion in the second case (or, in either case, to
an appropriate base class subobject) after applying the temporary materialization conversion (<a href='conv.rval'>[conv.rval]</a>).</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { };
struct B : A { } b;
extern B f();
const A&amp; rca2 = f();                <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the <span class='texttt'>B</span> rvalue.
</span>A&amp;&amp; rra = f();                      <span class='comment'>// same as above
</span>struct X {
  operator B();
  operator int&amp;();
} x;
const A&amp; r = x;                     <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the result of the conversion
</span>int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); <span class='comment'>// bound directly to <span class='texttt'>i2</span>
</span>B&amp;&amp; rrb = x;                        <span class='comment'>// bound directly to the result of <span class='texttt'>operator B</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise:
</p><ul ><li ><p >If <span class='texttt'>T1</span> or <span class='texttt'>T2</span> is a class type and
<span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>,
user-defined conversions are considered
using the rules for copy-initialization of an object of type 
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” by
user-defined conversion
(<a href='dcl.init'>[dcl.init]</a>, <a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.conv'>[over.match.conv]</a>);
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
For this direct-initialization, user-defined conversions are not considered.
</p></li><li ><p >Otherwise,
the initializer expression is implicitly converted to a prvalue
of type “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>”.
The temporary materialization conversion is applied and the reference is
bound to the result.
</p></li></ul><p >If
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>:
</p><ul ><li ><p ><i>cv1</i>
shall be the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>; and
</p></li><li ><p >if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&amp;(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &amp;&amp;banana1 = ConstBanana(); <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana2 = Enigma();      <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana3 = Alaska();      <span class='comment'>// ill-formed
</span>}

const double&amp; rcd2 = 2;         <span class='comment'>// <span class='texttt'>rcd2</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>double&amp;&amp; rrd = 2;               <span class='comment'>// <span class='texttt'>rrd</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>const volatile int cvi = 1;
const int&amp; r2 = cvi;            <span class='comment'>// error: type qualifiers dropped
</span>struct A { operator volatile int&amp;(); } a;
const int&amp; r3 = a;              <span class='comment'>// error: type qualifiers dropped
</span>                                <span class='comment'>// from result of conversion function
</span>double d2 = 1.0;
double&amp;&amp; rrd2 = d2;             <span class='comment'>// error: initializer is lvalue of related type
</span>struct X { operator int&amp;(); };
int&amp;&amp; rri2 = X();               <span class='comment'>// error: result of conversion function is lvalue of related type
</span>int i3 = 2;
double&amp;&amp; rrd3 = i3;             <span class='comment'>// <span class='texttt'>rrd3</span> refers to temporary with value <span class='texttt'>2.0</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></li></ul><p >In all cases except the last
(i.e., implicitly converting the initializer expression
to the underlying type of the reference),
the reference is said to <a class='hidden_link' href='#def:bind_directly' id='def:bind_directly'><i>bind directly</i></a> to the
initializer expression.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<a href='class.temporary'>[class.temporary]</a> describes the lifetime of temporaries bound to references.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-106'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-106'>106)</a></div><p >This requires a conversion
function (<a href='class.conv.fct'>[class.conv.fct]</a>) returning a reference type.</p></div></div></div></body></html>