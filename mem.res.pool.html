<!DOCTYPE html><html lang='en'><head><title>[mem.res.pool]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.12</a> Memory resources <a class='abbr_ref' href='mem.res#pool'>[mem.res]</a></h2><div id='mem.res.pool'><h3 ><a class='secnum' style='min-width:103pt'>20.12.5</a> Pool resource classes <a class='abbr_ref'>[mem.res.pool]</a></h3><div id='overview'><h4 ><a class='secnum' href='#overview' style='min-width:118pt'>20.12.5.1</a> Classes <span class='texttt'>synchronized_pool_resource</span> and <span class='texttt'>unsynchronized_pool_resource</span> <a class='abbr_ref' href='mem.res.pool.overview'>[mem.res.pool.overview]</a></h4><div class='para' id='overview-1'><div class='marginalizedparent'><a class='marginalized' href='#overview-1'>1</a></div><p >The <span class='texttt'>synchronized_pool_resource</span> and
<span class='texttt'>unsynchronized_pool_resource</span> classes
(collectively called <a class='hidden_link' href='#def:pool_resource_classes' id='def:pool_resource_classes'><i>pool resource classes</i></a>)
are general-purpose memory resources having the following qualities:
</p><ul class='itemize'><li id='overview-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#overview-1.1'>(1.1)</a></div><p >Each resource <a class='hidden_link' href='#def:owns' id='def:owns'><i>owns</i></a> the allocated memory, and frees it on destruction –
even if <span class='texttt'>deallocate</span> has not been called for some of the allocated blocks.
</p></li><li id='overview-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#overview-1.2'>(1.2)</a></div><p >A pool resource consists of a collection of <a class='hidden_link' href='#def:pools' id='def:pools'><i>pools</i></a>,
serving requests for different block sizes.
Each individual pool manages a collection of <a class='hidden_link' href='#def:chunks' id='def:chunks'><i>chunks</i></a>
that are in turn divided into blocks of uniform size,
returned via calls to <span class='texttt'>do_allocate</span>.
Each call to <span class='texttt'>do_allocate(size, alignment)</span> is dispatched
to the pool serving the smallest blocks accommodating at least <span class='texttt'>size</span> bytes.
</p></li><li id='overview-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#overview-1.3'>(1.3)</a></div><p >When a particular pool is exhausted,
allocating a block from that pool results in the allocation
of an additional chunk of memory from the <a class='hidden_link' href='#def:upstream_allocator' id='def:upstream_allocator'><i>upstream allocator</i></a>
(supplied at construction), thus replenishing the pool.
With each successive replenishment,
the chunk size obtained increases geometrically.
[&nbsp;<i>Note:</i>
By allocating memory in chunks,
the pooling strategy increases the chance that consecutive allocations
will be close together in memory.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='overview-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#overview-1.4'>(1.4)</a></div><p >Allocation requests that exceed the largest block size of any pool
are fulfilled directly from the upstream allocator.
</p></li><li id='overview-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#overview-1.5'>(1.5)</a></div><p >A <span class='texttt'>pool_options</span> struct may be passed to the pool resource constructors
to tune the largest block size and the maximum chunk size.
</p></li></ul></div><div class='para' id='overview-2'><div class='marginalizedparent'><a class='marginalized' href='#overview-2'>2</a></div><p >A <span class='texttt'>synchronized_pool_resource</span> may be accessed from multiple threads
without external synchronization
and may have thread-specific pools to reduce synchronization costs.
An <span class='texttt'>unsynchronized_pool_resource</span> class may not be accessed
from multiple threads simultaneously
and thus avoids the cost of synchronization entirely
in single-threaded applications.</p><p ><span class='indexparent'><a class='index' id='pool_options'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource'></a></span></p><pre class='codeblock'>
struct pool_options {
  size_t max_blocks_per_chunk = 0;
  size_t largest_required_pool_block = 0;
};

class synchronized_pool_resource : public memory_resource {
public:
  synchronized_pool_resource(const pool_options &amp;opts,
                             memory_resource *upstream);

  synchronized_pool_resource()
      : synchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit synchronized_pool_resource(memory_resource *upstream)
      : synchronized_pool_resource(pool_options(), upstream) {}
  explicit synchronized_pool_resource(const pool_options &amp;opts)
      : synchronized_pool_resource(opts, get_default_resource()) {}

  synchronized_pool_resource(const synchronized_pool_resource &amp;) = delete;
  virtual ~synchronized_pool_resource();

  synchronized_pool_resource &amp;
    operator=(const synchronized_pool_resource &amp;) = delete;

  void release();
  memory_resource *upstream_resource() const;
  pool_options options() const;

protected:
  void *do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void *p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource &amp;other) const noexcept override;
};

class unsynchronized_pool_resource : public memory_resource {
public:
  unsynchronized_pool_resource(const pool_options &amp;opts,
                               memory_resource *upstream);

  unsynchronized_pool_resource()
      : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit unsynchronized_pool_resource(memory_resource *upstream)
      : unsynchronized_pool_resource(pool_options(), upstream) {}
  explicit unsynchronized_pool_resource(const pool_options &amp;opts)
      : unsynchronized_pool_resource(opts, get_default_resource()) {}

  unsynchronized_pool_resource(const unsynchronized_pool_resource &amp;) = delete;
  virtual ~unsynchronized_pool_resource();

  unsynchronized_pool_resource &amp;
    operator=(const unsynchronized_pool_resource &amp;) = delete;

  void release();
  memory_resource *upstream_resource() const;
  pool_options options() const;

protected:
  void *do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void *p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource &amp;other) const noexcept override;
};
</pre></div></div><div id='options'><h4 ><a class='secnum' href='#options' style='min-width:118pt'>20.12.5.2</a> <span class='texttt'>pool_options</span> data members <a class='abbr_ref' href='mem.res.pool.options'>[mem.res.pool.options]</a></h4><div class='para' id='options-1'><div class='marginalizedparent'><a class='marginalized' href='#options-1'>1</a></div><p >The members of <span class='texttt'>pool_options</span>
comprise a set of constructor options for pool resources.
The effect of each option on the pool resource behavior is described below:</p><p ><span class='indexparent'><a class='index' id='pool_options,max_blocks_per_chunk'></a></span><code class='itemdecl'>
size_t max_blocks_per_chunk;
</code></p></div><div class='itemdescr'></div><div class='para' id='options-2'><div class='marginalizedparent'><a class='marginalized' href='#options-2'>2</a></div><div class='itemdescr'><p >The maximum number of blocks that will be allocated at once
from the upstream memory resource (<a href='mem.res.monotonic.buffer'>[mem.res.monotonic.buffer]</a>)
to replenish a pool.
If the value of <span class='texttt'>max_blocks_per_chunk</span> is zero or
is greater than an <span class='indexparent'><a class='index' id='largest_supported_value_to_configure_the_maximum_number_of_blocks_to_replenish_a_pool'></a></span>implementation-defined
limit, that limit is used instead.
The implementation
may choose to use a smaller value than is specified in this field and
may use different values for different pools.
</p></div></div><p ><span class='indexparent'><a class='index' id='pool_options,largest_required_pool_block'></a></span><code class='itemdecl'>
size_t largest_required_pool_block;
</code></p><div class='itemdescr'></div><div class='para' id='options-3'><div class='marginalizedparent'><a class='marginalized' href='#options-3'>3</a></div><div class='itemdescr'><p >The largest allocation size that is required to be fulfilled
using the pooling mechanism.
Attempts to allocate a single block larger than this threshold
will be allocated directly from the upstream memory resource.
If <span class='texttt'>largest_required_pool_block</span> is zero or
is greater than an <span class='indexparent'><a class='index' id='largest_supported_value_to_configure_the_largest_allocation_satisfied_directly_by_a_pool'></a></span>implementation-defined
limit, that limit is used instead.
The implementation may choose a pass-through threshold
larger than specified in this field.
</p></div></div></div><div id='ctor'><h4 ><a class='secnum' href='#ctor' style='min-width:118pt'>20.12.5.3</a> Pool resource constructors and destructors <a class='abbr_ref' href='mem.res.pool.ctor'>[mem.res.pool.ctor]</a></h4><p ><span class='indexparent'><a class='index' id='synchronized_pool_resource,constructor'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,constructor'></a></span><code class='itemdecl'>
synchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);
unsynchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>upstream</span> is the address of a valid memory resource.</p></div></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a pool resource object that will obtain memory from <span class='texttt'>upstream</span>
whenever the pool resource is unable to satisfy a memory request
from its own internal data structures.
The resulting object will hold a copy of <span class='texttt'>upstream</span>,
but will not own the resource to which <span class='texttt'>upstream</span> points.
[&nbsp;<i>Note:</i>
The intention is that calls to <span class='texttt'>upstream-&gt;allocate()</span>
will be substantially fewer than calls to <span class='texttt'>this-&gt;allocate()</span>
in most cases.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The behavior of the pooling mechanism is tuned
according to the value of the <span class='texttt'>opts</span> argument.</p></div></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless <span class='texttt'>upstream-&gt;allocate()</span> throws.
It is unspecified if, or under what conditions,
this constructor calls <span class='texttt'>upstream-&gt;allocate()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='synchronized_pool_resource,destructor'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,destructor'></a></span><code class='itemdecl'>
virtual ~synchronized_pool_resource();
virtual ~unsynchronized_pool_resource();
</code></p><div class='itemdescr'></div><div class='para' id='ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#ctor-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls <span class='texttt'>release()</span>.
</p></div></div></div><div id='mem'><h4 ><a class='secnum' href='#mem' style='min-width:118pt'>20.12.5.4</a> Pool resource members <a class='abbr_ref' href='mem.res.pool.mem'>[mem.res.pool.mem]</a></h4><p ><span class='indexparent'><a class='index' id='release,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,release'></a></span><span class='indexparent'><a class='index' id='release,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,release'></a></span><code class='itemdecl'>
void release();
</code></p><div class='itemdescr'></div><div class='para' id='mem-1'><div class='marginalizedparent'><a class='marginalized' href='#mem-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls <span class='texttt'>upstream_resource()-&gt;deallocate()</span> as necessary
to release all allocated memory.
[&nbsp;<i>Note:</i>
The memory is released back to <span class='texttt'>upstream_resource()</span>
even if <span class='texttt'>deallocate</span> has not been called
for some of the allocated blocks.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='upstream_resource,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,upstream_resource'></a></span><span class='indexparent'><a class='index' id='upstream_resource,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,upstream_resource'></a></span><code class='itemdecl'>
memory_resource* upstream_resource() const;
</code></p><div class='itemdescr'></div><div class='para' id='mem-2'><div class='marginalizedparent'><a class='marginalized' href='#mem-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The value of the <span class='texttt'>upstream</span> argument
provided to the constructor of this object.
</p></div></div><p ><span class='indexparent'><a class='index' id='options,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,options'></a></span><span class='indexparent'><a class='index' id='options,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,options'></a></span><code class='itemdecl'>
pool_options options() const;
</code></p><div class='itemdescr'></div><div class='para' id='mem-3'><div class='marginalizedparent'><a class='marginalized' href='#mem-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
The options that control the pooling behavior of this resource.
The values in the returned struct may differ
from those supplied to the pool resource constructor in that
values of zero will be replaced with <span class='indexparent'><a class='index' id='default_configuration_of_a_pool'></a></span>implementation-defined
defaults, and sizes may be rounded to unspecified granularity.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_allocate,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,do_allocate'></a></span><span class='indexparent'><a class='index' id='do_allocate,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,do_allocate'></a></span><code class='itemdecl'>
void* do_allocate(size_t bytes, size_t alignment) override;
</code></p><div class='itemdescr'></div><div class='para' id='mem-4'><div class='marginalizedparent'><a class='marginalized' href='#mem-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to allocated storage (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
with a size of at least <span class='texttt'>bytes</span>.
The size and alignment of the allocated memory shall meet the requirements
for a class derived from <span class='texttt'>memory_resource</span> (<a href='mem.res'>[mem.res]</a>).</p></div></div><div class='para' id='mem-5'><div class='marginalizedparent'><a class='marginalized' href='#mem-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
If the pool selected for a block of size <span class='texttt'>bytes</span>
is unable to satisfy the memory request from its own internal data structures,
it will call <span class='texttt'>upstream_resource()-&gt;allocate()</span> to obtain more memory.
If <span class='texttt'>bytes</span> is larger than that which the largest pool can handle,
then memory will be allocated using <span class='texttt'>upstream_resource()-&gt;allocate()</span>.</p></div></div><div class='para' id='mem-6'><div class='marginalizedparent'><a class='marginalized' href='#mem-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless <span class='texttt'>upstream_resource()-&gt;allocate()</span> throws.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_deallocate,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,do_deallocate'></a></span><span class='indexparent'><a class='index' id='do_deallocate,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,do_deallocate'></a></span><code class='itemdecl'>
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
</code></p><div class='itemdescr'></div><div class='para' id='mem-7'><div class='marginalizedparent'><a class='marginalized' href='#mem-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Returns the memory at <span class='texttt'>p</span> to the pool.
It is unspecified if, or under what circumstances,
this operation will result in a call to <span class='texttt'>upstream_resource()-&gt;deallocate()</span>.</p></div></div><div class='para' id='mem-8'><div class='marginalizedparent'><a class='marginalized' href='#mem-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_is_equal,unsynchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource,do_is_equal'></a></span><code class='itemdecl'>
bool unsynchronized_pool_resource::do_is_equal(const memory_resource&amp; other) const noexcept override;
</code></p><div class='itemdescr'></div><div class='para' id='mem-9'><div class='marginalizedparent'><a class='marginalized' href='#mem-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>this == dynamic_cast&lt;const unsynchronized_pool_resource*&gt;(&amp;other)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_is_equal,synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource,do_is_equal'></a></span><code class='itemdecl'>
bool synchronized_pool_resource::do_is_equal(const memory_resource&amp; other) const noexcept override;
</code></p><div class='itemdescr'></div><div class='para' id='mem-10'><div class='marginalizedparent'><a class='marginalized' href='#mem-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>this == dynamic_cast&lt;const synchronized_pool_resource*&gt;(&amp;other)</span>.
</p></div></div></div></div></div></body></html>