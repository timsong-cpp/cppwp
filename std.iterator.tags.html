<!DOCTYPE html><html lang='en'><head><title>[std.iterator.tags]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>27</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>27.4</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives#std.iterator.tags'>[iterator.primitives]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>27.4.2</a> Standard iterator tags <a class='abbr_ref'>[std.iterator.tags]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/82796606a63a7c62b05785593f651fba105f1c2c/source/iterators.tex#L976'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id='lib:input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='lib:output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='lib:forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='lib:bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='lib:random_access_iterator_tag'></a></span>It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>To facilitate this, the
library introduces
<span class='textit'>category tag</span>
classes which are used as compile time tags for algorithm selection<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>They are:
<span class='texttt'>input_&shy;iterator_&shy;tag</span>,
<span class='texttt'>output_&shy;iterator_&shy;tag</span>,
<span class='texttt'>forward_&shy;iterator_&shy;tag</span>,
<span class='texttt'>bidirectional_&shy;iterator_&shy;tag</span>
and
<span class='texttt'>random_&shy;access_&shy;iterator_&shy;tag</span><a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>For every iterator of type
<span class='texttt'>Iterator</span>,
<span class='texttt'>iterator_&shy;traits&lt;Iterator&gt;&#x200b;::&#x200b;iterator_&shy;category</span>
shall be defined to be the most specific category tag that describes the
iterator's behavior<a class='hidden_link' href='#1.sentence-4'>.</a></div><div id='1.sentence-5' class='sentence'><pre class='codeblock'>
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
}</pre></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/82796606a63a7c62b05785593f651fba105f1c2c/source/iterators.tex#L1013'>#</a></div><div id='2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id='lib:empty'></a></span><span class='indexparent'><a class='index' id='lib:input_iterator_tag_'></a></span><span class='indexparent'><a class='index' id='lib:output_iterator_tag_'></a></span><span class='indexparent'><a class='index' id='lib:forward_iterator_tag_'></a></span><span class='indexparent'><a class='index' id='lib:bidirectional_iterator_tag_'></a></span><span class='indexparent'><a class='index' id='lib:random_access_iterator_tag_'></a></span><div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='2.sentence-2' class='sentence'>For a program-defined iterator
<span class='texttt'>BinaryTreeIterator</span>,
it could be included
into the bidirectional iterator category by specializing the
<span class='texttt'>iterator_&shy;traits</span>
template:</div><div id='2.sentence-3' class='sentence'><pre class='codeblock'>
template&lt;class T&gt; struct iterator_traits&lt;BinaryTreeIterator&lt;T&gt;&gt; {
  using iterator_category = bidirectional_iterator_tag;
  using difference_type   = ptrdiff_t;
  using value_type        = T;
  using pointer           = T*;
  using reference         = T&amp;;
};</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/82796606a63a7c62b05785593f651fba105f1c2c/source/iterators.tex#L1039'>#</a></div><div id='3.sentence-1' class='sentence'><div id='3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='3.sentence-2' class='sentence'>If
<span class='texttt'>evolve()</span>
is well defined for bidirectional iterators, but can be implemented more
efficiently for random access iterators, then the implementation is as follows:</div><div id='3.sentence-3' class='sentence'><pre class='codeblock'>
template &lt;class BidirectionalIterator&gt;
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits&lt;BidirectionalIterator&gt;::iterator_category());
}

template &lt;class BidirectionalIterator&gt;
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  <span class='comment'>// more generic, but less efficient algorithm
</span>}

template &lt;class RandomAccessIterator&gt;
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  <span class='comment'>// more efficient, but less generic algorithm
</span>}</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div></div></div></body></html>