<!DOCTYPE html><html lang='en'><head><title>[std.iterator.tags]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>24</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>24.4</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives#std.iterator.tags'>[iterator.primitives]</a></h2><div id='std.iterator.tags'><h3 ><a class='secnum' style='min-width:103pt'>24.4.2</a> Standard iterator tags <a class='abbr_ref'>[std.iterator.tags]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
<i>category tag</i>
classes which are used as compile time tags for algorithm selection.
They are:
<span class='texttt'>input_iterator_tag</span>,
<span class='texttt'>output_iterator_tag</span>,
<span class='texttt'>forward_iterator_tag</span>,
<span class='texttt'>bidirectional_iterator_tag</span>
and
<span class='texttt'>random_access_iterator_tag</span>.
For every iterator of type
<span class='texttt'>Iterator</span>,
<span class='texttt'>iterator_traits&lt;Iterator&gt;::iterator_category</span>
shall be defined to be the most specific category tag that describes the
iterator's behavior.</p><pre class='codeblock'>
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
}
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='empty'></a></span><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>[&nbsp;<i>Example:</i><span class='space'></span>
For a program-defined iterator
<span class='texttt'>BinaryTreeIterator</span>,
it could be included
into the bidirectional iterator category by specializing the
<span class='texttt'>iterator_traits</span>
template:</p><pre class='codeblock'>
template&lt;class T&gt; struct iterator_traits&lt;BinaryTreeIterator&lt;T&gt; &gt; {
  using iterator_category = bidirectional_iterator_tag;
  using difference_type   = ptrdiff_t;
  using value_type        = T;
  using pointer           = T*;
  using reference         = T&amp;;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
If
<span class='texttt'>evolve()</span>
is well defined for bidirectional iterators, but can be implemented more
efficiently for random access iterators, then the implementation is as follows:</p><pre class='codeblock'>
template &lt;class BidirectionalIterator&gt;
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits&lt;BidirectionalIterator&gt;::iterator_category());
}

template &lt;class BidirectionalIterator&gt;
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  <span class='comment'>// more generic, but less efficient algorithm
</span>}

template &lt;class RandomAccessIterator&gt;
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  <span class='comment'>// more efficient, but less generic algorithm
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>