<!DOCTYPE html><html lang='en'><head><title>[basic.compound]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.9</a> Types <a class='abbr_ref' href='basic.types#basic.compound'>[basic.types]</a></h2><div id='basic.compound'><h3 ><a class='secnum' style='min-width:103pt'>3.9.2</a> Compound types <a class='abbr_ref'>[basic.compound]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/473966e60653e8e2bc8ed154d8b18a3736f97088/source/basic.tex#L3898'>#</a></div><p ><span class='indexparent'><a class='index' id='type,compound'></a></span>Compound types can be constructed in the following ways:
</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p ><a class='hidden_link' href='#def:type,array' id='def:type,array'><i>arrays</i></a> of objects of a given type, <a href='dcl.array'>[dcl.array]</a>;</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p ><a class='hidden_link' href='#def:type,function' id='def:type,function'><i>functions</i></a>, which have parameters of given types and return
<span class='texttt'>void</span> or references or objects of a given type, <a href='dcl.fct'>[dcl.fct]</a>;</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p ><a class='hidden_link' href='#def:type,pointer' id='def:type,pointer'><i>pointers</i></a> to <span class='textit'>cv</span> <span class='texttt'>void</span> or objects or functions (including
static members of classes) of a given type, <a href='dcl.ptr'>[dcl.ptr]</a>;</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p ><span class='indexparent'><a class='index' id='reference,lvalue'></a></span><span class='indexparent'><a class='index' id='reference,rvalue'></a></span><a class='hidden_link' href='#def:reference' id='def:reference'><i>references</i></a> to objects or functions of a given
type, <a href='dcl.ref'>[dcl.ref]</a>. There are two types of references:
</p><ul class='itemize'><li id='1.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.4.1'>(1.4.1)</a></div><p ><a class='hidden_link' href='#def:lvalue_reference' id='def:lvalue_reference'><i>lvalue reference</i></a>
</p></li><li id='1.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.4.2'>(1.4.2)</a></div><p ><a class='hidden_link' href='#def:rvalue_reference' id='def:rvalue_reference'><i>rvalue reference</i></a>
</p></li></ul></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><p ><a class='hidden_link' href='#def:class' id='def:class'><i>classes</i></a> containing a sequence of objects of various types
(Clause <a href='class'>[class]</a>), a set of types, enumerations and functions for
manipulating these objects (<a href='class.mfct'>[class.mfct]</a>), and a set of restrictions
on the access to these entities (Clause <a href='class.access'>[class.access]</a>);</p></li><li id='1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.6'>(1.6)</a></div><p ><a class='hidden_link' href='#def:union' id='def:union'><i>unions</i></a>, which are classes capable of containing objects of
different types at different times, <a href='class.union'>[class.union]</a>;</p></li><li id='1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.7'>(1.7)</a></div><p ><a class='hidden_link' href='#def:enum' id='def:enum'><i>enumerations</i></a>, which comprise a set of named constant values.
Each distinct enumeration constitutes a different
<a class='hidden_link' href='#def:type,enumerated' id='def:type,enumerated'><i>enumerated type</i></a>, <a href='dcl.enum'>[dcl.enum]</a>;</p></li><li id='1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.8'>(1.8)</a></div><p ><span class='indexparent'><a class='index' id='member_pointer_to'></a></span><a class='hidden_link' href='#def:pointer_to_member' id='def:pointer_to_member'><i>pointers to non-static class members</i></a>,<a class='footnotenum' href='#footnote-53'>53</a>
which identify members of a given
type within objects of a given class, <a href='dcl.mptr'>[dcl.mptr]</a>.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/473966e60653e8e2bc8ed154d8b18a3736f97088/source/basic.tex#L3943'>#</a></div><p >These methods of constructing types can be applied recursively;
restrictions are mentioned in <a href='dcl.ptr'>[dcl.ptr]</a>, <a href='dcl.array'>[dcl.array]</a>,
<a href='dcl.fct'>[dcl.fct]</a>, and <a href='dcl.ref'>[dcl.ref]</a>. Constructing a type such that the number of
bytes in its object representation exceeds the maximum value representable in
the type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> (<a href='support.types'>[support.types]</a>) is ill-formed.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/473966e60653e8e2bc8ed154d8b18a3736f97088/source/basic.tex#L3950'>#</a></div><p ><span class='indexparent'><a class='index' id='terminology,pointer'></a></span>The type of a pointer to <span class='textit'>cv</span> <span class='texttt'>void</span> or a pointer to an object type is
called an <a class='hidden_link' href='#def:object_pointer_type' id='def:object_pointer_type'><i>object pointer type</i></a>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> A pointer to <span class='texttt'>void</span>
does not have a pointer-to-object type, however, because <span class='texttt'>void</span> is not
an object type. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] The type of a pointer that can designate a function
is called a <a class='hidden_link' href='#def:function_pointer_type' id='def:function_pointer_type'><i>function pointer type</i></a>.
A pointer to objects of type <span class='texttt'>T</span> is referred to as a “pointer to
<span class='texttt'>T</span>”. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> A pointer to an object of type <span class='texttt'>int</span> is
referred to as “pointer to <span class='texttt'>int</span>” and a pointer to an object of
class <span class='texttt'>X</span> is called a “pointer to <span class='texttt'>X</span>”. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
Except for pointers to static members, text referring to “pointers”
does not apply to pointers to members. Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them (<a href='basic.align'>[basic.align]</a>).
<span class='indexparent'><a class='index' id='address'></a></span>Every value of pointer type is one of the following:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >a <a class='hidden_link' href='#def:pointer_to' id='def:pointer_to'><i>pointer to</i></a> an object or function (the pointer is said to <a class='hidden_link' href='#def:point' id='def:point'><i>point</i></a> to the object or function), or
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >a <a class='hidden_link' href='#def:pointer_past_the_end_of' id='def:pointer_past_the_end_of'><i>pointer past the end of</i></a> an object (<a href='expr.add'>[expr.add]</a>), or
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >the <a class='hidden_link' href='#def:null_pointer_value' id='def:null_pointer_value'><i>null pointer value</i></a> (<a href='conv.ptr'>[conv.ptr]</a>) for that type, or
</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >an <a class='hidden_link' href='#def:invalid_pointer_value' id='def:invalid_pointer_value'><i>invalid pointer value</i></a>.
</p></li></ul><p >A value of a
pointer type
that is a pointer to or past the end of an object
<a class='hidden_link' href='#def:represents_the_address' id='def:represents_the_address'><i>represents the address</i></a> of
the first byte in memory (<a href='intro.memory'>[intro.memory]</a>) occupied by the object<a class='footnotenum' href='#footnote-54'>54</a>
or the first byte in memory
after the end of the storage occupied by the object,
respectively.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
A pointer past the end of an object (<a href='expr.add'>[expr.add]</a>)
is not considered to point to an unrelated object
of the object's type
that might be located at that address.
A pointer value becomes invalid
when the storage it denotes
reaches the end of its storage duration;
see <a href='basic.stc'>[basic.stc]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
For purposes of <a href='expr.add'>pointer arithmetic</a>
and comparison (<a href='expr.rel'>[expr.rel]</a>, <a href='expr.eq'>[expr.eq]</a>),
a pointer past the end of the last element of
an array <span class='texttt'>x</span> of <span class='math'><span class='mathalpha'>n</span></span> elements
is considered to be equivalent to
a pointer to a hypothetical element <span class='texttt'>x[<span class='math'><span class='mathalpha'>n</span></span>]</span>.
The value representation of
pointer types is <span class='indexparent'><a class='index' id='value_representation_of_pointer_types'></a></span>implementation-defined. Pointers to
layout-compatible types shall
have the same value representation and <a href='basic.align'>alignment
requirements</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Pointers to
<a href='basic.align#def:over-aligned_type'>over-aligned types</a> have no special
representation, but their range of valid values is restricted by the extended
alignment requirement.<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/473966e60653e8e2bc8ed154d8b18a3736f97088/source/basic.tex#L4013'>#</a></div><p >Two objects <span class='textit'>a</span> and <span class='textit'>b</span> are <a class='hidden_link' href='#def:pointer-interconvertible' id='def:pointer-interconvertible'><i>pointer-interconvertible</i></a> if:
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >they are the same object, or
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >one is a standard-layout union object and
the other is a non-static data member of that object (<a href='class.union'>[class.union]</a>), or
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >one is a standard-layout class object and
the other is the first non-static data member of that object, or,
if the object has no non-static data members,
the first base class subobject of that object (<a href='class.mem'>[class.mem]</a>), or
</p></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><p >there exists an object <span class='textit'>c</span> such that
<span class='textit'>a</span> and <span class='textit'>c</span> are pointer-interconvertible, and
<span class='textit'>c</span> and <span class='textit'>b</span> are pointer-interconvertible.
</p></li></ul><p >If two objects are pointer-interconvertible,
then they have the same address,
and it is possible to obtain a pointer to one
from a pointer to the other
via a <a href='expr.reinterpret.cast'><span class='texttt'>reinterpret_&shy;cast</span></a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
An array object and its first element are not pointer-interconvertible,
even though they have the same address.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/473966e60653e8e2bc8ed154d8b18a3736f97088/source/basic.tex#L4041'>#</a></div><p ><span class='indexparent'><a class='index' id='pointer'></a></span><span class='indexparent'><a class='index' id='void*,type'></a></span>A pointer to <a href='basic.type.qualifier'><span class='textit'>cv</span>-qualified</a> or <span class='textit'>cv</span>-unqualified
<span class='texttt'>void</span>
can be used to point to objects of
unknown type. Such a pointer shall be able to hold any object pointer.
An object of type <span class='textit'>cv</span> <span class='texttt'>void*</span>
shall have the same representation and alignment
requirements as <span class='textit'>cv</span> <span class='texttt'>char*</span>.</p></div><div class='footnote' id='footnote-53'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-53'>53)</a></div><p >Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions.</p></div><div class='footnote' id='footnote-54'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-54'>54)</a></div><p >For an object that is not within its lifetime,
this is the first byte in memory that it will occupy or used to occupy.</p></div></div></div></body></html>