<!DOCTYPE html><html lang='en'><head><title>[basic.compound]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>6</a> Basics <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>6.8</a> Types <a class='abbr_ref' href='basic.types#basic.compound'>[basic.types]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>6.8.2</a> Compound types <a class='abbr_ref'>[basic.compound]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/eb0385965478ffa1491495ff09934b9099e93aa6/source/basic.tex#L4946'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':type,compound'></a></span>Compound types can be constructed in the following ways:
<ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><a class='hidden_link' href='#def:type,array' id='def:type,array'><i >arrays</i></a> of objects of a given type, <a href='dcl.array'>[dcl.array]</a>;</li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><a class='hidden_link' href='#def:type,function' id='def:type,function'><i >functions</i></a>, which have parameters of given types and return
<span class='texttt'><span class='keyword'>void</span></span> or references or objects of a given type, <a href='dcl.fct'>[dcl.fct]</a>;</li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><a class='hidden_link' href='#def:type,pointer' id='def:type,pointer'><i >pointers</i></a> to <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>void</span></span> or objects or functions (including
static members of classes) of a given type, <a href='dcl.ptr'>[dcl.ptr]</a>;</li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><span class='indexparent'><a class='index' id=':reference,lvalue'></a></span><span class='indexparent'><a class='index' id=':reference,rvalue'></a></span><a class='hidden_link' href='#def:reference' id='def:reference'><i >references</i></a> to objects or functions of a given
type, <a href='dcl.ref'>[dcl.ref]</a>. There are two types of references:
<ul class='itemize'><li id='1.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.4.1'>(1.4.1)</a></div>lvalue reference</li><li id='1.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.4.2'>(1.4.2)</a></div>rvalue reference</li></ul></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><a class='hidden_link' href='#def:class' id='def:class'><i >classes</i></a> containing a sequence of objects of various types (<a href='class'>[class]</a>),
a set of types, enumerations and functions for
manipulating these objects (<a href='class.mfct'>[class.mfct]</a>), and a set of restrictions
on the access to these entities (<a href='class.access'>[class.access]</a>);</li><li id='1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.6'>(1.6)</a></div><a class='hidden_link' href='#def:union' id='def:union'><i >unions</i></a>, which are classes capable of containing objects of
different types at different times, <a href='class.union'>[class.union]</a>;</li><li id='1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.7'>(1.7)</a></div><a class='hidden_link' href='#def:enum' id='def:enum'><i >enumerations</i></a>, which comprise a set of named constant values. Each distinct enumeration constitutes a different
<a class='hidden_link' href='#def:type,enumerated' id='def:type,enumerated'><i >enumerated type</i></a>, <a href='dcl.enum'>[dcl.enum]</a>;</li><li id='1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.8'>(1.8)</a></div><a class='hidden_link' href='#def:pointer_to_member' id='def:pointer_to_member'><i >pointers to non-static class members</i></a>,<a class='footnotenum' href='#footnote-42' id='footnoteref-42'>42</a>
which identify members of a given
type within objects of a given class, <a href='dcl.mptr'>[dcl.mptr]</a>. Pointers to data members and pointers to member functions are collectively
called <a class='hidden_link' href='#def:pointer-to-member' id='def:pointer-to-member'><i>pointer-to-member</i></a> types.</li></ul></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/eb0385965478ffa1491495ff09934b9099e93aa6/source/basic.tex#L4993'>#</a></div><div id='2.sentence-1' class='sentence'>These methods of constructing types can be applied recursively;
restrictions are mentioned in <a href='dcl.meaning'>[dcl.meaning]</a><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>Constructing a type such that the number of
bytes in its object representation exceeds the maximum value representable in
the type <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>size_&shy;t</span> (<a href='support.types'>[support.types]</a>) is ill-formed<a class='hidden_link' href='#2.sentence-2'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/eb0385965478ffa1491495ff09934b9099e93aa6/source/basic.tex#L5000'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':terminology,pointer'></a></span>The type of a pointer to <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>void</span></span> or a pointer to an object type is
called an <a class='hidden_link' href='#def:object_pointer_type' id='def:object_pointer_type'><i >object pointer type</i></a><a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.note-1' class='note'>[&nbsp;<a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-2' class='sentence'>A pointer to <span class='texttt'><span class='keyword'>void</span></span>
does not have a pointer-to-object type, however, because <span class='texttt'><span class='keyword'>void</span></span> is not
an object type<a class='hidden_link' href='#3.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='3.sentence-3' class='sentence'>
The type of a pointer that can designate a function
is called a <a class='hidden_link' href='#def:function_pointer_type' id='def:function_pointer_type'><i >function pointer type</i></a><a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>A pointer to objects of type <span class='texttt'>T</span> is referred to as a “pointer to
<span class='texttt'>T</span>”<a class='hidden_link' href='#3.sentence-4'>.</a></div> <div id='3.example-1' class='example'>[&nbsp;<a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='3.sentence-5' class='sentence'>A pointer to an object of type <span class='texttt'><span class='keyword'>int</span></span> is
referred to as “pointer to <span class='texttt'><span class='keyword'>int</span></span>” and a pointer to an object of
class <span class='texttt'>X</span> is called a “pointer to <span class='texttt'>X</span>”<a class='hidden_link' href='#3.sentence-5'>.</a></div> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='3.sentence-6' class='sentence'>
Except for pointers to static members, text referring to “pointers”
does not apply to pointers to members<a class='hidden_link' href='#3.sentence-6'>.</a></div> <div id='3.sentence-7' class='sentence'>Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them (<a href='basic.align'>[basic.align]</a>)<a class='hidden_link' href='#3.sentence-7'>.</a></div> <div id='3.sentence-8' class='sentence'><span class='indexparent'><a class='index' id=':address'></a></span>Every value of pointer type is one of the following:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div>a <a class='hidden_link' href='#def:pointer_to' id='def:pointer_to'><i >pointer to</i></a> an object or function (the pointer is said to <a class='hidden_link' href='#def:point' id='def:point'><i >point</i></a> to the object or function), or</li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div>a <a class='hidden_link' href='#def:pointer_past_the_end_of' id='def:pointer_past_the_end_of'><i >pointer past the end of</i></a> an object (<a href='expr.add'>[expr.add]</a>), or</li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div>
the <a class='hidden_link' href='#def:value,null_pointer' id='def:value,null_pointer'><i >null pointer value</i></a> (<a href='conv.ptr'>[conv.ptr]</a>) for that type, or</li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div>
an <a class='hidden_link' href='#def:value,invalid_pointer' id='def:value,invalid_pointer'><i >invalid pointer value</i></a><a class='hidden_link' href='#3.sentence-8'>.</a></li></ul></div> <div id='3.sentence-9' class='sentence'>
A value of a
pointer type
that is a pointer to or past the end of an object
<a class='hidden_link' href='#def:represents_the_address' id='def:represents_the_address'><i >represents the address</i></a> of
the first byte in memory (<a href='intro.memory'>[intro.memory]</a>) occupied by the object<a class='footnotenum' href='#footnote-43' id='footnoteref-43'>43</a>
or the first byte in memory
after the end of the storage occupied by the object,
respectively<a class='hidden_link' href='#3.sentence-9'>.</a></div> <div id='3.note-2' class='note'>[&nbsp;<a class='note_link' href='#3.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-10' class='sentence'>A pointer past the end of an object (<a href='expr.add'>[expr.add]</a>)
is not considered to point to an unrelated object
of the object's type
that might be located at that address<a class='hidden_link' href='#3.sentence-10'>.</a></div> <div id='3.sentence-11' class='sentence'>A pointer value becomes invalid
when the storage it denotes
reaches the end of its storage duration;
see <a href='basic.stc'>[basic.stc]</a><a class='hidden_link' href='#3.sentence-11'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='3.sentence-12' class='sentence'>
For purposes of pointer arithmetic (<a href='expr.add'>[expr.add]</a>)
and comparison (<a href='expr.rel'>[expr.rel]</a>, <a href='expr.eq'>[expr.eq]</a>),
a pointer past the end of the last element of
an array <span class='texttt'>x</span> of <span class='math'><span class='mathalpha'>n</span></span> elements
is considered to be equivalent to
a pointer to a hypothetical element <span class='texttt'>x<span class='squarebracket'>[</span><span class='math'><span class='mathalpha'>n</span></span><span class='squarebracket'>]</span></span><a class='hidden_link' href='#3.sentence-12'>.</a></div> <div id='3.sentence-13' class='sentence'>The value representation of
pointer types is <span class='indexparent'><a class='index' id=':value_representation_of_pointer_types'></a></span>implementation-defined<a class='hidden_link' href='#3.sentence-13'>.</a></div> <div id='3.sentence-14' class='sentence'>Pointers to
layout-compatible types shall
have the same value representation and alignment
requirements (<a href='basic.align'>[basic.align]</a>)<a class='hidden_link' href='#3.sentence-14'>.</a></div> <div id='3.note-3' class='note'>[&nbsp;<a class='note_link' href='#3.note-3'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-15' class='sentence'>Pointers to <a href='basic.align#def:type,over-aligned'>over-aligned types</a> have no special
representation, but their range of valid values is restricted by the extended
alignment requirement<a class='hidden_link' href='#3.sentence-15'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/eb0385965478ffa1491495ff09934b9099e93aa6/source/basic.tex#L5073'>#</a></div><div id='4.sentence-1' class='sentence'>Two objects <span class='textit'>a</span> and <span class='textit'>b</span> are <a class='hidden_link' href='#def:pointer-interconvertible' id='def:pointer-interconvertible'><i >pointer-interconvertible</i></a> if:
<ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div>they are the same object, or</li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div>one is a union object and
the other is a non-static data member of that object (<a href='class.union'>[class.union]</a>), or</li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div>one is a standard-layout class object and
the other is the first non-static data member of that object, or,
if the object has no non-static data members,
any base class subobject of that object (<a href='class.mem'>[class.mem]</a>), or</li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div>there exists an object <span class='textit'>c</span> such that
<span class='textit'>a</span> and <span class='textit'>c</span> are pointer-interconvertible, and
<span class='textit'>c</span> and <span class='textit'>b</span> are pointer-interconvertible<a class='hidden_link' href='#4.sentence-1'>.</a></li></ul></div> <div id='4.sentence-2' class='sentence'>
If two objects are pointer-interconvertible,
then they have the same address,
and it is possible to obtain a pointer to one
from a pointer to the other
via a <a href='expr.reinterpret.cast'><span class='texttt'>reinterpret_&shy;cast</span></a><a class='hidden_link' href='#4.sentence-2'>.</a></div> <div id='4.note-1' class='note'>[&nbsp;<a class='note_link' href='#4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='4.sentence-3' class='sentence'>An array object and its first element are not pointer-interconvertible,
even though they have the same address<a class='hidden_link' href='#4.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/eb0385965478ffa1491495ff09934b9099e93aa6/source/basic.tex#L5101'>#</a></div><div id='5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':void*,type'></a></span>A pointer to <span class='mathit'>cv</span>-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) or <span class='mathit'>cv</span>-unqualified
<span class='texttt'><span class='keyword'>void</span></span>
can be used to point to objects of
unknown type<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.sentence-2' class='sentence'>Such a pointer shall be able to hold any object pointer<a class='hidden_link' href='#5.sentence-2'>.</a></div> <div id='5.sentence-3' class='sentence'>An object of type <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>void</span><span class='operator'>*</span></span>
shall have the same representation and alignment
requirements as <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>char</span><span class='operator'>*</span></span><a class='hidden_link' href='#5.sentence-3'>.</a></div></div><div class='footnote' id='footnote-42'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-42'>42)</a></div><div id='footnote-42.sentence-1' class='sentence'>Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions<a class='hidden_link' href='#footnote-42.sentence-1'>.</a></div> <a href='#footnoteref-42'>⮥</a></div><div class='footnote' id='footnote-43'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-43'>43)</a></div><div id='footnote-43.sentence-1' class='sentence'>For an object that is not within its lifetime,
this is the first byte in memory that it will occupy or used to occupy<a class='hidden_link' href='#footnote-43.sentence-1'>.</a></div> <a href='#footnoteref-43'>⮥</a></div></div></body></html>