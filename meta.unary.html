<!DOCTYPE html><html lang='en'><head><title>[meta.unary]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.15</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#unary'>[meta]</a></h2><div id='meta.unary'><h3 ><a class='secnum' style='min-width:103pt'>20.15.4</a> Unary type traits <a class='abbr_ref'>[meta.unary]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause contains templates that may be used to query the
properties of a type at compile time.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each of these templates shall be a
UnaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is <span class='texttt'>true</span>, otherwise
<span class='texttt'>false_type</span>.</p></div><div id='cat'><h4 ><a class='secnum' href='#cat' style='min-width:118pt'>20.15.4.1</a> Primary type categories <a class='abbr_ref' href='meta.unary.cat'>[meta.unary.cat]</a></h4><div class='para' id='cat-1'><div class='marginalizedparent'><a class='marginalized' href='#cat-1'>1</a></div><p >The primary type categories correspond to the descriptions given in
section <a href='basic.types'>[basic.types]</a> of the C++ standard.</p></div><div class='para' id='cat-2'><div class='marginalizedparent'><a class='marginalized' href='#cat-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p></div><div class='para' id='cat-3'><div class='marginalizedparent'><a class='marginalized' href='#cat-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For any given type <span class='texttt'>T</span>, exactly one of the primary type categories
has a <span class='texttt'>value</span> member that evaluates to <span class='texttt'>true</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:type-traits.primary'>Table <a href='#tab:type-traits.primary'>35</a> — Primary type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='indexparent'><a class='index' id='is_void'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_void;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>void</span>       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_null_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_null_pointer;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>nullptr_t</span> (<a href='basic.fundamental'>[basic.fundamental]</a>)       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_integral'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_integral;</span>        </td><td class='left'>
<span class='texttt'>T</span> is an integral type (<a href='basic.fundamental'>[basic.fundamental]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_floating_point'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_floating_point;</span>  </td><td class='left'>
<span class='texttt'>T</span> is a floating point type (<a href='basic.fundamental'>[basic.fundamental]</a>)            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_array'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_array;</span>           </td><td class='left'>
<span class='texttt'>T</span> is an array type (<a href='basic.compound'>[basic.compound]</a>) of known or unknown extent    </td><td class='left'>
Class template <span class='texttt'>array</span> (<a href='array'>[array]</a>)
is not an array type.                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pointer;</span>         </td><td class='left'>
<span class='texttt'>T</span> is a pointer type (<a href='basic.compound'>[basic.compound]</a>)                      </td><td class='left'>
Includes pointers to functions
but not pointers to non-static members.                        </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_lvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_lvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_rvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_rvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an rvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_object_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_object_pointer;</span></td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member                              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_function_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_function_pointer;</span></td><td class='left'>
<span class='texttt'>T</span> is a pointer to non-static member function                           </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_enum'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_enum;</span>            </td><td class='left'>
<span class='texttt'>T</span> is an enumeration type (<a href='basic.compound'>[basic.compound]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_union'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_union;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a union type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_class'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_class;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a non-union class type (<a href='basic.compound'>[basic.compound]</a>) </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_function'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_function;</span>        </td><td class='left'>
<span class='texttt'>T</span> is a function type (<a href='basic.compound'>[basic.compound]</a>)                     </td><td class='left'>   </td></tr></table></div></div></div><div id='comp'><h4 ><a class='secnum' href='#comp' style='min-width:118pt'>20.15.4.2</a> Composite type traits <a class='abbr_ref' href='meta.unary.comp'>[meta.unary.comp]</a></h4><div class='para' id='comp-1'><div class='marginalizedparent'><a class='marginalized' href='#comp-1'>1</a></div><p >These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section <a href='basic.types'>[basic.types]</a>.</p></div><div class='para' id='comp-2'><div class='marginalizedparent'><a class='marginalized' href='#comp-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span>, and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p><div class='numberedTable' id='tab:type-traits.composite'>Table <a href='#tab:type-traits.composite'>36</a> — Composite type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='indexparent'><a class='index' id='is_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_reference;</span>   </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference or an rvalue reference </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_arithmetic'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_arithmetic;</span>          </td><td class='left'>
 <span class='texttt'>T</span> is an arithmetic type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_fundamental'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_fundamental;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a fundamental type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_object'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_object;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is an object type (<a href='basic.types'>[basic.types]</a>)                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_scalar'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_scalar;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is a scalar type (<a href='basic.types'>[basic.types]</a>)                         </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_compound'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_compound;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is a compound type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_pointer;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member
 or non-static member function             </td><td class='left'>   </td></tr></table></div></div></div><div id='prop'><h4 ><a class='secnum' href='#prop' style='min-width:118pt'>20.15.4.3</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h4><div class='para' id='prop-1'><div class='marginalizedparent'><a class='marginalized' href='#prop-1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='prop-2'><div class='marginalizedparent'><a class='marginalized' href='#prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='prop-3'><div class='marginalizedparent'><a class='marginalized' href='#prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this subclause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p></div><div class='para' id='prop-4'><div class='marginalizedparent'><a class='marginalized' href='#prop-4'>4</a></div><p >For the purpose of defining the templates in this subclause,
a function call expression <span class='texttt'>declval&lt;T&gt;()</span> for any type <span class='texttt'>T</span>
is considered to be a trivial (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>) function call
that is not an odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of <span class='texttt'>declval</span>
in the context of the corresponding definition
notwithstanding the restrictions of <a href='declval'>[declval]</a>.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>37</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='indexparent'><a class='index' id='is_const'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_volatile'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_trivial'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copyable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 (possibly cv-qualified) <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_standard_layout'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_pod'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_empty,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty_v&lt;B&gt;</span> is <span class='texttt'>false</span>. </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_polymorphic'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_abstract'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_final'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_final;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type marked with the <span class='grammarterm'>class-virt-specifier</span>
 <span class='texttt'>final</span> (Clause <a href='class'>[class]</a>). [&nbsp;<i>Note:</i><span class='space'></span> A union is a class type that
 can be marked with <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                        </td><td class='left'>
 If <span class='texttt'>T</span> is a class type, <span class='texttt'>T</span> shall be a complete type.                          </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_signed,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  If <span class='texttt'>is_arithmetic_v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(-1) &lt; T(0)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='is_unsigned'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  If <span class='texttt'>is_arithmetic_v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(0) &lt; T(-1)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='is_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 For a function type <span class='texttt'>T</span>,
 <span class='texttt'>is_constructible_v&lt;T, Args...&gt;</span> is <span class='texttt'>false</span>,
 otherwise <i><span class='texttt'>see below</span></i>                </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span> (<a href='defns.referenceable'>[defns.referenceable]</a>), the same result as
  <span class='texttt'>is_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i><span class='space'></span> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_swappable_with;</span> </td><td class='left'>
  The expressions <span class='texttt'>swap(declval&lt;T&gt;(), declval&lt;U&gt;())</span> and
  <span class='texttt'>swap(declval&lt;U&gt;(), declval&lt;T&gt;())</span> are each well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>)
  in an overload-resolution context
  for swappable values (<a href='swappable.requirements'>[swappable.requirements]</a>).
  Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>.
  Only the validity of the immediate context
  of the <span class='texttt'>swap</span> expressions is considered.
  [&nbsp;<i>Note:</i><span class='space'></span>
  The compilation of the expressions can result in side effects
  such as the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such side effects are not in the “immediate context” and
  can result in the program being ill-formed.
  <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or
  arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_swappable_with_v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  Either <span class='texttt'>T</span> is a reference type,
  or <span class='texttt'>T</span> is a complete object type
  for which the expression
  <span class='texttt'>declval&lt;U&amp;&gt;().~U()</span>
  is well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>),
  where <span class='texttt'>U</span> is
  <span class='texttt'>remove_all_extents&lt;T&gt;</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct</span><span class='hfill'></span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible_v&lt;T,</span><span class='hfill'></span><br/>
  <span class='texttt'>Args...&gt;</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible_v&lt;T,</span> <span class='texttt'> Args...&gt;</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_nothrow_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_swappable_with;</span> </td><td class='left'>
  <span class='texttt'>is_swappable_with_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and
  each <span class='texttt'>swap</span> expression of the definition of
  <span class='texttt'>is_swappable_with&lt;T, U&gt;</span> is known not to throw
  any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or
  arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_nothrow_swappable_with_v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='has_virtual_destructor'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='has_unique_object_representations'></a></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct has_unique_object_representations;</span> </td><td class='left'>
  For an array type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>has_unique_object_representations_v&lt;remove_all_extents_t&lt;T&gt;&gt;</span>,
  otherwise <i><span class='texttt'>see below</span></i>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly cv-qualified) <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr></table></div></div><div class='para' id='prop-5'><div class='marginalizedparent'><a class='marginalized' href='#prop-5'>5</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
is_const_v&lt;const volatile int&gt;     <span class='comment'>// <span class='texttt'>true</span>
</span>is_const_v&lt;const int*&gt;             <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;const int&amp;&gt;             <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;int[3]&gt;                 <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;const int[3]&gt;           <span class='comment'>// <span class='texttt'>true</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='prop-6'><div class='marginalizedparent'><a class='marginalized' href='#prop-6'>6</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
remove_const_t&lt;const volatile int&gt;  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const_t&lt;const int* const&gt;    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const_t&lt;const int&amp;&gt;          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const_t&lt;const int[3]&gt;        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='prop-7'><div class='marginalizedparent'><a class='marginalized' href='#prop-7'>7</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// Given:
</span>struct P final { };
union U1 { };
union U2 final { };

<span class='comment'>// the following assertions hold:
</span>static_assert(!is_final_v&lt;int&gt;, "Error!");
static_assert( is_final_v&lt;P&gt;,  "Error!");
static_assert(!is_final_v&lt;U1&gt;, "Error!");
static_assert( is_final_v&lt;U2&gt;, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='is_constructible'></a></span></p></div><div class='para' id='prop-8'><div class='marginalizedparent'><a class='marginalized' href='#prop-8'>8</a></div><p >The predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(declval&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i><span class='space'></span> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i><span class='space'></span> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='has_unique_object_representations'></a></span></p></div><div class='para' id='prop-9'><div class='marginalizedparent'><a class='marginalized' href='#prop-9'>9</a></div><p >The predicate condition for a template specialization
<span class='texttt'>has_unique_object_representations&lt;T&gt;</span>
shall be satisfied if and only if:
</p><ul ><li ><p ><span class='texttt'>T</span> is trivially copyable, and
</p></li><li ><p >any two objects of type <span class='texttt'>T</span> with the same value
have the same object representation, where
two objects of array or non-union class type are considered to have the same value
if their respective sequences of direct subobjects have the same values, and
two objects of union type are considered to have the same value
if they have the same active member and the corresponding members have the same value.
</p></li></ul><p >The set of scalar types for which this condition holds is
<span class='indexparent'><a class='index' id='which_scalar_types_have_unique_object_representations'></a></span>implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span> If a type has padding bits, the condition does not hold;
otherwise, the condition holds true for unsigned integral types. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></div></body></html>