<!DOCTYPE html><html lang='en'><head><title>[basic.stc.dynamic.allocation]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref' href='basic.stc#dynamic.allocation'>[basic.stc]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref' href='basic.stc.dynamic#allocation'>[basic.stc.dynamic]</a></h3><div id='basic.stc.dynamic.allocation'><h4 ><a class='secnum' style='min-width:118pt'>3.7.4.1</a> Allocation functions <a class='abbr_ref'>[basic.stc.dynamic.allocation]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='function,allocation'></a></span>An allocation function shall be a class member function or a global
function; a program is ill-formed if an allocation function is declared
in a namespace scope other than global scope or declared static in
global scope. The return type shall be <span class='texttt'>void*</span>. The first
parameter shall have type <span class='texttt'>std::size_t</span> (<a href='support.types'>[support.types]</a>). The
first parameter shall not have an associated default
argument (<a href='dcl.fct.default'>[dcl.fct.default]</a>). The value of the first parameter shall
be interpreted as the requested size of the allocation. An allocation
function can be a function template. Such a template shall declare its
return type and first parameter as specified above (that is, template
parameter types shall not be used in the return type and first parameter
type). Template allocation functions shall have two or more parameters.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The allocation function attempts to allocate the requested amount of
storage. If it is successful, it shall return the address of the start
of a block of storage whose length in bytes shall be at least as large
as the requested size. There are no constraints on the contents of the
allocated storage on return from the allocation function. The order,
contiguity, and initial value of storage allocated by successive calls
to an allocation function are unspecified. The pointer returned shall be
suitably aligned so that it can be converted to a pointer of any
complete object type with a fundamental alignment requirement (<a href='basic.align'>[basic.align]</a>)
and then used to access the object or array in the
storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space
requested is zero, the request can fail. If the request succeeds, the
value returned shall be a non-null pointer value (<a href='conv.ptr'>[conv.ptr]</a>)
<span class='texttt'>p0</span> different from any previously returned value <span class='texttt'>p1</span>,
unless that value <span class='texttt'>p1</span> was subsequently passed to an
<span class='texttt'>operator</span> <span class='texttt'>delete</span>. The effect of dereferencing a pointer
returned as a request for zero size is undefined.<a class='footnotenum' href='#footnote-35'>35</a></p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >An allocation function that fails to allocate storage can invoke the
currently installed new-handler function (<a href='new.handler'>[new.handler]</a>), if any.
[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='new_handler'></a></span>A program-supplied allocation function can obtain the address of the
currently installed <span class='texttt'>new_handler</span> using the
<span class='texttt'>std::get_new_handler</span> function (<a href='set.new.handler'>[set.new.handler]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an allocation function declared with a non-throwing
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>)
fails to allocate storage, it shall return a null pointer. Any other
allocation function that fails to allocate storage shall indicate
failure only by throwing an exception of a type that would match a
handler (<a href='except.handle'>[except.handle]</a>) of type
<span class='texttt'>std::bad_alloc</span> (<a href='bad.alloc'>[bad.alloc]</a>).</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A global allocation function is only called as the result of a new
expression (<a href='expr.new'>[expr.new]</a>), or called directly using the function call
syntax (<a href='expr.call'>[expr.call]</a>), or called indirectly through calls to the
functions in the C++ standard library. [&nbsp;<i>Note:</i> In particular, a
global allocation function is not called to allocate storage for objects
with static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>), for objects or references
with thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>), for objects of
type <span class='texttt'>std::type_info</span> (<a href='expr.typeid'>[expr.typeid]</a>), or for the copy of an
object thrown by a <span class='texttt'>throw</span> expression (<a href='except.throw'>[except.throw]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-35'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-35'>35)</a></div><p >The intent is
to have <span class='texttt'>operator new()</span> implementable by
calling <span class='texttt'>std::malloc()</span> or <span class='texttt'>std::calloc()</span>, so the rules are
substantially the same. C++ differs from C in requiring a zero request
to return a non-null pointer.</p></div></div></div></body></html>