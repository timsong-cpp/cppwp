<!DOCTYPE html><html lang='en'><head><title>[class.dtor]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.dtor'><h2 ><a class='secnum' style='min-width:88pt'>12.4</a> Destructors <a class='abbr_ref'>[class.dtor]</a></h2><p ><span class='indexparent'><a class='index' id='destructor'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A special declarator syntax using an optional
<i ><a href='dcl.fct.spec#nt:function-specifier'>function-specifier</a></i> (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>) followed by
<span class='texttt'>~</span>
followed by the destructor's class name
followed by an empty parameter list
is used to declare the destructor in a class definition.
In such a declaration, the
<span class='texttt'>~</span>
followed by the destructor's class name can be enclosed in optional parentheses;
such parentheses are ignored.
A
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
shall not be used as the
<i ><a href='class#nt:class-name'>class-name</a></i>
following the
<span class='texttt'><span class='math'>~</span></span>
in the declarator for a destructor declaration.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A destructor is used to destroy objects of its class type.
<span class='indexparent'><a class='index' id='restriction,destructor'></a></span>A destructor takes no parameters, and no return type can be
specified for it (not even
<span class='texttt'>void</span>).
The address of a destructor shall not be taken.
A destructor shall not be
<span class='texttt'>static</span>.
<span class='indexparent'><a class='index' id='const,destructor_and'></a></span><span class='indexparent'><a class='index' id='volatile,destructor_and'></a></span>A destructor can be invoked for a
<span class='texttt'>const</span>,
<span class='texttt'>volatile</span>
or
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
object.
A destructor shall not be declared
<span class='texttt'>const</span>,
<span class='texttt'>volatile</span>
or
<span class='texttt'>const</span>
<span class='texttt'>volatile</span> (<a href='class.this'>[class.this]</a>).
<span class='texttt'>const</span>
and
<span class='texttt'>volatile</span>
semantics (<a href='dcl.type.cv'>[dcl.type.cv]</a>) are not applied on an object under destruction.
They stop being in effect when the destructor for the
most derived object (<a href='intro.object'>[intro.object]</a>) starts.
A destructor shall not be declared with a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A declaration of a destructor that does not have an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
is implicitly considered to have the same <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> as an
implicit declaration (<a href='except.spec'>[except.spec]</a>).</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='generated_destructor'></a></span><span class='indexparent'><a class='index' id='destructor,default'></a></span><span class='indexparent'><a class='index' id='destructor,non-trivial'></a></span>If a class has no user-declared
destructor, a destructor is implicitly
declared as defaulted (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
An implicitly-declared destructor is an
<span class='texttt'>inline</span>
<span class='texttt'>public</span>
member of its class.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A defaulted destructor for a class
  <span class='texttt'>X</span> is defined as deleted if:
</p><ul ><li ><p ><span class='texttt'>X</span> is a union-like class that has a variant
  member with a non-trivial destructor,</p></li><li ><p >any of the non-static data members has class type
  <span class='texttt'>M</span> (or array thereof) and
  <span class='texttt'>M</span> has a deleted destructor or a destructor
  that is inaccessible from the defaulted destructor,</p></li><li ><p >any direct or virtual base class has a deleted
  destructor or a destructor that is inaccessible from the
  defaulted destructor,</p></li><li ><p >or, for a virtual destructor, lookup of the non-array deallocation
  function results in an ambiguity or in a function that is deleted or
  inaccessible from the defaulted destructor.
</p></li></ul><p >A destructor is trivial if it is not user-provided and if:</p><ul ><li ><p >the destructor is not <span class='texttt'>virtual</span>,</p></li><li ><p >all of the direct base classes of its class have trivial destructors, and</p></li><li ><p >for all of the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial destructor.
</p></li></ul><p >Otherwise, the destructor is
<span class='grammarterm'>non-trivial</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='destructor,implicitly_defined'></a></span>A destructor
that is defaulted and not defined as deleted
is
<a class='hidden_link' href='#def:implicitly_defined' id='def:implicitly_defined'><i>implicitly defined</i></a>
when it is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) to destroy an object of its class type (<a href='basic.stc'>[basic.stc]</a>)
or when it is explicitly defaulted after its first declaration.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Before the
defaulted destructor for a class is implicitly defined, all the non-user-provided
destructors for its base classes and its non-static data members shall have been
implicitly defined.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='order_of_execution,destructor'></a></span><span class='indexparent'><a class='index' id='order_of_execution,base_class_destructor'></a></span><span class='indexparent'><a class='index' id='order_of_execution,member_destructor'></a></span>After executing the body of the destructor and destroying
any automatic objects allocated within the body, a
destructor for class
<span class='texttt'>X</span>
calls the destructors for
<span class='texttt'>X</span>'s
direct non-variant non-static data members, the destructors for
<span class='texttt'>X</span>'s
direct base classes and, if
<span class='texttt'>X</span>
is the type of the most derived class (<a href='class.base.init'>[class.base.init]</a>),
its destructor calls the destructors for
<span class='texttt'>X</span>'s
virtual base classes.
All destructors are called as if they were referenced with a qualified name,
that is, ignoring any possible virtual overriding destructors in more
derived classes.
Bases and members are destroyed in the reverse order of the completion of
their constructor (see <a href='class.base.init'>[class.base.init]</a>).
A
<span class='texttt'>return</span>
statement (<a href='stmt.return'>[stmt.return]</a>) in a destructor might not directly return to the
caller; before transferring control to the caller, the destructors for the
members and bases are called.
<span class='indexparent'><a class='index' id='order_of_execution,destructor_and_array'></a></span>Destructors for elements of an array are called in reverse order of their
construction (see <a href='class.init'>[class.init]</a>).</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='destructor,virtual'></a></span><span class='indexparent'><a class='index' id='destructor,pure_virtual'></a></span>A destructor can be declared
<span class='texttt'>virtual</span> (<a href='class.virtual'>[class.virtual]</a>)
or pure
<span class='texttt'>virtual</span> (<a href='class.abstract'>[class.abstract]</a>);
if any objects of that class or any derived class are created in the program,
the destructor shall be defined.
If a class has a base class with a virtual destructor, its  destructor
(whether user- or implicitly-declared) is virtual.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='member_function,destructor_and'></a></span>some language constructs have special semantics when used during destruction;
see <a href='class.cdtor'>[class.cdtor]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='destructor,implicit_call'></a></span><span class='indexparent'><a class='index' id='destructor,program_termination_and'></a></span>Destructors are invoked implicitly</p><ul ><li ><p >for constructed objects with static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>) at program termination (<a href='basic.start.term'>[basic.start.term]</a>),</p></li><li ><p >for constructed objects with thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>) at thread exit,</p></li><li ><p >for constructed objects with automatic storage duration (<a href='basic.stc.auto'>[basic.stc.auto]</a>) when the block in which an object is created exits (<a href='stmt.dcl'>[stmt.dcl]</a>),</p></li><li ><p >for constructed temporary objects when the lifetime
of a temporary object ends (<a href='class.temporary'>[class.temporary]</a>),
<span class='indexparent'><a class='index' id='delete,destructor_and'></a></span>
</p></li><li ><p >for constructed objects allocated by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>), through use of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> (<a href='expr.delete'>[expr.delete]</a>),</p></li><li ><p >in several situations due to the handling of exceptions (<a href='except.handle'>[except.handle]</a>).
</p></li></ul><p >A program is ill-formed if an object of class type or array thereof is
declared and the destructor for the class is not accessible at the point
of the declaration.
<span class='indexparent'><a class='index' id='destructor,explicit_call'></a></span>Destructors can also be invoked explicitly.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >At the point of definition of a virtual destructor (including an implicit
definition (<a href='class.copy'>[class.copy]</a>)), the non-array deallocation function is looked up
in the scope of the destructor's class (<a href='class.member.lookup'>[class.member.lookup]</a>), and, if no
declaration is found, the function is looked up in the global scope.
If the result of this lookup is ambiguous or inaccessible, or if the lookup
selects a placement deallocation function or a function with a deleted definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>), the program is ill-formed.
[&nbsp;<i>Note:</i>
This assures that a deallocation function corresponding to the dynamic type of an
object is available for the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='destructor,explicit_call'></a></span>In an explicit destructor call, the destructor name appears as a
<span class='texttt'>~</span>
followed by a
<i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> or <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions (<a href='class.mfct'>[class.mfct]</a>),
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type, the program has
undefined behavior
(except that invoking
<span class='texttt'>delete</span>
on a null pointer has no effect).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct B {
  virtual ~B() { }
};
struct D : B {
  ~D() { }
};

D D_object;
typedef B B_alias;
B* B_ptr = &amp;D_object;

void f() {
  D_object.B::~B();             <span class='comment'>// calls <span class='texttt'>B</span>'s destructor
</span>  B_ptr-&gt;~B();                  <span class='comment'>// calls <span class='texttt'>D</span>'s destructor
</span>  B_ptr-&gt;~B_alias();            <span class='comment'>// calls <span class='texttt'>D</span>'s destructor
</span>  B_ptr-&gt;B_alias::~B();         <span class='comment'>// calls <span class='texttt'>B</span>'s destructor
</span>  B_ptr-&gt;B_alias::~B_alias();   <span class='comment'>// calls <span class='texttt'>B</span>'s destructor
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
An explicit destructor call must always be written using
a member access operator (<a href='expr.ref'>[expr.ref]</a>) or a qualified-id (<a href='expr.prim'>[expr.prim]</a>);
in particular, the
<i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='texttt'>~X()</span>
in a member function is not an explicit destructor call (<a href='expr.unary.op'>[expr.unary.op]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='object,destructor_and_placement_of'></a></span>explicit calls of destructors are rarely needed.
One use of such calls is for objects placed at specific
addresses using a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
with the placement option.
Such use of explicit placement and destruction of objects can be necessary
to cope with dedicated hardware resources and for writing memory management
facilities.
For example,
<span class='indexparent'><a class='index' id='example,explicit_destructor_call'></a></span>
</p><pre class='codeblock'>
void* operator new(std::size_t, void* p) { return p; }
struct X {
  X(int);
  ~X();
};
void f(X* p);

void g() {                      <span class='comment'>// rare, specialized use:
</span>  char* buf = new char[sizeof(X)];
  X* p = new(buf) X(222);       <span class='comment'>// use <span class='texttt'>buf[]</span> and initialize
</span>  f(p);
  p-&gt;X::~X();                   <span class='comment'>// cleanup
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >Once a destructor is invoked for an object, the object no longer exists;
the behavior is undefined if the destructor is invoked
for an object whose lifetime has ended (<a href='basic.life'>[basic.life]</a>).
[&nbsp;<i>Example:</i>
if the destructor for an automatic object is explicitly invoked,
and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undefined.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='fundamental_type,destructor_and'></a></span>the notation for explicit call of a destructor can be used for any scalar type
name (<a href='expr.pseudo'>[expr.pseudo]</a>).
Allowing this makes it possible to write code without having to know if a
destructor exists for a given type.
For example,</p><pre class='codeblock'>
typedef int I;
I* p;
p-&gt;I::~I();
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>