<!DOCTYPE html><html lang='en'><head><title>[locale.categories]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>22</a> Localization library <a class='abbr_ref' href='./#localization'>[localization]</a></h1><div id='locale.categories'><h2 ><a class='secnum' style='min-width:88pt'>22.4</a> Standard <span class='texttt'>locale</span> categories <a class='abbr_ref'>[locale.categories]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Each of the standard categories includes a family of facets.
Some of these implement formatting or parsing of a datum, for use
by standard or users' iostream operators
<span class='texttt'>&lt;&lt;</span>
and
<span class='texttt'>&gt;&gt;</span>,
as members
<span class='texttt'>put()</span>
and
<span class='texttt'>get()</span>,
respectively.
Each such member function takes an
<span class='indexparent'><a class='index' id='flags,ios_base'></a></span><span class='texttt'>ios_base&amp;</span>
argument whose members
<span class='indexparent'><a class='index' id='flags,ios_base'></a></span><span class='texttt'>flags()</span>,
<span class='indexparent'><a class='index' id='precision,ios_base'></a></span><span class='texttt'>precision()</span>,
and
<span class='indexparent'><a class='index' id='width,ios_base'></a></span><span class='texttt'>width()</span>,
specify the format of the corresponding datum (<a href='ios.base'>[ios.base]</a>).
Those functions which need to use other facets call its member
<span class='texttt'>getloc()</span>
to retrieve the locale imbued there.
Formatting facets use the character argument
<span class='texttt'>fill</span>
to fill out the specified width where necessary.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The
<span class='texttt'>put()</span>
members make no provision for error reporting.
(Any failures of the
OutputIterator argument must be extracted from the returned iterator.)
The
<span class='texttt'>get()</span>
members take an
<span class='texttt'>ios_base::iostate&amp;</span>
argument whose value they ignore, but set to
<span class='texttt'>ios_base::failbit</span>
in case of a parse error.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Within this clause it is unspecified whether one virtual function calls another
virtual function.</p></div><div id='category.ctype'><h3 ><a class='secnum' href='#category.ctype' style='min-width:103pt'>22.4.1</a> The <span class='texttt'>ctype</span> category <a class='abbr_ref' href='category.ctype'>[category.ctype]</a></h3><p ><span class='indexparent'><a class='index' id='ctype_base'></a></span></p><pre class='codeblock'>
namespace std {
  class ctype_base {
  public:
    typedef <b><i>T</i></b> mask;

    <span class='comment'>// numeric values are for exposition only.
</span>    static const mask space = 1 &lt;&lt; 0;
    static const mask print = 1 &lt;&lt; 1;
    static const mask cntrl = 1 &lt;&lt; 2;
    static const mask upper = 1 &lt;&lt; 3;
    static const mask lower = 1 &lt;&lt; 4;
    static const mask alpha = 1 &lt;&lt; 5;
    static const mask digit = 1 &lt;&lt; 6;
    static const mask punct = 1 &lt;&lt; 7;
    static const mask xdigit = 1 &lt;&lt; 8;
    static const mask blank = 1 &lt;&lt; 9;
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;
  };
}
</pre><div class='para' id='category.ctype-1'><div class='marginalizedparent'><a class='marginalized' href='#category.ctype-1'>1</a></div><p >The type
<span class='texttt'>mask</span>
is a bitmask type (<a href='bitmask.types'>[bitmask.types]</a>).</p></div><div id='locale.ctype'><h4 ><a class='secnum' href='#locale.ctype' style='min-width:118pt'>22.4.1.1</a> Class template <span class='texttt'>ctype</span> <a class='abbr_ref' href='locale.ctype'>[locale.ctype]</a></h4><p ><span class='indexparent'><a class='index' id='ctype'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class ctype : public locale::facet, public ctype_base {
  public:
    typedef charT char_type;

    explicit ctype(size_t refs = 0);

    bool         is(mask m, charT c) const;
    const charT* is(const charT* low, const charT* high, mask* vec) const;
    const charT* scan_is(mask m,
                         const charT* low, const charT* high) const;
    const charT* scan_not(mask m,
                          const charT* low, const charT* high) const;
    charT        toupper(charT c) const;
    const charT* toupper(charT* low, const charT* high) const;
    charT        tolower(charT c) const;
    const charT* tolower(charT* low, const charT* high) const;

    charT        widen(char c) const;
    const char*  widen(const char* low, const char* high, charT* to) const;
    char         narrow(charT c, char dfault) const;
    const charT* narrow(const charT* low, const charT*, char dfault,
                        char* to) const;

    static locale::id id;

  protected:
   ~ctype();
    virtual bool         do_is(mask m, charT c) const;
    virtual const charT* do_is(const charT* low, const charT* high,
                               mask* vec) const;
    virtual const charT* do_scan_is(mask m,
                                    const charT* low, const charT* high) const;
    virtual const charT* do_scan_not(mask m,
                                     const charT* low, const charT* high) const;
    virtual charT        do_toupper(charT) const;
    virtual const charT* do_toupper(charT* low, const charT* high) const;
    virtual charT        do_tolower(charT) const;
    virtual const charT* do_tolower(charT* low, const charT* high) const;
    virtual charT        do_widen(char) const;
    virtual const char*  do_widen(const char* low, const char* high,
                                  charT* dest) const;
    virtual char         do_narrow(charT, char dfault) const;
    virtual const charT* do_narrow(const charT* low, const charT* high,
                                   char dfault, char* dest) const;
  };
}
</pre><div class='para' id='locale.ctype-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype-1'>1</a></div><p >Class
<span class='texttt'>ctype</span>
encapsulates the C library
<span class='texttt'>&lt;cctype&gt;</span>
features.
<span class='texttt'>istream</span>
members are required to use
<span class='texttt'>ctype&lt;&gt;</span>
for character classing during input parsing.</p></div><div class='para' id='locale.ctype-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype-2'>2</a></div><p >The specializations required in Table <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>ctype&lt;char&gt;</span>
and
<span class='texttt'>ctype&lt;wchar_t&gt;</span>,
implement character classing appropriate
to the implementation's native character set.</p></div><div id='locale.ctype.members'><h4 ><a class='secnum' href='#locale.ctype.members' style='min-width:133pt'>22.4.1.1.1</a> <span class='texttt'>ctype</span> members <a class='abbr_ref' href='locale.ctype.members'>[locale.ctype.members]</a></h4><p ><span class='indexparent'><a class='index' id='ctype,is'></a></span><span class='indexparent'><a class='index' id='is,ctype'></a></span><code class='itemdecl'>
bool         is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high,
                mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_is(m,c)</span>
or
<span class='texttt'>do_is(low,high,vec)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,scan_is'></a></span><span class='indexparent'><a class='index' id='scan_is,ctype'></a></span><code class='itemdecl'>
const charT* scan_is(mask m,
                     const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_scan_is(m,low,high)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,scan_not'></a></span><span class='indexparent'><a class='index' id='scan_not,ctype'></a></span><code class='itemdecl'>
const charT* scan_not(mask m,
                      const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_scan_not(m,low,high)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,toupper'></a></span><span class='indexparent'><a class='index' id='toupper,ctype'></a></span><code class='itemdecl'>
charT        toupper(charT) const;
const charT* toupper(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_toupper(c)</span>
or
<span class='texttt'>do_toupper(low,high)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,tolower'></a></span><span class='indexparent'><a class='index' id='tolower,ctype'></a></span><code class='itemdecl'>
charT        tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_tolower(c)</span>
or
<span class='texttt'>do_tolower(low,high)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,widen'></a></span><span class='indexparent'><a class='index' id='widen,ctype'></a></span><code class='itemdecl'>
charT       widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_widen(c)</span>
or
<span class='texttt'>do_widen(low,high,to)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,narrow'></a></span><span class='indexparent'><a class='index' id='narrow,ctype'></a></span><code class='itemdecl'>
char         narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT*, char dfault,
                    char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_narrow(c,dfault)</span>
or
<span class='texttt'>do_narrow(low,high,dfault,to)</span>
</p></div></div></div><div id='locale.ctype.virtuals'><h4 ><a class='secnum' href='#locale.ctype.virtuals' style='min-width:133pt'>22.4.1.1.2</a> <span class='texttt'>ctype</span> virtual functions <a class='abbr_ref' href='locale.ctype.virtuals'>[locale.ctype.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='ctype,do_is'></a></span><span class='indexparent'><a class='index' id='do_is,ctype'></a></span><code class='itemdecl'>
bool         do_is(mask m, charT c) const;
const charT* do_is(const charT* low, const charT* high,
                   mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Classifies a character or sequence of characters.
For each argument character, identifies a value
<span class='texttt'>M</span>
of type
<span class='texttt'>ctype_base::mask</span>.
The second form identifies a value <span class='texttt'>M</span> of type
<span class='texttt'>ctype_base::mask</span>
for each
<span class='texttt'>*p</span>
where
<span class='texttt'>(low&lt;=p &amp;&amp; p&lt;high)</span>,
and places it into
<span class='texttt'>vec[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the result of the expression
<span class='texttt'>(M &amp; m) != 0</span>;
i.e.,
<span class='texttt'>true</span>
if the character has the characteristics specified.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype_base,do_scan_is'></a></span><span class='indexparent'><a class='index' id='do_scan_is,ctype_base'></a></span><code class='itemdecl'>
const charT* do_scan_is(mask m,
                       const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Locates a character in a buffer that conforms to a classification
<span class='texttt'>m</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest pointer <span class='texttt'>p</span> in the range
<span class='texttt'>[low, high)</span>
such that
<span class='texttt'>is(m,*p)</span>
would return
<span class='texttt'>true</span>;
otherwise, returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_scan_not'></a></span><span class='indexparent'><a class='index' id='do_scan_not,ctype'></a></span><code class='itemdecl'>
const charT* do_scan_not(mask m,
                        const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Locates a character in a buffer that fails to conform to a classification
<span class='texttt'>m</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest pointer <span class='texttt'>p</span>, if any, in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>
such that
<span class='texttt'>is(m,*p)</span>
would return
<span class='texttt'>false</span>;
otherwise, returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_toupper'></a></span><span class='indexparent'><a class='index' id='do_toupper,ctype'></a></span><code class='itemdecl'>
charT        do_toupper(charT c) const;
const charT* do_toupper(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Converts a character or characters to upper case.
The second form replaces each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>
for which a corresponding upper-case character exists, with
that character.</p></div></div><div class='para' id='locale.ctype.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the corresponding upper-case character if it
is known to exist, or its argument if not.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_tolower'></a></span><span class='indexparent'><a class='index' id='do_tolower,ctype'></a></span><code class='itemdecl'>
charT        do_tolower(charT c) const;
const charT* do_tolower(charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Converts a character or characters to lower case.
The second form replaces each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>
and for which a corresponding lower-case character exists,
with that character.</p></div></div><div class='para' id='locale.ctype.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the corresponding lower-case character if it
is known to exist, or its argument if not.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_widen'></a></span><span class='indexparent'><a class='index' id='do_widen,ctype'></a></span><code class='itemdecl'>
charT        do_widen(char c) const;
const char*  do_widen(const char* low, const char* high,
                      charT* dest) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Applies the simplest reasonable transformation from a
<span class='texttt'>char</span>
value or sequence of
<span class='texttt'>char</span>
values to the corresponding
<span class='texttt'>charT</span>
value or values.<a class='footnotenum' href='#footnote-240'>240</a>
The only characters for which unique transformations are required
are those in the basic source character set (<a href='lex.charset'>[lex.charset]</a>).</p><p >For any named
<span class='texttt'>ctype</span>
category with a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet <span class='texttt'>ctc</span> and valid
<span class='texttt'>ctype_base::mask</span>
value <span class='texttt'>M</span>,
<span class='texttt'>(ctc.<span class='discretionary'></span>is(M, c) || !is(M, do_widen(c)) )</span>
is
<span class='texttt'>true</span>.<a class='footnotenum' href='#footnote-241'>241</a></p><p >The second form transforms each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>,
placing the result in
<span class='texttt'>dest[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the transformed value.
The second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype,do_narrow'></a></span><span class='indexparent'><a class='index' id='do_narrow,ctype'></a></span><code class='itemdecl'>
char         do_narrow(charT c, char dfault) const;
const charT* do_narrow(const charT* low, const charT* high,
                       char dfault, char* dest) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.ctype.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Applies the simplest reasonable transformation from a
<span class='texttt'>charT</span>
value or sequence of
<span class='texttt'>charT</span>
values to the corresponding
<span class='texttt'>char</span>
value or values.</p><p >For any character <span class='texttt'>c</span> in the basic source character set (<a href='lex.charset'>[lex.charset]</a>)
the transformation is such that</p><pre class='codeblock'>
do_widen(do_narrow(c,0)) == c
</pre><p >For any named
<span class='texttt'>ctype</span>
category with a
<span class='texttt'>ctype&lt;char&gt;</span>
facet <span class='texttt'>ctc</span> however, and
<span class='texttt'>ctype_base::mask</span>
value <span class='texttt'>M</span>,</p><pre class='codeblock'>
(is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )
</pre><p >is
<span class='texttt'>true</span>
(unless
<span class='texttt'>do_narrow</span>
returns
<span class='texttt'>dfault</span>).
In addition, for any digit character <span class='texttt'>c</span>,
the expression
<span class='texttt'>(do_narrow(c, dfault) - '0')</span>
evaluates to the digit value of the character.
The second form transforms each character
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>,
placing the result (or <span class='texttt'>dfault</span>
if no simple transformation is readily available) in
<span class='texttt'>dest[p-low]</span>.</p></div></div><div class='para' id='locale.ctype.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.ctype.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns the transformed value; or <span class='texttt'>dfault</span>
if no mapping is readily available.
The second form returns <span class='texttt'>high</span>.
</p></div></div><div class='footnote' id='footnote-239'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-239'>239)</a></div><p >The char argument of
<span class='texttt'>do_widen</span>
is intended to accept values derived from character literals for conversion
to the locale's encoding.</p></div><div class='footnote' id='footnote-240'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-240'>240)</a></div><p >In other words, the transformed character is not a member
of any character classification that <span class='texttt'>c</span> is not also a member of.</p></div></div></div><div id='locale.ctype.byname'><h4 ><a class='secnum' href='#locale.ctype.byname' style='min-width:118pt'>22.4.1.2</a> Class template <span class='texttt'>ctype_byname</span> <a class='abbr_ref' href='locale.ctype.byname'>[locale.ctype.byname]</a></h4><p ><span class='indexparent'><a class='index' id='ctype_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class ctype_byname : public ctype&lt;charT&gt; {
  public:
    typedef typename ctype&lt;charT&gt;::mask mask;
    explicit ctype_byname(const char*, size_t refs = 0);
    explicit ctype_byname(const string&amp;, size_t refs = 0);
  protected:
   ~ctype_byname();
  };
}
</pre></div><div id='facet.ctype.special'><h4 ><a class='secnum' href='#facet.ctype.special' style='min-width:118pt'>22.4.1.3</a> <span class='texttt'>ctype</span> specializations <a class='abbr_ref' href='facet.ctype.special'>[facet.ctype.special]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;&gt; class ctype&lt;char&gt;
    : public locale::facet, public ctype_base {
  public:
    typedef char char_type;

    explicit ctype(const mask* tab = 0, bool del = false,
                   size_t refs = 0);

    bool is(mask m, char c) const;
    const char* is(const char* low, const char* high, mask* vec) const;
    const char* scan_is (mask m,
                         const char* low, const char* high) const;
    const char* scan_not(mask m,
                         const char* low, const char* high) const;

    char        toupper(char c) const;
    const char* toupper(char* low, const char* high) const;
    char        tolower(char c) const;
    const char* tolower(char* low, const char* high) const;

    char  widen(char c) const;
    const char* widen(const char* low, const char* high, char* to) const;
    char  narrow(char c, char dfault) const;
    const char* narrow(const char* low, const char* high, char dfault,
                       char* to) const;

    static locale::id id;
    static const size_t table_size = <i>implementation-defined</i>;

    const mask* table() const noexcept;
    static const mask* classic_table() noexcept;

  protected:
   ~ctype();
    virtual char        do_toupper(char c) const;
    virtual const char* do_toupper(char* low, const char* high) const;
    virtual char        do_tolower(char c) const;
    virtual const char* do_tolower(char* low, const char* high) const;

    virtual char        do_widen(char c) const;
    virtual const char* do_widen(const char* low,
                                 const char* high,
                                 char* to) const;
    virtual char        do_narrow(char c, char dfault) const;
    virtual const char* do_narrow(const char* low,
                                  const char* high,
                                  char dfault, char* to) const;
  };
}
</pre><div class='para' id='facet.ctype.special-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.special-1'>1</a></div><p >A specialization
<span class='texttt'>ctype&lt;char&gt;</span>
is provided so that the member functions on type
<span class='texttt'>char</span>
can be implemented
<span class='texttt'>inline</span>.<a class='footnotenum' href='#footnote-242'>242</a>
The <span class='indexparent'><a class='index' id='value_of_ctype<char>::table_size'></a></span>implementation-defined value of member
<span class='texttt'>table_size</span>
is at least 256.</p></div><div class='footnote' id='footnote-241'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-241'>241)</a></div><p >Only the
<span class='texttt'>char</span>
(not
<span class='texttt'>unsigned char</span>
and
<span class='texttt'>signed char</span>)
form is provided.
The specialization is specified in the standard, and not left as an
implementation detail, because it affects the derivation interface for
<span class='texttt'>ctype&lt;char&gt;</span>.</p></div><div id='facet.ctype.char.dtor'><h4 ><a class='secnum' href='#facet.ctype.char.dtor' style='min-width:133pt'>22.4.1.3.1</a> <span class='texttt'>ctype&lt;char&gt;</span> destructor <a class='abbr_ref' href='facet.ctype.char.dtor'>[facet.ctype.char.dtor]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,destructor'></a></span><code class='itemdecl'>
~ctype();
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
If the constructor's first argument was nonzero, and its second argument
was true, does
<span class='texttt'>delete [] table()</span>.
</p></div></div></div><div id='facet.ctype.char.members'><h4 ><a class='secnum' href='#facet.ctype.char.members' style='min-width:133pt'>22.4.1.3.2</a> <span class='texttt'>ctype&lt;char&gt;</span> members <a class='abbr_ref' href='facet.ctype.char.members'>[facet.ctype.char.members]</a></h4><div class='para' id='facet.ctype.char.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ctype<char>,ctype<char>'></a></span>In the following member descriptions, for
<span class='texttt'>unsigned char</span>
values <span class='texttt'>v</span> where <span class='texttt'>v &gt;= table_size</span>,
<span class='texttt'>table()[v]</span> is assumed to have an
implementation-specific value (possibly different for each
such value <span class='texttt'>v</span>) without performing the array lookup.</p><p ><span class='indexparent'><a class='index' id='ctype<char>,constructor'></a></span><code class='itemdecl'>
explicit ctype(const mask* tbl = 0, bool del = false,
               size_t refs = 0);
</code></p></div><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>tbl</span> either 0 or an array of at least
<span class='texttt'>table_size</span>
elements.</p></div></div><div class='para' id='facet.ctype.char.members-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Passes its <span class='texttt'>refs</span> argument to its base class constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,is'></a></span><span class='indexparent'><a class='index' id='is,ctype<char>'></a></span><code class='itemdecl'>
bool        is(mask m, char c) const;
const char* is(const char* low, const char* high,
               mask* vec) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
The second form, for all
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>,
assigns
into
<span class='texttt'>vec[p-low]</span>
the value
<span class='texttt'>table()[&nbsp;(unsigned char)*p]</span>.</p></div></div><div class='para' id='facet.ctype.char.members-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first form returns
<span class='texttt'>table()[(unsigned char)c] &amp; m</span>;
the second form returns <span class='texttt'>high</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,scan_is'></a></span><span class='indexparent'><a class='index' id='scan_is,ctype<char>'></a></span><code class='itemdecl'>
const char* scan_is(mask m,
                    const char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest
<span class='texttt'>p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>
such that
</p><pre class='codeblock'>
table()[(unsigned char) *p] &amp; m
</pre><p >is
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,scan_not'></a></span><span class='indexparent'><a class='index' id='scan_not,ctype<char>'></a></span><code class='itemdecl'>
const char* scan_not(mask m,
                     const char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-7'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The smallest
<span class='texttt'>p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>
such that
</p><pre class='codeblock'>
table()[(unsigned char) *p] &amp; m
</pre><p >is
<span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,toupper'></a></span><span class='indexparent'><a class='index' id='toupper,ctype<char>'></a></span><code class='itemdecl'>
char        toupper(char c) const;
const char* toupper(char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-8'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_toupper(c)</span>
or
<span class='texttt'>do_toupper(low,high)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,tolower'></a></span><span class='indexparent'><a class='index' id='tolower,ctype<char>'></a></span><code class='itemdecl'>
char        tolower(char c) const;
const char* tolower(char* low, const char* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-9'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_tolower(c)</span>
or
<span class='texttt'>do_tolower(low,high)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,widen'></a></span><span class='indexparent'><a class='index' id='widen,ctype<char>'></a></span><code class='itemdecl'>
char  widen(char c) const;
const char* widen(const char* low, const char* high,
    char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-10'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_widen(c)</span>
or
<span class='indexparent'><a class='index' id='do_widen'></a></span><span class='texttt'>do_widen(low, high, to)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,narrow'></a></span><span class='indexparent'><a class='index' id='narrow,ctype<char>'></a></span><code class='itemdecl'>
char        narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high,
                   char dfault, char* to) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-11'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='indexparent'><a class='index' id='do_narrow'></a></span><span class='texttt'>do_narrow(c, dfault)</span>
or
<span class='indexparent'><a class='index' id='do_narrow'></a></span><span class='texttt'>do_narrow(low, high, dfault, to)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='ctype<char>,table'></a></span><span class='indexparent'><a class='index' id='table,ctype<char>'></a></span><code class='itemdecl'>
const mask* table() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.members-12'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first constructor argument, if it was non-zero, otherwise
<span class='texttt'>classic_table()</span>.
</p></div></div></div><div id='facet.ctype.char.statics'><h4 ><a class='secnum' href='#facet.ctype.char.statics' style='min-width:133pt'>22.4.1.3.3</a> <span class='texttt'>ctype&lt;char&gt;</span> static members <a class='abbr_ref' href='facet.ctype.char.statics'>[facet.ctype.char.statics]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,classic_table'></a></span><span class='indexparent'><a class='index' id='classic_table,ctype<char>'></a></span><code class='itemdecl'>
static const mask* classic_table() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='facet.ctype.char.statics-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.ctype.char.statics-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to the initial element of an array of size
<span class='texttt'>table_size</span>
which represents the classifications of characters in the "C" locale.
</p></div></div></div><div id='facet.ctype.char.virtuals'><h4 ><a class='secnum' href='#facet.ctype.char.virtuals' style='min-width:133pt'>22.4.1.3.4</a> <span class='texttt'>ctype&lt;char&gt;</span> virtual functions <a class='abbr_ref' href='facet.ctype.char.virtuals'>[facet.ctype.char.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='ctype<char>,do_toupper'></a></span><span class='indexparent'><a class='index' id='do_toupper,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_tolower'></a></span><span class='indexparent'><a class='index' id='do_tolower,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_widen'></a></span><span class='indexparent'><a class='index' id='do_widen,ctype<char>'></a></span><span class='indexparent'><a class='index' id='ctype<char>,do_narrow'></a></span><span class='indexparent'><a class='index' id='do_narrow,ctype<char>'></a></span></p><pre class='codeblock'>
char        do_toupper(char) const;
const char* do_toupper(char* low, const char* high) const;
char        do_tolower(char) const;
const char* do_tolower(char* low, const char* high) const;

virtual char        do_widen(char c) const;
virtual const char* do_widen(const char* low,
                             const char* high,
                             char* to) const;
virtual char        do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low,
                              const char* high,
                              char dfault, char* to) const;
</pre><p >These functions are described identically as those members of the
same name in the
<span class='texttt'>ctype</span>
class template (<a href='locale.ctype.members'>[locale.ctype.members]</a>).</p></div></div><div id='locale.codecvt'><h4 ><a class='secnum' href='#locale.codecvt' style='min-width:118pt'>22.4.1.4</a> Class template <span class='texttt'>codecvt</span> <a class='abbr_ref' href='locale.codecvt'>[locale.codecvt]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt'></a></span></p><pre class='codeblock'>
namespace std {
  class codecvt_base {
  public:
    enum result { ok, partial, error, noconv };
  };

  template &lt;class internT, class externT, class stateT&gt;
  class codecvt : public locale::facet, public codecvt_base {
  public:
    typedef internT  intern_type;
    typedef externT  extern_type;
    typedef stateT state_type;

    explicit codecvt(size_t refs = 0);

    result out(stateT&amp; state,
               const internT* from, const internT* from_end, const internT*&amp; from_next,
               externT*   to,       externT* to_end, externT*&amp; to_next) const;
    result unshift(stateT&amp; state,
                   externT*   to,        externT* to_end, externT*&amp; to_next) const;
    result in(stateT&amp; state,
              const externT* from, const externT* from_end, const externT*&amp; from_next,
              internT*   to,       internT* to_end, internT*&amp; to_next) const;
    int encoding() const noexcept;
    bool always_noconv() const noexcept;
    int length(stateT&amp;, const externT* from, const externT* end,
               size_t max) const;
    int max_length() const noexcept;

    static locale::id id;

  protected:
    ~codecvt();
    virtual result do_out(stateT&amp; state,
                          const internT* from, const internT* from_end, const internT*&amp; from_next,
                          externT* to,         externT* to_end, externT*&amp; to_next) const;
    virtual result do_in(stateT&amp; state,
                         const externT* from, const externT* from_end, const externT*&amp; from_next,
                         internT* to,         internT* to_end, internT*&amp; to_next) const;
    virtual result do_unshift(stateT&amp; state,
                              externT* to,         externT* to_end, externT*&amp; to_next) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(stateT&amp;, const externT* from,
                          const externT* end, size_t max) const;
    virtual int do_max_length() const noexcept;
  };
}
</pre><div class='para' id='locale.codecvt-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-1'>1</a></div><p >The class
<span class='texttt'>codecvt&lt;internT,externT,stateT&gt;</span>
is for use when
converting from one character encoding to another, such as from wide characters
to multibyte  characters or between wide character encodings such as
Unicode and EUC.</p></div><div class='para' id='locale.codecvt-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-2'>2</a></div><p >The
<span class='texttt'>stateT</span>
argument selects the pair of character encodings being mapped between.</p></div><div class='para' id='locale.codecvt-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt-3'>3</a></div><p >The specializations required in Table <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>)
convert the implementation-defined native character set.
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>
implements a degenerate conversion;
it does not convert at all.
The specialization <span class='texttt'>codecvt&lt;char16_t,</span> <span class='texttt'>char, mbstate_t&gt;</span>
converts between the UTF-16 and UTF-8 encoding schemes, and
the specialization <span class='texttt'>codecvt</span> <span class='texttt'>&lt;char32_t, char, mbstate_t&gt;</span>
converts between the UTF-32 and UTF-8 encoding schemes.
<span class='texttt'>codecvt&lt;wchar_t,char,mbstate_t&gt;</span>
converts between the native character sets for narrow and wide characters.
Specializations on
<span class='texttt'>mbstate_t</span>
perform conversion between encodings known to the library implementer.
Other encodings can be converted by specializing on a user-defined
<span class='texttt'>stateT</span>
type.
The
<span class='texttt'>stateT</span>
object can contain any state that is useful to communicate to or from
the specialized
<span class='texttt'>do_in</span>
or
<span class='texttt'>do_out</span>
members.</p></div><div id='locale.codecvt.members'><h4 ><a class='secnum' href='#locale.codecvt.members' style='min-width:133pt'>22.4.1.4.1</a> <span class='texttt'>codecvt</span> members <a class='abbr_ref' href='locale.codecvt.members'>[locale.codecvt.members]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt,out'></a></span><span class='indexparent'><a class='index' id='out,codecvt'></a></span><code class='itemdecl'>
result out(stateT&amp; state,
  const internT* from, const internT* from_end, const internT*&amp; from_next,
        externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_out(state, from, from_end, from_next, to, to_end, to_next)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,unshift'></a></span><span class='indexparent'><a class='index' id='unshift,codecvt'></a></span><code class='itemdecl'>
result unshift(stateT&amp; state,
        externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_unshift(state, to, to_end, to_next)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,in'></a></span><span class='indexparent'><a class='index' id='in,codecvt'></a></span><code class='itemdecl'>
result in(stateT&amp; state,
  const externT* from, const externT* from_end, const externT*&amp; from_next,
        internT* to, internT* to_end, internT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_in(state, from, from_end, from_next, to, to_end, to_next)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,encoding'></a></span><span class='indexparent'><a class='index' id='encoding,codecvt'></a></span><code class='itemdecl'>
int encoding() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_encoding()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,always_noconv'></a></span><span class='indexparent'><a class='index' id='always_noconv,codecvt'></a></span><code class='itemdecl'>
bool always_noconv() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_always_noconv()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,length'></a></span><span class='indexparent'><a class='index' id='length,codecvt'></a></span><code class='itemdecl'>
int length(stateT&amp; state, const externT* from, const externT* from_end,
           size_t max) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_length(state, from,from_end,max)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,max_length'></a></span><span class='indexparent'><a class='index' id='max_length,codecvt'></a></span><code class='itemdecl'>
int max_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_max_length()</span>
</p></div></div></div><div id='locale.codecvt.virtuals'><h4 ><a class='secnum' href='#locale.codecvt.virtuals' style='min-width:133pt'>22.4.1.4.2</a> <span class='texttt'>codecvt</span> virtual functions <a class='abbr_ref' href='locale.codecvt.virtuals'>[locale.codecvt.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt,do_out'></a></span><span class='indexparent'><a class='index' id='do_out,codecvt'></a></span><span class='indexparent'><a class='index' id='codecvt,do_in'></a></span><span class='indexparent'><a class='index' id='do_in,codecvt'></a></span><code class='itemdecl'>
result do_out(stateT&amp; state,
  const internT* from, const internT* from_end, const internT*&amp; from_next,
  externT* to, externT* to_end, externT*&amp; to_next) const;

result do_in(stateT&amp; state,
  const externT* from, const externT* from_end, const externT*&amp; from_next,
        internT* to, internT* to_end, internT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(from&lt;=from_end &amp;&amp; to&lt;=to_end)</span>
well-defined and
<span class='texttt'>true</span>;
<span class='texttt'>state</span> initialized, if at the beginning of a sequence, or else equal to
the result of converting the preceding characters in the sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Translates characters in the source range
<span class='texttt'>[from,from_end)</span>,
placing the results in sequential positions starting at destination <span class='texttt'>to</span>.
Converts no more than
<span class='texttt'>(from_end-from)</span>
source elements, and
stores no more than
<span class='texttt'>(to_end-to)</span>
destination elements.</p><p >Stops if it encounters a character it cannot convert.
It always leaves the <span class='texttt'>from_next</span> and <span class='texttt'>to_next</span> pointers
pointing one beyond the last element successfully converted.
If returns
<span class='texttt'>noconv</span>,
<span class='texttt'>internT</span>
and
<span class='texttt'>externT</span>
are the same type and the converted sequence is
identical to the input sequence
<span class='texttt'>[from, from_next)</span>.
<span class='texttt'>to_next</span> is set equal to <span class='texttt'>to</span>, the value of <span class='texttt'>state</span> is
unchanged, and there are no changes to the values in
<span class='texttt'>[to, to_end)</span>.</p></div></div><div class='para' id='locale.codecvt.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-3'>3</a></div><div class='itemdescr'><p >A
<span class='texttt'>codecvt</span>
facet that is used by
<span class='texttt'>basic_filebuf</span> (<a href='file.streams'>[file.streams]</a>) shall have the property that if
</p><pre class='codeblock'>
do_out(state, from, from_end, from_next, to, to_end, to_next)
</pre><p >would return
<span class='texttt'>ok</span>,
where
<span class='texttt'>from != from_end</span>,
then
</p><pre class='codeblock'>
do_out(state, from, from + 1, from_next, to, to_end, to_next)
</pre><p >shall also return
<span class='texttt'>ok</span>,
and that if
</p><pre class='codeblock'>
do_in(state, from, from_end, from_next, to, to_end, to_next)
</pre><p >would return
<span class='texttt'>ok</span>,
where
<span class='texttt'>to != to_end</span>,
then
</p><pre class='codeblock'>
do_in(state, from, from_end, from_next, to, to + 1, to_next)
</pre><p >shall also return
<span class='texttt'>ok</span>.<a class='footnotenum' href='#footnote-243'>243</a>
[&nbsp;<i>Note:</i> As a result of operations on <span class='texttt'>state</span>, it can return <span class='texttt'>ok</span> or <span class='texttt'>partial</span> and set <span class='texttt'>from_next == from</span> and <span class='texttt'>to_next != to</span>. <i>&nbsp;&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.codecvt.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Its operations on <span class='texttt'>state</span> are unspecified.
[&nbsp;<i>Note:</i>
This argument can be used, for example, to maintain
shift state, to specify conversion options (such as count only), or to
identify a cache of seek offsets.
<i>&nbsp;&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.codecvt.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value, as summarized in Table <a href='#tab:localization.convert.result.values.out.in'>[tab:localization.convert.result.values.out.in]</a>.</p><div class='numberedTable' id='tab:localization.convert.result.values.out.in'>Table <a href='#tab:localization.convert.result.values.out.in'>83</a>  <span class='texttt'>do_in/do_out</span> result values<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Value</b></td><td colspan='1' class='center'><b>Meaning</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ok</span>                  </td><td class='justify'>   completed the conversion            </td></tr><tr ><td class='left'>
<span class='texttt'>partial</span>             </td><td class='justify'>   not all source characters converted </td></tr><tr ><td class='left'>
<span class='texttt'>error</span>               </td><td class='justify'>
encountered a character in <span class='texttt'>[from,from_end)</span>
that it could not convert                                           </td></tr><tr ><td class='left'>
<span class='texttt'>noconv</span>              </td><td class='justify'>
<span class='texttt'>internT</span> and <span class='texttt'>externT</span> are the same type, and input
sequence is identical to converted sequence                         </td></tr></table></div><p >A return value of
<span class='texttt'>partial</span>,
if
<span class='texttt'>(from_next==from_end)</span>,
indicates that either the destination sequence has not absorbed all the
available destination elements, or that additional source elements are
needed before another destination element can be produced.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_unshift'></a></span><span class='indexparent'><a class='index' id='do_unshift,codecvt'></a></span><code class='itemdecl'>
result do_unshift(stateT&amp; state,
  externT* to, externT* to_end, externT*&amp; to_next) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(to &lt;= to_end)</span>
well defined and true; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the
sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Places characters starting at <span class='texttt'>to</span> that should be appended
to terminate a sequence when the current
<span class='texttt'>stateT</span>
is given by <span class='texttt'>state</span>.<a class='footnotenum' href='#footnote-244'>244</a>
Stores no more than
<span class='texttt'>(to_end-to)</span>
destination elements, and leaves the <span class='texttt'>to_next</span> pointer
pointing one beyond the last element successfully stored.</p></div></div><div class='para' id='locale.codecvt.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value, as summarized in Table <a href='#tab:localization.convert.result.values.unshift'>[tab:localization.convert.result.values.unshift]</a>.</p><div class='numberedTable' id='tab:localization.convert.result.values.unshift'>Table <a href='#tab:localization.convert.result.values.unshift'>84</a>  <span class='texttt'>do_unshift</span> result values<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Value</b></td><td colspan='1' class='center'><b>Meaning</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ok</span>                  </td><td class='justify'>   completed the sequence                                  </td></tr><tr ><td class='left'>
<span class='texttt'>partial</span>             </td><td class='justify'>
space for more than <span class='texttt'>to_end-to</span> destination elements was needed
to terminate a sequence given the value of <span class='texttt'>state</span></td></tr><tr ><td class='left'>
<span class='texttt'>error</span>               </td><td class='justify'>   an unspecified error has occurred </td></tr><tr ><td class='left'>
<span class='texttt'>noconv</span>              </td><td class='justify'>   no termination is needed for this <span class='texttt'>state_type</span>    </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_encoding'></a></span><span class='indexparent'><a class='index' id='do_encoding,codecvt'></a></span><code class='itemdecl'>
int do_encoding() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
-1 if the encoding of the <span class='texttt'>externT</span> sequence is state-dependent; else the
constant number of <span class='texttt'>externT</span> characters needed to produce an internal
character; or 0 if this number is not a constant.<a class='footnotenum' href='#footnote-245'>245</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_always_noconv'></a></span><span class='indexparent'><a class='index' id='do_always_noconv,codecvt'></a></span><code class='itemdecl'>
bool do_always_noconv() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if
<span class='texttt'>do_in()</span>
and
<span class='texttt'>do_out()</span>
return
<span class='texttt'>noconv</span>
for all valid argument values.
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>
returns
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_length'></a></span><span class='indexparent'><a class='index' id='do_length,codecvt'></a></span><code class='itemdecl'>
int do_length(stateT&amp; state, const externT* from, const externT* from_end,
              size_t max) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>(from&lt;=from_end)</span>
well-defined and
<span class='texttt'>true</span>;
<span class='texttt'>state</span> initialized, if at the beginning of a sequence, or else equal to
the result of converting the preceding characters in the sequence.</p></div></div><div class='para' id='locale.codecvt.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
The effect on the <span class='texttt'>state</span> argument is as if it called
<span class='texttt'>do_in(state, from, from_end, from, to, to+max, to)</span>
for <span class='texttt'>to</span> pointing to a buffer of at least <span class='texttt'>max</span> elements.</p></div></div><div class='para' id='locale.codecvt.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>(from_next-from)</span>
where
<span class='texttt'>from_next</span>
is the largest value in the range
<span class='texttt'>[from,from_end]</span>
such that the sequence of values in the range
<span class='texttt'>[<span class='discretionary'></span>from,<span class='discretionary'></span>from_next<span class='discretionary'></span>)</span>
represents
<span class='texttt'>max</span>
or fewer valid complete characters of type
<span class='texttt'>internT</span>.
The specialization
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;</span>,
returns the lesser of
<span class='texttt'>max</span>
and
<span class='texttt'>(from_end-from)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='codecvt,do_max_length'></a></span><span class='indexparent'><a class='index' id='do_max_length,codecvt'></a></span><code class='itemdecl'>
int do_max_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='locale.codecvt.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.codecvt.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i>
The maximum value that
<span class='texttt'>do_length(state, from, from_end, 1)</span>
can return for any valid range
<span class='texttt'>[from, from_end)</span>
and
<span class='texttt'>stateT</span>
value
<span class='texttt'>state</span>.
The specialization
<span class='texttt'>codecvt&lt;char, char, mbstate_t&gt;<span class='discretionary'></span>::<span class='discretionary'></span>do_max_length()</span>
returns 1.
</p></div></div><div class='footnote' id='footnote-242'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-242'>242)</a></div><p >Informally, this means that
<span class='texttt'>basic_filebuf</span>
assumes that the mappings from internal to external characters is
1 to N: a
<span class='texttt'>codecvt</span>
facet that is used by
<span class='texttt'>basic_filebuf</span>
must be able to translate characters one internal character at a time.
</p></div><div class='footnote' id='footnote-243'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-243'>243)</a></div><p >Typically these will be characters to return the state to
<span class='texttt'>stateT()</span></p></div><div class='footnote' id='footnote-244'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-244'>244)</a></div><p >If <span class='texttt'>encoding()</span>
yields -1, then more than <span class='texttt'>max_length()</span> <span class='texttt'>externT</span> elements
may be consumed when producing a single <span class='texttt'>internT</span> character, and additional
<span class='texttt'>externT</span> elements may appear at the end of a sequence after those that
yield the final <span class='texttt'>internT</span> character.</p></div></div></div><div id='locale.codecvt.byname'><h4 ><a class='secnum' href='#locale.codecvt.byname' style='min-width:118pt'>22.4.1.5</a> Class template <span class='texttt'>codecvt_byname</span> <a class='abbr_ref' href='locale.codecvt.byname'>[locale.codecvt.byname]</a></h4><p ><span class='indexparent'><a class='index' id='codecvt_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class internT, class externT, class stateT&gt;
  class codecvt_byname : public codecvt&lt;internT, externT, stateT&gt; {
  public:
    explicit codecvt_byname(const char*, size_t refs = 0);
    explicit codecvt_byname(const string&amp;, size_t refs = 0);
  protected:
    ~codecvt_byname();
  };
}
</pre></div></div><div id='category.numeric'><h3 ><a class='secnum' href='#category.numeric' style='min-width:103pt'>22.4.2</a> The numeric category <a class='abbr_ref' href='category.numeric'>[category.numeric]</a></h3><div class='para' id='category.numeric-1'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-1'>1</a></div><p >The classes
<span class='texttt'>num_get&lt;&gt;</span>
and
<span class='texttt'>num_put&lt;&gt;</span>
handle numeric formatting and parsing.
Virtual functions are provided for several numeric types.
Implementations may (but are not required to) delegate extraction
of smaller types to extractors for larger types.<a class='footnotenum' href='#footnote-246'>246</a></p></div><div class='para' id='category.numeric-2'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-2'>2</a></div><p >All specifications of member functions for
<span class='texttt'>num_put</span>
and
<span class='texttt'>num_get</span>
in the subclauses of <a href='category.numeric'>[category.numeric]</a> only apply to the
specializations required in Tables <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='locale.category#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>num_get&lt;char&gt;</span>,
<span class='texttt'>num_get&lt;wchar_t&gt;</span>,
<span class='texttt'>num_get&lt;C, InputIterator&gt;</span>,
<span class='texttt'>num_put&lt;char&gt;</span>,
<span class='texttt'>num_put&lt;wchar_t&gt;</span>,
and
<span class='texttt'>num_put&lt;C,OutputIterator&gt;</span>.
These specializations refer to the
<span class='texttt'>ios_base&amp;</span>
argument for formatting specifications (<a href='locale.categories'>[locale.categories]</a>),
and to its imbued locale for the
<span class='texttt'>numpunct&lt;&gt;</span>
facet to identify all numeric punctuation preferences,
and also for the
<span class='texttt'>ctype&lt;&gt;</span>
facet to perform character classification.</p></div><div class='para' id='category.numeric-3'><div class='marginalizedparent'><a class='marginalized' href='#category.numeric-3'>3</a></div><p >Extractor and inserter members of the standard iostreams use
<span class='texttt'>num_get&lt;&gt;</span>
and
<span class='texttt'>num_put&lt;&gt;</span>
member functions for formatting and parsing numeric values (<a href='istream.formatted.reqmts'>[istream.formatted.reqmts]</a>, <a href='ostream.formatted.reqmts'>[ostream.formatted.reqmts]</a>).</p></div><div class='footnote' id='footnote-245'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-245'>245)</a></div><p >Parsing
<span class='texttt'>"-1"</span> correctly into, e.g., an
<span class='texttt'>unsigned short</span>
requires that the corresponding member
<span class='texttt'>get()</span>
at least extract the sign before delegating.</p></div><div id='locale.num.get'><h4 ><a class='secnum' href='#locale.num.get' style='min-width:118pt'>22.4.2.1</a> Class template <span class='texttt'>num_get</span> <a class='abbr_ref' href='locale.num.get'>[locale.num.get]</a></h4><p ><span class='indexparent'><a class='index' id='num_get'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
  class num_get : public locale::facet {
  public:
    typedef charT            char_type;
    typedef InputIterator    iter_type;

    explicit num_get(size_t refs = 0);

    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, bool&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned short&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned int&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, unsigned long long&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, float&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, double&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, long double&amp; v) const;
    iter_type get(iter_type in, iter_type end, ios_base&amp;,
                  ios_base::iostate&amp; err, void*&amp; v) const;

    static locale::id id;

  protected:
    ~num_get();
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, bool&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned short&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned int&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, unsigned long long&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, float&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, double&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, long double&amp; v) const;
    virtual iter_type do_get(iter_type, iter_type, ios_base&amp;,
                             ios_base::iostate&amp; err, void*&amp; v) const;
  };
}
</pre><div class='para' id='locale.num.get-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.num.get-1'>1</a></div><p >The facet
<span class='texttt'>num_get</span>
is used to parse numeric values from an input sequence such as an istream.</p></div><div id='facet.num.get.members'><h4 ><a class='secnum' href='#facet.num.get.members' style='min-width:133pt'>22.4.2.1.1</a> <span class='texttt'>num_get</span> members <a class='abbr_ref' href='facet.num.get.members'>[facet.num.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='num_get,get'></a></span><span class='indexparent'><a class='index' id='get,num_get'></a></span><code class='itemdecl'>
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, bool&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned short&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned int&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long long&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, float&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, double&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long double&amp; val) const;
iter_type get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, void*&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(in, end, str, err, val)</span>.
</p></div></div></div><div id='facet.num.get.virtuals'><h4 ><a class='secnum' href='#facet.num.get.virtuals' style='min-width:133pt'>22.4.2.1.2</a> <span class='texttt'>num_get</span> virtual functions <a class='abbr_ref' href='facet.num.get.virtuals'>[facet.num.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='num_get,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,num_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned short&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned int&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, unsigned long long&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, float&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, double&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, long double&amp; val) const;
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
  ios_base::iostate&amp; err, void*&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters from <span class='texttt'>in</span>,
interpreting them according to
<span class='texttt'>str.flags()</span>,
<span class='texttt'>use_facet&lt;ctype&lt;<span class='discretionary'></span>charT&gt; &gt;(loc)</span>,
and
<span class='texttt'>use_facet&lt; numpunct&lt;charT&gt; &gt;(loc)</span>,
where
<span class='texttt'>loc</span>
is
<span class='texttt'>str.getloc()</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-2'>2</a></div><div class='itemdescr'><p >The details of this operation occur in three stages</p><ul ><li ><p >Stage 1:
Determine a conversion specifier
</p></li><li ><p >Stage 2: Extract characters from <span class='texttt'>in</span> and determine a corresponding
<span class='texttt'>char</span>
value for the format expected by the conversion specification determined
in stage 1.
</p></li><li ><p >Stage 3:
Store results
</p></li></ul></div></div><div class='para' id='facet.num.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-3'>3</a></div><div class='itemdescr'><p >The details of the stages are presented below.</p><ul ><li ><p >The function initializes local variables via</p><pre class='codeblock'>
fmtflags flags = str .flags();
fmtflags basefield = (flags &amp; ios_base::basefield);
fmtflags uppercase = (flags &amp; ios_base::uppercase);
fmtflags boolalpha = (flags &amp; ios_base::boolalpha);
</pre><p >For conversion to an integral type, the
function determines the integral conversion specifier as indicated in
Table <a href='#tab:localization.integer.conversions.in'>[tab:localization.integer.conversions.in]</a>.
The table is ordered.
That is, the first line whose condition is true applies.</p><div class='numberedTable' id='tab:localization.integer.conversions.in'>Table <a href='#tab:localization.integer.conversions.in'>85</a>  Integer conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent   </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>basefield == oct</span>        </td><td class='center'>   <span class='texttt'>%o</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>basefield == hex</span>        </td><td class='center'>   <span class='texttt'>%X</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>basefield == 0</span>          </td><td class='center'>   <span class='texttt'>%i</span>                 </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>signed</span> integral type    </td><td class='center'>   <span class='texttt'>%d</span>                 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned</span> integral type  </td><td class='center'>   <span class='texttt'>%u</span>                 </td></tr></table></div><p >For conversions to a  floating type the specifier is
<span class='texttt'>%g</span>.</p><p >For conversions to
<span class='texttt'>void*</span>
the specifier is
<span class='texttt'>%p</span>.</p><p >A length modifier is added to the conversion specification, if needed,
as indicated in Table <a href='#tab:localization.length.modifier.in'>[tab:localization.length.modifier.in]</a>.</p><div class='numberedTable' id='tab:localization.length.modifier.in'>Table <a href='#tab:localization.length.modifier.in'>86</a>  Length modifier<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td class='center'>   Length modifier </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>short</span>               </td><td class='center'>   <span class='texttt'>h</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned short</span>      </td><td class='center'>   <span class='texttt'>h</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long</span>                </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long</span>       </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long long</span>           </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long long</span>  </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>double</span>              </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long double</span>         </td><td class='center'>   <span class='texttt'>L</span>       </td></tr></table></div></li><li ><p >If
<span class='texttt'>in==end</span>
then stage 2 terminates.
Otherwise a
<span class='texttt'>charT</span>
is taken from <span class='texttt'>in</span> and local variables are initialized as if by</p><pre class='codeblock'>
char_type ct = *in ;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct ==  use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).decimal_point())
c = '.';
bool discard =
  ct == use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).thousands_sep()
  &amp;&amp; use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().length() != 0;
</pre><p >where the values
<span class='texttt'>src</span>
and
<span class='texttt'>atoms</span>
are defined as if by:</p><pre class='codeblock'>
static const char src[] = "0123456789abcdefxABCDEFX+-";
char_type atoms[sizeof(src)];
use_facet&lt;ctype&lt;charT&gt; &gt;(loc).widen(src, src + sizeof(src), atoms);
</pre><p >for this value of
<span class='texttt'>loc</span>.</p><p >If <span class='texttt'>discard</span> is true, then if
<span class='texttt'>'.'</span>
has not yet been accumulated, then the position of the character is remembered,
but the character is otherwise ignored.
Otherwise, if
<span class='texttt'>'.'</span>
has already been accumulated, the character is discarded and
Stage 2 terminates.
If it is not discarded, then a check is made to determine if <span class='texttt'>c</span> is
allowed as the next character of an input field of the conversion specifier
returned by Stage 1. If so, it is accumulated.</p><p >If the character is either discarded or accumulated then <span class='texttt'>in</span>
is advanced by
<span class='texttt'>++in</span>
and processing returns to the beginning of stage 2.</p></li><li ><p >The sequence of <span class='texttt'>char</span>s accumulated in stage 2 (the field) is converted to a numeric value by the rules of one of the functions declared in the header <span class='texttt'>&lt;cstdlib&gt;</span>:</p><ul ><li ><p >For a signed integer value, the function <span class='texttt'>strtoll</span>.</p></li><li ><p >For an unsigned integer value, the function <span class='texttt'>strtoull</span>.</p></li><li ><p >For a floating-point value, the function <span class='texttt'>strtold</span>.
</p></li></ul><p >The numeric value to be stored can be one of:</p><ul ><li ><p >zero, if the conversion function fails to convert the entire field. <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></li><li ><p >the most positive representable value, if the field represents a value too large positive to be represented in <span class='texttt'>val</span>. <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></li><li ><p >the most negative representable value or zero for an unsigned integer type, if the field represents a value too large negative to be represented in <span class='texttt'>val</span>. <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></li><li ><p >the converted value, otherwise.
</p></li></ul><p >The resultant numeric value is stored in <span class='texttt'>val</span>.</p></li></ul></div></div><div class='para' id='facet.num.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-4'>4</a></div><div class='itemdescr'><p >Digit grouping is checked.
That is, the positions of discarded
separators is examined for consistency with
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping()</span>.
If they are not consistent then
<span class='texttt'>ios_base::failbit</span>
is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-5'>5</a></div><div class='itemdescr'><p >In any case, if stage 2 processing was terminated by the test for
<span class='texttt'>in==end</span>
then
<span class='texttt'>err |=ios_base::eofbit</span>
is performed.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_get,num_get'></a></span><span class='indexparent'><a class='index' id='num_get,do_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type in, iter_type end, ios_base&amp; str,
                 ios_base::iostate&amp; err, bool&amp; val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.get.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>(str<span class='texttt'>.flags()&amp;ios_base::boolalpha)==0</span></span>
then input proceeds as it would for a
<span class='texttt'>long</span>
except that if a value is being stored into <span class='texttt'>val</span>,
the value is determined according to the following:
If the value to be stored is 0 then
<span class='texttt'>false</span>
is stored.
If the value is 1
then
<span class='texttt'>true</span>
is stored.
Otherwise <span class='texttt'>true</span> is stored and <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-7'>7</a></div><div class='itemdescr'><p >Otherwise target sequences are determined as if by calling the
members
<span class='texttt'>falsename()</span>
and
<span class='texttt'>truename()</span>
of the facet obtained by
<span class='texttt'>use_facet&lt;numpunct&lt;charT&gt; &gt;(str.getloc())</span>.
Successive characters in the range
<span class='texttt'>[<span class='discretionary'></span>in,<span class='discretionary'></span>end<span class='discretionary'></span>)</span>
(see <a href='sequence.reqmts'>[sequence.reqmts]</a>) are obtained and
matched against corresponding positions in the target sequences only
as necessary to identify a unique match. The input iterator <span class='texttt'>in</span> is
compared to <span class='texttt'>end</span> only when necessary to obtain a character. If a target sequence is uniquely matched, <span class='texttt'>val</span> is set to the
corresponding value. Otherwise <span class='texttt'>false</span> is stored and <span class='texttt'>ios_base::failbit</span> is assigned to <span class='texttt'>err</span>.</p></div></div><div class='para' id='facet.num.get.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-8'>8</a></div><div class='itemdescr'><p >The <span class='texttt'>in</span> iterator is always left pointing one position beyond the last
character successfully matched. If <span class='texttt'>val</span> is set, then <span class='texttt'>err</span> is set to
<span class='texttt'>str.goodbit</span>;
or to
<span class='texttt'>str.eofbit</span>
if, when seeking another character to match, it is found that
<span class='texttt'>(in == end)</span>.
If <span class='texttt'>val</span> is not set, then <span class='texttt'>err</span> is set to
<span class='texttt'>str.failbit</span>;
or to
<span class='texttt'>(str.failbit|str.eofbit)</span>
if the reason for the failure was that
<span class='texttt'>(in == end)</span>.
[&nbsp;<i>Example:</i>
For targets
<span class='texttt'>true</span>:
<span class='texttt'>"a"</span>
and
<span class='texttt'>false</span>:
<span class='texttt'>"abb"</span>,
the input sequence
 <span class='texttt'>"a"</span>
yields
<span class='texttt'>val == true</span>
and
<span class='texttt'>err == str.eofbit</span>;
the input sequence
 <span class='texttt'>"abc"</span>
yields
<span class='texttt'>err = str.failbit</span>,
with <span class='texttt'>in</span> ending at the
<span class='texttt'>'c'</span>
element. For targets
<span class='texttt'>true</span>:
<span class='texttt'>"1"</span>
and
<span class='texttt'>false</span>:
<span class='texttt'>"0"</span>, the input sequence <span class='texttt'>"1"</span> yields
<span class='texttt'>val == true</span>
and
<span class='texttt'>err == str.goodbit</span>.
For empty targets <span class='texttt'>("")</span>, any input sequence yields
<span class='texttt'>err == str.failbit</span>.
<i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='facet.num.get.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.get.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>in</span>.
</p></div></div></div></div><div id='locale.nm.put'><h4 ><a class='secnum' href='#locale.nm.put' style='min-width:118pt'>22.4.2.2</a> Class template <span class='texttt'>num_put</span> <a class='abbr_ref' href='locale.nm.put'>[locale.nm.put]</a></h4><p ><span class='indexparent'><a class='index' id='num_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
  class num_put : public locale::facet {
  public:
    typedef charT            char_type;
    typedef OutputIterator   iter_type;

    explicit num_put(size_t refs = 0);

    iter_type put(iter_type s, ios_base&amp; f, char_type fill, bool v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill, long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill, long long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  unsigned long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  unsigned long long v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  double v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  long double v) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  const void* v) const;

    static locale::id id;

  protected:
    ~num_put();
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             bool v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long long v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             unsigned long) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             double v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             long double v) const;
    virtual iter_type do_put(iter_type, ios_base&amp;, char_type fill,
                             const void* v) const;
  };
}
</pre><div class='para' id='locale.nm.put-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.nm.put-1'>1</a></div><p >The facet
<span class='texttt'>num_put</span>
is used to format numeric values to a character sequence such as an ostream.</p></div><div id='facet.num.put.members'><h4 ><a class='secnum' href='#facet.num.put.members' style='min-width:133pt'>22.4.2.2.1</a> <span class='texttt'>num_put</span> members <a class='abbr_ref' href='facet.num.put.members'>[facet.num.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='num_put,put'></a></span><span class='indexparent'><a class='index' id='put,num_put'></a></span><code class='itemdecl'>
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  bool val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long long val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  double val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  long double val) const;
iter_type put(iter_type out, ios_base&amp; str, char_type fill,
  const void* val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_put(out, str, fill, val)</span>.
</p></div></div></div><div id='facet.num.put.virtuals'><h4 ><a class='secnum' href='#facet.num.put.virtuals' style='min-width:133pt'>22.4.2.2.2</a> <span class='texttt'>num_put</span> virtual functions <a class='abbr_ref' href='facet.num.put.virtuals'>[facet.num.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='num_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,num_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  unsigned long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  long double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
  const void* val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Writes characters to the sequence <span class='texttt'>out</span>,
formatting <span class='texttt'>val</span> as desired.
In the following description,
a local variable initialized with</p><pre class='codeblock'>
locale loc = str.getloc();
</pre></div></div><div class='para' id='facet.num.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-2'>2</a></div><div class='itemdescr'><p >The details of this operation occur in several stages:</p><ul ><li ><p >Stage 1:
Determine a printf conversion specifier <span class='texttt'>spec</span> and
determining the characters that would be printed by
<span class='texttt'>printf</span> (<a href='c.files'>[c.files]</a>)
given this conversion specifier for</p><pre class='codeblock'>
printf(spec, val )
</pre><p >assuming that the current locale is
the <span class='texttt'>"C"</span> locale.
</p></li><li ><p >Stage 2:
Adjust the representation by converting each
<span class='texttt'>char</span>
determined by stage 1 to a
<span class='texttt'>charT</span>
using a conversion and values returned by members of
<span class='texttt'>use_facet&lt; numpunct&lt;charT&gt; &gt;(str.getloc())</span>
</p></li><li ><p >Stage 3:
Determine where padding is required.
</p></li><li ><p >Stage 4:
Insert the sequence into the <span class='texttt'>out</span>.
</p></li></ul></div></div><div class='para' id='facet.num.put.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-3'>3</a></div><div class='itemdescr'><p >Detailed descriptions of each stage follow.</p></div></div><div class='para' id='facet.num.put.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>out</span>.</p></div></div><div class='para' id='facet.num.put.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-5'>5</a></div><div class='itemdescr'><ul ><li ><p >The first action of stage 1 is to determine a conversion specifier.
The tables that describe this determination use the following local variables</p><pre class='codeblock'>
fmtflags flags = str.flags() ;
fmtflags basefield =  (flags &amp; (ios_base::basefield));
fmtflags uppercase =  (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos =    (flags &amp; (ios_base::showpos));
fmtflags showbase =   (flags &amp; (ios_base::showbase));
</pre><p >All tables used in describing stage 1 are ordered.
That is, the first line whose condition is true applies.
A line without a condition is the default behavior when none of the earlier
lines apply.</p><p >For conversion from an integral type other than a character type, the
function determines the integral conversion specifier as indicated in
Table <a href='#tab:localization.integer.conversions.out'>[tab:localization.integer.conversions.out]</a>.</p><div class='numberedTable' id='tab:localization.integer.conversions.out'>Table <a href='#tab:localization.integer.conversions.out'>87</a>  Integer conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent       </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>basefield == ios_base::oct</span>                      </td><td class='center'>   <span class='texttt'>%o</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>(basefield == ios_base::hex) &amp;&amp; !uppercase</span>    </td><td class='center'>   <span class='texttt'>%x</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>(basefield == ios_base::hex)</span>                    </td><td class='center'>   <span class='texttt'>%X</span> </td></tr><tr class='rowsep'><td class='left'> 
for a <span class='texttt'>signed</span> integral type                     </td><td class='center'>   <span class='texttt'>%d</span> </td></tr><tr class='rowsep'><td class='left'> 
for an <span class='texttt'>unsigned</span> integral type                  </td><td class='center'>   <span class='texttt'>%u</span> </td></tr></table></div><p >For conversion from a floating-point type, the function determines
the floating-point conversion specifier as indicated in Table <a href='#tab:localization.fp.conversions.out'>[tab:localization.fp.conversions.out]</a>.</p><div class='numberedTable' id='tab:localization.fp.conversions.out'>Table <a href='#tab:localization.fp.conversions.out'>88</a>  Floating-point conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent                       </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::fixed</span>                       </td><td class='center'>   <span class='texttt'>%f</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::scientific &amp;&amp; !uppercase</span>  </td><td class='center'>   <span class='texttt'>%e</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == ios_base::scientific</span>                  </td><td class='center'>   <span class='texttt'>%E</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == (ios_base::fixed | ios_base::scientific) &amp;&amp; !uppercase</span> </td><td class='center'> <span class='texttt'>%a</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>floatfield == (ios_base::fixed | ios_base::scientific)</span> </td><td class='center'> <span class='texttt'>%A</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>!uppercase</span>                                          </td><td class='center'>   <span class='texttt'>%g</span> </td></tr><tr class='rowsep'><td class='left'> 
<i>otherwise</i>                                          </td><td class='center'>   <span class='texttt'>%G</span> </td></tr></table></div><p >For conversions from an integral or floating-point
type a length modifier is added to the
conversion specifier as indicated in  Table <a href='#tab:localization.length.modifier.out'>[tab:localization.length.modifier.out]</a>.</p><div class='numberedTable' id='tab:localization.length.modifier.out'>Table <a href='#tab:localization.length.modifier.out'>89</a>  Length modifier<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td class='center'>   Length modifier </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>long</span>                </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long long</span>           </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long</span>       </td><td class='center'>   <span class='texttt'>l</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>unsigned long long</span>  </td><td class='center'>   <span class='texttt'>ll</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>long double</span>         </td><td class='center'>   <span class='texttt'>L</span>       </td></tr><tr class='rowsep'><td class='left'> 
<i>otherwise</i>          </td><td class='center'>   <i>none</i>   </td></tr></table></div><p >The conversion specifier has the following optional additional qualifiers
prepended as indicated in Table <a href='#tab:localization.numeric.conversions'>[tab:localization.numeric.conversions]</a>.</p><div class='numberedTable' id='tab:localization.numeric.conversions'>Table <a href='#tab:localization.numeric.conversions'>90</a>  Numeric conversions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type(s)</b></td><td colspan='1' class='center'><b>State</b></td><td class='center'>   <span class='texttt'>stdio</span> equivalent   </td></tr><tr class='capsep'><td class='left'> 
an integral type                </td><td class='left'>   <span class='texttt'>flags &amp; showpos</span>    </td><td class='center'>   <span class='texttt'>+</span>                   </td></tr><tr ><td class='left'>
                                </td><td class='left'>   <span class='texttt'>flags &amp; showbase</span>   </td><td class='center'>   <span class='texttt'>#</span>                  </td></tr><tr class='rowsep'><td class='left'> 
a floating-point type           </td><td class='left'>   <span class='texttt'>flags &amp; showpos</span>    </td><td class='center'>   <span class='texttt'>+</span>                   </td></tr><tr ><td class='left'>
                                </td><td class='left'>   <span class='texttt'>flags &amp; showpoint</span>  </td><td class='center'>   <span class='texttt'>#</span>                  </td></tr></table></div><p >For conversion from a floating-point type,
if <span class='texttt'>floatfield != (ios_base::fixed | ios_base::<span class='discretionary'></span>scientific)</span>,
<span class='texttt'>str.precision()</span>
is specified as precision in the conversion specification.
Otherwise, no precision is specified.
 
For conversion from
<span class='texttt'>void*</span>
the specifier is
<span class='texttt'>%p</span>.
 
The representations at the end of stage 1 consists of the
<span class='texttt'>char</span>'s
that would be printed by a call of
<span class='texttt'>printf(s, val)</span>
where <span class='texttt'>s</span> is the conversion specifier determined above.</p></li><li ><p >Any character <span class='texttt'>c</span> other than a decimal point(.) is converted to a
<span class='texttt'>charT</span>
via
<span class='texttt'>use_facet&lt;ctype&lt;charT&gt; &gt;(loc).widen( c )</span></p><p >A local variable <span class='texttt'>punct</span> is initialized via
</p><pre class='codeblock'>
const numpunct&lt;charT&gt;&amp; punct = use_facet&lt; numpunct&lt;charT&gt; &gt;(str.getloc());
</pre><p >For arithmetic types,
<span class='texttt'>punct.thousands_sep()</span>
characters are inserted into the sequence as determined by the value returned
by
<span class='texttt'>punct.do_grouping()</span>
using the method described in <a href='facet.numpunct.virtuals'>[facet.numpunct.virtuals]</a>
 
Decimal point characters(.) are replaced by
<span class='texttt'>punct.decimal_point()</span></p></li><li ><p >A local variable is initialized as</p><pre class='codeblock'>
fmtflags adjustfield=   (flags &amp; (ios_base::adjustfield));
</pre><p >The location of any padding<a class='footnotenum' href='#footnote-247'>247</a> is determined according to Table <a href='#tab:localization.fill.padding'>[tab:localization.fill.padding]</a>.</p><div class='numberedTable' id='tab:localization.fill.padding'>Table <a href='#tab:localization.fill.padding'>91</a>  Fill padding<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>State</b></td><td colspan='1' class='center'><b>Location</b></td></tr><tr class='capsep'><td class='justify'> 
<span class='texttt'>adjustfield == ios_base::left</span>   </td><td class='left'>   pad after                       </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == ios_base::right</span>  </td><td class='left'>   pad before                      </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == internal</span> and a sign occurs in the representation
                                        </td><td class='left'>   pad after the sign              </td></tr><tr class='rowsep'><td class='justify'> 
<span class='texttt'>adjustfield == internal</span> and representation after stage 1
began with 0x or 0X                     </td><td class='left'>   pad after x or X                </td></tr><tr class='rowsep'><td class='justify'> 
<i>otherwise</i>                      </td><td class='left'>   pad before                      </td></tr></table></div><p >If
<span class='texttt'>str.width()</span>
is nonzero and the number of
<span class='texttt'>charT</span>'s
in the sequence after stage 2 is less than
<span class='texttt'>str.<span class='discretionary'></span>width()</span>,
then enough <span class='texttt'>fill</span> characters are added to the sequence at the position
indicated for padding to bring the length of the sequence to
<span class='texttt'>str.width()</span>.
 
<span class='texttt'>str.width(0)</span>
is called.</p></li><li ><p >The sequence of
<span class='texttt'>charT</span>'s
at the end of stage 3 are output via</p><pre class='codeblock'>
*out++ = c
</pre></li></ul></div></div><p ><span class='indexparent'><a class='index' id='do_put,num_put'></a></span><span class='indexparent'><a class='index' id='num_put,do_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill,
                 bool val) const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.num.put.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.num.put.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
If
<span class='texttt'>(str.flags() &amp; ios_base::boolalpha) == 0</span>
returns
<span class='texttt'>do_put(out, str, fill,<br/>(int)val)</span>,
otherwise obtains a string
<span class='texttt'>s</span>
as if by
</p><pre class='codeblock'>
string_type s =
  val ? use_facet&lt;ctype&lt;charT&gt; &gt;(loc).truename()
    : use_facet&lt;ctype&lt;charT&gt; &gt;(loc).falsename();
</pre><p >and then inserts each character
<span class='texttt'>c</span>
of
<span class='texttt'>s</span>
into
<span class='texttt'>out</span>
via
<span class='texttt'>*out++ = c</span>
and returns
<span class='texttt'>out</span>.
</p></div></div><div class='footnote' id='footnote-246'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-246'>246)</a></div><p >The conversion specification
<span class='texttt'>#o</span>
generates a leading
<span class='texttt'>0</span>
which is
<i>not</i>
a padding character.</p></div></div></div></div><div id='facet.numpunct'><h3 ><a class='secnum' href='#facet.numpunct' style='min-width:103pt'>22.4.3</a> The numeric punctuation facet <a class='abbr_ref' href='facet.numpunct'>[facet.numpunct]</a></h3><div id='locale.numpunct'><h4 ><a class='secnum' href='#locale.numpunct' style='min-width:118pt'>22.4.3.1</a> Class template <span class='texttt'>numpunct</span> <a class='abbr_ref' href='locale.numpunct'>[locale.numpunct]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class numpunct : public locale::facet {
  public:
    typedef charT               char_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit numpunct(size_t refs = 0);

    char_type    decimal_point()   const;
    char_type    thousands_sep()   const;
    string       grouping()        const;
    string_type  truename()        const;
    string_type  falsename()       const;

    static locale::id id;

  protected:
   ~numpunct();                 <span class='comment'>// virtual
</span>    virtual char_type    do_decimal_point() const;
    virtual char_type    do_thousands_sep() const;
    virtual string       do_grouping()      const;
    virtual string_type  do_truename()      const;      <span class='comment'>// for <span class='texttt'>bool</span>
</span>    virtual string_type  do_falsename()     const;      <span class='comment'>// for <span class='texttt'>bool</span>
</span>  };
}
</pre><div class='para' id='locale.numpunct-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.numpunct-1'>1</a></div><p ><span class='texttt'>numpunct&lt;&gt;</span>
specifies numeric punctuation.
The specializations required in Table <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>numpunct&lt;<span class='discretionary'></span>wchar_t&gt;</span>
and
<span class='texttt'>numpunct&lt;char&gt;</span>,
provide classic
<span class='texttt'>"C"</span>
numeric formats,
i.e., they contain information equivalent to that contained in the
<span class='texttt'>"C"</span>
locale or their wide character counterparts as if obtained by
a call to
<span class='texttt'>widen</span>.</p></div><div class='para' id='locale.numpunct-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.numpunct-2'>2</a></div><p >The syntax for number formats is as follows, where
<span class='texttt'>digit</span>
represents the radix set specified by the
<span class='texttt'>fmtflags</span>
argument value, and
<span class='texttt'>thousands-sep</span>
and
<span class='texttt'>decimal-point</span>
are the results of corresponding
<span class='texttt'>numpunct&lt;charT&gt;</span>
members.
Integer values have the format:</p><pre class='codeblock'>
integer   ::= [sign] units
sign      ::= plusminus
plusminus ::= '+' | '-'
units     ::= digits [thousands-sep units]
digits    ::= digit [digits]
</pre><p >and floating-point values have:</p><pre class='codeblock'>
floatval ::= [sign] units [decimal-point [digits]] [e [sign] digits] |
             [sign]        decimal-point  digits   [e [sign] digits]
e        ::= 'e' | 'E'
</pre><p >where the number of digits between
<span class='texttt'>thousands-sep</span>s
is as specified by
<span class='texttt'>do_grouping()</span>.
For parsing, if the
<span class='texttt'>digits</span>
portion contains no thousands-separators, no grouping constraint
is applied.</p></div><div id='facet.numpunct.members'><h4 ><a class='secnum' href='#facet.numpunct.members' style='min-width:133pt'>22.4.3.1.1</a> <span class='texttt'>numpunct</span> members <a class='abbr_ref' href='facet.numpunct.members'>[facet.numpunct.members]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct,decimal_point'></a></span><span class='indexparent'><a class='index' id='decimal_point,numpunct'></a></span><code class='itemdecl'>
char_type decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_decimal_point()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,thousands_sep'></a></span><span class='indexparent'><a class='index' id='thousands_sep,numpunct'></a></span><code class='itemdecl'>
char_type thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_thousands_sep()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,grouping'></a></span><span class='indexparent'><a class='index' id='grouping,numpunct'></a></span><code class='itemdecl'>
string grouping()  const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_grouping()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,truename'></a></span><span class='indexparent'><a class='index' id='truename,numpunct'></a></span><span class='indexparent'><a class='index' id='numpunct,falsename'></a></span><span class='indexparent'><a class='index' id='falsename,numpunct'></a></span><code class='itemdecl'>
string_type truename()  const;
string_type falsename() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.members-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_truename()</span>
or
<span class='texttt'>do_falsename()</span>,
respectively.
</p></div></div></div><div id='facet.numpunct.virtuals'><h4 ><a class='secnum' href='#facet.numpunct.virtuals' style='min-width:133pt'>22.4.3.1.2</a> <span class='texttt'>numpunct</span> virtual functions <a class='abbr_ref' href='facet.numpunct.virtuals'>[facet.numpunct.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct,do_decimal_point'></a></span><span class='indexparent'><a class='index' id='do_decimal_point,numpunct'></a></span><code class='itemdecl'>
char_type do_decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A character for use as the decimal radix separator.
The required specializations return <span class='texttt'>'.'</span> or <span class='texttt'>L'.'</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_thousands_sep'></a></span><span class='indexparent'><a class='index' id='do_thousands_sep,numpunct'></a></span><code class='itemdecl'>
char_type do_thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A character for use as the digit group separator.
The required specializations return <span class='texttt'>','</span> or <span class='texttt'>L','</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_grouping'></a></span><span class='indexparent'><a class='index' id='do_grouping,numpunct'></a></span><code class='itemdecl'>
string do_grouping() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A basic_string&lt;char&gt; <span class='texttt'>vec</span> used as a vector of integer values,
in which each element
<span class='texttt'>vec[i]</span>
represents the number of digits<a class='footnotenum' href='#footnote-248'>248</a>
in the group at position <span class='texttt'>i</span>, starting with position 0 as the
rightmost group.
If
<span class='texttt'>vec.size() &lt;= i</span>,
the number is the same as group
<span class='texttt'>(i-1)</span>;
if
<span class='texttt'>(i&lt;0 || vec[i]&lt;=0 || vec[i]==CHAR_MAX)</span>,
the size of the digit group is unlimited.</p></div></div><div class='para' id='facet.numpunct.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-4'>4</a></div><div class='itemdescr'><p >The required specializations return the empty string, indicating
no grouping.
</p></div></div><p ><span class='indexparent'><a class='index' id='numpunct,do_truename'></a></span><span class='indexparent'><a class='index' id='do_truename,numpunct'></a></span><span class='indexparent'><a class='index' id='numpunct,do_falsename'></a></span><span class='indexparent'><a class='index' id='do_falsename,numpunct'></a></span><code class='itemdecl'>
string_type do_truename()  const;
string_type do_falsename() const;
</code></p><div class='itemdescr'></div><div class='para' id='facet.numpunct.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A string representing the name of the boolean value
<span class='texttt'>true</span>
or
<span class='texttt'>false</span>,
respectively.</p></div></div><div class='para' id='facet.numpunct.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#facet.numpunct.virtuals-6'>6</a></div><div class='itemdescr'><p >In the base class implementation these names are
<span class='texttt'>"true"</span> and <span class='texttt'>"false"</span>, or <span class='texttt'>L"true"</span> and <span class='texttt'>L"false"</span>.
</p></div></div><div class='footnote' id='footnote-247'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-247'>247)</a></div><p >Thus, the string
<span class='texttt'>"\003"</span> specifies groups of 3 digits each, and
<span class='texttt'>"3"</span> probably indicates groups of 51 (!) digits each,
because 51 is the ASCII value of <span class='texttt'>"3"</span>.</p></div></div></div><div id='locale.numpunct.byname'><h4 ><a class='secnum' href='#locale.numpunct.byname' style='min-width:118pt'>22.4.3.2</a> Class template <span class='texttt'>numpunct_byname</span> <a class='abbr_ref' href='locale.numpunct.byname'>[locale.numpunct.byname]</a></h4><p ><span class='indexparent'><a class='index' id='numpunct_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class numpunct_byname : public numpunct&lt;charT&gt; {
  <span class='comment'>// this class is specialized for <span class='texttt'>char</span> and <span class='texttt'>wchar_t</span>.
</span>  public:
    typedef charT                char_type;
    typedef basic_string&lt;charT&gt;  string_type;
    explicit numpunct_byname(const char*, size_t refs = 0);
    explicit numpunct_byname(const string&amp;, size_t refs = 0);
  protected:
   ~numpunct_byname();
  };
}
</pre></div></div><div id='category.collate'><h3 ><a class='secnum' href='#category.collate' style='min-width:103pt'>22.4.4</a> The collate category <a class='abbr_ref' href='category.collate'>[category.collate]</a></h3><div id='locale.collate'><h4 ><a class='secnum' href='#locale.collate' style='min-width:118pt'>22.4.4.1</a> Class template <span class='texttt'>collate</span> <a class='abbr_ref' href='locale.collate'>[locale.collate]</a></h4><p ><span class='indexparent'><a class='index' id='collate'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class collate : public locale::facet {
  public:
    typedef charT               char_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit collate(size_t refs = 0);

    int compare(const charT* low1, const charT* high1,
                const charT* low2, const charT* high2) const;
    string_type transform(const charT* low, const charT* high) const;
    long hash(const charT* low, const charT* high) const;

    static locale::id id;

  protected:
    ~collate();
    virtual int do_compare(const charT* low1, const charT* high1,
                           const charT* low2, const charT* high2) const;
    virtual string_type do_transform(const charT* low, const charT* high) const;
    virtual long do_hash (const charT* low, const charT* high) const;
  };
}
</pre><div class='para' id='locale.collate-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate-1'>1</a></div><p >The class
<span class='texttt'>collate&lt;charT&gt;</span>
provides features for use in the
collation (comparison) and hashing of strings.
A locale member function template,
<span class='texttt'>operator()</span>,
uses the collate facet to allow a locale to act directly as the predicate
argument for standard algorithms (Clause <a href='algorithms'>[algorithms]</a>) and containers operating on strings.
The specializations required in Table <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>collate&lt;char&gt;</span>
and
<span class='texttt'>collate&lt;wchar_t&gt;</span>,
apply lexicographic ordering (<a href='alg.lex.comparison'>[alg.lex.comparison]</a>).</p></div><div class='para' id='locale.collate-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate-2'>2</a></div><p >Each function compares a string of characters
<span class='texttt'>*p</span>
in the range
<span class='texttt'>[<span class='discretionary'></span>low,<span class='discretionary'></span>high<span class='discretionary'></span>)</span>.</p></div><div id='locale.collate.members'><h4 ><a class='secnum' href='#locale.collate.members' style='min-width:133pt'>22.4.4.1.1</a> <span class='texttt'>collate</span> members <a class='abbr_ref' href='locale.collate.members'>[locale.collate.members]</a></h4><p ><span class='indexparent'><a class='index' id='collate,compare'></a></span><span class='indexparent'><a class='index' id='compare,collate'></a></span><code class='itemdecl'>
int compare(const charT* low1, const charT* high1,
            const charT* low2, const charT* high2) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_compare(low1, high1, low2, high2)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,transform'></a></span><span class='indexparent'><a class='index' id='transform,collate'></a></span><code class='itemdecl'>
string_type transform(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_transform(low, high)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,hash'></a></span><span class='indexparent'><a class='index' id='hash,collate'></a></span><code class='itemdecl'>
long hash(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_hash(low, high)</span>
</p></div></div></div><div id='locale.collate.virtuals'><h4 ><a class='secnum' href='#locale.collate.virtuals' style='min-width:133pt'>22.4.4.1.2</a> <span class='texttt'>collate</span> virtual functions <a class='abbr_ref' href='locale.collate.virtuals'>[locale.collate.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='collate,do_compare'></a></span><span class='indexparent'><a class='index' id='do_compare,collate'></a></span><code class='itemdecl'>
int do_compare(const charT* low1, const charT* high1,
               const charT* low2, const charT* high2) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>1</span>
if the first string is greater than the second,
<span class='texttt'>-1</span>
if less, zero otherwise.
The specializations required in Table <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>collate&lt;char&gt;</span>
and
<span class='texttt'>collate&lt;wchar_t&gt;</span>,
implement
a lexicographical comparison (<a href='alg.lex.comparison'>[alg.lex.comparison]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,do_transform'></a></span><span class='indexparent'><a class='index' id='do_transform,collate'></a></span><code class='itemdecl'>
string_type do_transform(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
A
<span class='texttt'>basic_string&lt;charT&gt;</span>
value that, compared lexicographically with the result of calling
<span class='texttt'>transform()</span>
on another string, yields the same result as calling
<span class='texttt'>do_compare()</span>
on the same two strings.<a class='footnotenum' href='#footnote-249'>249</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='collate,do_hash'></a></span><span class='indexparent'><a class='index' id='do_hash,collate'></a></span><code class='itemdecl'>
long do_hash(const charT* low, const charT* high) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.collate.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.collate.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An integer value equal to the result of calling
<span class='texttt'>hash()</span>
on any other string for which
<span class='texttt'>do_compare()</span>
returns 0 (equal) when passed the two strings.
[&nbsp;<i>Note:</i>
The probability that the result equals that for another string which does
not compare equal should be very small, approaching
<span class='texttt'>(1.0/numeric_limits&lt;unsigned long&gt;::max())</span>.
<i>&nbsp;&nbsp;end note</i>&nbsp;]
</p></div></div><div class='footnote' id='footnote-248'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-248'>248)</a></div><p >This function is useful when one string is
being compared to many other strings.</p></div></div></div><div id='locale.collate.byname'><h4 ><a class='secnum' href='#locale.collate.byname' style='min-width:118pt'>22.4.4.2</a> Class template <span class='texttt'>collate_byname</span> <a class='abbr_ref' href='locale.collate.byname'>[locale.collate.byname]</a></h4><p ><span class='indexparent'><a class='index' id='collate_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class collate_byname : public collate&lt;charT&gt; {
  public:
    typedef basic_string&lt;charT&gt; string_type;
    explicit collate_byname(const char*, size_t refs = 0);
    explicit collate_byname(const string&amp;, size_t refs = 0);
  protected:
    ~collate_byname();
  };
}
</pre></div></div><div id='category.time'><h3 ><a class='secnum' href='#category.time' style='min-width:103pt'>22.4.5</a> The time category <a class='abbr_ref' href='category.time'>[category.time]</a></h3><div class='para' id='category.time-1'><div class='marginalizedparent'><a class='marginalized' href='#category.time-1'>1</a></div><p >Templates
<span class='texttt'>time_get&lt;charT,InputIterator&gt;</span>
and
<span class='texttt'>time_put&lt;charT,OutputIterator&gt;</span>
provide date and time formatting and parsing.
All specifications of member functions for
<span class='texttt'>time_put</span>
and
<span class='texttt'>time_get</span>
in the subclauses of <a href='category.time'>[category.time]</a> only apply to the
specializations required in Tables <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='locale.category#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>).
Their members use their
<span class='texttt'>ios_base&amp;</span>,
<span class='texttt'>ios_base::iostate&amp;</span>,
and
<span class='texttt'>fill</span>
arguments as described in (<a href='locale.categories'>[locale.categories]</a>), and the
<span class='texttt'>ctype&lt;&gt;</span>
facet, to determine formatting details.</p></div><div id='locale.time.get'><h4 ><a class='secnum' href='#locale.time.get' style='min-width:118pt'>22.4.5.1</a> Class template <span class='texttt'>time_get</span> <a class='abbr_ref' href='locale.time.get'>[locale.time.get]</a></h4><p ><span class='indexparent'><a class='index' id='time_get'></a></span></p><pre class='codeblock'>
namespace std {
  class time_base {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
  class time_get : public locale::facet, public time_base {
  public:
    typedef charT            char_type;
    typedef InputIterator    iter_type;

    explicit time_get(size_t refs = 0);

    dateorder date_order()  const { return do_date_order(); }
    iter_type get_time(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t)  const;
    iter_type get_date(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t)  const;
    iter_type get_weekday(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get_monthname(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get_year(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm* t) const;
    iter_type get(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm *t, char format, char modifier = 0) const;
    iter_type get(iter_type s, iter_type end, ios_base&amp; f,
                       ios_base::iostate&amp; err, tm *t, const char_type *fmt,
                       const char_type *fmtend) const;

    static locale::id id;

  protected:
    ~time_get();
    virtual dateorder do_date_order()  const;
    virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&amp;,
                                     ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp;,
                                       ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&amp;,
                                  ios_base::iostate&amp; err, tm* t) const;
    virtual iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
                             ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
  };
}
</pre><div class='para' id='locale.time.get-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get-1'>1</a></div><p ><span class='texttt'>time_get</span>
is used to
parse a character sequence, extracting components of a time or date
into a
<span class='texttt'>struct tm</span>
record.
Each
<span class='texttt'>get</span>
member parses a format as produced by a corresponding format specifier to
<span class='texttt'>time_put&lt;&gt;::put</span>.
If the sequence being parsed matches the correct format, the corresponding
members of the
<span class='texttt'>struct tm</span>
argument are set to the values used to produce the sequence; otherwise
either an error is reported or unspecified values are assigned.<a class='footnotenum' href='#footnote-250'>250</a></p></div><div class='para' id='locale.time.get-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get-2'>2</a></div><p >If the end iterator is reached during parsing by any of the
<span class='texttt'>get()</span>
member functions, the member sets
<span class='texttt'>ios_base::eofbit</span>
in <span class='texttt'>err</span>.</p></div><div class='footnote' id='footnote-249'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-249'>249)</a></div><p >In
other words, user confirmation is required for reliable parsing of
user-entered dates and times, but machine-generated formats can be
parsed reliably.
This allows parsers to be aggressive about
interpreting user variations on standard formats.</p></div><div id='locale.time.get.members'><h4 ><a class='secnum' href='#locale.time.get.members' style='min-width:133pt'>22.4.5.1.1</a> <span class='texttt'>time_get</span> members <a class='abbr_ref' href='locale.time.get.members'>[locale.time.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='time_get,date_order'></a></span><span class='indexparent'><a class='index' id='date_order,time_get'></a></span><code class='itemdecl'>
dateorder date_order() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_date_order()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_time'></a></span><span class='indexparent'><a class='index' id='get_time,time_get'></a></span><code class='itemdecl'>
iter_type get_time(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_time(s, end, str, err, t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_date'></a></span><span class='indexparent'><a class='index' id='get_date,time_get'></a></span><code class='itemdecl'>
iter_type get_date(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_date(s, end, str, err, t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_weekday'></a></span><span class='indexparent'><a class='index' id='get_weekday,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get_monthname'></a></span><span class='indexparent'><a class='index' id='get_monthname,time_get'></a></span><code class='itemdecl'>
iter_type get_weekday(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base&amp; str,
                        ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_weekday(s, end, str, err, t)</span>
or
<span class='texttt'>do_get_monthname(s, end, str, err, t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,get_year'></a></span><span class='indexparent'><a class='index' id='get_year,time_get'></a></span><code class='itemdecl'>
iter_type get_year(iter_type s, iter_type end, ios_base&amp; str,
                   ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get_year(s, end, str, err, t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm *t, char format, char modifier = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>do_get(s, end, f, err, t, format, modifier)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm *t, const char_type *fmt, const char_type *fmtend) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.members-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>[<span class='discretionary'></span>fmt,<span class='discretionary'></span>fmtend<span class='discretionary'></span>)</span> shall be a valid range.</p></div></div><div class='para' id='locale.time.get.members-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> The function starts by evaluating
<span class='texttt'>err = ios_base::goodbit</span>. It then enters a loop, reading zero or more
characters from <span class='texttt'>s</span> at each iteration. Unless otherwise specified below,
the loop terminates when the first of the following conditions holds:</p><ul ><li ><p >The expression <span class='texttt'>fmt == fmtend</span> evaluates to true.</p></li><li ><p >The expression <span class='texttt'>err == ios_base::goodbit</span> evaluates to false.</p></li><li ><p >The expression <span class='texttt'>s == end</span> evaluates to true,
in which case the function
evaluates <span class='texttt'>err = ios_base::eofbit | ios_base::failbit</span>.</p></li><li ><p >The next element of <span class='texttt'>fmt</span> is equal to
<span class='texttt'>'%'</span>, optionally followed by a
modifier character, followed by a conversion specifier character,
<span class='texttt'>format</span>, together forming a conversion specification valid for the
ISO/IEC 9945 function <span class='texttt'>strptime</span>. If the number of elements in the range
<span class='texttt'>[<span class='discretionary'></span>fmt,<span class='discretionary'></span>fmtend<span class='discretionary'></span>)</span> is not sufficient to unambiguously determine whether the
conversion specification is complete and valid, the function evaluates
<span class='texttt'>err = ios_base::failbit</span>. Otherwise, the function evaluates
<span class='texttt'>s = do_get(s, end, f, err, t, format, modifier)</span>, where the value
of <span class='texttt'>modifier</span> is <span class='texttt'>'\0'</span>
when the optional modifier is absent from the conversion specification.
If <span class='texttt'>err == ios_base::goodbit</span> holds after the evaluation of the
expression, the function increments <span class='texttt'>fmt</span> to point just past the end of
the conversion specification and continues looping.</p></li><li ><p >The expression <span class='texttt'>isspace(*fmt, f.getloc())</span> evaluates to true,
in which case
the function first increments <span class='texttt'>fmt</span> until
<span class='texttt'>fmt == fmtend || !isspace(*fmt, f.getloc())</span> evaluates to true,
then advances <span class='texttt'>s</span> until
<span class='texttt'>s == end || !isspace(*s, f.getloc())</span> is true, and finally resumes looping.</p></li><li ><p >The next character read from <span class='texttt'>s</span> matches the element
pointed to by <span class='texttt'>fmt</span> in
a case-insensitive comparison, in which case the function evaluates
<span class='texttt'>++fmt, ++s</span> and continues looping. Otherwise, the function evaluates
<span class='texttt'>err = ios_base::failbit</span>.
</p></li></ul></div></div><div class='para' id='locale.time.get.members-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The function uses the <span class='texttt'>ctype&lt;charT&gt;</span>
facet installed in <span class='texttt'>f</span>'s locale
to determine valid whitespace characters. It is unspecified by what
means the function performs case-insensitive comparison or whether
multi-character sequences are considered while doing so.</p></div></div><div class='para' id='locale.time.get.members-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>s</span>
</p></div></div></div><div id='locale.time.get.virtuals'><h4 ><a class='secnum' href='#locale.time.get.virtuals' style='min-width:133pt'>22.4.5.1.2</a> <span class='texttt'>time_get</span> virtual functions <a class='abbr_ref' href='locale.time.get.virtuals'>[locale.time.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='time_get,do_date_order'></a></span><span class='indexparent'><a class='index' id='do_date_order,time_get'></a></span><code class='itemdecl'>
dateorder do_date_order() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
An enumeration value indicating the preferred order of components for
those date formats that are composed of day, month, and year.<a class='footnotenum' href='#footnote-251'>251</a>
Returns
<span class='texttt'>no_order</span>
if the date format specified by
<span class='texttt'>'x'</span>
contains other variable components (e.g., Julian day, week number, week day).
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_time'></a></span><span class='indexparent'><a class='index' id='do_get_time,time_get'></a></span><code class='itemdecl'>
iter_type do_get_time(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted those
<span class='texttt'>struct tm</span>
members, and remaining format characters, used by
<span class='texttt'>time_put&lt;&gt;::put</span>
to produce the format specified by
<span class='texttt'>"%H:%M:%S"</span>,
or until it encounters an error or end of sequence.</p></div></div><div class='para' id='locale.time.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as possibly part of a valid time.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_date'></a></span><span class='indexparent'><a class='index' id='do_get_date,time_get'></a></span><code class='itemdecl'>
iter_type do_get_date(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted those
<span class='texttt'>struct tm</span>
members and remaining format characters used by
<span class='texttt'>time_put&lt;&gt;::put</span>
to produce one of the following formats,
or until it encounters an error. The format depends on the value returned
by <span class='texttt'>date_order()</span> as shown in
Table <a href='#tab:lib.locale.time.get.virtuals.dogetdate'>[tab:lib.locale.time.get.virtuals.dogetdate]</a>.</p><div class='numberedTable' id='tab:lib.locale.time.get.virtuals.dogetdate'>Table <a href='#tab:lib.locale.time.get.virtuals.dogetdate'>92</a>  <span class='texttt'>do_get_date</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><span class='texttt'>date_order()</span></b></td><td colspan='1' class='center'><b>Format</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>no_order</span>  </td><td class='left'> <span class='texttt'>"%m%d%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>dmy</span>       </td><td class='left'> <span class='texttt'>"%d%m%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>mdy</span>       </td><td class='left'> <span class='texttt'>"%m%d%y"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ymd</span>       </td><td class='left'> <span class='texttt'>"%y%m%d"</span> </td></tr><tr ><td class='left'>
<span class='texttt'>ydm</span>       </td><td class='left'> <span class='texttt'>"%y%d%m"</span> </td></tr></table></div></div></div><div class='para' id='locale.time.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-5'>5</a></div><div class='itemdescr'><p >An implementation may also accept additional <span class='indexparent'><a class='index' id='additional_formats_for_time_get::do_get_date'></a></span>implementation-defined formats.</p></div></div><div class='para' id='locale.time.get.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as possibly part of a valid date.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_weekday'></a></span><span class='indexparent'><a class='index' id='do_get_weekday,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,do_get_monthname'></a></span><span class='indexparent'><a class='index' id='do_get_monthname,time_get'></a></span><code class='itemdecl'>
iter_type do_get_weekday(iter_type s, iter_type end, ios_base&amp; str,
                         ios_base::iostate&amp; err, tm* t) const;
iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp; str,
                           ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted the (perhaps abbreviated) name of a weekday or month.
If it finds an abbreviation that is followed by characters that could
match a full name, it continues reading until it matches the full name or
fails.
It sets the appropriate
<span class='texttt'>struct tm</span>
member accordingly.</p></div></div><div class='para' id='locale.time.get.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid name.
</p></div></div><p ><span class='indexparent'><a class='index' id='time_get,do_get_year'></a></span><span class='indexparent'><a class='index' id='do_get_year,time_get'></a></span><code class='itemdecl'>
iter_type do_get_year(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters starting at <span class='texttt'>s</span>
until it has extracted an unambiguous year identifier.
It is
<span class='indexparent'><a class='index' id='whether_time_get::do_get_year_accepts_two-digit_year_numbers'></a></span>implementation-defined whether
two-digit year numbers are accepted,
and (if so) what century they are assumed to lie in.
Sets the
<span class='texttt'>t-&gt;tm_year</span>
member accordingly.</p></div></div><div class='para' id='locale.time.get.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid year identifier.
</p></div></div><p ><span class='indexparent'><a class='index' id='do_get,time_get'></a></span><span class='indexparent'><a class='index' id='time_get,do_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
    ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.get.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>t</span> shall be dereferenceable.</p></div></div><div class='para' id='locale.time.get.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> The function starts by evaluating
<span class='texttt'>err = ios_base::goodbit</span>. It
then reads characters starting at <span class='texttt'>s</span> until it encounters an error, or
until it has extracted and assigned those <span class='texttt'>struct tm</span> members, and any
remaining format characters, corresponding to a conversion directive
appropriate for the ISO/IEC 9945 function <span class='texttt'>strptime</span>, formed by
concatenating <span class='texttt'>'%'</span>, the <span class='texttt'>modifier</span> character,
when non-NUL, and the <span class='texttt'>format</span>
character. When the concatenation fails to yield a complete valid
directive the function leaves the object pointed to by <span class='texttt'>t</span> unchanged and
evaluates <span class='texttt'>err |= ios_base::failbit</span>. When <span class='texttt'>s == end</span>
evaluates to true after reading a character the function evaluates
<span class='texttt'>err |= ios_base::eofbit</span>.</p></div></div><div class='para' id='locale.time.get.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-13'>13</a></div><div class='itemdescr'><p >For complex conversion directives such as <span class='texttt'>%c</span>,
<span class='texttt'>%x</span>, or <span class='texttt'>%X</span>, or directives
that involve the optional modifiers <span class='texttt'>E</span> or <span class='texttt'>O</span>,
when the function is unable
to unambiguously determine some or all <span class='texttt'>struct tm</span> members from the input
sequence <span class='texttt'>[<span class='discretionary'></span>s,<span class='discretionary'></span>end<span class='discretionary'></span>)</span>, it evaluates <span class='texttt'>err |= ios_base::eofbit</span>.
In such cases the values of those <span class='texttt'>struct tm</span> members are unspecified
and may be outside their valid range.</p></div></div><div class='para' id='locale.time.get.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Remark:</i> It is unspecified whether multiple calls to
<span class='texttt'>do_get()</span> with the
address of the same <span class='texttt'>struct tm</span> object will update the current contents of
the object or simply overwrite its members. Portable programs must zero
out the object before invoking the function.</p></div></div><div class='para' id='locale.time.get.virtuals-15'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.get.virtuals-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator pointing immediately beyond the last character
recognized as possibly part of a valid input sequence for the given
<span class='texttt'>format</span> and <span class='texttt'>modifier</span>.
</p></div></div><div class='footnote' id='footnote-250'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-250'>250)</a></div><p >This
function is intended as a convenience only, for common
formats, and may return
<span class='texttt'>no_order</span>
in valid locales.</p></div></div></div><div id='locale.time.get.byname'><h4 ><a class='secnum' href='#locale.time.get.byname' style='min-width:118pt'>22.4.5.2</a> Class template <span class='texttt'>time_get_byname</span> <a class='abbr_ref' href='locale.time.get.byname'>[locale.time.get.byname]</a></h4><p ><span class='indexparent'><a class='index' id='time_get_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
  class time_get_byname : public time_get&lt;charT, InputIterator&gt; {
  public:
    typedef time_base::dateorder dateorder;
    typedef InputIterator        iter_type;

    explicit time_get_byname(const char*, size_t refs = 0);
    explicit time_get_byname(const string&amp;, size_t refs = 0);
  protected:
    ~time_get_byname();
  };
}
</pre></div><div id='locale.time.put'><h4 ><a class='secnum' href='#locale.time.put' style='min-width:118pt'>22.4.5.3</a> Class template <span class='texttt'>time_put</span> <a class='abbr_ref' href='locale.time.put'>[locale.time.put]</a></h4><p ><span class='indexparent'><a class='index' id='time_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
  class time_put : public locale::facet {
  public:
    typedef charT            char_type;
    typedef OutputIterator   iter_type;

    explicit time_put(size_t refs = 0);

    <span class='comment'>// the following is implemented in terms of other member functions.
</span>    iter_type put(iter_type s, ios_base&amp; f, char_type fill, const tm* tmb,
                  const charT* pattern, const charT* pat_end) const;
    iter_type put(iter_type s, ios_base&amp; f, char_type fill,
                  const tm* tmb, char format, char modifier = 0) const;

    static locale::id id;

  protected:
    ~time_put();
    virtual iter_type do_put(iter_type s, ios_base&amp;, char_type, const tm* t,
                             char format, char modifier) const;
  };
}
</pre><div id='locale.time.put.members'><h4 ><a class='secnum' href='#locale.time.put.members' style='min-width:133pt'>22.4.5.3.1</a> <span class='texttt'>time_put</span> members <a class='abbr_ref' href='locale.time.put.members'>[locale.time.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='time_put,put'></a></span><span class='indexparent'><a class='index' id='put,time_put'></a></span><code class='itemdecl'>
iter_type put(iter_type s, ios_base&amp; str, char_type fill, const tm* t,
              const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base&amp; str, char_type fill, const tm* t,
              char format, char modifier = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first form steps through the sequence from
<span class='texttt'>pattern</span>
to
<span class='texttt'>pat_end</span>,
identifying characters that are part of a format sequence.
Each character that is not part of a format sequence is written to
<span class='texttt'>s</span>
immediately, and each format sequence, as it is identified, results in
a call to
<span class='texttt'>do_put</span>;
thus, format elements and other characters are interleaved in the output
in the order in which they appear in the pattern.
Format sequences are identified by converting each character
<span class='texttt'>c</span>
to a
<span class='texttt'>char</span>
value as if by
<span class='texttt'>ct.narrow(c,0)</span>,
where
<span class='texttt'>ct</span>
is a reference to
<span class='texttt'>ctype&lt;charT&gt;</span>
obtained from
<span class='texttt'>str.getloc()</span>.
The first character of each sequence is equal to
<span class='texttt'>'%'</span>,
followed by an optional modifier character
<span class='texttt'>mod</span><a class='footnotenum' href='#footnote-252'>252</a> and a format specifier character
<span class='texttt'>spec</span>
as defined for the function
<span class='texttt'>strftime</span>.
If no modifier character is present,
<span class='texttt'>mod</span>
is zero.
For each valid format sequence identified, calls
<span class='texttt'>do_put(s, str, fill, t, spec, mod)</span>.</p></div></div><div class='para' id='locale.time.put.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-2'>2</a></div><div class='itemdescr'><p >The second form calls
<span class='texttt'>do_put(s, str, fill, t, format, modifier)</span>.</p></div></div><div class='para' id='locale.time.put.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
The <span class='texttt'>fill</span> argument may be used in the implementation-defined
formats or by derivations. A space character is a reasonable
default for this argument.
<i>&nbsp;&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.time.put.members-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
</p></div></div><div class='footnote' id='footnote-251'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-251'>251)</a></div><p >Although the C programming language defines no modifiers,
most vendors do.</p></div></div><div id='locale.time.put.virtuals'><h4 ><a class='secnum' href='#locale.time.put.virtuals' style='min-width:133pt'>22.4.5.3.2</a> <span class='texttt'>time_put</span> virtual functions <a class='abbr_ref' href='locale.time.put.virtuals'>[locale.time.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='time_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,time_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type s, ios_base&amp;, char_type fill, const tm* t,
                 char format, char modifier) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.time.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Formats the contents of the parameter <span class='texttt'>t</span>
into characters placed on the output sequence <span class='texttt'>s</span>.
Formatting is controlled by the parameters <span class='texttt'>format</span> and <span class='texttt'>modifier</span>,
interpreted identically as the format specifiers in the string
argument to the standard library function
<span class='indexparent'><a class='index' id='strftime'></a></span><span class='texttt'>strftime()</span><a class='footnotenum' href='#footnote-253'>253</a>,
except that the sequence of characters produced for those specifiers
that are described as depending on the C locale are instead <span class='indexparent'><a class='index' id='formatted_character_sequence_generated_by_time_put::do_put_in_C_locale'></a></span>implementation-defined.<a class='footnotenum' href='#footnote-254'>254</a></p></div></div><div class='para' id='locale.time.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.time.put.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
[&nbsp;<i>Note:</i>
The <span class='texttt'>fill</span> argument may be used in the implementation-defined
formats or by derivations. A space character is a reasonable
default for this argument.
<i>&nbsp;&nbsp;end note</i>&nbsp;]
</p></div></div><div class='footnote' id='footnote-252'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-252'>252)</a></div><p >Interpretation of the <span class='texttt'>modifier</span>
argument is implementation-defined, but should follow POSIX
conventions.</p></div><div class='footnote' id='footnote-253'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-253'>253)</a></div><p >Implementations are encouraged to refer to other standards
such as POSIX
for these definitions.</p></div></div></div><div id='locale.time.put.byname'><h4 ><a class='secnum' href='#locale.time.put.byname' style='min-width:118pt'>22.4.5.4</a> Class template <span class='texttt'>time_put_byname</span> <a class='abbr_ref' href='locale.time.put.byname'>[locale.time.put.byname]</a></h4><p ><span class='indexparent'><a class='index' id='time_put_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
  class time_put_byname : public time_put&lt;charT, OutputIterator&gt;
  {
  public:
    typedef charT          char_type;
    typedef OutputIterator iter_type;

    explicit time_put_byname(const char*, size_t refs = 0);
    explicit time_put_byname(const string&amp;, size_t refs = 0);
  protected:
    ~time_put_byname();
  };
}
</pre></div></div><div id='category.monetary'><h3 ><a class='secnum' href='#category.monetary' style='min-width:103pt'>22.4.6</a> The monetary category <a class='abbr_ref' href='category.monetary'>[category.monetary]</a></h3><div class='para' id='category.monetary-1'><div class='marginalizedparent'><a class='marginalized' href='#category.monetary-1'>1</a></div><p >These templates handle monetary formats.
A template parameter indicates whether
local or international monetary formats are to be used.</p></div><div class='para' id='category.monetary-2'><div class='marginalizedparent'><a class='marginalized' href='#category.monetary-2'>2</a></div><p >All specifications of member functions for
<span class='texttt'>money_put</span>
and
<span class='texttt'>money_get</span>
in the subclauses of <a href='category.monetary'>[category.monetary]</a> only apply to the
specializations required in Tables <a href='locale.category#tab:localization.category.facets'>[tab:localization.category.facets]</a>
and <a href='locale.category#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>).
Their members use their
<span class='texttt'>ios_base&amp;</span>,
<span class='texttt'>ios_base&nbsp;::&nbsp;iostate&amp;</span>,
and
<span class='texttt'>fill</span>
arguments as described in (<a href='locale.categories'>[locale.categories]</a>), and the
<span class='texttt'>moneypunct&lt;&gt;</span>
and
<span class='texttt'>ctype&lt;&gt;</span>
facets, to determine formatting details.</p></div><div id='locale.money.get'><h4 ><a class='secnum' href='#locale.money.get' style='min-width:118pt'>22.4.6.1</a> Class template <span class='texttt'>money_get</span> <a class='abbr_ref' href='locale.money.get'>[locale.money.get]</a></h4><p ><span class='indexparent'><a class='index' id='money_get'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT,
    class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
  class money_get : public locale::facet {
  public:
    typedef charT               char_type;
    typedef InputIterator       iter_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit money_get(size_t refs = 0);

    iter_type get(iter_type s, iter_type end, bool intl,
                  ios_base&amp; f, ios_base::iostate&amp; err,
                  long double&amp; units) const;
    iter_type get(iter_type s, iter_type end, bool intl,
                  ios_base&amp; f, ios_base::iostate&amp; err,
                  string_type&amp; digits) const;

    static locale::id id;

  protected:
    ~money_get();
    virtual iter_type do_get(iter_type, iter_type, bool, ios_base&amp;,
                             ios_base::iostate&amp; err, long double&amp; units) const;
    virtual iter_type do_get(iter_type, iter_type, bool, ios_base&amp;,
                             ios_base::iostate&amp; err, string_type&amp; digits) const;
  };
}
</pre><div id='locale.money.get.members'><h4 ><a class='secnum' href='#locale.money.get.members' style='min-width:133pt'>22.4.6.1.1</a> <span class='texttt'>money_get</span> members <a class='abbr_ref' href='locale.money.get.members'>[locale.money.get.members]</a></h4><p ><span class='indexparent'><a class='index' id='money_get,get'></a></span><span class='indexparent'><a class='index' id='get,money_get'></a></span><code class='itemdecl'>
iter_type get(iter_type s, iter_type end, bool intl,
              ios_base&amp; f, ios_base::iostate&amp; err,
              long double&amp; quant) const;
iter_type get(s, iter_type end, bool intl, ios_base&amp;f,
              ios_base::iostate&amp; err, string_type&amp; quant) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.get.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(s, end, intl, f, err, quant)</span>
</p></div></div></div><div id='locale.money.get.virtuals'><h4 ><a class='secnum' href='#locale.money.get.virtuals' style='min-width:133pt'>22.4.6.1.2</a> <span class='texttt'>money_get</span> virtual functions <a class='abbr_ref' href='locale.money.get.virtuals'>[locale.money.get.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='money_get,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,money_get'></a></span><code class='itemdecl'>
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base&amp; str, ios_base::iostate&amp; err,
                 long double&amp; units) const;
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base&amp; str, ios_base::iostate&amp; err,
                 string_type&amp; digits) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.get.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Reads characters from
<span class='texttt'>s</span>
to parse and construct a monetary value according to the
format specified by a
<span class='texttt'>moneypunct&lt;charT,Intl&gt;</span>
facet reference
<span class='texttt'>mp</span>
and the character mapping specified by a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet reference
<span class='texttt'>ct</span>
obtained from the locale returned by
<span class='texttt'>str.getloc()</span>,
and
<span class='texttt'>str.flags()</span>.
If a valid sequence is recognized,
does not change <span class='texttt'>err</span>;
otherwise, sets <span class='texttt'>err</span> to
<span class='texttt'>(err|str.failbit)</span>,
or
<span class='texttt'>(err|str.failbit|str.eofbit)</span>
if no more characters are available,
and does not change <span class='texttt'>units</span> or <span class='texttt'>digits</span>.
Uses the pattern returned by
<span class='texttt'>mp.neg_format()</span>
to parse all values.
The result is returned as an integral value stored in
<span class='texttt'>units</span>
or as a sequence of digits possibly preceded by a minus sign
(as produced by
<span class='texttt'>ct.widen(c)</span>
where
<span class='texttt'>c</span>
is
<span class='texttt'>'-'</span>
or in the range from
<span class='texttt'>'0'</span>
through
<span class='texttt'>'9'</span>,
inclusive)
stored in
<span class='texttt'>digits</span>.
[&nbsp;<i>Example:</i>
The sequence
<span class='texttt'>&#36;1,056.23</span>
in a common United States locale would yield, for
<span class='texttt'>units</span>,
<span class='texttt'>105623</span>,
or, for
<span class='texttt'>digits</span>,
<span class='texttt'>"105623"</span>.
<i>&nbsp;&nbsp;end example</i>&nbsp;]
If
<span class='texttt'>mp.grouping()</span>
indicates that no thousands separators are permitted,
any such characters are not read, and parsing is terminated at the point
where they first appear.
Otherwise, thousands separators are optional;
if present, they are checked for correct placement only after
all format components have been read.</p></div></div><div class='para' id='locale.money.get.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-2'>2</a></div><div class='itemdescr'><p >Where
<span class='texttt'>money_base::space</span>
or
<span class='texttt'>money_base::none</span>
appears as the last element in the format pattern,
no white space is consumed. Otherwise, where <span class='texttt'>money_base::space</span> appears in any of the
initial elements of the format pattern, at least one white space character is required. Where
<span class='texttt'>money_base::none</span> appears in any of the initial elements of the format pattern, white
space is allowed but not required.
If
<span class='texttt'>(str.flags() &amp; str.showbase)</span>
is false, the currency symbol is optional and is consumed only if
other characters are needed to complete the format;
otherwise, the currency symbol is required.</p></div></div><div class='para' id='locale.money.get.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-3'>3</a></div><div class='itemdescr'><p >If the first character (if any) in the string
<span class='texttt'>pos</span>
returned by
<span class='texttt'>mp.positive_sign()</span>
or the string
<span class='texttt'>neg</span>
returned by
<span class='texttt'>mp.negative_sign()</span>
is recognized in the position indicated by
<span class='texttt'>sign</span>
in the format pattern, it is consumed and any remaining characters
in the string are required after all the other format components.
[&nbsp;<i>Example:</i>
If
<span class='texttt'>showbase</span>
is off, then for a
<span class='texttt'>neg</span>
value of <span class='texttt'>"()"</span> and a currency symbol of <span class='texttt'>"L"</span>,
in <span class='texttt'>"(100 L)"</span> the <span class='texttt'>"L"</span> is consumed;
but if
<span class='texttt'>neg</span>
is <span class='texttt'>"-"</span>, the <span class='texttt'>"L"</span> in <span class='texttt'>"-100 L"</span> is not consumed.
<i>&nbsp;&nbsp;end example</i>&nbsp;]
If
<span class='texttt'>pos</span>
or
<span class='texttt'>neg</span>
is empty, the sign component is optional, and if no sign is
detected, the result is given the sign that corresponds to the source
of the empty string.
Otherwise, the character in the indicated position must
match the first character of
<span class='texttt'>pos</span>
or
<span class='texttt'>neg</span>,
and the result is given the corresponding sign.
If the first character of
<span class='texttt'>pos</span>
is equal to the first character of
<span class='texttt'>neg</span>,
or if both strings are empty, the result is given a positive sign.</p></div></div><div class='para' id='locale.money.get.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-4'>4</a></div><div class='itemdescr'><p >Digits in the numeric monetary component are extracted and placed in
<span class='texttt'>digits</span>,
or into a character buffer
<span class='texttt'>buf1</span>
for conversion to produce a value for
<span class='texttt'>units</span>,
in the order in which they appear,
preceded by a minus sign if and only if the result is negative.
The value
<span class='texttt'>units</span>
is produced as if by<a class='footnotenum' href='#footnote-255'>255</a></p><pre class='codeblock'>
for (int i = 0; i &lt; n; ++i)
  buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &amp;units);
</pre><p >where
<span class='texttt'>n</span>
is the number of characters placed in
<span class='texttt'>buf1</span>,
<span class='texttt'>buf2</span>
is a character buffer, and the values
<span class='texttt'>src</span>
and
<span class='texttt'>atoms</span>
are defined as if by</p><pre class='codeblock'>
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
</pre></div></div><div class='para' id='locale.money.get.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.get.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately beyond the last character recognized
as part of a valid monetary quantity.
</p></div></div><div class='footnote' id='footnote-254'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-254'>254)</a></div><p >The semantics here are different from
<span class='texttt'>ct.narrow</span>.</p></div></div></div><div id='locale.money.put'><h4 ><a class='secnum' href='#locale.money.put' style='min-width:118pt'>22.4.6.2</a> Class template <span class='texttt'>money_put</span> <a class='abbr_ref' href='locale.money.put'>[locale.money.put]</a></h4><p ><span class='indexparent'><a class='index' id='money_put'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT,
    class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
  class money_put : public locale::facet {
  public:
    typedef charT               char_type;
    typedef OutputIterator      iter_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit money_put(size_t refs = 0);

    iter_type put(iter_type s, bool intl, ios_base&amp; f,
                  char_type fill, long double units) const;
    iter_type put(iter_type s, bool intl, ios_base&amp; f,
                  char_type fill, const string_type&amp; digits) const;

    static locale::id id;

  protected:
    ~money_put();
    virtual iter_type do_put(iter_type, bool, ios_base&amp;, char_type fill,
                             long double units) const;
    virtual iter_type do_put(iter_type, bool, ios_base&amp;, char_type fill,
                             const string_type&amp; digits) const;
  };
}
</pre><div id='locale.money.put.members'><h4 ><a class='secnum' href='#locale.money.put.members' style='min-width:133pt'>22.4.6.2.1</a> <span class='texttt'>money_put</span> members <a class='abbr_ref' href='locale.money.put.members'>[locale.money.put.members]</a></h4><p ><span class='indexparent'><a class='index' id='money_put,put'></a></span><span class='indexparent'><a class='index' id='put,money_put'></a></span><code class='itemdecl'>
iter_type put(iter_type s, bool intl, ios_base&amp; f, char_type fill,
              long double quant) const;
iter_type put(iter_type s, bool intl, ios_base&amp; f, char_type fill,
              const string_type&amp; quant) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.put.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_put(s, intl, f, loc, quant)</span>
</p></div></div></div><div id='locale.money.put.virtuals'><h4 ><a class='secnum' href='#locale.money.put.virtuals' style='min-width:133pt'>22.4.6.2.2</a> <span class='texttt'>money_put</span> virtual functions <a class='abbr_ref' href='locale.money.put.virtuals'>[locale.money.put.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='money_put,do_put'></a></span><span class='indexparent'><a class='index' id='do_put,money_put'></a></span><code class='itemdecl'>
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, const string_type&amp; digits) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.money.put.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Writes characters to
<span class='texttt'>s</span>
according to the format specified by a
<span class='texttt'>moneypunct&lt;charT,Intl&gt;</span>
facet reference
<span class='texttt'>mp</span>
and the character mapping specified by a
<span class='texttt'>ctype&lt;charT&gt;</span>
facet reference
<span class='texttt'>ct</span>
obtained from the locale returned by
<span class='texttt'>str.getloc()</span>,
and
<span class='texttt'>str.flags()</span>.
The argument
<span class='texttt'>units</span>
is transformed into a sequence of wide characters as if by</p><pre class='codeblock'>
ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)
</pre><p >for character buffers
<span class='texttt'>buf1</span>
and
<span class='texttt'>buf2</span>.
If the first character in
<span class='texttt'>digits</span>
or
<span class='texttt'>buf2</span>
is equal to
<span class='texttt'>ct.widen('-')</span>,
then the pattern used for formatting is the result of
<span class='texttt'>mp.neg_format()</span>;
otherwise the pattern is the result of
<span class='texttt'>mp.pos_format()</span>.
Digit characters are written, interspersed with any thousands separators
and decimal point specified by the format, in the order they appear
(after the optional leading minus sign)
in
<span class='texttt'>digits</span>
or
<span class='texttt'>buf2</span>.
In
<span class='texttt'>digits</span>,
only the optional leading minus sign and the immediately subsequent
digit characters (as classified according to
<span class='texttt'>ct</span>)
are used; any trailing characters (including digits appearing
after a non-digit character) are ignored.
Calls
<span class='texttt'>str.width(0)</span>.</p></div></div><div class='para' id='locale.money.put.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The currency symbol is generated if and only if
<span class='texttt'>(str.flags() &amp; str.showbase)</span>
is nonzero.
If the number of characters generated for the specified format is less than the value
returned by
<span class='texttt'>str.width()</span>
on entry to the function, then copies of
<span class='texttt'>fill</span>
are inserted as necessary to pad to the specified width.
For the value
<span class='texttt'>af</span>
equal to
<span class='texttt'>(str.flags() &amp; str.adjustfield)</span>,
if
<span class='texttt'>(af == str.internal)</span>
is true, the fill characters are placed where
<span class='texttt'>none</span>
or
<span class='texttt'>space</span>
appears in the formatting pattern; otherwise if
<span class='texttt'>(af == str.left)</span>
is true, they are placed after the other characters;
otherwise, they are placed before the other characters.
[&nbsp;<i>Note:</i>
It is possible, with some combinations of format patterns and flag values,
to produce output that cannot be parsed using
<span class='texttt'>num_get&lt;&gt;::get</span>.
<i>&nbsp;&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='locale.money.put.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.money.put.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
An iterator pointing immediately after the last character produced.
</p></div></div></div></div><div id='locale.moneypunct'><h4 ><a class='secnum' href='#locale.moneypunct' style='min-width:118pt'>22.4.6.3</a> Class template <span class='texttt'>moneypunct</span> <a class='abbr_ref' href='locale.moneypunct'>[locale.moneypunct]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct'></a></span></p><pre class='codeblock'>
namespace std {
  class money_base {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
  };

  template &lt;class charT, bool International = false&gt;
  class moneypunct : public locale::facet, public money_base {
  public:
    typedef charT char_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit moneypunct(size_t refs = 0);

    charT        decimal_point() const;
    charT        thousands_sep() const;
    string       grouping()      const;
    string_type  curr_symbol()   const;
    string_type  positive_sign() const;
    string_type  negative_sign() const;
    int          frac_digits()   const;
    pattern      pos_format()    const;
    pattern      neg_format()    const;

    static locale::id id;
    static const bool intl = International;

  protected:
    ~moneypunct();
    virtual charT        do_decimal_point() const;
    virtual charT        do_thousands_sep() const;
    virtual string       do_grouping()      const;
    virtual string_type  do_curr_symbol()   const;
    virtual string_type  do_positive_sign() const;
    virtual string_type  do_negative_sign() const;
    virtual int          do_frac_digits()   const;
    virtual pattern      do_pos_format()    const;
    virtual pattern      do_neg_format()    const;
  };
}
</pre><div class='para' id='locale.moneypunct-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-1'>1</a></div><p >The
<span class='texttt'>moneypunct&lt;&gt;</span>
facet defines monetary formatting parameters used by
<span class='texttt'>money_get&lt;&gt;</span>
and
<span class='texttt'>money_put&lt;&gt;</span>.
A monetary format is a sequence of four components,
specified by a
<span class='texttt'>pattern</span>
value
<span class='texttt'>p</span>,
such that the
<span class='texttt'>part</span>
value
<span class='texttt'>static_cast&lt;part&gt;(p.field[i])</span>
determines the
<span class='texttt'>i</span>th
component of the format<a class='footnotenum' href='#footnote-256'>256</a>
In the
<span class='texttt'>field</span>
member of a
<span class='texttt'>pattern</span>
object, each value
<span class='texttt'>symbol</span>,
<span class='texttt'>sign</span>,
<span class='texttt'>value</span>,
and either
<span class='texttt'>space</span>
or
<span class='texttt'>none</span>
appears exactly once.
The value
<span class='texttt'>none</span>,
if present, is not first;
the value
<span class='texttt'>space</span>,
if present, is neither first nor last.</p></div><div class='para' id='locale.moneypunct-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-2'>2</a></div><p >Where
<span class='texttt'>none</span>
or
<span class='texttt'>space</span>
appears, white space is permitted in the format,
except where
<span class='texttt'>none</span>
appears at the end, in which case no white space is permitted.
The value
<span class='texttt'>space</span>
indicates that at least one space is required at that position.
Where
<span class='texttt'>symbol</span>
appears, the sequence of characters returned by
<span class='texttt'>curr_symbol()</span>
is permitted, and can be required.
Where
<span class='texttt'>sign</span>
appears, the first (if any) of the sequence of characters returned by
<span class='texttt'>positive_sign()</span>
or
<span class='texttt'>negative_sign()</span>
(respectively as the monetary value is non-negative or negative) is required.
Any remaining characters of the sign sequence are required after all
other format components.
Where
<span class='texttt'>value</span>
appears, the absolute numeric monetary value is required.</p></div><div class='para' id='locale.moneypunct-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-3'>3</a></div><p >The format of the numeric monetary value is a decimal number:</p><pre class='codeblock'>
value ::= units [ decimal-point [ digits ]] |
  decimal-point digits
</pre><p >if
<span class='texttt'>frac_digits()</span>
returns a positive value, or</p><pre class='codeblock'>
value ::= units
</pre><p >otherwise.
The symbol
<span class='texttt'>decimal-point</span>
indicates the character returned by
<span class='texttt'>decimal_point()</span>.
The other symbols are defined as follows:</p><pre class='codeblock'>
units ::= digits [ thousands-sep units ]
digits ::= adigit [ digits ]
</pre><p >In the syntax specification, the symbol
<span class='texttt'>adigit</span>
is any of the values
<span class='texttt'>ct.widen(c)</span>
for
<span class='texttt'>c</span>
in the range
<span class='texttt'>'0'</span>
through
<span class='texttt'>'9'</span>,
inclusive, and
<span class='texttt'>ct</span>
is a reference of type
<span class='texttt'>const ctype&lt;charT&gt;&amp;</span>
obtained as described in the definitions of
<span class='texttt'>money_get&lt;&gt;</span>
and
<span class='texttt'>money_put&lt;&gt;</span>.
The symbol
<span class='texttt'>thousands-sep</span>
is the character returned by
<span class='texttt'>thousands_sep()</span>.
The space character used is the value
<span class='texttt'>ct.widen(' ')</span>.
White space characters are those characters
<span class='texttt'>c</span>
for which
<span class='texttt'>ci.is(space,c)</span>
returns
<span class='texttt'>true</span>.
The number of digits required after the decimal point (if any)
is exactly the value returned by
<span class='texttt'>frac_digits()</span>.</p></div><div class='para' id='locale.moneypunct-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct-4'>4</a></div><p >The placement of thousands-separator characters (if any)
is determined by the value returned by
<span class='texttt'>grouping()</span>,
defined identically as the member
<span class='texttt'>numpunct&lt;&gt;::do_grouping()</span>.</p></div><div class='footnote' id='footnote-255'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-255'>255)</a></div><p >An array of
<span class='texttt'>char</span>,
rather than an array of
<span class='texttt'>part</span>,
is specified for
<span class='texttt'>pattern::field</span>
purely for efficiency.</p></div><div id='locale.moneypunct.members'><h4 ><a class='secnum' href='#locale.moneypunct.members' style='min-width:133pt'>22.4.6.3.1</a> <span class='texttt'>moneypunct</span> members <a class='abbr_ref' href='locale.moneypunct.members'>[locale.moneypunct.members]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct,decimal_point'></a></span><span class='indexparent'><a class='index' id='decimal_point,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,thousands_sep'></a></span><span class='indexparent'><a class='index' id='thousands_sep,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,grouping'></a></span><span class='indexparent'><a class='index' id='grouping,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,curr_symbol'></a></span><span class='indexparent'><a class='index' id='curr_symbol,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,positive_sign'></a></span><span class='indexparent'><a class='index' id='positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,negative_sign'></a></span><span class='indexparent'><a class='index' id='negative_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,frac_digits'></a></span><span class='indexparent'><a class='index' id='frac_digits,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,positive_sign'></a></span><span class='indexparent'><a class='index' id='positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,negative_sign'></a></span><span class='indexparent'><a class='index' id='negative_sign,moneypunct'></a></span></p><pre class='codeblock'>
charT        decimal_point() const;
charT        thousands_sep() const;
string       grouping()      const;
string_type  curr_symbol()   const;
string_type  positive_sign() const;
string_type  negative_sign() const;
int          frac_digits()   const;
pattern      pos_format()    const;
pattern      neg_format()    const;
</pre><div class='para' id='locale.moneypunct.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.members-1'>1</a></div><p >Each of these functions <span class='texttt'>F</span>
returns the result of calling the corresponding
virtual member function
<span class='texttt'>do_</span><span class='textbf'></span><i>F</i><span class='texttt'>()</span>.</p></div></div><div id='locale.moneypunct.virtuals'><h4 ><a class='secnum' href='#locale.moneypunct.virtuals' style='min-width:133pt'>22.4.6.3.2</a> <span class='texttt'>moneypunct</span> virtual functions <a class='abbr_ref' href='locale.moneypunct.virtuals'>[locale.moneypunct.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct,do_decimal_point'></a></span><span class='indexparent'><a class='index' id='do_decimal_point,moneypunct'></a></span><code class='itemdecl'>
charT do_decimal_point() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The radix separator to use in case
<span class='texttt'>do_frac_digits()</span>
is greater than zero.<a class='footnotenum' href='#footnote-257'>257</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_thousands_sep'></a></span><span class='indexparent'><a class='index' id='do_thousands_sep,moneypunct'></a></span><code class='itemdecl'>
charT do_thousands_sep() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
The digit group separator to use in case
<span class='texttt'>do_grouping()</span>
specifies a digit grouping pattern.<a class='footnotenum' href='#footnote-258'>258</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_grouping'></a></span><span class='indexparent'><a class='index' id='do_grouping,moneypunct'></a></span><code class='itemdecl'>
string do_grouping() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pattern defined identically as, but not necessarily equal to, the result of
<span class='texttt'>numpunct&lt;charT&gt;::<span class='discretionary'></span>do_grouping()</span>.<a class='footnotenum' href='#footnote-259'>259</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_curr_symbol'></a></span><span class='indexparent'><a class='index' id='do_curr_symbol,moneypunct'></a></span><code class='itemdecl'>
string_type do_curr_symbol() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
A string to use as the currency identifier symbol.<a class='footnotenum' href='#footnote-260'>260</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_positive_sign'></a></span><span class='indexparent'><a class='index' id='do_positive_sign,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,do_negative_sign'></a></span><span class='indexparent'><a class='index' id='do_negative_sign,moneypunct'></a></span><code class='itemdecl'>
string_type do_positive_sign() const;
string_type do_negative_sign() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_positive_sign()</span>
returns the string to use to indicate a
positive monetary value;<a class='footnotenum' href='#footnote-261'>261</a>
<span class='texttt'>do_negative_sign()</span>
returns the string to use to indicate a negative value.
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_frac_digits'></a></span><span class='indexparent'><a class='index' id='do_frac_digits,moneypunct'></a></span><code class='itemdecl'>
int do_frac_digits() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The number of digits after the decimal radix separator, if any.<a class='footnotenum' href='#footnote-262'>262</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='moneypunct,do_pos_format'></a></span><span class='indexparent'><a class='index' id='do_pos_format,moneypunct'></a></span><span class='indexparent'><a class='index' id='moneypunct,do_neg_format'></a></span><span class='indexparent'><a class='index' id='do_neg_format,moneypunct'></a></span><code class='itemdecl'>
pattern do_pos_format() const;
pattern do_neg_format() const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.moneypunct.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.moneypunct.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The specializations required in Table <a href='locale.category#tab:localization.required.specializations'>[tab:localization.required.specializations]</a> (<a href='locale.category'>[locale.category]</a>), namely
<span class='texttt'>moneypunct&lt;char&gt;</span>,
<span class='texttt'>moneypunct&lt;<span class='discretionary'></span>wchar_t&gt;</span>,
<span class='texttt'>moneypunct&lt;char,true&gt;</span>,
and
<span class='texttt'>moneypunct&lt;wchar_t,true&gt;</span>,
return an object of type
<span class='texttt'>pattern</span>
initialized to
<span class='texttt'>{ symbol, sign, none, value }</span>.<a class='footnotenum' href='#footnote-263'>263</a>
</p></div></div><div class='footnote' id='footnote-256'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-256'>256)</a></div><p >In common U.S. locales this is
<span class='texttt'>'.'</span>.</p></div><div class='footnote' id='footnote-257'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-257'>257)</a></div><p >In common U.S. locales this is
<span class='texttt'>','</span>.</p></div><div class='footnote' id='footnote-258'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-258'>258)</a></div><p >To specify grouping by 3s,
the value is <span class='texttt'>"\003"</span>
<i>not</i>
<span class='texttt'>"3"</span>.</p></div><div class='footnote' id='footnote-259'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-259'>259)</a></div><p >For international
specializations (second template parameter
<span class='texttt'>true</span>)
this is typically four characters long, usually three letters and a space.</p></div><div class='footnote' id='footnote-260'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-260'>260)</a></div><p >This is usually the empty string.</p></div><div class='footnote' id='footnote-261'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-261'>261)</a></div><p >In
common U.S. locales, this is 2.</p></div><div class='footnote' id='footnote-262'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-262'>262)</a></div><p >Note that the international
symbol returned by
<span class='texttt'>do_curr_sym()</span>
usually contains a space, itself;
for example, <span class='texttt'>"USD "</span>.</p></div></div></div><div id='locale.moneypunct.byname'><h4 ><a class='secnum' href='#locale.moneypunct.byname' style='min-width:118pt'>22.4.6.4</a> Class template <span class='texttt'>moneypunct_byname</span> <a class='abbr_ref' href='locale.moneypunct.byname'>[locale.moneypunct.byname]</a></h4><p ><span class='indexparent'><a class='index' id='moneypunct_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, bool Intl = false&gt;
  class moneypunct_byname : public moneypunct&lt;charT, Intl&gt; {
  public:
    typedef money_base::pattern pattern;
    typedef basic_string&lt;charT&gt; string_type;

    explicit moneypunct_byname(const char*, size_t refs = 0);
    explicit moneypunct_byname(const string&amp;, size_t refs = 0);
  protected:
    ~moneypunct_byname();
  };
}
</pre></div></div><div id='category.messages'><h3 ><a class='secnum' href='#category.messages' style='min-width:103pt'>22.4.7</a> The message retrieval category <a class='abbr_ref' href='category.messages'>[category.messages]</a></h3><div class='para' id='category.messages-1'><div class='marginalizedparent'><a class='marginalized' href='#category.messages-1'>1</a></div><p >Class
<span class='texttt'>messages&lt;charT&gt;</span>
implements retrieval of strings from message catalogs.</p></div><div id='locale.messages'><h4 ><a class='secnum' href='#locale.messages' style='min-width:118pt'>22.4.7.1</a> Class template <span class='texttt'>messages</span> <a class='abbr_ref' href='locale.messages'>[locale.messages]</a></h4><p ><span class='indexparent'><a class='index' id='messages'></a></span></p><pre class='codeblock'>
namespace std {
  class messages_base {
  public:
    typedef int catalog;
  };

  template &lt;class charT&gt;
  class messages : public locale::facet, public messages_base {
  public:
    typedef charT char_type;
    typedef basic_string&lt;charT&gt; string_type;

    explicit messages(size_t refs = 0);

    catalog open(const basic_string&lt;char&gt;&amp; fn, const locale&amp;) const;
    string_type get(catalog c, int set, int msgid,
                     const string_type&amp; dfault) const;
    void close(catalog c) const;

    static locale::id id;

  protected:
    ~messages();
    virtual catalog do_open(const basic_string&lt;char&gt;&amp;, const locale&amp;) const;
    virtual string_type do_get(catalog, int set, int msgid,
                               const string_type&amp; dfault) const;
    virtual void do_close(catalog) const;
  };
}
</pre><div class='para' id='locale.messages-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages-1'>1</a></div><p >Values of type
<span class='texttt'>messages_base::catalog</span>
usable as arguments to members
<span class='texttt'>get</span>
and
<span class='texttt'>close</span>
can be obtained only by calling member
<span class='texttt'>open</span>.</p></div><div id='locale.messages.members'><h4 ><a class='secnum' href='#locale.messages.members' style='min-width:133pt'>22.4.7.1.1</a> <span class='texttt'>messages</span> members <a class='abbr_ref' href='locale.messages.members'>[locale.messages.members]</a></h4><p ><span class='indexparent'><a class='index' id='messages,open'></a></span><span class='indexparent'><a class='index' id='open,messages'></a></span><code class='itemdecl'>
catalog open(const basic_string&lt;char&gt;&amp; name, const locale&amp; loc) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_open(name, loc)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,get'></a></span><span class='indexparent'><a class='index' id='get,messages'></a></span><code class='itemdecl'>
string_type get(catalog cat, int set, int msgid,
                const string_type&amp; dfault) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>do_get(cat, set, msgid, dfault)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,close'></a></span><span class='indexparent'><a class='index' id='close,messages'></a></span><code class='itemdecl'>
void  close(catalog cat) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.members-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>do_close(cat)</span>.
</p></div></div></div><div id='locale.messages.virtuals'><h4 ><a class='secnum' href='#locale.messages.virtuals' style='min-width:133pt'>22.4.7.1.2</a> <span class='texttt'>messages</span> virtual functions <a class='abbr_ref' href='locale.messages.virtuals'>[locale.messages.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='messages,do_open'></a></span><span class='indexparent'><a class='index' id='do_open,messages'></a></span><code class='itemdecl'>
catalog do_open(const basic_string&lt;char&gt;&amp; name,
                const locale&amp; loc) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A value that may be passed to
<span class='texttt'>get()</span>
to retrieve a message from the message catalog identified by the string
<span class='texttt'>name</span> according to an <span class='indexparent'><a class='index' id='mapping_from_name_to_catalog_when_calling_messages::do_open'></a></span>implementation-defined mapping.
The result can be used until it is passed to
<span class='texttt'>close()</span>.</p></div></div><div class='para' id='locale.messages.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-2'>2</a></div><div class='itemdescr'><p >Returns a value less than 0 if no such catalog can be opened.</p></div></div><div class='para' id='locale.messages.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The locale argument <span class='texttt'>loc</span>
is used for character set code conversion when retrieving
messages, if needed.
</p></div></div><p ><span class='indexparent'><a class='index' id='messages,do_get'></a></span><span class='indexparent'><a class='index' id='do_get,messages'></a></span><code class='itemdecl'>
string_type do_get(catalog cat, int set, int msgid,
              const string_type&amp; dfault) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>cat</span> shall be a catalog obtained from
<span class='texttt'>open()</span>
and not yet closed.</p></div></div><div class='para' id='locale.messages.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
A message identified by arguments <span class='texttt'>set</span>, <span class='texttt'>msgid</span>, and <span class='texttt'>dfault</span>, according
to an <span class='indexparent'><a class='index' id='mapping_to_message_when_calling_messages::do_get'></a></span>implementation-defined mapping. If no
such message can be found, returns <span class='texttt'>dfault</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='message,do_close'></a></span><span class='indexparent'><a class='index' id='do_close,message'></a></span><code class='itemdecl'>
void do_close(catalog cat) const;
</code></p><div class='itemdescr'></div><div class='para' id='locale.messages.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>cat</span> shall be a catalog obtained from
<span class='texttt'>open()</span>
and not yet closed.</p></div></div><div class='para' id='locale.messages.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Releases unspecified resources associated with  <span class='texttt'>cat</span>.</p></div></div><div class='para' id='locale.messages.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#locale.messages.virtuals-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The limit on such resources, if any, is implementation-defined.
</p></div></div></div></div><div id='locale.messages.byname'><h4 ><a class='secnum' href='#locale.messages.byname' style='min-width:118pt'>22.4.7.2</a> Class template <span class='texttt'>messages_byname</span> <a class='abbr_ref' href='locale.messages.byname'>[locale.messages.byname]</a></h4><p ><span class='indexparent'><a class='index' id='messages_byname'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  class messages_byname : public messages&lt;charT&gt; {
  public:
    typedef messages_base::catalog catalog;
    typedef basic_string&lt;charT&gt;    string_type;

    explicit messages_byname(const char*, size_t refs = 0);
    explicit messages_byname(const string&amp;, size_t refs = 0);
  protected:
    ~messages_byname();
  };
}
</pre></div></div><div id='facets.examples'><h3 ><a class='secnum' href='#facets.examples' style='min-width:103pt'>22.4.8</a> Program-defined facets <a class='abbr_ref' href='facets.examples'>[facets.examples]</a></h3><div class='para' id='facets.examples-1'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-1'>1</a></div><p >A C++ program may define facets to be added to a locale and used identically as
the built-in facets.
To create a new facet interface, C++ programs simply derive from
<span class='texttt'>locale::facet</span>
a class containing a static member:
<span class='texttt'>static locale::id id</span>.</p></div><div class='para' id='facets.examples-2'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-2'>2</a></div><p >[&nbsp;<i>Note:</i>
The locale member function templates verify its type and storage class.
<i>&nbsp;&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='facets.examples-3'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-3'>3</a></div><p >[&nbsp;<i>Example:</i>
Traditional global localization is still easy:</p><pre class='codeblock'>
#include &lt;iostream&gt;
#include &lt;locale&gt;
int main(int argc, char** argv) {
  using namespace std;
  locale::global(locale(""));           <span class='comment'>// set the global locale
</span>                                        <span class='comment'>// imbue it on all the std streams
</span>  cin.imbue(locale());
  cout.imbue(locale());
  cerr.imbue(locale());
  wcin.imbue(locale());
  wcout.imbue(locale());
  wcerr.imbue(locale());

  return MyObject(argc, argv).doit();
}
</pre><p ><i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-4'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-4'>4</a></div><p >[&nbsp;<i>Example:</i>
Greater flexibility is possible:</p><pre class='codeblock'>
#include &lt;iostream&gt;
#include &lt;locale&gt;
int main() {
  using namespace std;
  cin.imbue(locale(""));        <span class='comment'>// the user's preferred locale
</span>  cout.imbue(locale::classic());
  double f;
  while (cin &gt;&gt; f) cout &lt;&lt; f &lt;&lt; endl;
  return (cin.fail() != 0);
}
</pre><p >In a European locale, with input
<span class='texttt'>3.456,78</span>,
output is
<span class='texttt'>3456.78</span>.
<i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-5'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-5'>5</a></div><p >This can be important even for simple programs, which may need to
write a data file in a fixed format, regardless of a user's preference.</p></div><div class='para' id='facets.examples-6'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-6'>6</a></div><p >[&nbsp;<i>Example:</i>
Here is an example of the use of locales in a library interface.</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>Date.h</span>
</span>#include &lt;iosfwd&gt;
#include &lt;string&gt;
#include &lt;locale&gt;

class Date {
public:
  Date(unsigned day, unsigned month, unsigned year);
  std::string asString(const std::locale&amp; = std::locale());
};

std::istream&amp; operator&gt;&gt;(std::istream&amp; s, Date&amp; d);
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Date d);
</pre></div><div class='para' id='facets.examples-7'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-7'>7</a></div><p >This example illustrates two architectural uses of class
<span class='texttt'>locale</span>.</p></div><div class='para' id='facets.examples-8'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-8'>8</a></div><p >The first is as a default argument in
<span class='texttt'>Date::asString()</span>,
where the
default is the global (presumably user-preferred) locale.</p></div><div class='para' id='facets.examples-9'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-9'>9</a></div><p >The second is in the operators
<span class='texttt'>&lt;&lt;</span>
and
<span class='texttt'>&gt;&gt;</span>,
where a locale hitchhikes
on another object, in this case a stream, to the point where it
is needed.</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>Date.C</span>
</span>#include "Date"                 <span class='comment'>// includes <span class='texttt'>&lt;ctime&gt;</span>
</span>#include &lt;sstream&gt;
std::string Date::asString(const std::locale&amp; l) {
  using namespace std;
  ostringstream s; s.imbue(l);
  s &lt;&lt; *this; return s.str();
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; s, Date&amp; d) {
  using namespace std;
  istream::sentry cerberos(s);
  if (cerberos) {
    ios_base::iostate err = goodbit;
    struct tm t;
    use_facet&lt; time_get&lt;char&gt; &gt;(s.getloc()).get_date(s, 0, s, err, &amp;t);
    if (!err) d = Date(t.tm_day, t.tm_mon + 1, t.tm_year + 1900);
    s.setstate(err);
  }
  return s;
}
</pre><p ><i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-10'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-10'>10</a></div><p >A locale object may be extended with a new facet simply by constructing
it with an instance of a class derived from
<span class='texttt'>locale::facet</span>.
The only member a C++ program must define is the static member
<span class='texttt'>id</span>,
which identifies your class interface as a new facet.</p></div><div class='para' id='facets.examples-11'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-11'>11</a></div><p >[&nbsp;<i>Example:</i>
Classifying Japanese characters:</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>&lt;jctype&gt;</span>
</span>#include &lt;locale&gt;
namespace My {
  using namespace std;
  class JCtype : public locale::facet {
  public:
    static locale::id id;       <span class='comment'>// required for use as a new locale facet
</span>    bool is_kanji (wchar_t c) const;
    JCtype() { }
  protected:
    ~JCtype() { }
  };
}

<span class='comment'>// file: <span class='texttt'>filt.C</span>
</span>#include &lt;iostream&gt;
#include &lt;locale&gt;
#include "jctype"               <span class='comment'>// above
</span>std::locale::id My::JCtype::id; <span class='comment'>// the static <span class='texttt'>JCtype</span> member declared above.
</span>
int main() {
  using namespace std;
  typedef ctype&lt;wchar_t&gt; wctype;
  locale loc(locale(""),        <span class='comment'>// the user's preferred locale ...
</span>         new My::JCtype);       <span class='comment'>// and a new feature ...
</span>  wchar_t c = use_facet&lt;wctype&gt;(loc).widen('!');
  if (!use_facet&lt;My::JCtype&gt;(loc).is_kanji(c))
    cout &lt;&lt; "no it isn't!" &lt;&lt; endl;
  return 0;
}
</pre></div><div class='para' id='facets.examples-12'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-12'>12</a></div><p >The new facet is used exactly like the built-in facets.
<i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='facets.examples-13'><div class='marginalizedparent'><a class='marginalized' href='#facets.examples-13'>13</a></div><p >[&nbsp;<i>Example:</i>
Replacing an existing facet is even easier.
The code does not define a member
<span class='texttt'>id</span>
because it is reusing the
<span class='texttt'>numpunct&lt;charT&gt;</span>
facet interface:</p><pre class='codeblock'>
<span class='comment'>// file: <span class='texttt'>my_bool.C</span>
</span>#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
namespace My {
  using namespace std;
  typedef numpunct_byname&lt;char&gt; cnumpunct;
  class BoolNames : public cnumpunct {
  protected:
    string do_truename()  const { return "Oui Oui!"; }
    string do_falsename() const { return "Mais Non!"; }
    ~BoolNames() { }
  public:
    BoolNames(const char* name) : cnumpunct(name) { }
  };
}

int main(int argc, char** argv) {
  using namespace std;
  <span class='comment'>// make the user's preferred locale, except for...
</span>  locale loc(locale(""), new My::BoolNames(""));
  cout.imbue(loc);
  cout &lt;&lt; boolalpha &lt;&lt; "Any arguments today? " &lt;&lt; (argc &gt; 1) &lt;&lt; endl;
  return 0;
}
</pre><p ><i>&nbsp;&nbsp;end example</i>&nbsp;]</p></div></div></div></div></body></html>