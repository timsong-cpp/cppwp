<!DOCTYPE html><html lang='en'><head><title>[func.require]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.8</a> Function objects <a class='abbr_ref' href='function.objects#func.require'>[function.objects]</a></h2><div id='func.require'><h3 ><a class='secnum' style='min-width:103pt'>20.8.2</a> Requirements <a class='abbr_ref'>[func.require]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> as follows:</p><ul ><li ><p ><span class='texttt'>(t1.*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of
type <span class='texttt'>T</span> or a reference to an object of type <span class='texttt'>T</span> or a
reference to an object of a type derived from <span class='texttt'>T</span>;</p></li><li ><p ><span class='texttt'>((*t1).*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the
types described in the previous item;</p></li><li ><p ><span class='texttt'>t1.*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of type <span class='texttt'>T</span> or a
reference to an object of type <span class='texttt'>T</span> or a reference to an object
of a type derived from <span class='texttt'>T</span>;</p></li><li ><p ><span class='texttt'>(*t1).*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the types described in
the previous item;</p></li><li ><p ><span class='texttt'>f(t1, t2, ..., tN)</span> in all other cases.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span> as
<span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> implicitly converted
to <span class='texttt'>R</span>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='weak_result_type'></a></span><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='target_object'></a></span>If a call wrapper (<a href='func.def'>[func.def]</a>) has a <i>weak result type</i>
the type of its member type <span class='texttt'>result_type</span> is based on the
type <span class='texttt'>T</span> of the wrapper's target object (<a href='func.def'>[func.def]</a>):
</p><ul ><li ><p >if <span class='texttt'>T</span> is a pointer to
function type, <span class='texttt'>result_type</span> shall be a synonym for the return
type of <span class='texttt'>T</span>;</p></li><li ><p >if <span class='texttt'>T</span> is a pointer to member function, <span class='texttt'>result_type</span>
shall be a synonym for the return type of <span class='texttt'>T</span>;</p></li><li ><p >if <span class='texttt'>T</span> is a class type with a member type <span class='texttt'>result_type</span>,
then <span class='texttt'>result_type</span> shall be a synonym for <span class='texttt'>T::result_type</span>;</p></li><li ><p >otherwise <span class='texttt'>result_type</span> shall not be defined.
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='call_wrapper,simple'></a></span><span class='indexparent'><a class='index' id='call_wrapper,forwarding'></a></span><span class='indexparent'><a class='index' id='simple_call_wrapper'></a></span><span class='indexparent'><a class='index' id='forwarding_call_wrapper'></a></span>Every call wrapper (<a href='func.def'>[func.def]</a>) shall be
<span class='texttt'>MoveConstructible</span>. A <a class='hidden_link' href='#def:simple_call_wrapper' id='def:simple_call_wrapper'><i>simple call wrapper</i></a> is a call wrapper
that is <span class='texttt'>CopyConstructible</span> and <span class='texttt'>CopyAssignable</span> and whose copy
constructor, move constructor, and assignment operator
do not throw exceptions. A <a class='hidden_link' href='#def:forwarding_call_wrapper' id='def:forwarding_call_wrapper'><i>forwarding call wrapper</i></a> is a
call wrapper that can be called with an arbitrary argument list
and delivers the arguments to the wrapped callable object as references.
This forwarding step shall ensure that rvalue arguments are delivered as rvalue-references
and lvalue arguments are delivered as lvalue-references.
[&nbsp;<i>Note:</i> In a typical implementation
forwarding call wrappers have an overloaded function call
operator of
the form</p><pre class='codeblock'>
template&lt;class... UnBoundArgs&gt;
R operator()(UnBoundArgs&amp;&amp;... unbound_args) <i>cv-qual</i>;
</pre><p ><i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>