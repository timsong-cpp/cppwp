<!DOCTYPE html><html lang='en'><head><title>[temp.mem]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.mem'>[temp.decls]</a></h2><div id='temp.mem'><h3 ><a class='secnum' style='min-width:103pt'>14.5.2</a> Member templates <a class='abbr_ref'>[temp.mem]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A template can be declared within a class or class template; such a template
is called a member template.
A member template can be defined within or outside its class definition or
class template definition.
A member template of a class template that is defined outside of its class
template definition shall be specified with the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
of the class template followed by the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
of the member template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct string {
  template&lt;class T2&gt; int compare(const T2&amp;);
  template&lt;class T2&gt; string(const string&lt;T2&gt;&amp; s) { <span class='comment'>/* ... */</span> }
};

template&lt;class T&gt; template&lt;class T2&gt; int string&lt;T&gt;::compare(const T2&amp; s) {
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A local class shall not have member templates.
Access control rules (Clause <a href='class.access'>[class.access]</a>)
apply to member template names.
A destructor shall not be a member
template.
A normal (non-template) member function with a given name
and type and a member function template of the same name, which could be
used to generate a specialization of the same type, can both be
declared in a class.
When both exist, a use of that name and type refers to the
non-template member unless an explicit template argument list is supplied.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class T2&gt; void f(T2);
};

template &lt;&gt; void A&lt;int&gt;::f(int) { }                     <span class='comment'>// non-template member
</span>template &lt;&gt; template &lt;&gt; void A&lt;int&gt;::f&lt;&gt;(int) { }       <span class='comment'>// template member
</span>
int main() {
  A&lt;char&gt; ac;
  ac.f(1);          <span class='comment'>// non-template
</span>  ac.f('c');        <span class='comment'>// template
</span>  ac.f&lt;&gt;(1);        <span class='comment'>// template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A member function template shall not be virtual.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct AA {
  template &lt;class C&gt; virtual void g(C);   <span class='comment'>// error
</span>  virtual void f();                       <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A specialization of
a member function template does not override a virtual function from a
base class.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class B {
  virtual void f(int);
};

class D : public B {
  template &lt;class T&gt; void f(T); <span class='comment'>// does not override <span class='texttt'>B::f(int)</span>
</span>  void f(int i) { f&lt;&gt;(i); }     <span class='comment'>// overriding function that calls
</span>                                <span class='comment'>// the template instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A specialization of a
conversion function template
is referenced in
the same way as a non-template conversion function that converts to
the same type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T*();
};
template &lt;class T&gt; A::operator T*(){ return 0; }
template &lt;&gt; A::operator char*(){ return 0; }    <span class='comment'>// specialization
</span>template A::operator void*();                   <span class='comment'>// explicit instantiation
</span>
int main() {
  A a;
  int *ip;
  ip = a.operator int*();       <span class='comment'>// explicit call to template operator
</span>                                <span class='comment'>// <span class='texttt'>A::operator int*()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Because the explicit template argument list follows the function template
name, and because conversion member function templates and constructor
member function templates are called without using a function name,
there is no way to provide an explicit template argument list for these
function templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A specialization of a
conversion function template
is not found by name
lookup.
Instead, any
conversion function templates
visible in the
context of the use are considered.
For each such operator, if argument
deduction succeeds (<a href='temp.deduct.conv'>[temp.deduct.conv]</a>), the resulting specialization is
used as if found by name lookup.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> in a derived class cannot refer to a specialization
of a
conversion function template
in a base class.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Overload resolution (<a href='over.ics.rank'>[over.ics.rank]</a>) and partial
ordering (<a href='temp.func.order'>[temp.func.order]</a>) are used to select the best conversion function
among multiple
specializations of conversion function templates
and/or non-template
conversion functions.</p></div></div></div></body></html>