<!DOCTYPE html><html lang='en'><head><title>[stream.iterators]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>24</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><div id='stream.iterators'><h2 ><a class='secnum' style='min-width:88pt'>24.6</a> Stream iterators <a class='abbr_ref'>[stream.iterators]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >To make it possible for algorithmic templates to work directly with input/output streams, appropriate
iterator-like
class templates
are provided.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
partial_sum_copy(istream_iterator&lt;double, char&gt;(cin),
  istream_iterator&lt;double, char&gt;(),
  ostream_iterator&lt;double, char&gt;(cout, "\n"));
</pre><p >reads a file containing floating point numbers from
<span class='texttt'>cin</span>,
and prints the partial sums onto
<span class='texttt'>cout</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='istream.iterator'><h3 ><a class='secnum' href='#istream.iterator' style='min-width:103pt'>24.6.1</a> Class template <span class='texttt'>istream_iterator</span> <a class='abbr_ref' href='istream.iterator'>[istream.iterator]</a></h3><div class='para' id='istream.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator-1'>1</a></div><p ><span class='indexparent'><a class='index' id='istream_iterator'></a></span>The class template
<span class='texttt'>istream_iterator</span>
is an input iterator (<a href='input.iterators'>[input.iterators]</a>) that
reads (using
<span class='texttt'>operator&gt;&gt;</span>)
successive elements from the input stream for which it was constructed.
After it is constructed, and every time
<span class='texttt'>++</span>
is used, the iterator reads and stores a value of
<span class='texttt'>T</span>.
If the iterator fails to read and store a value of <span class='texttt'>T</span>
(<span class='texttt'>fail()</span>
on the stream returns
<span class='texttt'>true</span>),
the iterator becomes equal to the
<a class='hidden_link' href='#def:end-of-stream' id='def:end-of-stream'><i>end-of-stream</i></a>
iterator value.
The constructor with no arguments
<span class='texttt'>istream_iterator()</span>
always constructs
an end-of-stream input iterator object, which is the only legitimate iterator to be used
for the end condition.
The result of
<span class='texttt'>operator*</span>
on an end-of-stream iterator is not defined.
For any other iterator value a
<span class='texttt'>const T&amp;</span>
is returned.
The result of
<span class='texttt'>operator-&gt;</span>
on an end-of-stream iterator is not defined.
For any other iterator value a
<span class='texttt'>const T*</span>
is returned.
The behavior of a program that applies <span class='texttt'>operator++()</span> to an end-of-stream
iterator is undefined.
It is impossible to store things into istream iterators.</p></div><div class='para' id='istream.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator-2'>2</a></div><p >Two end-of-stream iterators are always equal.
An end-of-stream iterator is not
equal to a non-end-of-stream iterator.
Two non-end-of-stream iterators are equal when they are constructed from the same stream.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
      class Distance = ptrdiff_t&gt;
  class istream_iterator:
    public iterator&lt;input_iterator_tag, T, Distance, const T*, const T&amp;&gt; {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream&lt;charT,traits&gt; istream_type;
    <i><span class='texttt'>see below</span></i> istream_iterator();
    istream_iterator(istream_type&amp; s);
    istream_iterator(const istream_iterator&amp; x) = default;
   ~istream_iterator() = default;

    const T&amp; operator*() const;
    const T* operator-&gt;() const;
    istream_iterator&lt;T,charT,traits,Distance&gt;&amp; operator++();
    istream_iterator&lt;T,charT,traits,Distance&gt;  operator++(int);
  private:
    basic_istream&lt;charT,traits&gt;* in_stream; <span class='comment'>// <i>exposition only</i>
</span>    T value;                                <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
            const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
            const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
}
</pre></div><div id='istream.iterator.cons'><h4 ><a class='secnum' href='#istream.iterator.cons' style='min-width:118pt'>24.6.1.1</a> <span class='texttt'>istream_iterator</span> constructors and destructor <a class='abbr_ref' href='istream.iterator.cons'>[istream.iterator.cons]</a></h4><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
<i><span class='texttt'>see below</span></i> istream_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs the end-of-stream iterator. If <span class='texttt'>T</span> is a literal type, then this
constructor shall be a <span class='texttt'>constexpr</span> constructor.</p></div></div><div class='para' id='istream.iterator.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
istream_iterator(istream_type&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <i>in_stream</i> with <span class='texttt'>&amp;s</span>. <i>value</i> may be initialized during
construction or the first time it is referenced.</p></div></div><div class='para' id='istream.iterator.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == &amp;s</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
istream_iterator(const istream_iterator&amp; x) = default;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a copy of <span class='texttt'>x</span>. If <span class='texttt'>T</span> is a literal type, then this constructor shall be a trivial copy constructor.</p></div></div><div class='para' id='istream.iterator.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == x.in_stream</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,destructor'></a></span><code class='itemdecl'>
~istream_iterator() = default;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
The iterator is destroyed. If <span class='texttt'>T</span> is a literal type, then this destructor shall be a trivial destructor.
</p></div></div></div><div id='istream.iterator.ops'><h4 ><a class='secnum' href='#istream.iterator.ops' style='min-width:118pt'>24.6.1.2</a> <span class='texttt'>istream_iterator</span> operations <a class='abbr_ref' href='istream.iterator.ops'>[istream.iterator.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator*'></a></span><code class='itemdecl'>
const T&amp; operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<i>value</i>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator->'></a></span><code class='itemdecl'>
const T* operator-&gt;() const;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>&amp;(operator*())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator++'></a></span><code class='itemdecl'>
istream_iterator&lt;T,charT,traits,Distance&gt;&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>in_stream != 0</span>.</p></div></div><div class='para' id='istream.iterator.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>*in_stream &gt;&gt; value</span>.</p></div></div><div class='para' id='istream.iterator.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator++'></a></span><code class='itemdecl'>
istream_iterator&lt;T,charT,traits,Distance&gt; operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>in_stream != 0</span>.</p></div></div><div class='para' id='istream.iterator.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
istream_iterator&lt;T,charT,traits,Distance&gt; tmp = *this;
*in_stream &gt;&gt; value;
return (tmp);
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator==,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(const istream_iterator&lt;T,charT,traits,Distance&gt; &amp;x,
                  const istream_iterator&lt;T,charT,traits,Distance&gt; &amp;y);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.in_stream == y.in_stream</span>.<span class='indexparent'><a class='index' id='istream_iterator,operator=='></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator!='></a></span><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt; &amp;x,
                  const istream_iterator&lt;T,charT,traits,Distance&gt; &amp;y);
</code></p><p ><span class='indexparent'><a class='index' id='istream_iterator,operator!='></a></span></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>
</p></div></div></div></div><div id='ostream.iterator'><h3 ><a class='secnum' href='#ostream.iterator' style='min-width:103pt'>24.6.2</a> Class template <span class='texttt'>ostream_iterator</span> <a class='abbr_ref' href='ostream.iterator'>[ostream.iterator]</a></h3><div class='para' id='ostream.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ostream_iterator'></a></span><span class='texttt'>ostream_iterator</span>
writes (using
<span class='texttt'>operator&lt;&lt;</span>)
successive elements onto the output stream from which it was constructed.
If it was constructed with
<span class='texttt'>charT*</span>
as a constructor argument, this string, called a
<a class='hidden_link' href='#def:delimiter_string' id='def:delimiter_string'><i>delimiter string</i></a>,
is written to the stream after every
<span class='texttt'>T</span>
is written.
It is not possible to get a value out of the output iterator.
Its only use is as an output iterator in situations like</p><pre class='codeblock'>
while (first != last)
  *result++ = *first++;
</pre></div><div class='para' id='ostream.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator-2'>2</a></div><p ><span class='texttt'>ostream_iterator</span>
is defined as:</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
  class ostream_iterator:
    public iterator&lt;output_iterator_tag, void, void, void, void&gt; {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream&lt;charT,traits&gt; ostream_type;
    ostream_iterator(ostream_type&amp; s);
    ostream_iterator(ostream_type&amp; s, const charT* delimiter);
    ostream_iterator(const ostream_iterator&lt;T,charT,traits&gt;&amp; x);
   ~ostream_iterator();
    ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(const T&amp; value);

    ostream_iterator&lt;T,charT,traits&gt;&amp; operator*();
    ostream_iterator&lt;T,charT,traits&gt;&amp; operator++();
    ostream_iterator&lt;T,charT,traits&gt;&amp; operator++(int);
  private:
    basic_ostream&lt;charT,traits&gt;* out_stream;  <span class='comment'>// <i>exposition only</i>
</span>    const charT* delim;                       <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre></div><div id='ostream.iterator.cons.des'><h4 ><a class='secnum' href='#ostream.iterator.cons.des' style='min-width:118pt'>24.6.2.1</a> <span class='texttt'>ostream_iterator</span> constructors and destructor <a class='abbr_ref' href='ostream.iterator.cons.des'>[ostream.iterator.cons.des]</a></h4><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(ostream_type&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <i>out_stream</i> with <span class='texttt'>&amp;s</span> and <i>delim</i> with null.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(ostream_type&amp; s, const charT* delimiter);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <i>out_stream</i> with <span class='texttt'>&amp;s</span> and <i>delim</i> with <span class='texttt'>delimiter</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(const ostream_iterator&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-3'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a copy of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,destructor'></a></span><code class='itemdecl'>
~ostream_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-4'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
The iterator is destroyed.
</p></div></div></div><div id='ostream.iterator.ops'><h4 ><a class='secnum' href='#ostream.iterator.ops' style='min-width:118pt'>24.6.2.2</a> <span class='texttt'>ostream_iterator</span> operations <a class='abbr_ref' href='ostream.iterator.ops'>[ostream.iterator.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator='></a></span><code class='itemdecl'>
ostream_iterator&amp; operator=(const T&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
*<i>out_stream</i> &lt;&lt; value;
if(delim != 0)
  *<i>out_stream</i> &lt;&lt; <i>delim</i>;
return (*this);
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator*,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator*'></a></span><code class='itemdecl'>
ostream_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator++'></a></span><code class='itemdecl'>
ostream_iterator&amp; operator++();
ostream_iterator&amp; operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div></div><div id='istreambuf.iterator'><h3 ><a class='secnum' href='#istreambuf.iterator' style='min-width:103pt'>24.6.3</a> Class template <span class='texttt'>istreambuf_iterator</span> <a class='abbr_ref' href='istreambuf.iterator'>[istreambuf.iterator]</a></h3><div class='para' id='istreambuf.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator-1'>1</a></div><p >The
class template
<span class='texttt'>istreambuf_iterator</span>
defines an input iterator (<a href='input.iterators'>[input.iterators]</a>) that
reads successive
<i>characters</i>
from the streambuf for which it was constructed.
<span class='texttt'>operator*</span>
provides access to the current input character, if any.
[&nbsp;<i>Note:</i> <span class='texttt'>operator-&gt;</span> may return a proxy. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
Each time
<span class='texttt'>operator++</span>
is evaluated, the iterator advances to the next input character.
If the end of stream is reached (streambuf_type::sgetc() returns
<span class='texttt'>traits::eof()</span>),
the iterator becomes equal to the
<a class='hidden_link' href='#def:end-of-stream' id='def:end-of-stream'><i>end-of-stream</i></a>
iterator value.
The default constructor
<span class='texttt'>istreambuf_iterator()</span>
and the constructor
<span class='texttt'>istreambuf_iterator(0)</span>
both construct an end-of-stream iterator object suitable for use
as an end-of-range.
All specializations of <span class='texttt'>istreambuf_iterator</span> shall have a trivial copy
constructor, a <span class='texttt'>constexpr</span> default constructor, and a trivial destructor.</p></div><div class='para' id='istreambuf.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator-2'>2</a></div><p >The result of
<span class='texttt'>operator*()</span>
on an end-of-stream iterator is undefined.
<span class='indexparent'><a class='index' id='undefined_behavior'></a></span>For any other iterator value a
<span class='texttt'>char_type</span>
value is returned.
It is impossible to assign a character via an input iterator.</p><p ><span class='indexparent'><a class='index' id='istreambuf_iterator'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class istreambuf_iterator
     : public iterator&lt;input_iterator_tag, charT,
                       typename traits::off_type, <i><span class='texttt'>unspecified</span></i>, charT&gt; {
  public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf&lt;charT,traits&gt; streambuf_type;
    typedef basic_istream&lt;charT,traits&gt;   istream_type;

    class proxy;                          <span class='comment'>// <i>exposition only</i>
</span>
    constexpr istreambuf_iterator() noexcept;
    istreambuf_iterator(const istreambuf_iterator&amp;) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type&amp; s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy&amp; p) noexcept;
    charT operator*() const;
    pointer operator-&gt;() const;
    istreambuf_iterator&lt;charT,traits&gt;&amp; operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator&amp; b) const;
  private:
    streambuf_type* sbuf_;                <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
}
</pre></div><div id='istreambuf.iterator::proxy'><h4 ><a class='secnum' href='#istreambuf.iterator::proxy' style='min-width:118pt'>24.6.3.1</a> Class template <span class='texttt'>istreambuf_iterator::proxy</span> <a class='abbr_ref' href='./istreambuf.iterator::proxy'>[istreambuf.iterator::proxy]</a></h4><p ><span class='indexparent'><a class='index' id='proxy,istreambuf_iterator'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class istreambuf_iterator&lt;charT, traits&gt;::proxy {
    charT <i>keep_</i>;
    basic_streambuf&lt;charT,traits&gt;* <i>sbuf_</i>;
    proxy(charT c,
      basic_streambuf&lt;charT,traits&gt;* sbuf)
      : <i>keep_</i>(c), <i>sbuf_</i>(sbuf) { }
  public:
    charT operator*() { return <i>keep_</i>; }
  };
}
</pre><div class='para' id='istreambuf.iterator::proxy-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::proxy-1'>1</a></div><p >Class
<span class='texttt'>istreambuf_iterator&lt;charT,traits&gt;::proxy</span>
is for exposition only.
An implementation is permitted to provide equivalent functionality without
providing a class with this name.
Class
<span class='texttt'>istreambuf_iterator&lt;charT, traits&gt;::proxy</span>
provides a temporary
placeholder as the return value of the post-increment operator
(<span class='texttt'>operator++</span>).
It keeps the character pointed to by the previous value
of the iterator for some possible future access to get the character.</p></div></div><div id='istreambuf.iterator.cons'><h4 ><a class='secnum' href='#istreambuf.iterator.cons' style='min-width:118pt'>24.6.3.2</a> <span class='texttt'>istreambuf_iterator</span> constructors <a class='abbr_ref' href='istreambuf.iterator.cons'>[istreambuf.iterator.cons]</a></h4><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
constexpr istreambuf_iterator() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs the end-of-stream iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
istreambuf_iterator(basic_istream&lt;charT,traits&gt;&amp; s) noexcept;
istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an
<span class='texttt'>istreambuf_iterator&lt;&gt;</span>
that uses the
<span class='texttt'>basic_streambuf&lt;&gt;</span>
object
<span class='texttt'>*(s.rdbuf())</span>,
or
<span class='texttt'>*s</span>,
respectively.
Constructs an end-of-stream iterator if
<span class='texttt'>s.rdbuf()</span>
is null.
</p></div></div><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
istreambuf_iterator(const proxy&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>istreambuf_iterator&lt;&gt;</span>
that uses the
<span class='texttt'>basic_streambuf&lt;&gt;</span>
object pointed to by the
<span class='texttt'>proxy</span>
object's constructor argument <span class='texttt'>p</span>.
</p></div></div></div><div id='istreambuf.iterator::op*'><h4 ><a class='secnum' href='#istreambuf.iterator::op*' style='min-width:118pt'>24.6.3.3</a> <span class='texttt'>istreambuf_iterator::operator*</span> <a class='abbr_ref' href='./istreambuf.iterator::op*'>[istreambuf.iterator::op*]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,istreambuf_iterator'></a></span><code class='itemdecl'>
charT operator*() const
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op*-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op*-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The character obtained via the
<span class='texttt'>streambuf</span>
member
<span class='texttt'><i>sbuf_</i>-&gt;sgetc()</span>.
</p></div></div></div><div id='istreambuf.iterator::op++'><h4 ><a class='secnum' href='#istreambuf.iterator::op++' style='min-width:118pt'>24.6.3.4</a> <span class='texttt'>istreambuf_iterator::operator++</span> <a class='abbr_ref' href='./istreambuf.iterator::op++'>[istreambuf.iterator::op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,istreambuf_iterator'></a></span><code class='itemdecl'>
istreambuf_iterator&lt;charT,traits&gt;&amp;
    istreambuf_iterator&lt;charT,traits&gt;::operator++();
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op++-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'><i>sbuf_</i>-&gt;sbumpc()</span>.</p></div></div><div class='para' id='istreambuf.iterator::op++-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istreambuf_iterator'></a></span><span class='indexparent'><a class='index' id='istreambuf_iterator,operator++'></a></span><code class='itemdecl'>
proxy istreambuf_iterator&lt;charT,traits&gt;::operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op++-3'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>proxy(<i>sbuf_</i>-&gt;sbumpc(), <i>sbuf_</i>)</span>.
</p></div></div></div><div id='istreambuf.iterator::equal'><h4 ><a class='secnum' href='#istreambuf.iterator::equal' style='min-width:118pt'>24.6.3.5</a> <span class='texttt'>istreambuf_iterator::equal</span> <a class='abbr_ref' href='./istreambuf.iterator::equal'>[istreambuf.iterator::equal]</a></h4><p ><span class='indexparent'><a class='index' id='equal,istreambuf_iterator'></a></span><code class='itemdecl'>
bool equal(const istreambuf_iterator&lt;charT,traits&gt;&amp; b) const;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::equal-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::equal-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if and only if both iterators are at end-of-stream,
or neither is at end-of-stream, regardless of what
<span class='texttt'>streambuf</span>
object they use.
</p></div></div></div><div id='istreambuf.iterator::op=='><h4 ><a class='secnum' href='#istreambuf.iterator::op==' style='min-width:118pt'>24.6.3.6</a> <span class='texttt'>operator==</span> <a class='abbr_ref' href='./istreambuf.iterator::op=='>[istreambuf.iterator::op==]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,istreambuf_iterator'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op==-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op==-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>a.equal(b)</span>.
</p></div></div></div><div id='istreambuf.iterator::op!='><h4 ><a class='secnum' href='#istreambuf.iterator::op!=' style='min-width:118pt'>24.6.3.7</a> <span class='texttt'>operator!=</span> <a class='abbr_ref' href='./istreambuf.iterator::op!='>[istreambuf.iterator::op!=]</a></h4><p ><span class='indexparent'><a class='index' id='operator!=,istreambuf_iterator'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op!=-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op!=-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!a.equal(b)</span>.
</p></div></div></div></div><div id='ostreambuf.iterator'><h3 ><a class='secnum' href='#ostreambuf.iterator' style='min-width:103pt'>24.6.4</a> Class template <span class='texttt'>ostreambuf_iterator</span> <a class='abbr_ref' href='ostreambuf.iterator'>[ostreambuf.iterator]</a></h3><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class ostreambuf_iterator :
    public iterator&lt;output_iterator_tag, void, void, void, void&gt; {
  public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf&lt;charT,traits&gt; streambuf_type;
    typedef basic_ostream&lt;charT,traits&gt;   ostream_type;

  public:
    ostreambuf_iterator(ostream_type&amp; s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator&amp; operator=(charT c);

    ostreambuf_iterator&amp; operator*();
    ostreambuf_iterator&amp; operator++();
    ostreambuf_iterator&amp; operator++(int);
    bool failed() const noexcept;

  private:
    streambuf_type* sbuf_;                <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre><div class='para' id='ostreambuf.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iterator-1'>1</a></div><p >The
class template
<span class='texttt'>ostreambuf_iterator</span>
writes successive
<i>characters</i>
onto the output stream from which it was constructed.
It is not possible to get a character value out of the output iterator.</p></div><div id='ostreambuf.iter.cons'><h4 ><a class='secnum' href='#ostreambuf.iter.cons' style='min-width:118pt'>24.6.4.1</a> <span class='texttt'>ostreambuf_iterator</span> constructors <a class='abbr_ref' href='ostreambuf.iter.cons'>[ostreambuf.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator,constructor'></a></span><code class='itemdecl'>
ostreambuf_iterator(ostream_type&amp; s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s.rdbuf()</span>
shall not null pointer.
</p></div></div><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>:sbuf_(s.rdbuf()) {}</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator,constructor'></a></span><code class='itemdecl'>
ostreambuf_iterator(streambuf_type* s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s</span>
shall not be a null pointer.</p></div></div><div class='para' id='ostreambuf.iter.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>: <i>sbuf_</i>(s) {}</span>.
</p></div></div></div><div id='ostreambuf.iter.ops'><h4 ><a class='secnum' href='#ostreambuf.iter.ops' style='min-width:118pt'>24.6.4.2</a> <span class='texttt'>ostreambuf_iterator</span> operations <a class='abbr_ref' href='ostreambuf.iter.ops'>[ostreambuf.iter.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&lt;charT,traits&gt;&amp;
  operator=(charT c);
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>failed()</span>
yields
<span class='texttt'>false</span>,
calls
<span class='texttt'><i>sbuf_</i>-&gt;sputc(c)</span>;
otherwise has no effect.</p></div></div><div class='para' id='ostreambuf.iter.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&lt;charT,traits&gt;&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&lt;charT,traits&gt;&amp; operator++();
ostreambuf_iterator&lt;charT,traits&gt;&amp; operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='failed,ostreambuf_iterator'></a></span><code class='itemdecl'>
bool failed() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if in any prior use of member
<span class='texttt'>operator=</span>,
the call to
<span class='texttt'><i>sbuf_</i>-&gt;sputc()</span>
returned
<span class='texttt'>traits::eof()</span>;
or
<span class='texttt'>false</span>
otherwise.
</p></div></div></div></div><div id='iterator.range'><h3 ><a class='secnum' href='#iterator.range' style='min-width:103pt'>24.6.5</a> range access <a class='abbr_ref' href='iterator.range'>[iterator.range]</a></h3><div class='para' id='iterator.range-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range-1'>1</a></div><p >In addition to being available via inclusion of the <span class='texttt'>&lt;iterator&gt;</span> header,
the function templates in <a href='iterator.range'>[iterator.range]</a> are available when any of the following
headers are included: <span class='texttt'>&lt;array&gt;</span>, <span class='texttt'>&lt;deque&gt;</span>, <span class='texttt'>&lt;forward_list&gt;</span>,
<span class='texttt'>&lt;list&gt;</span>, <span class='texttt'>&lt;map&gt;</span>, <span class='texttt'>&lt;regex&gt;</span>, <span class='texttt'>&lt;set&gt;</span>, <span class='texttt'>&lt;string&gt;</span>,
<span class='texttt'>&lt;unordered_map&gt;</span>, <span class='texttt'>&lt;unordered_set&gt;</span>, and <span class='texttt'>&lt;vector&gt;</span>.</p><p ><span class='indexparent'><a class='index' id='begin(C&)'></a></span><code class='itemdecl'>
template &lt;class C&gt; auto begin(C&amp; c) -&gt; decltype(c.begin());
template &lt;class C&gt; auto begin(const C&amp; c) -&gt; decltype(c.begin());
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.range-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c.begin()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='end(C&)'></a></span><code class='itemdecl'>
template &lt;class C&gt; auto end(C&amp; c) -&gt; decltype(c.end());
template &lt;class C&gt; auto end(const C&amp; c) -&gt; decltype(c.end());
</code></p><div class='itemdescr'></div><div class='para' id='iterator.range-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c.end()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='begin(T_(&)[N])'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt; T* begin(T (&amp;array)[N]);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.range-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>array</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='end(T_(&)[N])'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.range-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>array + N</span>.
</p></div></div></div></div></div></body></html>