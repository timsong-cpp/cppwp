<!DOCTYPE html><html lang='en'><head><title>[namespace.udir]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.3</a> Namespaces <a class='abbr_ref' href='basic.namespace#namespace.udir'>[basic.namespace]</a></h2><div id='namespace.udir'><h3 ><a class='secnum' style='min-width:103pt'>7.3.4</a> Using directive <a class='abbr_ref'>[namespace.udir]</a></h3><p ><span class='indexparent'><a class='index' id='using-directive'></a></span></p><pre class='bnf'><a id='nt:using-directive'>using-directive:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>using  namespace</span> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> <span class='terminal'>;</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> shall not appear in class scope, but may
appear in namespace scope or in block scope.
[&nbsp;<i>Note:</i>
When looking up a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> in a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>, only namespace names are considered,
see <a href='basic.lookup.udir'>[basic.lookup.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> specifies that the names in the nominated
namespace can be used in the scope in which the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> appears after the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.
During unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the names
appear as if they were declared in the nearest enclosing namespace which
contains both the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> and the nominated
namespace.
[&nbsp;<i>Note:</i>
In this context, “contains” means “contains directly or indirectly”.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> does not add any members to the declarative
region in which it appears.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  int i;
  namespace B {
    namespace C {
      int i;
    }
    using namespace A::B::C;
    void f1() {
      i = 5;        <span class='comment'>// OK, <span class='texttt'>C::i</span> visible in <span class='texttt'>B</span> and hides <span class='texttt'>A::i</span>
</span>    }
  }
  namespace D {
    using namespace B;
    using namespace C;
    void f2() {
      i = 5;        <span class='comment'>// ambiguous, <span class='texttt'>B::C::i</span> or <span class='texttt'>A::i</span>?
</span>    }
  }
  void f3() {
    i = 5;          <span class='comment'>// uses <span class='texttt'>A::i</span>
</span>  }
}
void f4() {
  i = 5;            <span class='comment'>// ill-formed; neither <span class='texttt'>i</span> is visible
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> is transitive: if a scope contains a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> that nominates a second namespace that itself
contains <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>, the effect is as if the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> from the second namespace also appeared in
the first.
[&nbsp;<i>Note:</i> For qualified lookup, see <a href='namespace.qual'>[namespace.qual]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace M {
  int i;
}

namespace N {
  int i;
  using namespace M;
}

void f() {
  using namespace N;
  i = 7;            <span class='comment'>// error: both <span class='texttt'>M::i</span> and <span class='texttt'>N::i</span> are visible
</span>}
</pre><p >For another example,</p><pre class='codeblock'>
namespace A {
  int i;
}
namespace B {
  int i;
  int j;
  namespace C {
    namespace D {
      using namespace A;
      int j;
      int k;
      int a = i;    <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    }
    using namespace D;
    int k = 89;     <span class='comment'>// no problem yet
</span>    int l = k;      <span class='comment'>// ambiguous: <span class='texttt'>C::k</span> or <span class='texttt'>D::k</span>
</span>    int m = i;      <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    int n = j;      <span class='comment'>// <span class='texttt'>D::j</span> hides <span class='texttt'>B::j</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If a namespace is extended by an
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> after a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> for that namespace is given, the additional
members of the extended namespace and the members of namespaces
nominated by <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> can be used after the
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If name lookup finds a declaration for a name in two different
namespaces, and the declarations do not declare the same entity and do
not declare functions, the use of the name is ill-formed.
[&nbsp;<i>Note:</i>
In particular, the name of a variable, function or enumerator does not
hide the name of a class or enumeration declared in a different
namespace. For example,</p><pre class='codeblock'>
namespace A {
  class X { };
  extern "C"   int g();
  extern "C++" int h();
}
namespace B {
  void X(int);
  extern "C"   int g();
  extern "C++" int h(int);
}
using namespace A;
using namespace B;

void f() {
  X(1);             <span class='comment'>// error: name <span class='texttt'>X</span> found in two namespaces
</span>  g();              <span class='comment'>// okay: name <span class='texttt'>g</span> refers to the same entity
</span>  h();              <span class='comment'>// okay: overload resolution selects <span class='texttt'>A::h</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='overloading,using_directive_and'></a></span>During overload resolution, all functions from the transitive search are
considered for argument matching. The set of declarations found by the
transitive search is unordered.
[&nbsp;<i>Note:</i>
In particular, the order in which namespaces were considered and the
relationships among the namespaces implied by the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> do not cause preference to be given to any
of the declarations found by the search.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An ambiguity exists if the best match finds two functions with the same
signature, even if one is in a namespace reachable through
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the namespace of the other.<a class='footnotenum' href='#footnote-96'>96</a>
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace D {
  int d1;
  void f(char);
}
using namespace D;

int d1;             <span class='comment'>// OK: no conflict with <span class='texttt'>D::d1</span>
</span>
namespace E {
  int e;
  void f(int);
}

namespace D {       <span class='comment'>// namespace extension
</span>  int d2;
  using namespace E;
  void f(int);
}

void f() {
  d1++;             <span class='comment'>// error: ambiguous <span class='texttt'>::d1</span> or <span class='texttt'>D::d1</span>?
</span>  ::d1++;           <span class='comment'>// OK
</span>  D::d1++;          <span class='comment'>// OK
</span>  d2++;             <span class='comment'>// OK: <span class='texttt'>D::d2</span>
</span>  e++;              <span class='comment'>// OK: <span class='texttt'>E::e</span>
</span>  f(1);             <span class='comment'>// error: ambiguous: <span class='texttt'>D::f(int)</span> or <span class='texttt'>E::f(int)</span>?
</span>  f('a');           <span class='comment'>// OK: <span class='texttt'>D::f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='using-directive'></a></span><span class='indexparent'><a class='index' id='namespaces'></a></span></p></div><div class='footnote' id='footnote-96'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-96'>96)</a></div><p >During
name lookup in a class hierarchy, some ambiguities may be
resolved by considering whether one member hides the other along some
paths (<a href='class.member.lookup'>[class.member.lookup]</a>). There is no such disambiguation when
considering the set of names found as a result of following
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>.</p></div></div></div></body></html>