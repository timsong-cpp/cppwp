<!DOCTYPE html><html lang='en'><head><title>[expr.unary]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><div id='expr.unary'><h2 ><a class='secnum' style='min-width:88pt'>5.3</a> Unary expressions <a class='abbr_ref'>[expr.unary]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,unary'></a></span>Expressions with unary operators group right-to-left.</p><p ><span class='indexparent'><a class='index' id='expression,unary'></a></span><span class='indexparent'><a class='index' id='operator,unary'></a></span><span class='indexparent'><a class='index' id='operator,sizeof'></a></span><span class='indexparent'><a class='index' id='operator,cast'></a></span></p><pre class='bnf'><a id='nt:unary-expression'>unary-expression:</a>
    <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
    <span class='terminal'>++</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>--</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <i ><a href='expr.unary#nt:unary-operator'>unary-operator</a></i> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>sizeof</span> <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
    <span class='terminal'>sizeof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
    <span class='terminal'>sizeof ...</span> <span class='terminal'>(</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span>
    <span class='terminal'>alignof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
    <i ><a href='expr.unary.noexcept#nt:noexcept-expression'>noexcept-expression</a></i>
    <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
    <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i></pre><p ><span class='indexparent'><a class='index' id='operator,indirection'></a></span><span class='indexparent'><a class='index' id='*'></a></span><span class='indexparent'><a class='index' id='operator,address-of'></a></span><span class='indexparent'><a class='index' id='&'></a></span><span class='indexparent'><a class='index' id='operator,unary_minus'></a></span><span class='indexparent'><a class='index' id='-'></a></span><span class='indexparent'><a class='index' id='operator,unary_plus'></a></span><span class='indexparent'><a class='index' id='+'></a></span><span class='indexparent'><a class='index' id='operator,logical_negation'></a></span><span class='indexparent'><a class='index' id='!'></a></span><span class='indexparent'><a class='index' id='operator,one&#39;s_complement'></a></span><span class='indexparent'><a class='index' id='_'></a></span><span class='indexparent'><a class='index' id='operator,increment'></a></span><span class='indexparent'><a class='index' id='operator,decrement'></a></span></p><pre class='bnf'><a id='nt:unary-operator'>unary-operator:</a> <span class='textnormal'>one of</span>
    <span class='terminal'>*  &amp;  +  -  !  ~</span></pre></div><div id='op'><h3 ><a class='secnum' href='#op' style='min-width:103pt'>5.3.1</a> Unary operators <a class='abbr_ref' href='expr.unary.op'>[expr.unary.op]</a></h3><div class='para' id='op-1'><div class='marginalizedparent'><a class='marginalized' href='#op-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,unary_operator'></a></span><span class='indexparent'><a class='index' id='operator,unary'></a></span>The unary <span class='texttt'>*</span> operator performs <a class='hidden_link' href='#def:indirection' id='def:indirection'><i>indirection</i></a>:
<span class='indexparent'><a class='index' id='dereferencing'></a></span><span class='indexparent'><a class='index' id='indirection'></a></span>the expression to which it is applied shall be a pointer to an object
type, or a pointer to a function type and the result is an lvalue
referring to the object or function to which the expression points. If
the type of the expression is “pointer to <span class='texttt'>T</span>,” the type of the
result is “<span class='texttt'>T</span>.”
[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>a pointer to an incomplete type (other than <i>cv</i> <span class='texttt'>void</span>)
can be dereferenced. The lvalue thus obtained can be used in limited
ways (to initialize a reference, for example); this lvalue must not be
converted to a prvalue, see <a href='conv.lval'>[conv.lval]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='op-2'><div class='marginalizedparent'><a class='marginalized' href='#op-2'>2</a></div><p >The result of each of the following unary operators is a prvalue.</p></div><div class='para' id='op-3'><div class='marginalizedparent'><a class='marginalized' href='#op-3'>3</a></div><p ><span class='indexparent'><a class='index' id='name,address_of_cv-qualified'></a></span><span class='indexparent'><a class='index' id='expression,pointer_to_member_constant'></a></span>The result of the unary <span class='texttt'>&amp;</span> operator is a pointer to its operand.
The operand shall be an lvalue or a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>.
If the operand is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> naming a non-static member <span class='texttt'>m</span>
of some class <span class='texttt'>C</span> with type <span class='texttt'>T</span>, the result has type “pointer to member
of class <span class='texttt'>C</span> of type <span class='texttt'>T</span>” and is a prvalue designating <span class='texttt'>C::m</span>.
Otherwise, if the type of the expression is <span class='texttt'>T</span>, the result has type “pointer to
<span class='texttt'>T</span>” and is a prvalue that is the address of the designated object (<a href='intro.memory'>[intro.memory]</a>)
or a pointer to the designated function. [&nbsp;<i>Note:</i> In particular, the address of an
object of type “<i>cv</i> <span class='texttt'>T</span>” is “pointer to <i>cv</i> <span class='texttt'>T</span>”, with the same
cv-qualification. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
struct A { int i; };
struct B : A { };
... &amp;B::i ...       <span class='comment'>// has type <span class='texttt'>int A::*</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
a pointer to member formed from a <span class='texttt'>mutable</span> non-static data
member (<a href='dcl.stc'>[dcl.stc]</a>) does not reflect the <span class='texttt'>mutable</span> specifier
associated with the non-static data member.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='op-4'><div class='marginalizedparent'><a class='marginalized' href='#op-4'>4</a></div><p >A pointer to member is only formed when an explicit <span class='texttt'>&amp;</span> is used
and its operand is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> not enclosed in
parentheses.
[&nbsp;<i>Note:</i> 
that is, the expression <span class='texttt'>&amp;(qualified-id)</span>, where the
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is enclosed in parentheses, does not form an
expression of type “pointer to member.” Neither does
<span class='texttt'>qualified-id</span>, because there is no implicit conversion from a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> for a non-static member function to the type
“pointer to member function” as there is from an lvalue of function
type to the type “pointer to function” (<a href='conv.func'>[conv.func]</a>). Nor is
<span class='texttt'>&amp;unqualified-id</span> a pointer to member, even within the scope of
the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i>'s class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='op-5'><div class='marginalizedparent'><a class='marginalized' href='#op-5'>5</a></div><p >The address of an object of incomplete type can be taken, but if the
complete type of that object is a class type that declares
<span class='texttt'>operator&amp;()</span> as a member function, then the behavior is
undefined (and no diagnostic is required). The operand of <span class='texttt'>&amp;</span>
shall not be a bit-field.</p></div><div class='para' id='op-6'><div class='marginalizedparent'><a class='marginalized' href='#op-6'>6</a></div><p ><span class='indexparent'><a class='index' id='overloaded_function,address_of'></a></span>The address of an overloaded function (Clause <a href='over'>[over]</a>) can be taken
only in a context that uniquely determines which version of the
overloaded function is referred to (see <a href='over.over'>[over.over]</a>).
[&nbsp;<i>Note:</i> 
since the context might determine whether the operand is a static or
non-static member function, the context can also affect whether the
expression has type “pointer to function” or “pointer to member
function.”
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='op-7'><div class='marginalizedparent'><a class='marginalized' href='#op-7'>7</a></div><p ><span class='indexparent'><a class='index' id='operator,unary_plus'></a></span>The operand of the unary <span class='texttt'>+</span> operator shall have arithmetic, unscoped
enumeration, or pointer type and the result is the value of the
argument. Integral promotion is performed on integral or enumeration
operands. The type of the result is the type of the promoted operand.</p></div><div class='para' id='op-8'><div class='marginalizedparent'><a class='marginalized' href='#op-8'>8</a></div><p ><span class='indexparent'><a class='index' id='operator,unary_minus'></a></span>The operand of the unary <span class='texttt'>-</span> operator shall have arithmetic or unscoped
enumeration type and the result is the negation of its operand. Integral
promotion is performed on integral or enumeration operands. The negative
of an unsigned quantity is computed by subtracting its value from <span class='math'>2<sup ><span class='mathalpha'>n</span></sup></span>,
where <span class='math'><span class='mathalpha'>n</span></span> is the number of bits in the promoted operand. The type of the
result is the type of the promoted operand.</p></div><div class='para' id='op-9'><div class='marginalizedparent'><a class='marginalized' href='#op-9'>9</a></div><p ><span class='indexparent'><a class='index' id='operator,logical_negation'></a></span>The operand of the logical negation operator <span class='texttt'>!</span> is contextually
converted to <span class='texttt'>bool</span>
(Clause <a href='conv'>[conv]</a>); its value is <span class='texttt'>true</span>
if the converted operand is <span class='texttt'>false</span> and <span class='texttt'>false</span> otherwise.
The type of the result is <span class='texttt'>bool</span>.</p></div><div class='para' id='op-10'><div class='marginalizedparent'><a class='marginalized' href='#op-10'>10</a></div><p ><span class='indexparent'><a class='index' id='operator,one&#39;s_complement'></a></span>The operand of <span class='texttt'>~</span> shall have integral or unscoped enumeration type; the
result is the one's complement of its operand. Integral promotions are
performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='texttt'>~X()</span>, where <span class='texttt'>X</span> is a <i ><a href='class#nt:class-name'>class-name</a></i> or <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.
The
ambiguity is resolved in favor of treating <span class='texttt'>~</span> as a unary
complement rather than treating <span class='texttt'>~X</span> as referring to a
destructor.</p></div></div><div id='expr.pre.incr'><h3 ><a class='secnum' href='#expr.pre.incr' style='min-width:103pt'>5.3.2</a> Increment and decrement <a class='abbr_ref' href='expr.pre.incr'>[expr.pre.incr]</a></h3><div class='para' id='expr.pre.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#expr.pre.incr-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,increment'></a></span><span class='indexparent'><a class='index' id='expression,decrement'></a></span>The operand of prefix <span class='texttt'>++</span>
<span class='indexparent'><a class='index' id='operator,increment'></a></span><span class='indexparent'><a class='index' id='prefix_++'></a></span>is modified by adding <span class='texttt'>1</span>,
<span class='indexparent'><a class='index' id='increment,bool'></a></span><span class='indexparent'><a class='index' id='prefix_--'></a></span><span class='indexparent'><a class='index' id='deprecated_features'></a></span>or set to <span class='texttt'>true</span> if it is <span class='texttt'>bool</span> (this use is deprecated).
The operand shall be a modifiable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a completely-defined object type.
The result is the updated operand; it is an lvalue, and it is a
bit-field if the operand is a bit-field. If <span class='texttt'>x</span> is not of type
<span class='texttt'>bool</span>, the expression <span class='texttt'>++x</span> is equivalent to <span class='texttt'>x+=1</span>
<span class='indexparent'><a class='index' id='operator,+='></a></span>[&nbsp;<i>Note:</i>
See the discussions of addition (<a href='expr.add'>[expr.add]</a>) and assignment
operators (<a href='expr.ass'>[expr.ass]</a>) for information on conversions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.pre.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#expr.pre.incr-2'>2</a></div><p >The operand of prefix
<span class='indexparent'><a class='index' id='operator,decrement'></a></span><span class='texttt'>--</span> is modified by subtracting <span class='texttt'>1</span>. The operand shall not
be of type <span class='texttt'>bool</span>. The requirements on the operand of prefix
<span class='texttt'>--</span> and the properties of its result are otherwise the same as
those of prefix <span class='texttt'>++</span>.
[&nbsp;<i>Note:</i> 
For postfix increment and decrement, see <a href='expr.post.incr'>[expr.post.incr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div></div><div id='expr.sizeof'><h3 ><a class='secnum' href='#expr.sizeof' style='min-width:103pt'>5.3.3</a> Sizeof <a class='abbr_ref' href='expr.sizeof'>[expr.sizeof]</a></h3><div class='para' id='expr.sizeof-1'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,sizeof'></a></span><span class='indexparent'><a class='index' id='operator,sizeof'></a></span><span class='indexparent'><a class='index' id='byte'></a></span>The <span class='texttt'>sizeof</span> operator yields the number of bytes in the object
representation of its operand. The operand is either an expression,
which is an unevaluated operand (Clause <a href='expr'>[expr]</a>), or a parenthesized
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>.
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>The <span class='texttt'>sizeof</span> operator shall not be applied to an expression that
has function or incomplete type, to an enumeration type whose underlying type is not fixed before all
its enumerators have been declared, to the parenthesized name of such
types, or to an lvalue that designates a bit-field.
<span class='texttt'>sizeof(char)</span>, <span class='texttt'>sizeof(signed char)</span> and
<span class='texttt'>sizeof(unsigned char)</span> are <span class='texttt'>1</span>. The result of
<span class='texttt'>sizeof</span> applied to any other fundamental
type (<a href='basic.fundamental'>[basic.fundamental]</a>) is <span class='indexparent'><a class='index' id='sizeof_applied'></a></span>implementation-defined.
[&nbsp;<i>Note:</i> 
in particular, <span class='texttt'>sizeof(bool)</span>, <span class='texttt'>sizeof(char16_t)</span>,
<span class='texttt'>sizeof(char32_t)</span>, and <span class='texttt'>sizeof(wchar_t)</span> are
implementation-defined.<a class='footnotenum' href='#footnote-74'>74</a>
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
See <a href='intro.memory'>[intro.memory]</a> for the definition of <a class='hidden_link' href='#def:byte' id='def:byte'><i>byte</i></a>
and <a href='basic.types'>[basic.types]</a> for the definition of <a class='hidden_link' href='#def:object_representation' id='def:object_representation'><i>object representation</i></a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.sizeof-2'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-2'>2</a></div><p ><span class='indexparent'><a class='index' id='reference,sizeof'></a></span>When applied to a reference or a reference type, the result is the size
of the referenced type.
<span class='indexparent'><a class='index' id='class_object,sizeof'></a></span>When applied to a class, the result is the number of bytes in an object
of that class including any padding required for placing objects of that
type in an array. The size of a most derived class shall be greater than
zero (<a href='intro.object'>[intro.object]</a>). The result of applying <span class='texttt'>sizeof</span> to a
base class subobject is the size of the base class type.<a class='footnotenum' href='#footnote-75'>75</a>
<span class='indexparent'><a class='index' id='array,sizeof'></a></span>When applied to an array, the result is the total number of bytes in the
array. This implies that the size of an array of <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> elements is
<a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> times the size of an element.</p></div><div class='para' id='expr.sizeof-3'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-3'>3</a></div><p >The <span class='texttt'>sizeof</span> operator can be applied to a pointer to a function,
but shall not be applied directly to a function.</p></div><div class='para' id='expr.sizeof-4'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-4'>4</a></div><p >The lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>), and
function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard conversions are not
applied to the operand of <span class='texttt'>sizeof</span>.</p></div><div class='para' id='expr.sizeof-5'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-5'>5</a></div><p >The identifier in a <span class='texttt'>sizeof...</span> expression shall name a parameter
pack. The <span class='texttt'>sizeof...</span> operator yields the number of arguments
provided for the parameter pack <i ><a href='lex.name#nt:identifier'>identifier</a></i>.
A <span class='texttt'>sizeof...</span> expression is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class... Types&gt;
struct count {
  static const std::size_t value = sizeof...(Types);
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expr.sizeof-6'><div class='marginalizedparent'><a class='marginalized' href='#expr.sizeof-6'>6</a></div><p >The result of <span class='texttt'>sizeof</span> and <span class='texttt'>sizeof...</span> is a constant of type
<span class='texttt'>std::size_t</span>.
[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='size_t'></a></span><span class='indexparent'><a class='index' id='size_t'></a></span><span class='texttt'>std::size_t</span> is defined in the standard header
<span class='indexparent'><a class='index' id='cstddef'></a></span><span class='texttt'>&lt;cstddef&gt;</span> (<a href='support.types'>[support.types]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='footnote' id='footnote-74'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-74'>74)</a></div><p ><span class='texttt'>sizeof(bool)</span> is not required to be <span class='texttt'>1</span>.</p></div><div class='footnote' id='footnote-75'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-75'>75)</a></div><p >The actual
size of a base class subobject may be less than the result of
applying <span class='texttt'>sizeof</span> to the subobject, due to virtual base classes
and less strict padding requirements on base class subobjects.</p></div></div><div id='expr.new'><h3 ><a class='secnum' href='#expr.new' style='min-width:103pt'>5.3.4</a> New <a class='abbr_ref' href='expr.new'>[expr.new]</a></h3><div class='para' id='expr.new-1'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,new'></a></span><span class='indexparent'><a class='index' id='free_store'></a></span><span class='indexparent'><a class='index' id='memory_management'></a></span><span class='indexparent'><a class='index' id='storage_management'></a></span><span class='indexparent'><a class='index' id='new'></a></span>The <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> attempts to create an object of the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i> (<a href='dcl.name'>[dcl.name]</a>) or <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> to which
it is applied. The type of that object is the <a class='hidden_link' href='#def:allocated_type' id='def:allocated_type'><i>allocated type</i></a>.
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>This type shall be a complete object type, but not an abstract class
type or array
thereof (<a href='intro.object'>[intro.object]</a>, <a href='basic.types'>[basic.types]</a>, <a href='class.abstract'>[class.abstract]</a>).
It is <span class='indexparent'><a class='index' id='support_for_over-aligned_types'></a></span>implementation-defined whether over-aligned types are
supported (<a href='basic.align'>[basic.align]</a>).
[&nbsp;<i>Note:</i> 
because references are not objects, references cannot be created by
<i ><a href='expr.new#nt:new-expression'>new-expressions</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
the <i ><a href='dcl.name#nt:type-id'>type-id</a></i> may be a cv-qualified type, in which case the
object created by the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> has a cv-qualified type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p><pre class='bnf'><a id='nt:new-expression'>new-expression:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> 
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p ><span class='indexparent'><a class='index' id='new,storage_allocation'></a></span></p><pre class='bnf'><a id='nt:new-placement'>new-placement:</a>
    <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:new-type-id'>new-type-id:</a>
    <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> <i ><a href='expr.new#nt:new-declarator'>new-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:new-declarator'>new-declarator:</a>
    <i ><a href='dcl.decl#nt:ptr-operator'>ptr-operator</a></i> <i ><a href='expr.new#nt:new-declarator'>new-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> 
    <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i></pre><pre class='bnf'><a id='nt:noptr-new-declarator'>noptr-new-declarator:</a>
    <span class='terminal'>[</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>]</span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> <span class='terminal'>[</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>]</span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:new-initializer'>new-initializer:</a>
    <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><p ><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span>Entities created by a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> have dynamic storage
duration (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>).
[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='new,scoping_and'></a></span>the lifetime of such an entity is not necessarily restricted to the
scope in which it is created.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
If the entity is a non-array object, the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
returns a pointer to the object created. If it is an array, the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> returns a pointer to the initial element of
the array.</p></div><div class='para' id='expr.new-2'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-2'>2</a></div><p >If the <span class='texttt'>auto</span> <span class='small'></span><span class='rmfamily'></span><i> type-specifier</i> appears in the
<span class='small'></span><span class='rmfamily'></span><i> type-specifier-seq</i> of a <span class='small'></span><span class='rmfamily'></span><i> new-type-id</i> or
<span class='small'></span><span class='rmfamily'></span><i> type-id</i> of a <span class='small'></span><span class='rmfamily'></span><i> new-expression</i>,
the <span class='small'></span><span class='rmfamily'></span><i> new-expression</i> shall contain a
<span class='small'></span><span class='rmfamily'></span><i> new-initializer</i> of the form</p><pre class='bnf'><span class='terminal'>(</span> <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> <span class='terminal'>)</span></pre><p >The allocated type is deduced from the <span class='small'></span><span class='rmfamily'></span><i> new-initializer</i> as
follows: Let <span class='texttt'>e</span> be the <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> in the <span class='small'></span><span class='rmfamily'></span><i> new-initializer</i> and
<span class='texttt'>T</span> be the <span class='small'></span><span class='rmfamily'></span><i> new-type-id</i> or <span class='small'></span><span class='rmfamily'></span><i> type-id</i> of
the <span class='small'></span><span class='rmfamily'></span><i> new-expression</i>, then the allocated type is the type
deduced for the variable <span class='texttt'>x</span> in the invented
declaration (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>):</p><pre class='codeblock'>
T x(e);
</pre><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
new auto(1);                    <span class='comment'>// allocated type is <span class='texttt'>int</span>
</span>auto x = new auto('a');         <span class='comment'>// allocated type is <span class='texttt'>char</span>, <span class='texttt'>x</span> is of type <span class='texttt'>char*</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expr.new-3'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-3'>3</a></div><p >The <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> in a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> is the longest
possible sequence of <i ><a href='expr.new#nt:new-declarator'>new-declarators</a></i>.
[&nbsp;<i>Note:</i> 
this prevents ambiguities between the declarator operators <span class='texttt'>&amp;</span>, <span class='texttt'>&amp;&amp;</span>,
<span class='texttt'>*</span>, and <span class='texttt'>[]</span> and their expression counterparts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
new int * i;                    <span class='comment'>// syntax error: parsed as <span class='texttt'>(new int*) i</span>, not as <span class='texttt'>(new int)*i</span>
</span></pre><p >The <span class='texttt'>*</span> is the pointer declarator and not the multiplication
operator.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='expr.new-4'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-4'>4</a></div><p >[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='ambiguity,parentheses_and'></a></span>parentheses in a <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> of a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
can have surprising effects.
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
new int(*[10])();               <span class='comment'>// error
</span></pre><p >is ill-formed because the binding is</p><pre class='codeblock'>
(new int) (*[10])();            <span class='comment'>// error
</span></pre><p >Instead, the explicitly parenthesized version of the <span class='texttt'>new</span>
operator can be used to create objects of compound
types (<a href='basic.compound'>[basic.compound]</a>):</p><pre class='codeblock'>
new (int (*[10])());
</pre><p >allocates an array of <span class='texttt'>10</span> pointers to functions (taking no
argument and returning <span class='texttt'>int</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] 
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.new-5'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-5'>5</a></div><p ><span class='indexparent'><a class='index' id='array,new'></a></span>When the allocated object is an array (that is, the
<i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> syntax is used or the
<i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> or <i ><a href='dcl.name#nt:type-id'>type-id</a></i> denotes an array type), the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> yields a pointer to the initial element (if
any) of the array.
[&nbsp;<i>Note:</i> 
both <span class='texttt'>new int</span> and <span class='texttt'>new int[10]</span> have type <span class='texttt'>int*</span> and
the type of <span class='texttt'>new int[i][10]</span> is <span class='texttt'>int (*)[10]</span>
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
The <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> appertains
to the associated array type.</p></div><div class='para' id='expr.new-6'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-6'>6</a></div><p >Every <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> in a
<i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> shall be an integral constant
expression (<a href='expr.const'>[expr.const]</a>) and evaluate to a strictly positive value.
<span class='indexparent'><a class='index' id='new'></a></span>The <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> shall be
of integral type, unscoped enumeration type, or a class type for which a single
non-explicit conversion function to integral or unscoped enumeration type
exists (<a href='class.conv'>[class.conv]</a>). If the expression is of class type, the
expression is converted by calling that conversion function, and the
result of the conversion is used in place of the original expression.
[&nbsp;<i>Example:</i>
given the definition <span class='texttt'>int n = 42</span>,
<span class='texttt'>new float[n][5]</span> is well-formed (because <span class='texttt'>n</span> is the
<i ><a href='expr.comma#nt:expression'>expression</a></i> of a <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i>), but
<span class='texttt'>new float[5][n]</span> is ill-formed (because <span class='texttt'>n</span> is not a
constant expression).
<i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='expr.new-7'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-7'>7</a></div><p ><span class='indexparent'><a class='index' id='function,allocation'></a></span>When the value of the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i>
is zero, the allocation function is called to allocate an array with no elements. If the
value of that <i ><a href='expr.comma#nt:expression'>expression</a></i> is less than zero or such that the size of the allocated object
would exceed the implementation-defined limit,
or if the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> is a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> for
which the number of <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> exceeds the number of
elements to initialize,
no storage is obtained and the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> terminates by throwing an exception of a type that would
match a handler (<a href='except.handle'>[except.handle]</a>) of type
<span class='texttt'>std::bad_array_new_length</span> (<a href='new.badlength'>[new.badlength]</a>).</p></div><div class='para' id='expr.new-8'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-8'>8</a></div><p >A <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> obtains storage for the object by calling an
<a class='hidden_link' href='#def:allocation_function' id='def:allocation_function'><i>allocation function</i></a> (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>). If
the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> terminates by throwing an exception, it
may release storage by calling a deallocation
function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>). If the allocated type
is a non-array type, the allocation function's name is
<span class='indexparent'><a class='index' id='operator_new'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator new</span> and the deallocation function's name is
<span class='texttt'>operator delete</span>. If the allocated type is an array type, the
allocation function's name is
<span class='indexparent'><a class='index' id='operator_new'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator new[]</span>
and the deallocation function's name is
<span class='texttt'>operator delete[]</span>.
[&nbsp;<i>Note:</i> 
an implementation shall provide default definitions for the global
allocation
functions (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>, <a href='new.delete.single'>[new.delete.single]</a>, <a href='new.delete.array'>[new.delete.array]</a>).
A C++ program can provide alternative definitions of
these functions (<a href='replacement.functions'>[replacement.functions]</a>) and/or class-specific
versions (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.new-9'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-9'>9</a></div><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span>If the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> begins with a unary <span class='texttt'>::</span>
operator, the allocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type <span class='texttt'>T</span> or
array thereof, the allocation function's name is looked up in the scope
of <span class='texttt'>T</span>. If this lookup fails to find the name, or if the allocated
type is not a class type, the allocation function's name is looked up in
the global scope.</p></div><div class='para' id='expr.new-10'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-10'>10</a></div><p >A <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> passes the amount of space requested to the
allocation function as the first argument of type
<span class='texttt'>std<span class='discretionary'></span>::<span class='discretionary'></span>size_t</span>. That argument shall be no less than the size
of the object being created; it may be greater than the size of the
object being created only if the object is an array. For arrays of
<span class='texttt'>char</span> and <span class='texttt'>unsigned char</span>, the difference between the
result of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> and the address returned by the
allocation function shall be an integral multiple of the
strictest fundamental
alignment requirement (<a href='basic.align'>[basic.align]</a>) of any object type whose size
is no greater than the size of the array being created.
[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='allocation,alignment_storage'></a></span>Because allocation functions are assumed to return pointers to storage
that is appropriately aligned for objects of any type
with fundamental alignment, this constraint
on array allocation overhead permits the common idiom of allocating
character arrays into which objects of other types will later be placed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.new-11'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-11'>11</a></div><p ><span class='indexparent'><a class='index' id='placement_syntax,new'></a></span>The <i ><a href='expr.new#nt:new-placement'>new-placement</a></i> syntax is used to supply additional
arguments to an allocation function. If used, overload resolution is
performed on a function call created by assembling an argument list
consisting of the amount of space requested (the first argument) and the
expressions in the <i ><a href='expr.new#nt:new-placement'>new-placement</a></i> part of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (the second and succeeding arguments). The
first of these arguments has type <span class='texttt'>std::size_t</span> and the remaining
arguments have the corresponding types of the expressions in the
<i ><a href='expr.new#nt:new-placement'>new-placement</a></i>.</p></div><div class='para' id='expr.new-12'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-12'>12</a></div><p >[&nbsp;<i>Example:</i> </p><ul ><li ><p ><span class='texttt'>new T</span> results in a call of <span class='texttt'>operator
new(sizeof(T))</span>,</p></li><li ><p ><span class='texttt'>new(2,f) T</span> results in a call of <span class='texttt'>operator
new(sizeof(T),2,f)</span>,</p></li><li ><p ><span class='texttt'>new T[5]</span> results in a call of <span class='texttt'>operator
new[](sizeof(T)*5+x)</span>, and</p></li><li ><p ><span class='texttt'>new(2,f) T[5]</span> results in a call of <span class='texttt'>operator
new[](sizeof(T)*5+y,2,f)</span>.
</p></li></ul><p >Here, <span class='texttt'>x</span> and <span class='texttt'>y</span> are non-negative unspecified values
representing array allocation overhead; the result of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> will be offset by this amount from the value
returned by <span class='texttt'>operator new[]</span>. This overhead may be applied in all
array <i ><a href='expr.new#nt:new-expression'>new-expressions</a></i>, including those referencing the
library function <span class='texttt'>operator new[](std::size_t, void*)</span> and other
placement allocation functions. The amount of overhead may vary from one
invocation of <span class='texttt'>new</span> to another.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='expr.new-13'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-13'>13</a></div><p >[&nbsp;<i>Note:</i> 
unless an allocation function is declared with a non-throwing
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>),
it indicates failure to allocate storage by throwing a
<span class='indexparent'><a class='index' id='bad_alloc'></a></span><span class='indexparent'><a class='index' id='bad_alloc'></a></span><span class='texttt'>std::bad_alloc</span> exception (Clause <a href='except'>[except]</a>, <a href='bad.alloc'>[bad.alloc]</a>);
it returns a non-null pointer otherwise. If the allocation function is
declared with a non-throwing <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>,
it returns null to indicate failure to allocate storage
and a non-null pointer otherwise.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
If the allocation function returns null, initialization shall not be
done, the deallocation function shall not be called, and the value of
the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> shall be null.</p></div><div class='para' id='expr.new-14'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-14'>14</a></div><p >[&nbsp;<i>Note:</i> 
when the allocation function returns a value other than null, it must be
a pointer to a block of storage in which space for the object has been
reserved. The block of storage is assumed to be appropriately aligned
and of the requested size. The address of the created object will not
necessarily be the same as that of the block if the object is an array.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.new-15'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-15'>15</a></div><p ><span class='indexparent'><a class='index' id='new,array_of_class_objects_and'></a></span><span class='indexparent'><a class='index' id='new,initialization_and'></a></span><span class='indexparent'><a class='index' id='new,constructor_and'></a></span><span class='indexparent'><a class='index' id='new,default_constructor_and'></a></span><span class='indexparent'><a class='index' id='constructor,_default'></a></span><span class='indexparent'><a class='index' id='trivial_type'></a></span><span class='indexparent'><a class='index' id='trivial_class_type'></a></span>A <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that creates an object of type <span class='texttt'>T</span>
initializes that object as follows:</p><ul ><li ><p >If the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> is omitted, the object is
default-initialized (<a href='dcl.init'>[dcl.init]</a>); if no initialization is performed, the
object has indeterminate value.</p></li><li ><p >Otherwise, the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> is interpreted according to
the initialization rules of <a href='dcl.init'>[dcl.init]</a> for direct-initialization.
</p></li></ul></div><div class='para' id='expr.new-16'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-16'>16</a></div><p ><span class='indexparent'><a class='index' id='new,unspecified_order_of_evaluation'></a></span><span class='indexparent'><a class='index' id='new,unspecified_constructor_and'></a></span>The invocation of the allocation function is indeterminately sequenced with respect to
the evaluations of expressions in the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i>. Initialization of
the allocated object is sequenced before the
<span class='indexparent'><a class='index' id='value_computation'></a></span>value computation of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
<span class='indexparent'><a class='index' id='constructor,unspecified_argument_to'></a></span>It is unspecified whether expressions in the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> are
evaluated if the allocation function returns the null pointer or exits
using an exception.</p></div><div class='para' id='expr.new-17'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-17'>17</a></div><p >If the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> creates an object or an array of
objects of class type, access and ambiguity control are done for the
allocation function, the deallocation function (<a href='class.free'>[class.free]</a>), and
the constructor (<a href='class.ctor'>[class.ctor]</a>). If the new expression creates an
array of objects of class type, access and ambiguity control are done
for the destructor (<a href='class.dtor'>[class.dtor]</a>).</p></div><div class='para' id='expr.new-18'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-18'>18</a></div><p ><span class='indexparent'><a class='index' id='new,exception_and'></a></span>If any part of the object initialization described above<a class='footnotenum' href='#footnote-76'>76</a>
terminates by throwing an exception and a suitable deallocation function
can be found, the deallocation function is called to free the memory in
which the object was being constructed, after which the exception
continues to propagate in the context of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
If no unambiguous matching deallocation function can be found,
propagating the exception does not cause the object's memory to be
freed.
[&nbsp;<i>Note:</i> 
This is appropriate when the called allocation function does not
allocate memory; otherwise, it is likely to result in a memory leak.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.new-19'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-19'>19</a></div><p >If the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> begins with a unary <span class='texttt'>::</span>
operator, the deallocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type <span class='texttt'>T</span> or an
array thereof, the deallocation function's name is looked up in the
scope of <span class='texttt'>T</span>. If this lookup fails to find the name, or if the
allocated type is not a class type or array thereof, the deallocation
function's name is looked up in the global scope.</p></div><div class='para' id='expr.new-20'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-20'>20</a></div><p >A declaration of a placement deallocation function matches the
declaration of a placement allocation function if it has the same number
of parameters and, after parameter transformations (<a href='dcl.fct'>[dcl.fct]</a>), all
parameter types except the first are identical. Any non-placement
deallocation function matches a non-placement allocation function. If
the lookup finds a single matching deallocation function, that function
will be called; otherwise, no deallocation function will be called. If
the lookup finds the two-parameter form of a usual deallocation
function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>) and that function,
considered as a placement deallocation function, would have been
selected as a match for the allocation function, the program is
ill-formed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S { 
  <span class='comment'>// Placement allocation function:
</span>  static void* operator new(std::size_t, std::size_t); 

  <span class='comment'>// Usual (non-placement) deallocation function:
</span>  static void operator delete(void*, std::size_t); 
}; 

S* p = new (0) S;   <span class='comment'>// ill-formed: non-placement deallocation function matches 
</span>                    <span class='comment'>// placement allocation function 
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expr.new-21'><div class='marginalizedparent'><a class='marginalized' href='#expr.new-21'>21</a></div><p >If a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> calls a deallocation function, it passes
the value returned from the allocation function call as the first
argument of type <span class='texttt'>void*</span>. If a placement deallocation function is
called, it is passed the same additional arguments as were passed to the
placement allocation function, that is, the same arguments as those
specified with the <i ><a href='expr.new#nt:new-placement'>new-placement</a></i> syntax. If the
implementation is allowed to make a copy of any argument as part of the
call to the allocation function, it is allowed to make a copy (of the
same original value) as part of the call to the deallocation function or
to reuse the copy made as part of the call to the allocation function.
If the copy is elided in one place, it need not be elided in the other.</p></div><div class='footnote' id='footnote-76'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-76'>76)</a></div><p >This may
include evaluating a <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> and/or calling
a constructor.</p></div></div><div id='expr.delete'><h3 ><a class='secnum' href='#expr.delete' style='min-width:103pt'>5.3.5</a> Delete <a class='abbr_ref' href='expr.delete'>[expr.delete]</a></h3><div class='para' id='expr.delete-1'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,delete'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> operator destroys a most derived
object (<a href='intro.object'>[intro.object]</a>) or array created by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.</p><pre class='bnf'><a id='nt:delete-expression'>delete-expression:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre><p >The first alternative is for non-array objects, and the second is for arrays. Whenever
the <span class='texttt'>delete</span> keyword is immediately followed by empty square brackets, it shall be
interpreted as the second alternative.<a class='footnotenum' href='#footnote-77'>77</a>
The operand shall have a pointer to object type, or a class type having a single
non-explicit conversion function (<a href='class.conv.fct'>[class.conv.fct]</a>) to a pointer to object
type. The result has type <span class='texttt'>void</span>.<a class='footnotenum' href='#footnote-78'>78</a></p></div><div class='para' id='expr.delete-2'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,object'></a></span>
If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section.
<span class='indexparent'><a class='index' id='object,delete'></a></span>In the first alternative
(<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), the value of the operand of <span class='texttt'>delete</span> may
be a null pointer value, a pointer to a non-array object
created by a previous <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a pointer to a
subobject (<a href='intro.object'>[intro.object]</a>) representing a base class of such an
object (Clause <a href='class.derived'>[class.derived]</a>). If not, the behavior is undefined.
<span class='indexparent'><a class='index' id='array,delete'></a></span><span class='indexparent'><a class='index' id='delete,array'></a></span>In the second alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>), the value of the
operand of <span class='texttt'>delete</span>
may be a null pointer value or a pointer value
that resulted from
a previous array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.<a class='footnotenum' href='#footnote-79'>79</a>
If not, the behavior is undefined.
[&nbsp;<i>Note:</i> 
this means that the syntax of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> must
match the type of the object allocated by <span class='texttt'>new</span>, not the syntax of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
a pointer to a <span class='texttt'>const</span> type can be the operand of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>; it is not necessary to cast away the
constness (<a href='expr.const.cast'>[expr.const.cast]</a>) of the pointer expression before it is
used as the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.delete-3'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-3'>3</a></div><p ><span class='indexparent'><a class='index' id='delete,undefined'></a></span>In the first alternative (<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), if the static type of
the object to be deleted is different from its dynamic type, the static type shall be
a base class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.</p></div><div class='para' id='expr.delete-4'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-4'>4</a></div><p >The <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall
be evaluated exactly once.</p></div><div class='para' id='expr.delete-5'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,incomplete'></a></span>If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.</p></div><div class='para' id='expr.delete-6'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-6'>6</a></div><p ><span class='indexparent'><a class='index' id='delete,destructor_and'></a></span>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='expr.delete-7'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-7'>7</a></div><p >If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will call a
<span class='indexparent'><a class='index' id='function,deallocation'></a></span><span class='indexparent'><a class='index' id='deallocation'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>
<a class='hidden_link' href='#def:deallocation_function' id='def:deallocation_function'><i>deallocation function</i></a> (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>).
Otherwise, it is unspecified whether the deallocation function will be
called.
[&nbsp;<i>Note:</i>
The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='expr.delete-8'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-8'>8</a></div><p >[&nbsp;<i>Note:</i> 
An implementation provides default definitions of the global
deallocation functions <span class='texttt'>operator delete()</span> for
non-arrays (<a href='new.delete.single'>[new.delete.single]</a>) and
<span class='indexparent'><a class='index' id='operator_'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator delete[]()</span> for arrays (<a href='new.delete.array'>[new.delete.array]</a>). A C++
program can provide alternative definitions of these
functions (<a href='replacement.functions'>[replacement.functions]</a>), and/or class-specific
versions (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='expr.delete-9'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-9'>9</a></div><p >When the keyword <span class='texttt'>delete</span> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is
preceded by the unary <span class='texttt'>::</span> operator, the global deallocation
function is used to deallocate the storage.</p></div><div class='para' id='expr.delete-10'><div class='marginalizedparent'><a class='marginalized' href='#expr.delete-10'>10</a></div><p >Access and ambiguity control are done for both the deallocation function
and the destructor (<a href='class.dtor'>[class.dtor]</a>, <a href='class.free'>[class.free]</a>).</p></div><div class='footnote' id='footnote-77'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-77'>77)</a></div><p >A lambda expression with a
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> that consists of
empty square brackets can follow the <span class='texttt'>delete</span> keyword if the lambda expression is
enclosed in parentheses.</p></div><div class='footnote' id='footnote-78'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-78'>78)</a></div><p >This implies that an object
cannot be deleted using a pointer of type
<span class='texttt'>void*</span> because <span class='texttt'>void</span> is not an object type.</p></div><div class='footnote' id='footnote-79'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-79'>79)</a></div><p >For non-zero-length
arrays, this is the same as a pointer to the first
element of the array created by that <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
Zero-length arrays do not have a first element.</p></div></div><div id='expr.alignof'><h3 ><a class='secnum' href='#expr.alignof' style='min-width:103pt'>5.3.6</a> Alignof <a class='abbr_ref' href='expr.alignof'>[expr.alignof]</a></h3><div class='para' id='expr.alignof-1'><div class='marginalizedparent'><a class='marginalized' href='#expr.alignof-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,alignof'></a></span>An <span class='texttt'>alignof</span> expression yields the alignment requirement
of its operand type. The operand shall be a <i ><a href='dcl.name#nt:type-id'>type-id</a></i>
representing a complete object type or an array thereof or a reference to a complete object type.</p></div><div class='para' id='expr.alignof-2'><div class='marginalizedparent'><a class='marginalized' href='#expr.alignof-2'>2</a></div><p >The result is an integral constant of type
<span class='texttt'>std::size_t</span>.</p></div><div class='para' id='expr.alignof-3'><div class='marginalizedparent'><a class='marginalized' href='#expr.alignof-3'>3</a></div><p >When <span class='texttt'>alignof</span> is applied to a reference type, the result
shall be the alignment of the referenced type. When <span class='texttt'>alignof</span>
is applied to an array type, the result shall be the alignment of the
element type.</p></div></div><div id='noexcept'><h3 ><a class='secnum' href='#noexcept' style='min-width:103pt'>5.3.7</a> <span class='texttt'>noexcept</span> operator <a class='abbr_ref' href='expr.unary.noexcept'>[expr.unary.noexcept]</a></h3><div class='para' id='noexcept-1'><div class='marginalizedparent'><a class='marginalized' href='#noexcept-1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,noexcept'></a></span>The <span class='texttt'>noexcept</span> operator determines whether the evaluation of its operand,
which is an unevaluated operand (Clause <a href='expr'>[expr]</a>), can throw an
exception (<a href='except.throw'>[except.throw]</a>).</p><pre class='bnf'><a id='nt:noexcept-expression'>noexcept-expression:</a>
  <span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre></div><div class='para' id='noexcept-2'><div class='marginalizedparent'><a class='marginalized' href='#noexcept-2'>2</a></div><p >The result of the <span class='texttt'>noexcept</span> operator is a constant of type <span class='texttt'>bool</span>
and is an rvalue.</p></div><div class='para' id='noexcept-3'><div class='marginalizedparent'><a class='marginalized' href='#noexcept-3'>3</a></div><p >The result of the <span class='texttt'>noexcept</span> operator is <span class='texttt'>false</span> if in a
potentially-evaluated context the <i ><a href='expr.comma#nt:expression'>expression</a></i> would contain</p><ul ><li ><p >a potentially evaluated call<a class='footnotenum' href='#footnote-80'>80</a>
to a function, member function, function pointer, or member function pointer
that does not have a non-throwing <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>),
unless the call is a constant expression (<a href='expr.const'>[expr.const]</a>),</p></li><li ><p >a potentially evaluated <i ><a href='except#nt:throw-expression'>throw-expression</a></i> (<a href='except.throw'>[except.throw]</a>),</p></li><li ><p >a potentially evaluated <span class='texttt'>dynamic_cast</span> expression
<span class='texttt'>dynamic_cast&lt;T&gt;(v)</span>, where <span class='texttt'>T</span> is a reference type,
that requires a run-time check (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>), or</p></li><li ><p >a potentially evaluated <span class='texttt'>typeid</span> expression (<a href='expr.typeid'>[expr.typeid]</a>) applied to
a glvalue expression whose type is a polymorphic class type (<a href='class.virtual'>[class.virtual]</a>).
</p></li></ul><p >Otherwise, the result is <span class='texttt'>true</span>.<span class='indexparent'><a class='index' id='expression,unary'></a></span></p></div><div class='footnote' id='footnote-80'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-80'>80)</a></div><p >This includes implicit calls such as
the call to an allocation function in a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.</p></div></div></div></div></body></html>