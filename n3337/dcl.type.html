<!DOCTYPE html><html lang='en'><head><title>[dcl.type]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.type'>[dcl.spec]</a></h2><div id='dcl.type'><h3 ><a class='secnum' style='min-width:103pt'>7.1.6</a> Type specifiers <a class='abbr_ref'>[dcl.type]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,type'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The type-specifiers are</p><p ><span class='indexparent'><a class='index' id='type,const'></a></span><span class='indexparent'><a class='index' id='type,volatile'></a></span></p><pre class='bnf'><a id='nt:type-specifier'>type-specifier:</a>
    <i ><a href='dcl.type#nt:trailing-type-specifier'>trailing-type-specifier</a></i>
    <i ><a href='class#nt:class-specifier'>class-specifier</a></i>
    <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i></pre><pre class='bnf'><a id='nt:trailing-type-specifier'>trailing-type-specifier:</a>
  <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
  <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
  <i ><a href='temp.res#nt:typename-specifier'>typename-specifier</a></i>
  <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i></pre><pre class='bnf'><a id='nt:type-specifier-seq'>type-specifier-seq:</a>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i></pre><pre class='bnf'><a id='nt:trailing-type-specifier-seq'>trailing-type-specifier-seq:</a>
  <i ><a href='dcl.type#nt:trailing-type-specifier'>trailing-type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='dcl.type#nt:trailing-type-specifier'>trailing-type-specifier</a></i> <i ><a href='dcl.type#nt:trailing-type-specifier-seq'>trailing-type-specifier-seq</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>
or a <i ><a href='dcl.type#nt:trailing-type-specifier-seq'>trailing-type-specifier-seq</a></i>
appertains
to the type denoted by the preceding <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i> (<a href='dcl.meaning'>[dcl.meaning]</a>). The
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> affects the type only for the declaration it appears in,
not other declarations involving the same type.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >As a general rule, at most one <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is allowed in the complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> or in a
<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> or <i ><a href='dcl.type#nt:trailing-type-specifier-seq'>trailing-type-specifier-seq</a></i>.
The only exceptions to this rule are the following:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p ><span class='texttt'>const</span> can be combined with any type specifier except itself.</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p ><span class='texttt'>volatile</span> can be combined with any type specifier except itself.</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p ><span class='texttt'>signed</span> or <span class='texttt'>unsigned</span> can be combined with
<span class='texttt'>char</span>, <span class='texttt'>long</span>, <span class='texttt'>short</span>, or <span class='texttt'>int</span>.</p></li><li id='2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.4'>(2.4)</a></div><p ><span class='texttt'>short</span> or <span class='texttt'>long</span> can be combined with <span class='texttt'>int</span>.</p></li><li id='2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.5'>(2.5)</a></div><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>double</span>.</p></li><li id='2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.6'>(2.6)</a></div><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>long</span>.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >At least one <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that is not a
<i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> is required in a declaration unless it declares
a constructor, destructor or conversion function.<a class='footnotenum' href='#footnote-92'>92</a>
A <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> shall not define a class or enumeration unless
it appears in the <i ><a href='dcl.name#nt:type-id'>type-id</a></i> of an
<i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>) that is not the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>
of a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i>
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifiers</a></i>,
<i ><a href='class#nt:class-specifier'>class-specifiers</a></i>,
and
<i ><a href='temp.res#nt:typename-specifier'>typename-specifiers</a></i>
are discussed
in
<a href='dcl.enum'>[dcl.enum]</a>,
<a href='class'>[class]</a>,
and
<a href='temp.res'>[temp.res]</a>, respectively. The remaining
<i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i> are discussed in the rest of this section.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-92'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-92'>92)</a></div><p >There is no special
provision for a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> that
lacks a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> or that has a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that only specifies <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i>.
The “implicit int” rule of C is no longer supported.</p></div><div id='cv'><h4 ><a class='secnum' href='#cv' style='min-width:118pt'>7.1.6.1</a> The <span class='grammarterm'>cv-qualifiers</span> <a class='abbr_ref' href='dcl.type.cv'>[dcl.type.cv]</a></h4><p ><span class='indexparent'><a class='index' id='specifier,cv-qualifier'></a></span><span class='indexparent'><a class='index' id='initialization,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span></p><div class='para' id='cv-1'><div class='marginalizedparent'><a class='marginalized' href='#cv-1'>1</a></div><p >There are two <span class='grammarterm'>cv-qualifiers</span>, <span class='texttt'>const</span> and
<span class='texttt'>volatile</span>. If a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> appears in a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> of
the declaration shall not be empty.
[&nbsp;<i>Note:</i>
<a href='basic.type.qualifier'>[basic.type.qualifier]</a> and <a href='dcl.fct'>[dcl.fct]</a> describe how cv-qualifiers affect object and
function types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Redundant cv-qualifications are ignored. [&nbsp;<i>Note:</i> For example,
these could be introduced by typedefs.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='cv-2'><div class='marginalizedparent'><a class='marginalized' href='#cv-2'>2</a></div><p >[&nbsp;<i>Note:</i>
Declaring a variable <span class='texttt'>const</span> can affect its linkage (<a href='dcl.stc'>[dcl.stc]</a>)
and its usability in constant expressions (<a href='expr.const'>[expr.const]</a>). As
described in <a href='dcl.init'>[dcl.init]</a>, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='cv-3'><div class='marginalizedparent'><a class='marginalized' href='#cv-3'>3</a></div><p >A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
[&nbsp;<i>Note:</i>
Cv-qualifiers are supported by the type system so that they cannot be
subverted without casting (<a href='expr.const.cast'>[expr.const.cast]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='cv-4'><div class='marginalizedparent'><a class='marginalized' href='#cv-4'>4</a></div><p ><span class='indexparent'><a class='index' id='const_object,undefined_change_to'></a></span>Except that any class member declared <span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>)
can be modified, any attempt to modify a <span class='texttt'>const</span> object during its
lifetime (<a href='basic.life'>[basic.life]</a>) results in undefined behavior.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
const int ci = 3;               <span class='comment'>// cv-qualified (initialized as required)
</span>ci = 4;                         <span class='comment'>// ill-formed: attempt to modify <span class='texttt'>const</span>
</span>
int i = 2;                      <span class='comment'>// not cv-qualified
</span>const int* cip;                 <span class='comment'>// pointer to <span class='texttt'>const int</span>
</span>cip = &amp;i;                       <span class='comment'>// OK: cv-qualified access path to unqualified
</span>*cip = 4;                       <span class='comment'>// ill-formed: attempt to modify through ptr to <span class='texttt'>const</span>
</span>
int* ip;
ip = const_cast&lt;int*&gt;(cip);     <span class='comment'>// cast needed to convert <span class='texttt'>const int*</span> to <span class='texttt'>int*</span>
</span>*ip = 4;                        <span class='comment'>// defined: <span class='texttt'>*ip</span> points to <span class='texttt'>i</span>, a non-<span class='texttt'>const</span> object
</span>
const int* ciq = new const int (3);     <span class='comment'>// initialized as required
</span>int* iq = const_cast&lt;int*&gt;(ciq);        <span class='comment'>// cast required
</span>*iq = 4;                                <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> object
</span></pre></div><div class='para' id='cv-5'><div class='marginalizedparent'><a class='marginalized' href='#cv-5'>5</a></div><p >For another example</p><pre class='codeblock'>
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                        <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>y.x.j++;                        <span class='comment'>// ill-formed: <span class='texttt'>const</span>-qualified member modified
</span>Y* p = const_cast&lt;Y*&gt;(&amp;y);      <span class='comment'>// cast away const-ness of <span class='texttt'>y</span>
</span>p-&gt;x.i = 99;                    <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>p-&gt;x.j = 99;                    <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> member
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='cv-6'><div class='marginalizedparent'><a class='marginalized' href='#cv-6'>6</a></div><p >If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of a glvalue with a
non-volatile-qualified type, the program behavior is undefined.</p></div><div class='para' id='cv-7'><div class='marginalizedparent'><a class='marginalized' href='#cv-7'>7</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span><span class='indexparent'><a class='index' id='volatile,implementation-defined'></a></span>[&nbsp;<i>Note:</i>
<span class='texttt'>volatile</span> is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
See <a href='intro.execution'>[intro.execution]</a> for detailed semantics. In general, the
semantics of <span class='texttt'>volatile</span> are intended to be the same in C++ as
they are in C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='simple'><h4 ><a class='secnum' href='#simple' style='min-width:118pt'>7.1.6.2</a> Simple type specifiers <a class='abbr_ref' href='dcl.type.simple'>[dcl.type.simple]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,simple'></a></span></p><div class='para' id='simple-1'><div class='marginalizedparent'><a class='marginalized' href='#simple-1'>1</a></div><p >The simple type specifiers are</p><pre class='bnf'><a id='nt:simple-type-specifier'>simple-type-specifier:</a>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <span class='terminal'>char</span>
    <span class='terminal'>char16_t</span>
    <span class='terminal'>char32_t</span>
    <span class='terminal'>wchar_t</span>
    <span class='terminal'>bool</span>
    <span class='terminal'>short</span>
    <span class='terminal'>int</span>
    <span class='terminal'>long</span>
    <span class='terminal'>signed</span>
    <span class='terminal'>unsigned</span>
    <span class='terminal'>float</span>
    <span class='terminal'>double</span>
    <span class='terminal'>void</span>
    <span class='terminal'>auto</span>
    <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i></pre><pre class='bnf'><a id='nt:type-name'>type-name:</a>
    <i ><a href='class#nt:class-name'>class-name</a></i>
    <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>
    <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><pre class='bnf'><a id='nt:decltype-specifier'>decltype-specifier:</a>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre></div><div class='para' id='simple-2'><div class='marginalizedparent'><a class='marginalized' href='#simple-2'>2</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,char'></a></span><span class='indexparent'><a class='index' id='type_specifier,char16_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,char32_t'></a></span><span class='indexparent'><a class='index' id='type-specifier,wchar_t'></a></span><span class='indexparent'><a class='index' id='type-specifier,bool'></a></span><span class='indexparent'><a class='index' id='type_specifier,short'></a></span><span class='indexparent'><a class='index' id='type_specifier,int'></a></span><span class='indexparent'><a class='index' id='type_specifier,long'></a></span><span class='indexparent'><a class='index' id='type_specifier,signed'></a></span><span class='indexparent'><a class='index' id='type_specifier,unsigned'></a></span><span class='indexparent'><a class='index' id='type_specifier,float'></a></span><span class='indexparent'><a class='index' id='type_specifier,double'></a></span><span class='indexparent'><a class='index' id='type_specifier,void'></a></span><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span><span class='indexparent'><a class='index' id='type-name'></a></span><span class='indexparent'><a class='index' id='lambda-introducer'></a></span>The <span class='texttt'>auto</span> specifier is a placeholder for a type to be
deduced (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
The other
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
specify either a previously-declared user-defined type or one of the
fundamental types (<a href='basic.fundamental'>[basic.fundamental]</a>).
Table <a href='#tab:simple.type.specifiers'>[tab:simple.type.specifiers]</a>
 summarizes the valid combinations of
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
and the types they specify.</p><div class='numberedTable' id='tab:simple.type.specifiers'>Table <a href='#tab:simple.type.specifiers'>10</a> — <span class='grammarterm'>simple-type-specifiers</span> and the types they specify<br><table ><tr class='rowsep'><td class='left'>


Specifier(s)                    </td><td class='left'>   Type                 </td></tr><tr class='capsep'><td class='left'> 
<span class='grammarterm'>type-name</span>         </td><td class='left'>   the type named          </td></tr><tr ><td class='left'>
<span class='grammarterm'>simple-template-id</span>    </td><td class='left'>   the type as defined in <a href='temp.names'>[temp.names]</a>   </td></tr><tr ><td class='left'>
char                            </td><td class='left'>   “char”                </td></tr><tr ><td class='left'>
unsigned char                   </td><td class='left'>   “unsigned char”       </td></tr><tr ><td class='left'>
signed char                     </td><td class='left'>   “signed char”         </td></tr><tr ><td class='left'>
char16_t                        </td><td class='left'>   “char16_t”            </td></tr><tr ><td class='left'>
char32_t                        </td><td class='left'>   “char32_t”            </td></tr><tr ><td class='left'>
bool                            </td><td class='left'>   “bool”                </td></tr><tr ><td class='left'>
unsigned                        </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
unsigned int                    </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
signed                          </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
signed int                      </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
int                             </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
unsigned short int              </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned short                  </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned long int               </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long                   </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long long int          </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
unsigned long long              </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
signed long int                 </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long                     </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long long int            </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
signed long long                </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long int                   </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long                       </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long int                        </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
long                            </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed short int                </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
signed short                    </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short int                       </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short                           </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
wchar_t                         </td><td class='left'>   “wchar_t”             </td></tr><tr ><td class='left'>
float                           </td><td class='left'>   “float”               </td></tr><tr ><td class='left'>
double                          </td><td class='left'>   “double”              </td></tr><tr ><td class='left'>
long double                     </td><td class='left'>   “long double”         </td></tr><tr ><td class='left'>
void                            </td><td class='left'>   “void”                </td></tr><tr ><td class='left'>
auto                            </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(<span class='grammarterm'>expression</span>) </td><td class='left'>   the type as defined below</td></tr></table></div></div><div class='para' id='simple-3'><div class='marginalizedparent'><a class='marginalized' href='#simple-3'>3</a></div><p >When multiple <span class='grammarterm'>simple-type-specifiers</span> are allowed, they can be
freely intermixed with other <span class='grammarterm'>decl-specifiers</span> in any order.
[&nbsp;<i>Note:</i>
It is implementation-defined whether objects of <span class='texttt'>char</span> type and
certain bit-fields (<a href='class.bit'>[class.bit]</a>) are represented as signed or
unsigned quantities. The <span class='texttt'>signed</span> specifier forces <span class='texttt'>char</span>
objects and bit-fields to be signed; it is redundant in other contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div><div class='para' id='simple-4'><div class='marginalizedparent'><a class='marginalized' href='#simple-4'>4</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span>The type denoted by <span class='texttt'>decltype(e)</span> is defined as follows:
</p><ul class='itemize'><li id='simple-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#simple-4.1'>(4.1)</a></div><p >if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> or
an unparenthesized
class
member access (<a href='expr.ref'>[expr.ref]</a>), <span class='texttt'>decltype(e)</span> is the
type of the entity named by <span class='texttt'>e</span>. If there is no such entity, or
if <span class='texttt'>e</span> names a set of overloaded functions, the program is
ill-formed;</p></li><li id='simple-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#simple-4.2'>(4.2)</a></div><p >otherwise, if <span class='texttt'>e</span> is
an xvalue, <span class='texttt'>decltype(e)</span> is <span class='texttt'>T&amp;&amp;</span>, where <span class='texttt'>T</span> is the type
of <span class='texttt'>e</span>;</p></li><li id='simple-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#simple-4.3'>(4.3)</a></div><p >otherwise, if <span class='texttt'>e</span> is an lvalue, <span class='texttt'>decltype(e)</span>
is <span class='texttt'>T&amp;</span>, where <span class='texttt'>T</span> is the type of <span class='texttt'>e</span>;</p></li><li id='simple-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#simple-4.4'>(4.4)</a></div><p >otherwise, <span class='texttt'>decltype(e)</span> is the type of <span class='texttt'>e</span>.
</p></li></ul><p >The operand of the <span class='texttt'>decltype</span> specifier is an unevaluated
operand (Clause <a href='expr'>[expr]</a>).</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const int&amp;&amp; foo(); 
int i; 
struct A { double x; };
const A* a = new A(); 
decltype(foo()) x1 = i;         <span class='comment'>// type is <span class='texttt'>const int&amp;&amp;</span>
</span>decltype(i) x2;                 <span class='comment'>// type is <span class='texttt'>int</span>
</span>decltype(a-&gt;x) x3;              <span class='comment'>// type is <span class='texttt'>double</span>
</span>decltype((a-&gt;x)) x4 = x3;       <span class='comment'>// type is <span class='texttt'>const double&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='simple-5'><div class='marginalizedparent'><a class='marginalized' href='#simple-5'>5</a></div><p >[&nbsp;<i>Note:</i> in the case where the operand of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>
is a function call and the return type of the function is a class type, a
special rule (<a href='expr.call'>[expr.call]</a>) ensures that the return type is not required to
be complete (as it would be if the call appeared in a sub-expression or outside
of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>). In this context, the common purpose of
writing the expression is merely to refer to its type. In that sense, a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is analogous to a use of a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>,
so the usual reasons for requiring a complete type do not apply. In particular,
it is not necessary to allocate storage for a temporary object or to enforce the
semantic constraints associated with invoking the type's destructor. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A { ~A() = delete; };
template&lt;class T&gt; auto h()
  -&gt; A&lt;T&gt;;
template&lt;class T&gt; auto i(T)     <span class='comment'>// identity
</span>  -&gt; T;
template&lt;class T&gt; auto f(T)     <span class='comment'>// #1
</span>  -&gt; decltype(i(h&lt;T&gt;()));       <span class='comment'>// forces completion of <span class='texttt'>A&lt;T&gt;</span> and implicitly uses
</span>                                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::~A()</span> for the temporary introduced by the
</span>                                <span class='comment'>// use of <span class='texttt'>h()</span>. (A temporary is not introduced
</span>                                <span class='comment'>// as a result of the use of <span class='texttt'>i()</span>.)
</span>template&lt;class T&gt; auto f(T)     <span class='comment'>// #2
</span>  -&gt; void;
auto g() -&gt; void {
  f(42);                        <span class='comment'>// OK: calls #2. (#1 is not a viable candidate: type
</span>                                <span class='comment'>// deduction fails (<a href='temp.deduct'>[temp.deduct]</a>) because <span class='texttt'>A&lt;int&gt;::~A()</span>
</span>                                <span class='comment'>// is implicitly used in its <span class='grammarterm'>decltype-specifier</span>)
</span>}
template&lt;class T&gt; auto q(T)
  -&gt; decltype((h&lt;T&gt;()));        <span class='comment'>// does not force completion of <span class='texttt'>A&lt;T&gt;</span>; <span class='texttt'>A&lt;T&gt;::~A()</span> is
</span>                                <span class='comment'>// not implicitly used within the context of this <span class='grammarterm'>decltype-specifier</span>
</span>void r() {
  q(42);                        <span class='comment'>// Error: deduction against <span class='texttt'>q</span> succeeds, so overload resolution
</span>                                <span class='comment'>// selects the specialization “<span class='texttt'>q(T) -&gt; decltype((h&lt;T&gt;())) [with T=int]</span>”.
</span>                                <span class='comment'>// The return type is <span class='texttt'>A&lt;int&gt;</span>, so a temporary is introduced and its
</span>                                <span class='comment'>// destructor is used, so the program is ill-formed.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='elab'><h4 ><a class='secnum' href='#elab' style='min-width:118pt'>7.1.6.3</a> Elaborated type specifiers <a class='abbr_ref' href='dcl.type.elab'>[dcl.type.elab]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,elaborated'></a></span><span class='indexparent'><a class='index' id='typename'></a></span><span class='indexparent'><a class='index' id='type_specifier,enum'></a></span></p><pre class='bnf'><a id='nt:elaborated-type-specifier'>elaborated-type-specifier:</a>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>template</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <span class='terminal'>enum</span> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='elab-1'><div class='marginalizedparent'><a class='marginalized' href='#elab-1'>1</a></div><p ><span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='name,elaborated,enum'></a></span>An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> shall not appear in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
unless the latter is the sole constituent of a declaration.
If an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is the sole constituent of a
declaration, the declaration is ill-formed unless it is an explicit
specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>), an explicit
instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or it has one of the following
forms:</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span></pre><p >In the first case, the <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>, if any, appertains
to the class being declared; the attributes in the
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of
the class whenever it is named.</p></div><div class='para' id='elab-2'><div class='marginalizedparent'><a class='marginalized' href='#elab-2'>2</a></div><p ><a href='basic.lookup.elab'>[basic.lookup.elab]</a> describes how name lookup proceeds for the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. If the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a <i ><a href='class#nt:class-name'>class-name</a></i> or
<i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>, the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
introduces it into the declaration the same way a
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> introduces its <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>. If
the <i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> or the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> resolves to
an alias template specialization,
the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is ill-formed.
[&nbsp;<i>Note:</i>
This implies that, within a class template with a template
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> <span class='texttt'>T</span>, the declaration</p><pre class='codeblock'>
friend class T;
</pre><p >is ill-formed. However, the similar declaration <span class='texttt'>friend T;</span> is allowed (<a href='class.friend'>[class.friend]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='elab-3'><div class='marginalizedparent'><a class='marginalized' href='#elab-3'>3</a></div><p >The <i ><a href='class#nt:class-key'>class-key</a></i> or <span class='texttt'>enum</span> keyword
present in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> shall agree in kind with the
declaration to which the name in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> refers. This rule also applies to
the form of <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> that declares a
<i ><a href='class#nt:class-name'>class-name</a></i> or <span class='texttt'>friend</span> class since it can be construed
as referring to the definition of the class. Thus, in any
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, the <span class='texttt'>enum</span> keyword
shall be
used to refer to an enumeration (<a href='dcl.enum'>[dcl.enum]</a>), the <span class='texttt'>union</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a union
(Clause <a href='class'>[class]</a>), and either the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a class
(Clause <a href='class'>[class]</a>) declared using the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
enum class E { a, b };
enum E x = E::a;                <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.spec.auto'><h4 ><a class='secnum' href='#dcl.spec.auto' style='min-width:118pt'>7.1.6.4</a> <span class='texttt'>auto</span> specifier <a class='abbr_ref' href='dcl.spec.auto'>[dcl.spec.auto]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span></p><div class='para' id='dcl.spec.auto-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-1'>1</a></div><p >The <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> signifies that the type of
a variable being declared shall be deduced from its
initializer or that a function declarator shall include a
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>.</p></div><div class='para' id='dcl.spec.auto-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-2'>2</a></div><p >The <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> may appear with a function declarator with
a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> (<a href='dcl.fct'>[dcl.fct]</a>) in any context where such a
declarator is valid.</p></div><div class='para' id='dcl.spec.auto-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-3'>3</a></div><p >Otherwise, the type of the variable is deduced from its initializer. The name of the
variable being declared shall not appear in the initializer expression. This use of
<span class='texttt'>auto</span> is allowed when declaring variables in a block (<a href='stmt.block'>[stmt.block]</a>), in
namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>), and in a
<span class='small'></span><span class='rmfamily'></span><i> for-init-statement</i> (<a href='stmt.for'>[stmt.for]</a>).
<span class='texttt'>auto</span> shall appear as one of the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall be followed by one or more <i ><a href='dcl.decl#nt:init-declarator'>init-declarators</a></i>, each of which shall
have a non-empty <i ><a href='dcl.init#nt:initializer'>initializer</a></i>.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x = 5;                 <span class='comment'>// OK: <span class='texttt'>x</span> has type <span class='texttt'>int</span>
</span>const auto *v = &amp;x, u = 6;  <span class='comment'>// OK: <span class='texttt'>v</span> has type <span class='texttt'>const int*</span>, <span class='texttt'>u</span> has type <span class='texttt'>const int</span>
</span>static auto y = 0.0;        <span class='comment'>// OK: <span class='texttt'>y</span> has type <span class='texttt'>double</span>
</span>auto int r;                 <span class='comment'>// error: auto is not a <span class='grammarterm'>storage-class-specifier</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-4'>4</a></div><p >The <span class='texttt'>auto</span> <span class='small'></span><span class='rmfamily'></span><i> type-specifier</i> can also be used in declaring a variable in
the <span class='small'></span><span class='rmfamily'></span><i> condition</i> of a selection statement (<a href='stmt.select'>[stmt.select]</a>) or an iteration
statement (<a href='stmt.iter'>[stmt.iter]</a>), in the <span class='small'></span><span class='rmfamily'></span><i> type-specifier-seq</i> in 
the <span class='small'></span><span class='rmfamily'></span><i> new-type-id</i> or <span class='small'></span><span class='rmfamily'></span><i> type-id</i> of a
<span class='small'></span><span class='rmfamily'></span><i> new-expression</i> (<a href='expr.new'>[expr.new]</a>), in a
<i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>, and in declaring a static data member with a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> that appears within the
<span class='small'></span><span class='rmfamily'></span><i> member-specification</i> of a class definition (<a href='class.static.data'>[class.static.data]</a>).</p></div><div class='para' id='dcl.spec.auto-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-5'>5</a></div><p >A program that uses <span class='texttt'>auto</span> in a context not explicitly allowed in
this section is ill-formed.</p></div><div class='para' id='dcl.spec.auto-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-6'>6</a></div><p >Once the type of a <span class='small'></span><span class='rmfamily'></span><i> declarator-id</i> has been determined according
to <a href='dcl.meaning'>[dcl.meaning]</a>, the type of the declared variable using the
<span class='small'></span><span class='rmfamily'></span><i> declarator-id</i> is determined from the type of its initializer
using the rules for template argument deduction. Let <span class='texttt'>T</span> be the type that
has been determined for a variable identifier <span class='texttt'>d</span>. Obtain <span class='texttt'>P</span> from
<span class='texttt'>T</span> by replacing the occurrences of <span class='texttt'>auto</span> with either a new
invented type template parameter <span class='texttt'>U</span> or, if the initializer is a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>), with
<span class='texttt'>std::initializer_list&lt;U&gt;</span>. The type deduced for the variable <span class='texttt'>d</span>
is then the deduced <span class='texttt'>A</span> determined using the rules of template argument
deduction from a function call (<a href='temp.deduct.call'>[temp.deduct.call]</a>), where <span class='texttt'>P</span> is a
function template parameter type and the initializer for <span class='texttt'>d</span> is the
corresponding argument. If the deduction fails, the declaration is ill-formed.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x1 = { 1, 2 };         <span class='comment'>// <span class='texttt'>decltype(x1)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x2 = { 1, 2.0 };       <span class='comment'>// error: cannot deduce element type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.spec.auto-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.spec.auto-7'>7</a></div><p >If the list of declarators contains more than one declarator, the type
of each declared variable is determined as described above. If the type
deduced for the template parameter <span class='texttt'>U</span> is not the same in each
deduction, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const auto &amp;i = expr;
</pre><p >The type of <span class='texttt'>i</span> is the deduced type of the parameter <span class='texttt'>u</span> in
the call <span class='texttt'>f(expr)</span> of the following invented function template:</p><pre class='codeblock'>
template &lt;class U&gt; void f(const U&amp; u);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='specifier'></a></span></p></div></div></div></div></body></html>