<!DOCTYPE html><html lang='en'><head><title>[expr.call]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.call'>[expr.post]</a></h2><div id='expr.call'><h3 ><a class='secnum' style='min-width:103pt'>5.2.2</a> Function call <a class='abbr_ref'>[expr.call]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,function_call'></a></span><span class='indexparent'><a class='index' id='operator,function_call'></a></span><span class='indexparent'><a class='index' id='()'></a></span>There are two kinds of function call: ordinary function call and member
function<a class='footnotenum' href='#footnote-63'>63</a> (<a href='class.mfct'>[class.mfct]</a>) call.
A function call is a postfix expression followed by parentheses
containing a possibly empty, comma-separated list of expressions which
constitute the arguments to the function. For an ordinary function call,
the postfix expression shall be either an lvalue that refers to a
function (in which case the function-to-pointer standard
conversion (<a href='conv.func'>[conv.func]</a>) is suppressed on the postfix expression),
or it shall have pointer to function type. Calling a function through an
expression whose function type has a language linkage that is different
from the language linkage of the function type of the called function's
definition is undefined (<a href='dcl.link'>[dcl.link]</a>). For a member function call,
the postfix expression shall be an
implicit (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>, <a href='class.static'>[class.static]</a>) or explicit
class member access (<a href='expr.ref'>[expr.ref]</a>) whose <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is a
function member name, or a pointer-to-member
expression (<a href='expr.mptr.oper'>[expr.mptr.oper]</a>) selecting a function member; the call is as a member of
the class object referred to by the
object expression. In the case of an implicit class
member access, the implied object is the one pointed to by <span class='texttt'>this</span>.
[&nbsp;<i>Note:</i> 
a member function call of the form <span class='texttt'>f()</span> is interpreted as
<span class='texttt'>(*this).f()</span> (see <a href='class.mfct.non-static'>[class.mfct.non-static]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
If a function or member function name is used, the name can be
overloaded (Clause <a href='over'>[over]</a>), in which case the appropriate function
shall be selected according to the rules in <a href='over.match'>[over.match]</a>. If the selected
function is non-virtual, or if the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> in the class
member access expression is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>, that function is
called. Otherwise, its final overrider (<a href='class.virtual'>[class.virtual]</a>) in the dynamic type
of the object expression is called.
[&nbsp;<i>Note:</i> 
the dynamic type is the type of the object referred to by the
current value of the object expression. <a href='class.cdtor'>[class.cdtor]</a> describes the
behavior of virtual function calls when the object expression
refers to
an object under construction or destruction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Note:</i>
If a function or member function name is used, and name
lookup (<a href='basic.lookup'>[basic.lookup]</a>) does not find a declaration of that name,
the program is ill-formed. No function is implicitly declared by such a
call.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> designates a destructor (<a href='class.dtor'>[class.dtor]</a>),
the type of the function call expression is <span class='texttt'>void</span>; otherwise, the
type of the function call expression is the return type of the
statically chosen function (i.e., ignoring the <span class='texttt'>virtual</span> keyword),
even if the type of the function actually called is different.
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>This type shall be an object type, a reference type or the type
<span class='texttt'>void</span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='function_argument'></a></span><span class='indexparent'><a class='index' id='function_parameter'></a></span><span class='indexparent'><a class='index' id='formal_argument'></a></span><span class='indexparent'><a class='index' id='initialization,parameter'></a></span>When a function is called, each parameter (<a href='dcl.fct'>[dcl.fct]</a>) shall be
initialized (<a href='dcl.init'>[dcl.init]</a>, <a href='class.copy'>[class.copy]</a>, <a href='class.ctor'>[class.ctor]</a>) with
its corresponding argument.
[&nbsp;<i>Note:</i> Such initializations are indeterminately sequenced
with respect to each other (<a href='intro.execution'>[intro.execution]</a>) <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the function is a non-static member
function, the <span class='texttt'>this</span> parameter of the function (<a href='class.this'>[class.this]</a>)
shall be initialized with a pointer to the object of the call, converted
as if by an explicit type conversion (<a href='expr.cast'>[expr.cast]</a>).
[&nbsp;<i>Note:</i> 
There is no access or ambiguity checking on this conversion; the access
checking and disambiguation are done as part of the (possibly implicit)
class member access operator.
See <a href='class.member.lookup'>[class.member.lookup]</a>, <a href='class.access.base'>[class.access.base]</a>,
and <a href='expr.ref'>[expr.ref]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
When a function is called, the parameters that have object type shall
have completely-defined object type.
[&nbsp;<i>Note:</i> 
this still allows a parameter to be a pointer or reference to an
incomplete class type. However, it prevents a passed-by-value parameter
to have an incomplete class type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
During the initialization of a parameter, an implementation may avoid
the construction of extra temporaries by combining the conversions on
the associated argument and/or the construction of temporaries with the
initialization of the parameter (see <a href='class.temporary'>[class.temporary]</a>). The
lifetime of a parameter ends when the function in which it is defined
returns. The initialization and destruction of each parameter occurs
within the context of the calling function.
[&nbsp;<i>Example:</i> 
the access of the constructor, conversion functions or destructor is
checked at the point of call in the calling function. If a constructor
or destructor for a function parameter throws an exception, the search
for a handler starts in the scope of the calling function; in
particular, if the function called has a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>
(Clause <a href='except'>[except]</a>) with a handler that could handle the exception,
this handler is not considered.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] 
The value of a function call is the value returned by the called
function except in a virtual function call if the return type of the
final overrider is different from the return type of the statically
chosen function, the value returned from the final overrider is
converted to the return type of the statically chosen function.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='type_checking,argument'></a></span><span class='indexparent'><a class='index' id='function_call'></a></span><span class='indexparent'><a class='index' id='argument_passing'></a></span><span class='indexparent'><a class='index' id='value,call_by'></a></span><span class='indexparent'><a class='index' id='reference,call_by'></a></span><span class='indexparent'><a class='index' id='argument,reference'></a></span>a function can change the values of its non-const parameters, but these
changes cannot affect the values of the arguments except where a
parameter is of a reference type (<a href='dcl.ref'>[dcl.ref]</a>); if the reference is to
a const-qualified type, <span class='texttt'>const_cast</span> is required to be used to
cast away the constness in order to modify the argument's value. Where a
parameter is of <span class='texttt'>const</span> reference type a temporary object is
introduced if
needed (<a href='dcl.type'>[dcl.type]</a>, <a href='lex.literal'>[lex.literal]</a>, <a href='lex.string'>[lex.string]</a>, <a href='dcl.array'>[dcl.array]</a>, <a href='class.temporary'>[class.temporary]</a>).
In addition, it is possible to modify the values of nonconstant objects through
pointer parameters.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='declaration,ellipsis_in_function'></a></span><span class='indexparent'><a class='index' id='parameter_list,variable'></a></span>A function can be declared to accept fewer arguments (by declaring default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>)) or more arguments (by using the ellipsis,
<span class='texttt'>...</span>, or a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>)) than the number of
parameters in the function definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
[&nbsp;<i>Note:</i> 
this implies that, except where the ellipsis (<span class='texttt'>...</span>) or a function
parameter pack is used, a parameter is available for each argument.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='ellipsis,conversion_sequence'></a></span>When there is no parameter for a given argument, the argument is passed
in such a way that the receiving function can obtain the value of the
argument by invoking <span class='texttt'>va_arg</span> (<a href='support.runtime'>[support.runtime]</a>).
[&nbsp;<i>Note:</i> This paragraph does not apply to arguments passed to a function parameter pack.
Function parameter packs are expanded during template instantiation (<a href='temp.variadic'>[temp.variadic]</a>),
thus each such argument has a corresponding parameter when a function template
specialization is actually called. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard conversions are
performed on the argument expression.
An argument that has (possibly cv-qualified) type <span class='texttt'>std::nullptr_t</span> is converted
to type <span class='texttt'>void*</span> (<a href='conv.ptr'>[conv.ptr]</a>).
After these conversions, if the
argument does not have arithmetic, enumeration, pointer, pointer to
member, or class type, the program is ill-formed. Passing a potentially-evaluated
argument of class type (Clause <a href='class'>[class]</a>) having a non-trivial
copy constructor, a non-trivial move constructor,
or a
non-trivial destructor, with no corresponding parameter, is conditionally-supported with
<span class='indexparent'><a class='index' id='passing_argument_of_class_type_through_ellipsis'></a></span>implementation-defined semantics. If the argument has
integral or enumeration type that is subject to the integral
promotions (<a href='conv.prom'>[conv.prom]</a>), or a floating point type that is subject to the floating
point promotion (<a href='conv.fpprom'>[conv.fpprom]</a>), the value of the argument is converted to the
promoted type before the call. These promotions are referred to as the <a class='hidden_link' href='#def:default
argument_promotions' id='def:default
argument_promotions'><i>default
argument promotions</i></a>.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='evaluation,order_of_argument'></a></span><span class='indexparent'><a class='index' id='evaluation,unspecified_order_of_function_call'></a></span>[&nbsp;<i>Note:</i>
The evaluations of the postfix expression and of the argument
expressions are all unsequenced relative to one another.
<span class='indexparent'><a class='index' id='evaluation,unspecified_order_of_argument'></a></span>All side effects of
argument expression evaluations are sequenced before the function is
entered (see <a href='intro.execution'>[intro.execution]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='function_call,recursive'></a></span>Recursive calls are permitted, except to the function named
<span class='texttt'>main</span> (<a href='basic.start.main'>[basic.start.main]</a>).</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >A function call is an lvalue
if the result type is an lvalue reference type or an rvalue reference to function type,
an xvalue if the result type is an rvalue reference to object type, and a prvalue
otherwise.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >If a function call is a prvalue of object type:</p><ul ><li ><p >if the function call is either
</p><ul ><li ><p >the operand of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> or
</p></li><li ><p >the right operand of a comma operator that is the operand of a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>,
</p></li></ul><p >a temporary object is not introduced for the prvalue. The type of the prvalue
may be incomplete. [&nbsp;<i>Note:</i> as a result, storage is not allocated for the
prvalue and it is not destroyed; thus, a class type is not instantiated as a
result of being the type of a function call in this context. This is true
regardless of whether the expression uses function call notation or operator
notation (<a href='over.match.oper'>[over.match.oper]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i> unlike the rule for
a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> that considers whether an <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
is parenthesized (<a href='dcl.type.simple'>[dcl.type.simple]</a>), parentheses have no special meaning
in this context. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >otherwise, the type of the prvalue shall be complete.
</p></li></ul></div><div class='footnote' id='footnote-63'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-63'>63)</a></div><p >A static member function (<a href='class.static'>[class.static]</a>) is an ordinary
function.</p></div></div></div></body></html>