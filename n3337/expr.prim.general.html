<!DOCTYPE html><html lang='en'><head><title>[expr.prim.general]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.1</a> Primary expressions <a class='abbr_ref' href='expr.prim#general'>[expr.prim]</a></h2><div id='expr.prim.general'><h3 ><a class='secnum' style='min-width:103pt'>5.1.1</a> General <a class='abbr_ref'>[expr.prim.general]</a></h3><pre class='bnf'><a id='nt:primary-expression'>primary-expression:</a>
    <i ><a href='lex.literal.kinds#nt:literal'>literal</a></i>
    <span class='terminal'>this</span>
    <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
    <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
    <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i></pre><pre class='bnf'><a id='nt:id-expression'>id-expression:</a>
    <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i>
    <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i></pre><pre class='bnf'><a id='nt:unqualified-id'>unqualified-id:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i>
    <i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>
    <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i>
    <span class='terminal'>~</span> <i ><a href='class#nt:class-name'>class-name</a></i>
    <span class='terminal'>~</span> <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>
    <i ><a href='temp.names#nt:template-id'>template-id</a></i></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A
<span class='indexparent'><a class='index' id='literal'></a></span><span class='indexparent'><a class='index' id='constant'></a></span><i ><a href='lex.literal.kinds#nt:literal'>literal</a></i> 
is a primary expression.
Its type depends on its form (<a href='lex.literal'>[lex.literal]</a>).
A string literal is an lvalue; all other literals are prvalues.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='this'></a></span>The keyword <span class='texttt'>this</span> names a pointer to the object for which a non-static member
function (<a href='class.this'>[class.this]</a>) is invoked or a non-static data member's
initializer (<a href='class.mem'>[class.mem]</a>) is evaluated.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If a declaration declares a member function or member function template of a
class <span class='texttt'>X</span>, the expression <span class='texttt'>this</span> is a prvalue of type “pointer to
<i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i> <span class='texttt'>X</span>” between the optional
<span class='grammarterm'>cv-qualifer-seq</span> and the end of the <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>,
<i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>, or <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>. It shall not appear
before the optional <i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i> and it shall not appear within
the declaration of a static member function (although its type and value category
are defined within a static member function as they are within a non-static
member function). [&nbsp;<i>Note:</i> this is because declaration matching does not
occur until the complete declarator is known. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Unlike the object
expression in other contexts, <span class='texttt'>*this</span> is not required to be of complete
type for purposes of class member access (<a href='expr.ref'>[expr.ref]</a>) outside the member
function body. [&nbsp;<i>Note:</i> only class members declared prior to the declaration
are visible. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  char g();
  template&lt;class T&gt; auto f(T t) -&gt; decltype(t + g())
    { return t + g(); }
};
template auto A::f(int t) -&gt; decltype(t + g());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Otherwise, if a <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i> declares a non-static data
member (<a href='class.mem'>[class.mem]</a>) of a class <span class='texttt'>X</span>, the expression <span class='texttt'>this</span> is
a prvalue of type “pointer to <span class='texttt'>X</span>” within the
optional <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>. It shall not appear elsewhere
in the <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The expression <span class='texttt'>this</span> shall not appear in any other context.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class Outer {
  int a[sizeof(*this)];               <span class='comment'>// error: not inside a member function
</span>  unsigned int sz = sizeof(*this);    <span class='comment'>// OK: in <span class='grammarterm'>brace-or-equal-initializer</span>
</span>
  void f() {
    int b[sizeof(*this)];             <span class='comment'>// OK
</span>
    struct Inner {
      int c[sizeof(*this)];           <span class='comment'>// error: not inside a member function of <span class='texttt'>Inner</span>
</span>    };
  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='expression,parenthesized'></a></span>A parenthesized expression is a primary expression whose type and value
are identical to those of the enclosed expression. The presence of
parentheses does not affect whether the expression is an lvalue. The
parenthesized expression can be used in exactly the same contexts as
those where the enclosed expression can be used, and with the same
meaning, except as otherwise indicated.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='name'></a></span><span class='indexparent'><a class='index' id='id-expression'></a></span>An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is a restricted form of a
<i ><a href='expr.prim.general#nt:primary-expression'>primary-expression</a></i>.
[&nbsp;<i>Note:</i> 
an <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> can appear after <span class='texttt'>.</span> and <span class='texttt'>-&gt;</span>
operators (<a href='expr.ref'>[expr.ref]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='identifier'></a></span>An <i ><a href='lex.name#nt:identifier'>identifier</a></i> is an <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> provided it has
been suitably declared (Clause <a href='dcl.dcl'>[dcl.dcl]</a>).
[&nbsp;<i>Note:</i> 
for <i ><a href='over.oper#nt:operator-function-id'>operator-function-ids</a></i>, see <a href='over.oper'>[over.oper]</a>; for
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-ids</a></i>, see <a href='class.conv.fct'>[class.conv.fct]</a>; for
<i ><a href='over.literal#nt:literal-operator-id'>literal-operator-ids</a></i>, see <a href='over.literal'>[over.literal]</a>; for
<i ><a href='temp.names#nt:template-id'>template-ids</a></i>, see <a href='temp.names'>[temp.names]</a>. A <i ><a href='class#nt:class-name'>class-name</a></i>
or <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>
prefixed by <span class='texttt'>~</span> denotes a destructor; see <a href='class.dtor'>[class.dtor]</a>.
Within the definition of a non-static member function, an
<i ><a href='lex.name#nt:identifier'>identifier</a></i> that names a non-static member is transformed to a
class member access expression (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
The type of the expression is the type of the <i ><a href='lex.name#nt:identifier'>identifier</a></i>. The
result is the entity denoted by the identifier. The result is an lvalue
if the entity is a function, variable, or data member and a prvalue otherwise.
</p><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span><span class='indexparent'><a class='index' id='::'></a></span></p><pre class='bnf'><a id='nt:qualified-id'>qualified-id:</a>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i>
    <span class='terminal'>::</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <span class='terminal'>::</span> <i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i>
    <span class='terminal'>::</span> <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i>
    <span class='terminal'>::</span> <i ><a href='temp.names#nt:template-id'>template-id</a></i></pre><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span><span class='indexparent'><a class='index' id='name_hiding'></a></span></p><pre class='bnf'><a id='nt:nested-name-specifier'>nested-name-specifier:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> <span class='terminal'>::</span>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> <span class='terminal'>::</span>
    <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> <span class='terminal'>::</span>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>::</span>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>::</span></pre><p >A <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> that denotes a class, optionally
followed by the keyword <span class='texttt'>template</span> (<a href='temp.names'>[temp.names]</a>), and then
followed by the name of a member of either that class (<a href='class.mem'>[class.mem]</a>)
or one of its base classes (Clause <a href='class.derived'>[class.derived]</a>), is a
<span class='indexparent'><a class='index' id='id,qualified'></a></span><i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>; <a href='class.qual'>[class.qual]</a> describes name lookup for
class members that appear in <span class='grammarterm'>qualified-ids</span>. The result is the
member. The type of the result is the type of the member. The result is
an lvalue if the member is a static member function or a data member and a
prvalue otherwise.
[&nbsp;<i>Note:</i> 
a class member can be referred to using a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> at any
point in its potential scope (<a href='basic.scope.class'>[basic.scope.class]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
Where <i ><a href='class#nt:class-name'>class-name</a></i> <span class='texttt'>::</span> <i ><a href='class#nt:class-name'>class-name</a></i> is used,
and the two <i ><a href='class#nt:class-name'>class-names</a></i> refer to the same class, this
notation names the constructor (<a href='class.ctor'>[class.ctor]</a>). Where
<i ><a href='class#nt:class-name'>class-name</a></i> <span class='texttt'>::~</span> <i ><a href='class#nt:class-name'>class-name</a></i> is used,
the two <i ><a href='class#nt:class-name'>class-names</a></i> shall refer to the same class; this
notation names the destructor (<a href='class.dtor'>[class.dtor]</a>).
The form <span class='grammarterm'>~</span> <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> also denotes the destructor,
but it shall not be used as the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> in a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>.
[&nbsp;<i>Note:</i> 
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a class is a
<i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A <span class='texttt'>::</span>, or a <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> that names a
namespace (<a href='basic.namespace'>[basic.namespace]</a>), in either case followed by the name of a member of
that namespace (or the name of a member of a namespace made visible by a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>) is a
<span class='indexparent'><a class='index' id='id,qualified'></a></span><i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>; <a href='namespace.qual'>[namespace.qual]</a> describes name lookup for
namespace members that appear in <span class='grammarterm'>qualified-ids</span>. The result is
the member. The type of the result is the type of the member. The result
is an lvalue if the member is a function or a variable and a prvalue otherwise.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >A <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> that denotes an
enumeration (<a href='dcl.enum'>[dcl.enum]</a>), followed by the name of an
enumerator of that enumeration, is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
that refers to the enumerator. The result is the enumerator. The type
of the result is the type of the enumeration. The result is a prvalue.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >In a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>, if the
<i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i>
is a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>, its <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
shall denote the same type in both the context in which the entire
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> occurs and in the context of the class denoted
by the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> that denotes a non-static data member or
non-static member function of a class can only be used:</p><ul ><li ><p >as part of a class member access (<a href='expr.ref'>[expr.ref]</a>) in which the
object expression
refers to the member's class<a class='footnotenum' href='#footnote-61'>61</a> or a class derived from
that class, or</p></li><li ><p >to form a pointer to member (<a href='expr.unary.op'>[expr.unary.op]</a>), or</p></li><li ><p >in a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> for a constructor for that class
or for a class derived from that class (<a href='class.base.init'>[class.base.init]</a>), or</p></li><li ><p >in a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> for a non-static data member
of that class or of a class derived from that class (<a href='class.base.init'>[class.base.init]</a>), or</p></li><li ><p >if that <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> denotes a non-static data member
and it appears in an unevaluated operand.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S {
  int m;
};
int i = sizeof(S::m);           <span class='comment'>// OK
</span>int j = sizeof(S::m + 42);      <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></div><div class='footnote' id='footnote-61'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-61'>61)</a></div><p >This also applies when the object expression
is an implicit <span class='texttt'>(*this)</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>).</p></div></div></div></body></html>