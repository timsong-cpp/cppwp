<!DOCTYPE html><html lang='en'><head><title>[expr.unary.op]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.3</a> Unary expressions <a class='abbr_ref' href='expr.unary#op'>[expr.unary]</a></h2><div id='expr.unary.op'><h3 ><a class='secnum' style='min-width:103pt'>5.3.1</a> Unary operators <a class='abbr_ref'>[expr.unary.op]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,unary_operator'></a></span><span class='indexparent'><a class='index' id='operator,unary'></a></span>The unary <span class='texttt'>*</span> operator performs <a class='hidden_link' href='#def:indirection' id='def:indirection'><i>indirection</i></a>:
<span class='indexparent'><a class='index' id='dereferencing'></a></span><span class='indexparent'><a class='index' id='indirection'></a></span>the expression to which it is applied shall be a pointer to an object
type, or a pointer to a function type and the result is an lvalue
referring to the object or function to which the expression points. If
the type of the expression is “pointer to <span class='texttt'>T</span>,” the type of the
result is “<span class='texttt'>T</span>.”
[&nbsp;<i>Note:</i> 
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>a pointer to an incomplete type (other than <i>cv</i> <span class='texttt'>void</span>)
can be dereferenced. The lvalue thus obtained can be used in limited
ways (to initialize a reference, for example); this lvalue must not be
converted to a prvalue, see <a href='conv.lval'>[conv.lval]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The result of each of the following unary operators is a prvalue.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='name,address_of_cv-qualified'></a></span><span class='indexparent'><a class='index' id='expression,pointer_to_member_constant'></a></span>The result of the unary <span class='texttt'>&amp;</span> operator is a pointer to its operand.
The operand shall be an lvalue or a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>.
If the operand is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> naming a non-static member <span class='texttt'>m</span>
of some class <span class='texttt'>C</span> with type <span class='texttt'>T</span>, the result has type “pointer to member
of class <span class='texttt'>C</span> of type <span class='texttt'>T</span>” and is a prvalue designating <span class='texttt'>C::m</span>.
Otherwise, if the type of the expression is <span class='texttt'>T</span>, the result has type “pointer to
<span class='texttt'>T</span>” and is a prvalue that is the address of the designated object (<a href='intro.memory'>[intro.memory]</a>)
or a pointer to the designated function. [&nbsp;<i>Note:</i> In particular, the address of an
object of type “<i>cv</i> <span class='texttt'>T</span>” is “pointer to <i>cv</i> <span class='texttt'>T</span>”, with the same
cv-qualification. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
struct A { int i; };
struct B : A { };
... &amp;B::i ...       <span class='comment'>// has type <span class='texttt'>int A::*</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
a pointer to member formed from a <span class='texttt'>mutable</span> non-static data
member (<a href='dcl.stc'>[dcl.stc]</a>) does not reflect the <span class='texttt'>mutable</span> specifier
associated with the non-static data member.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A pointer to member is only formed when an explicit <span class='texttt'>&amp;</span> is used
and its operand is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> not enclosed in
parentheses.
[&nbsp;<i>Note:</i> 
that is, the expression <span class='texttt'>&amp;(qualified-id)</span>, where the
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is enclosed in parentheses, does not form an
expression of type “pointer to member.” Neither does
<span class='texttt'>qualified-id</span>, because there is no implicit conversion from a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> for a non-static member function to the type
“pointer to member function” as there is from an lvalue of function
type to the type “pointer to function” (<a href='conv.func'>[conv.func]</a>). Nor is
<span class='texttt'>&amp;unqualified-id</span> a pointer to member, even within the scope of
the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i>'s class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The address of an object of incomplete type can be taken, but if the
complete type of that object is a class type that declares
<span class='texttt'>operator&amp;()</span> as a member function, then the behavior is
undefined (and no diagnostic is required). The operand of <span class='texttt'>&amp;</span>
shall not be a bit-field.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='overloaded_function,address_of'></a></span>The address of an overloaded function (Clause <a href='over'>[over]</a>) can be taken
only in a context that uniquely determines which version of the
overloaded function is referred to (see <a href='over.over'>[over.over]</a>).
[&nbsp;<i>Note:</i> 
since the context might determine whether the operand is a static or
non-static member function, the context can also affect whether the
expression has type “pointer to function” or “pointer to member
function.”
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='operator,unary_plus'></a></span>The operand of the unary <span class='texttt'>+</span> operator shall have arithmetic, unscoped
enumeration, or pointer type and the result is the value of the
argument. Integral promotion is performed on integral or enumeration
operands. The type of the result is the type of the promoted operand.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='operator,unary_minus'></a></span>The operand of the unary <span class='texttt'>-</span> operator shall have arithmetic or unscoped
enumeration type and the result is the negation of its operand. Integral
promotion is performed on integral or enumeration operands. The negative
of an unsigned quantity is computed by subtracting its value from <span class='math'>2<sup ><span class='mathalpha'>n</span></sup></span>,
where <span class='math'><span class='mathalpha'>n</span></span> is the number of bits in the promoted operand. The type of the
result is the type of the promoted operand.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='operator,logical_negation'></a></span>The operand of the logical negation operator <span class='texttt'>!</span> is contextually
converted to <span class='texttt'>bool</span>
(Clause <a href='conv'>[conv]</a>); its value is <span class='texttt'>true</span>
if the converted operand is <span class='texttt'>false</span> and <span class='texttt'>false</span> otherwise.
The type of the result is <span class='texttt'>bool</span>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='operator,one&#39;s_complement'></a></span>The operand of <span class='texttt'>~</span> shall have integral or unscoped enumeration type; the
result is the one's complement of its operand. Integral promotions are
performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='texttt'>~X()</span>, where <span class='texttt'>X</span> is a <i ><a href='class#nt:class-name'>class-name</a></i> or <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.
The
ambiguity is resolved in favor of treating <span class='texttt'>~</span> as a unary
complement rather than treating <span class='texttt'>~X</span> as referring to a
destructor.</p></div></div></div></body></html>