<!DOCTYPE html><html lang='en'><head><title>[over.oper]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><div id='over.oper'><h2 ><a class='secnum' style='min-width:88pt'>13.5</a> Overloaded operators <a class='abbr_ref'>[over.oper]</a></h2><p ><span class='indexparent'><a class='index' id='overloading,operator'></a></span><span class='indexparent'><a class='index' id='overloaded_operator'></a></span><span class='indexparent'><a class='index' id='operator_overloading'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='operator,overloaded'></a></span><span class='indexparent'><a class='index' id='function,operator'></a></span>A function declaration having one of the following
<i ><a href='over.oper#nt:operator-function-id'>operator-function-ids</a></i>
as its name declares an
<a class='hidden_link' href='#def:operator_function' id='def:operator_function'><i>operator function</i></a>.
A function template declaration having one of the
following <i ><a href='over.oper#nt:operator-function-id'>operator-function-ids</a></i> as its name
declares an <a class='hidden_link' href='#def:operator_function_template' id='def:operator_function_template'><i>operator function template</i></a>. A specialization
of an operator function template is also an operator function.
An operator function is said to
<a class='hidden_link' href='#def:implement' id='def:implement'><i>implement</i></a>
the operator named in its
<i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i>.</p><pre class='bnf'><a id='nt:operator-function-id'>operator-function-id:</a>
    <span class='terminal'>operator</span> <i ><a href='over.oper#nt:operator'>operator</a></i></pre><pre class='bnf'><a id='nt:operator'>operator:</a> <span class='textnormal'>one of</span>
&#9;new&#9;delete&#9;new[]&#9;delete[]
&#9;+&#9;-&#9;*&#9;/&#9;%&#9;^&#9;&amp;&#9;|&#9;<span class='math'>~</span>
&#9;!&#9;=&#9;&lt;&#9;&gt;&#9;+=&#9;-=&#9;*=&#9;/=&#9;%=
&#9;^=&#9;&amp;=&#9;|=&#9;&lt;&lt;&#9;&gt;&gt;&#9;&gt;&gt;=&#9;&lt;&lt;=&#9;==&#9;!=
&#9;&lt;=&#9;&gt;=&#9;&amp;&amp;&#9;||&#9;++&#9;--&#9;,&#9;-&gt;*&#9;-&gt;
&#9;(&nbsp;)&#9;[&nbsp;]</pre><p >[&nbsp;<i>Note:</i>
The last two operators are function call (<a href='expr.call'>[expr.call]</a>)
and subscripting (<a href='expr.sub'>[expr.sub]</a>).
The operators
<span class='texttt'>new[]</span>,
<span class='texttt'>delete[]</span>,
<span class='texttt'>()</span>,
and
<span class='texttt'>[]</span>
are formed from more than one token.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='operator,subscripting'></a></span><span class='indexparent'><a class='index' id='operator,function_call'></a></span>
</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Both the unary and binary forms of</p><pre class='codeblock'>
+    -    *     &amp;
</pre><p >can be overloaded.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='restriction,operator_overloading'></a></span>The following operators cannot be overloaded:</p><pre class='codeblock'>
.    .*   ::    ?:
</pre><p >nor can the preprocessing symbols
<span class='texttt'>#</span>
and
<span class='texttt'>##</span>
(Clause <a href='cpp'>[cpp]</a>).</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='call,operator_function'></a></span>Operator functions are usually not called directly; instead they are invoked
to evaluate the operators they implement (<a href='over.unary'>[over.unary]</a> – <a href='over.inc'>[over.inc]</a>).
They can be explicitly called, however, using the
<i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i>
as the name of the function in the function call syntax (<a href='expr.call'>[expr.call]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
complex z = a.operator+(b);     <span class='comment'>// <span class='texttt'>complex z = a+b;</span>
</span>void* p = operator new(sizeof(int)*n);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The allocation and deallocation functions,
<span class='texttt'>operator</span>
<span class='texttt'>new</span>,
<span class='texttt'>operator</span>
<span class='texttt'>new[]</span>,
<span class='texttt'>operator</span>
<span class='texttt'>delete</span>
and
<span class='texttt'>operator</span>
<span class='texttt'>delete<span class='discretionary'></span></span>,
are described completely in <a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>.
The attributes and restrictions
found in the rest of this subclause do not apply to them unless explicitly
stated in <a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='restriction,overloading'></a></span>An operator function
shall either be a non-static member function or be a non-member function and
have at least one parameter whose type is a class, a reference to a class, an
enumeration, or a reference to an enumeration.
It is not possible to change the precedence, grouping, or number of operands
of operators.
The meaning of the operators
<span class='texttt'>=</span>,
(unary)
<span class='texttt'>&amp;</span>,
and
<span class='texttt'>,</span>
(comma), predefined for each type, can be changed for specific
class and enumeration types by
defining operator functions that implement these operators.
<span class='indexparent'><a class='index' id='overloaded_operator,inheritance_of'></a></span>Operator functions are inherited in the same manner as other base class
functions.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='operator'></a></span>The identities among certain predefined operators applied to basic types
(for example,
<span class='texttt'>++a</span> <span class='math'>&equiv;</span>
<span class='texttt'>a+=1</span>)
need not hold for operator functions.
Some predefined operators, such as
<span class='texttt'>+=</span>,
require an operand to be an lvalue when applied to basic types;
this is not required by operator functions.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='argument,overloaded_operator_and_default'></a></span>An operator function cannot have default arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>),
except where explicitly stated below.
Operator
functions cannot have more or fewer parameters than the
number required for the corresponding operator, as
described in the rest of this subclause.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >Operators not mentioned explicitly in subclauses <a href='over.ass'>[over.ass]</a> through <a href='over.inc'>[over.inc]</a>
act as ordinary unary and binary
operators obeying the rules of  <a href='over.unary'>[over.unary]</a> or <a href='over.binary'>[over.binary]</a>.<span class='indexparent'><a class='index' id='overloading,resolution,best_viable_function'></a></span><span class='indexparent'><a class='index' id='overloading,resolution,viable_functions'></a></span></p></div><div id='over.unary'><h3 ><a class='secnum' href='#over.unary' style='min-width:103pt'>13.5.1</a> Unary operators <a class='abbr_ref' href='over.unary'>[over.unary]</a></h3><p ><span class='indexparent'><a class='index' id='unary_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,unary_operator'></a></span></p><div class='para' id='over.unary-1'><div class='marginalizedparent'><a class='marginalized' href='#over.unary-1'>1</a></div><p >A prefix unary operator shall be implemented by a
non-static member function (<a href='class.mfct'>[class.mfct]</a>) with no parameters or a
non-member function with one parameter.
<span class='indexparent'><a class='index' id='unary_operator,interpretation_of'></a></span>Thus, for any prefix unary operator
<span class='texttt'>@</span>,
<span class='texttt'>@x</span>
can be interpreted as either
<span class='texttt'>x.operator@()</span>
or
<span class='texttt'>operator@(x)</span>.
If both forms of the operator function have been declared,
the rules in <a href='over.match.oper'>[over.match.oper]</a> determine which, if any, interpretation is
used.
See <a href='over.inc'>[over.inc]</a> for an explanation of the postfix unary operators
<span class='texttt'>++</span>
and
<span class='texttt'>--</span>.</p></div><div class='para' id='over.unary-2'><div class='marginalizedparent'><a class='marginalized' href='#over.unary-2'>2</a></div><p >The unary and binary forms of the same operator are considered to have
the same name.
[&nbsp;<i>Note:</i>
Consequently, a unary operator can hide a binary
operator from an enclosing scope, and vice versa.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='over.binary'><h3 ><a class='secnum' href='#over.binary' style='min-width:103pt'>13.5.2</a> Binary operators <a class='abbr_ref' href='over.binary'>[over.binary]</a></h3><p ><span class='indexparent'><a class='index' id='binary_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,binary_operator'></a></span></p><div class='para' id='over.binary-1'><div class='marginalizedparent'><a class='marginalized' href='#over.binary-1'>1</a></div><p >A binary operator shall be implemented either by a non-static member
function (<a href='class.mfct'>[class.mfct]</a>)
with one parameter or by a non-member function with two parameters.
<span class='indexparent'><a class='index' id='binary_operator,interpretation_of'></a></span>Thus, for any binary operator
<span class='texttt'>@</span>,
<span class='texttt'>x@y</span>
can be interpreted as either
<span class='texttt'>x.operator@(y)</span>
or
<span class='texttt'>operator@(x,y)</span>.
If both forms of the operator function have been declared,
the rules in <a href='over.match.oper'>[over.match.oper]</a> determine which, if any, interpretation is
used.</p></div></div><div id='over.ass'><h3 ><a class='secnum' href='#over.ass' style='min-width:103pt'>13.5.3</a> Assignment <a class='abbr_ref' href='over.ass'>[over.ass]</a></h3><p ><span class='indexparent'><a class='index' id='assignment_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,assignment_operator'></a></span></p><div class='para' id='over.ass-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ass-1'>1</a></div><p >An assignment operator shall be implemented by a
non-static member function with
exactly one parameter.
Because a copy assignment operator
<span class='texttt'>operator=</span>
is implicitly declared for a class if not declared by the user (<a href='class.copy'>[class.copy]</a>),
a base class assignment operator is always hidden by the copy assignment
operator of the derived class.</p></div><div class='para' id='over.ass-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ass-2'>2</a></div><p >Any assignment operator, even the copy and move assignment operators, can be virtual.
[&nbsp;<i>Note:</i>
For a derived class
<span class='texttt'>D</span>
with a base class
<span class='texttt'>B</span>
for which a virtual copy/move assignment has been declared,
the copy/move assignment operator in
<span class='texttt'>D</span>
does not override
<span class='texttt'>B</span>'s
virtual copy/move assignment operator.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct B {
  virtual int operator= (int);
  virtual B&amp; operator= (const B&amp;);
};
struct D : B {
  virtual int operator= (int);
  virtual D&amp; operator= (const B&amp;);
};

D dobj1;
D dobj2;
B* bptr = &amp;dobj1;
void f() {
  bptr-&gt;operator=(99);          <span class='comment'>// calls <span class='texttt'>D::operator=(int)</span>
</span>  *bptr = 99;                   <span class='comment'>// ditto
</span>  bptr-&gt;operator=(dobj2);       <span class='comment'>// calls <span class='texttt'>D::operator=(const B&amp;)</span>
</span>  *bptr = dobj2;                <span class='comment'>// ditto
</span>  dobj1 = dobj2;                <span class='comment'>// calls implicitly-declared
</span>                                <span class='comment'>// <span class='texttt'>D::operator=(const D&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='over.call'><h3 ><a class='secnum' href='#over.call' style='min-width:103pt'>13.5.4</a> Function call <a class='abbr_ref' href='over.call'>[over.call]</a></h3><p ><span class='indexparent'><a class='index' id='function_call_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,function_call_operator'></a></span></p><div class='para' id='over.call-1'><div class='marginalizedparent'><a class='marginalized' href='#over.call-1'>1</a></div><p ><span class='texttt'>operator()</span>
shall be a non-static member function with an arbitrary number of
parameters.
It can have default arguments.
It implements the function call syntax</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><p >where the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
evaluates to a class object and the possibly empty
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
matches the parameter list of an
<span class='texttt'>operator()</span>
member function of the class.
Thus, a call
<span class='texttt'>x(arg1,...)</span>
is interpreted as
<span class='texttt'>x.operator()(arg1, ...)</span>
for a class object
<span class='texttt'>x</span>
of type
<span class='texttt'>T</span>
if
<span class='texttt'>T::operator()(T1,</span>
<span class='texttt'>T2,</span>
<span class='texttt'>T3)</span>
exists and if the operator is selected as the best match function by
the overload resolution mechanism (<a href='over.match.best'>[over.match.best]</a>).</p></div></div><div id='over.sub'><h3 ><a class='secnum' href='#over.sub' style='min-width:103pt'>13.5.5</a> Subscripting <a class='abbr_ref' href='over.sub'>[over.sub]</a></h3><p ><span class='indexparent'><a class='index' id='subscripting_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,subscripting_operator'></a></span></p><div class='para' id='over.sub-1'><div class='marginalizedparent'><a class='marginalized' href='#over.sub-1'>1</a></div><p ><span class='texttt'>operator[]</span>
shall be a non-static member function with exactly one parameter.
It implements the subscripting syntax</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>[</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>]</span></pre><p >or</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>[</span> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> <span class='terminal'>]</span></pre><p >Thus, a subscripting expression
<span class='texttt'>x[y]</span>
is interpreted as
<span class='texttt'>x.operator[](y)</span>
for a class object
<span class='texttt'>x</span>
of type
<span class='texttt'>T</span>
if
<span class='texttt'>T::operator[](T1)</span>
exists and if the operator is selected as the best match function by
the overload resolution mechanism (<a href='over.match.best'>[over.match.best]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct X {
  Z operator[](std::initializer_list&lt;int&gt;);
};
X x;
x[{1,2,3}] = 7;           <span class='comment'>// OK: meaning <span class='texttt'>x.operator[]({1,2,3})</span>
</span>int a[10];
a[{1,2,3}] = 7;           <span class='comment'>// error: built-in subscript operator
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='over.ref'><h3 ><a class='secnum' href='#over.ref' style='min-width:103pt'>13.5.6</a> Class member access <a class='abbr_ref' href='over.ref'>[over.ref]</a></h3><p ><span class='indexparent'><a class='index' id='member_access_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,member_access_operator'></a></span></p><div class='para' id='over.ref-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ref-1'>1</a></div><p ><span class='texttt'>operator-&gt;</span>
shall be a non-static member function taking no parameters.
It implements the class member access syntax that
uses <span class='texttt'>-&gt;</span>.</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i></pre><p >An expression
<span class='texttt'>x-&gt;m</span>
is interpreted as
<span class='texttt'>(x.operator-&gt;())-&gt;m</span>
for a class object
<span class='texttt'>x</span>
of type
<span class='texttt'>T</span>
if
<span class='texttt'>T::operator-&gt;()</span>
exists and if the operator is selected as the best match function by
the overload resolution mechanism (<a href='over.match'>[over.match]</a>).</p></div></div><div id='over.inc'><h3 ><a class='secnum' href='#over.inc' style='min-width:103pt'>13.5.7</a> Increment and decrement <a class='abbr_ref' href='over.inc'>[over.inc]</a></h3><p ><span class='indexparent'><a class='index' id='increment_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='decrement_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='prefix_++_and_--_overloading,overloading'></a></span><span class='indexparent'><a class='index' id='postfix_++_and_--_overloading,overloading'></a></span>
</p><div class='para' id='over.inc-1'><div class='marginalizedparent'><a class='marginalized' href='#over.inc-1'>1</a></div><p >The user-defined function called
<span class='texttt'>operator++</span>
implements the prefix and postfix
<span class='texttt'>++</span>
operator.
If this function is a member function with no parameters, or a non-member
function with one parameter of class or enumeration type,
it defines the prefix increment operator
<span class='texttt'>++</span>
for objects of that type.
If the function is a member function with one parameter (which shall be of type
<span class='texttt'>int</span>)
or a non-member function with two parameters (the second of which shall be of type
<span class='texttt'>int</span>),
it defines the postfix increment operator
<span class='texttt'>++</span>
for objects of that type.
When the postfix increment is called as a result of using the
<span class='texttt'>++</span>
operator, the
<span class='texttt'>int</span>
argument will have value zero.<a class='footnotenum' href='#footnote-136'>136</a>
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X {
  X&amp;   operator++();            <span class='comment'>// prefix <span class='texttt'>++a</span>
</span>  X    operator++(int);         <span class='comment'>// postfix <span class='texttt'>a++</span>
</span>};

struct Y { };
Y&amp;   operator++(Y&amp;);            <span class='comment'>// prefix <span class='texttt'>++b</span>
</span>Y    operator++(Y&amp;, int);       <span class='comment'>// postfix <span class='texttt'>b++</span>
</span>
void f(X a, Y b) {
  ++a;                          <span class='comment'>// <span class='texttt'>a.operator++();</span>
</span>  a++;                          <span class='comment'>// <span class='texttt'>a.operator++(0);</span>
</span>  ++b;                          <span class='comment'>// <span class='texttt'>operator++(b);</span>
</span>  b++;                          <span class='comment'>// <span class='texttt'>operator++(b, 0);</span>
</span>
  a.operator++();               <span class='comment'>// explicit call: like <span class='texttt'>++a;</span>
</span>  a.operator++(0);              <span class='comment'>// explicit call: like <span class='texttt'>a++;</span>
</span>  operator++(b);                <span class='comment'>// explicit call: like <span class='texttt'>++b;</span>
</span>  operator++(b, 0);             <span class='comment'>// explicit call: like <span class='texttt'>b++;</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='over.inc-2'><div class='marginalizedparent'><a class='marginalized' href='#over.inc-2'>2</a></div><p >The prefix and postfix decrement operators
<span class='texttt'>--</span>
are handled analogously.</p></div><div class='footnote' id='footnote-136'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-136'>136)</a></div><p >Calling
<span class='texttt'>operator++</span>
explicitly, as in expressions like
<span class='texttt'>a.operator++(2)</span>,
has no special properties:
The argument to
<span class='texttt'>operator++</span>
is
<span class='texttt'>2</span>.</p></div></div><div id='over.literal'><h3 ><a class='secnum' href='#over.literal' style='min-width:103pt'>13.5.8</a> User-defined literals <a class='abbr_ref' href='over.literal'>[over.literal]</a></h3><p ><span class='indexparent'><a class='index' id='user-defined_literal,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,user-defined_literal'></a></span></p><pre class='bnf'><a id='nt:literal-operator-id'>literal-operator-id:</a>
    <span class='terminal'>operator</span> <span class='terminal'>""</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='over.literal-1'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-1'>1</a></div><p >The <i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> is called a
<a class='hidden_link' href='#def:literal_suffix_identifier' id='def:literal_suffix_identifier'><i>literal suffix identifier</i></a>.
[&nbsp;<i>Note:</i> some literal suffix identifiers are reserved for future standardization;
see <a href='usrlit.suffix'>[usrlit.suffix]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='over.literal-2'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-2'>2</a></div><p >A declaration whose <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a
<i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> shall be a declaration of a namespace-scope
function or function template (it could be a friend
function (<a href='class.friend'>[class.friend]</a>)), an explicit instantiation or specialization of a
function template, or a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>).
A function declared with a <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> is a <a class='hidden_link' href='#def:literal
operator' id='def:literal
operator'><i>literal
operator</i></a>. A function template declared with a <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i>
is a <a class='hidden_link' href='#def:literal_operator_template' id='def:literal_operator_template'><i>literal operator template</i></a>.</p></div><div class='para' id='over.literal-3'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-3'>3</a></div><p >The declaration of a literal operator shall have a
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> equivalent to one of the following:</p><pre class='codeblock'>
const char*
unsigned long long int
long double
char
wchar_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t
</pre></div><div class='para' id='over.literal-4'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-4'>4</a></div><p >A <a class='hidden_link' href='#def:raw_literal_operator' id='def:raw_literal_operator'><i>raw literal operator</i></a> is a literal operator with a single parameter
whose type is <span class='texttt'>const char*</span>.</p></div><div class='para' id='over.literal-5'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-5'>5</a></div><p >The declaration of a literal operator template shall have an empty
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and its
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> shall have a single
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> that is a non-type template parameter
pack (<a href='temp.variadic'>[temp.variadic]</a>) with element type <span class='texttt'>char</span>.</p></div><div class='para' id='over.literal-6'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-6'>6</a></div><p >Literal operators and literal operator templates shall not have C language linkage.</p></div><div class='para' id='over.literal-7'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-7'>7</a></div><p >[&nbsp;<i>Note:</i> Literal operators and literal operator templates are usually invoked
implicitly through user-defined literals (<a href='lex.ext'>[lex.ext]</a>). However, except for
the constraints described above, they are ordinary namespace-scope functions and
function templates. In particular, they are looked up like ordinary functions
and function templates and they follow the same overload resolution rules. Also,
they can be declared <span class='texttt'>inline</span> or <span class='texttt'>constexpr</span>, they may have internal
or external linkage, they can be called explicitly, their addresses can be
taken, etc. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='over.literal-8'><div class='marginalizedparent'><a class='marginalized' href='#over.literal-8'>8</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
void operator "" _km(long double);                  <span class='comment'>// OK
</span>string operator "" _i18n(const char*, std::size_t); <span class='comment'>// OK
</span>template &lt;char...&gt; int operator "" \u03C0();        <span class='comment'>// OK: UCN for lowercase pi
</span>float operator ""E(const char*);                    <span class='comment'>// error: <span class='texttt'>""E</span> (with no intervening space)
</span>                                                    <span class='comment'>// is a single token
</span>float operator " " B(const char*);                  <span class='comment'>// error: non-adjacent quotes
</span>string operator "" 5X(const char*, std::size_t);    <span class='comment'>// error: invalid literal suffix identifier
</span>double operator "" _miles(double);                  <span class='comment'>// error: invalid <span class='grammarterm'>parameter-declaration-clause</span>
</span>template &lt;char...&gt; int operator "" j(const char*);  <span class='comment'>// error: invalid <span class='grammarterm'>parameter-declaration-clause</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='overloading,operator'></a></span></p></div></div></div></div></body></html>