<!DOCTYPE html><html lang='en'><head><title>[util.smartptr.shared]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.7</a> Smart pointers <a class='abbr_ref' href='smartptr#util.smartptr.shared'>[smartptr]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.7.2</a> Shared-ownership pointers <a class='abbr_ref' href='util.smartptr#shared'>[util.smartptr]</a></h3><div id='util.smartptr.shared'><h4 ><a class='secnum' style='min-width:118pt'>20.7.2.2</a> Class template <span class='texttt'>shared_ptr</span> <a class='abbr_ref'>[util.smartptr.shared]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='shared_ptr'></a></span>The <span class='texttt'>shared_ptr</span> class template stores a pointer, usually obtained
via <span class='texttt'>new</span>. <span class='texttt'>shared_ptr</span> implements semantics of shared ownership;
the last remaining owner of the pointer is responsible for destroying
the object, or otherwise releasing the resources associated with the stored pointer. A
<span class='texttt'>shared_ptr</span> object is <a class='hidden_link' href='#def:empty' id='def:empty'><i>empty</i></a> if it does not own a pointer.</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class shared_ptr {
  public:
    typedef T element_type;

    <span class='comment'>// <a href='util.smartptr.shared.const'>[util.smartptr.shared.const]</a>, constructors:
</span>    constexpr shared_ptr() noexcept;
    template&lt;class Y&gt; explicit shared_ptr(Y* p);
    template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
    template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
    template &lt;class D&gt; shared_ptr(nullptr_t p, D d)
    template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a)
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T *p) noexcept;
    shared_ptr(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
    template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
    constexpr shared_ptr(nullptr_t) : shared_ptr() { }

    <span class='comment'>// <a href='util.smartptr.shared.dest'>[util.smartptr.shared.dest]</a>, destructor:
</span>    ~shared_ptr();

    <span class='comment'>// <a href='util.smartptr.shared.assign'>[util.smartptr.shared.assign]</a>, assignment:
</span>    shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);

    <span class='comment'>// <a href='util.smartptr.shared.mod'>[util.smartptr.shared.mod]</a>, modifiers:
</span>    void swap(shared_ptr&amp; r) noexcept;
    void reset() noexcept;
    template&lt;class Y&gt; void reset(Y* p);
    template&lt;class Y, class D&gt; void reset(Y* p, D d);
    template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);

    <span class='comment'>// <a href='util.smartptr.shared.obs'>[util.smartptr.shared.obs]</a>, observers:
</span>    T* get() const noexcept;
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
  };

  <span class='comment'>// <a href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a>, shared_ptr creation
</span>  template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

  <span class='comment'>// <a href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a>, shared_ptr comparisons:
</span>  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;

  template &lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a>, shared_ptr specialized algorithms:
</span>  template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a>, shared_ptr casts:
</span>  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

  <span class='comment'>// <a href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a>, shared_ptr get_deleter:
</span>  template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a>, shared_ptr I/O:
</span>  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);
} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Specializations of <span class='texttt'>shared_ptr</span> shall be <span class='texttt'>CopyConstructible</span>,
<span class='texttt'>CopyAssignable</span>, and <span class='texttt'>LessThanComparable</span>, allowing their use in standard
containers. Specializations of <span class='texttt'>shared_ptr</span> shall be convertible to <span class='texttt'>bool</span>,
allowing their use in boolean expressions and declarations in conditions. The template
parameter <span class='texttt'>T</span> of <span class='texttt'>shared_ptr</span> may be an incomplete type.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
if(shared_ptr&lt;X&gt; px = dynamic_pointer_cast&lt;X&gt;(py)) {
  <span class='comment'>// do something with px
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For purposes of determining the presence of a data race, member functions shall
access and modify only the <span class='texttt'>shared_ptr</span> and <span class='texttt'>weak_ptr</span> objects
themselves and not objects they refer to. Changes in <span class='texttt'>use_count()</span> do not
reflect modifications that can introduce data races.</p></div><div id='const'><h4 ><a class='secnum' href='#const' style='min-width:133pt'>20.7.2.2.1</a> <span class='texttt'>shared_ptr</span> constructors <a class='abbr_ref' href='util.smartptr.shared.const'>[util.smartptr.shared.const]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,shared_ptr'></a></span><code class='itemdecl'>
constexpr shared_ptr() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='const-1'><div class='marginalizedparent'><a class='marginalized' href='#const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an <i>empty</i> <span class='texttt'>shared_ptr</span> object.</p></div></div><div class='para' id='const-2'><div class='marginalizedparent'><a class='marginalized' href='#const-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 0 &amp;&amp; get() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</code></p><div class='itemdescr'></div><div class='para' id='const-3'><div class='marginalizedparent'><a class='marginalized' href='#const-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall be convertible to <span class='texttt'>T*</span>.
<span class='texttt'>Y</span> shall be a complete type. The expression <span class='texttt'>delete p</span>
shall be well formed, shall have well defined behavior, and shall not
throw exceptions.</p></div></div><div class='para' id='const-4'><div class='marginalizedparent'><a class='marginalized' href='#const-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>shared_ptr</span> object that <i>owns</i> the pointer
<span class='texttt'>p</span>.</p></div></div><div class='para' id='const-5'><div class='marginalizedparent'><a class='marginalized' href='#const-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1 &amp;&amp; get() == p</span>.</p></div></div><div class='para' id='const-6'><div class='marginalizedparent'><a class='marginalized' href='#const-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception when a resource other than memory could not be obtained.</p></div></div><div class='para' id='const-7'><div class='marginalizedparent'><a class='marginalized' href='#const-7'>7</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, <span class='texttt'>delete p</span> is
called.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</code></p><div class='itemdescr'></div><div class='para' id='const-8'><div class='marginalizedparent'><a class='marginalized' href='#const-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall be convertible to <span class='texttt'>T*</span>. <span class='texttt'>D</span> shall be
<span class='texttt'>CopyConstructible</span>. The copy constructor and destructor of <span class='texttt'> D</span>
shall not throw exceptions. The expression <span class='texttt'>d(p)</span> shall be
well formed, shall have well defined behavior, and shall not throw exceptions.
<span class='texttt'>A</span> shall be an allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).
The copy constructor and destructor of <span class='texttt'>A</span> shall not throw exceptions.</p></div></div><div class='para' id='const-9'><div class='marginalizedparent'><a class='marginalized' href='#const-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that <i>owns</i> the
object <span class='texttt'>p</span> and the deleter <span class='texttt'>d</span>.
The second and fourth constructors shall use a copy of <span class='texttt'>a</span> to
allocate memory for internal use.</p></div></div><div class='para' id='const-10'><div class='marginalizedparent'><a class='marginalized' href='#const-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1 &amp;&amp; get() == p</span>.</p></div></div><div class='para' id='const-11'><div class='marginalizedparent'><a class='marginalized' href='#const-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception
when a resource other than memory could not be obtained.</p></div></div><div class='para' id='const-12'><div class='marginalizedparent'><a class='marginalized' href='#const-12'>12</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, <span class='texttt'>d(p)</span> is called.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T *p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='const-13'><div class='marginalizedparent'><a class='marginalized' href='#const-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>shared_ptr</span> instance that
stores <span class='texttt'>p</span> and <i>shares ownership</i> with <span class='texttt'>r</span>.</p></div></div><div class='para' id='const-14'><div class='marginalizedparent'><a class='marginalized' href='#const-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p &amp;&amp; use_count() == r.use_count()</span></p></div></div><div class='para' id='const-15'><div class='marginalizedparent'><a class='marginalized' href='#const-15'>15</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> To avoid the possibility of a dangling pointer, the
user of this constructor must ensure that <span class='texttt'>p</span> remains valid at
least until the ownership group of <span class='texttt'>r</span> is destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='const-16'><div class='marginalizedparent'><a class='marginalized' href='#const-16'>16</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This constructor allows creation of an <i>empty</i>
<span class='texttt'>shared_ptr</span> instance with a non-NULL stored pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
shared_ptr(const shared_ptr&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='const-17'><div class='marginalizedparent'><a class='marginalized' href='#const-17'>17</a></div><div class='itemdescr'><p ><i>Requires:</i>
The second constructor shall not participate in the overload resolution unless
<span class='texttt'>Y*</span> is implicitly convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='const-18'><div class='marginalizedparent'><a class='marginalized' href='#const-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i>  If <span class='texttt'>r</span> is <i>empty</i>, constructs
an <i>empty</i> <span class='texttt'>shared_ptr</span> object; otherwise, constructs
a <span class='texttt'>shared_ptr</span> object that <i>shares ownership</i> with <span class='texttt'>r</span>.</p></div></div><div class='para' id='const-19'><div class='marginalizedparent'><a class='marginalized' href='#const-19'>19</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>get() == r.get() &amp;&amp; use_count() == r.use_count()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><code class='itemdecl'>
shared_ptr(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='const-20'><div class='marginalizedparent'><a class='marginalized' href='#const-20'>20</a></div><div class='itemdescr'><p ><i>Remark:</i> The second constructor shall not participate in overload resolution unless
<span class='texttt'>Y*</span> is convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='const-21'><div class='marginalizedparent'><a class='marginalized' href='#const-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i> Move-constructs a <span class='texttt'>shared_ptr</span> instance from
<span class='texttt'>r</span>.</p></div></div><div class='para' id='const-22'><div class='marginalizedparent'><a class='marginalized' href='#const-22'>22</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> shall contain the old value of
<span class='texttt'>r</span>. <span class='texttt'>r</span> shall be <i>empty</i>. <span class='texttt'>r.get() == 0.</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='weak_ptr'></a></span><code class='itemdecl'>
template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='const-23'><div class='marginalizedparent'><a class='marginalized' href='#const-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Y*</span> shall be convertible to <span class='texttt'>T*</span>.</p></div></div><div class='para' id='const-24'><div class='marginalizedparent'><a class='marginalized' href='#const-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that <i>shares ownership</i> with
<span class='texttt'>r</span> and stores a copy of the pointer stored in <span class='texttt'>r</span>.</p></div></div><div class='para' id='const-25'><div class='marginalizedparent'><a class='marginalized' href='#const-25'>25</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == r.use_count()</span>.</p></div></div><div class='para' id='const-26'><div class='marginalizedparent'><a class='marginalized' href='#const-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_weak_ptr</span> when <span class='texttt'>r.expired()</span>.</p></div></div><div class='para' id='const-27'><div class='marginalizedparent'><a class='marginalized' href='#const-27'>27</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, the constructor has no
effect.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='auto_ptr'></a></span>
<code class='itemdecl'>
template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='const-28'><div class='marginalizedparent'><a class='marginalized' href='#const-28'>28</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>r.release()</span> shall be convertible to <span class='texttt'>T*</span>.
<span class='texttt'>Y</span> shall be a complete type. The expression <span class='texttt'>delete
r.release()</span> shall be well formed, shall have well defined behavior,
and shall not throw exceptions.</p></div></div><div class='para' id='const-29'><div class='marginalizedparent'><a class='marginalized' href='#const-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a <span class='texttt'>shared_ptr</span> object that stores and <i>owns</i>
<span class='texttt'>r.release()</span>.</p></div></div><div class='para' id='const-30'><div class='marginalizedparent'><a class='marginalized' href='#const-30'>30</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>use_count() == 1</span> <span class='texttt'>&amp;&amp;</span> <span class='texttt'>r.get() == 0</span>.</p></div></div><div class='para' id='const-31'><div class='marginalizedparent'><a class='marginalized' href='#const-31'>31</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>bad_alloc</span>, or an <span class='indexparent'><a class='index' id='exception_type_when_shared_ptr_constructor_fails'></a></span>implementation-defined exception when a
resource other than memory could not be obtained.</p></div></div><div class='para' id='const-32'><div class='marginalizedparent'><a class='marginalized' href='#const-32'>32</a></div><div class='itemdescr'><p ><i>Exception safety:</i>  If an exception is thrown, the constructor has no
effect.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,constructor'></a></span><span class='indexparent'><a class='index' id='unique_ptr'></a></span><code class='itemdecl'>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp;r);
</code></p><div class='itemdescr'></div><div class='para' id='const-33'><div class='marginalizedparent'><a class='marginalized' href='#const-33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(r.release(), r.get_deleter())</span> when
<span class='texttt'>D</span> is not a reference type, otherwise <span class='texttt'>shared_ptr(r.release(),
ref(r.get_deleter()))</span>.</p></div></div><div class='para' id='const-34'><div class='marginalizedparent'><a class='marginalized' href='#const-34'>34</a></div><div class='itemdescr'><p ><i>Exception safety:</i> If an exception is thrown, the constructor has no effect.
</p></div></div></div><div id='dest'><h4 ><a class='secnum' href='#dest' style='min-width:133pt'>20.7.2.2.2</a> <span class='texttt'>shared_ptr</span> destructor <a class='abbr_ref' href='util.smartptr.shared.dest'>[util.smartptr.shared.dest]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,destructor'></a></span><code class='itemdecl'>
~shared_ptr();
</code></p><div class='itemdescr'></div><div class='para' id='dest-1'><div class='marginalizedparent'><a class='marginalized' href='#dest-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li id='dest-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dest-1.1'>(1.1)</a></div><p >If <span class='texttt'>*this</span> is <i>empty</i> or shares ownership with another
<span class='texttt'>shared_ptr</span> instance (<span class='texttt'>use_count() &gt; 1</span>), there are no side effects.</p></li><li id='dest-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dest-1.2'>(1.2)</a></div><p >Otherwise, if <span class='texttt'>*this</span> <i>owns</i> an object
<span class='texttt'>p</span> and a deleter <span class='texttt'>d</span>, <span class='texttt'>d(p)</span> is called.</p></li><li id='dest-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dest-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>*this</span> <i>owns</i> a pointer <span class='texttt'>p</span>,
and <span class='texttt'>delete p</span> is called.
</p></li></ul></div></div><div class='para' id='dest-2'><div class='marginalizedparent'><a class='marginalized' href='#dest-2'>2</a></div><p >[&nbsp;<i>Note:</i> Since the destruction of <span class='texttt'>*this</span>
decreases the number of instances that share ownership with <span class='texttt'>*this</span>
by one,
after <span class='texttt'>*this</span> has been destroyed
all <span class='texttt'>shared_ptr</span> instances that shared ownership with
<span class='texttt'>*this</span> will report a <span class='texttt'>use_count()</span> that is one less
than its previous value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='assign'><h4 ><a class='secnum' href='#assign' style='min-width:133pt'>20.7.2.2.3</a> <span class='texttt'>shared_ptr</span> assignment <a class='abbr_ref' href='util.smartptr.shared.assign'>[util.smartptr.shared.assign]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><code class='itemdecl'>
shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='assign-1'><div class='marginalizedparent'><a class='marginalized' href='#assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(r).swap(*this)</span>.</p></div></div><div class='para' id='assign-2'><div class='marginalizedparent'><a class='marginalized' href='#assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*this</span>.</p></div></div><div class='para' id='assign-3'><div class='marginalizedparent'><a class='marginalized' href='#assign-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
The use count updates caused by the temporary object
construction and destruction are not observable side
effects, so the implementation may meet the effects (and the
implied guarantees) via different means, without creating a
temporary. In particular, in the example:
</p><pre class='codeblock'>
shared_ptr&lt;int&gt; p(new int);
shared_ptr&lt;void&gt; q(p);
p = p;
q = p;
</pre><p >both assignments may be no-ops. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><code class='itemdecl'>
shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assign-4'><div class='marginalizedparent'><a class='marginalized' href='#assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(std::move(r)).swap(*this)</span>.</p></div></div><div class='para' id='assign-5'><div class='marginalizedparent'><a class='marginalized' href='#assign-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator='></a></span><code class='itemdecl'>
template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='assign-6'><div class='marginalizedparent'><a class='marginalized' href='#assign-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>shared_ptr(std::move(r)).swap(*this)</span>.</p></div></div><div class='para' id='assign-7'><div class='marginalizedparent'><a class='marginalized' href='#assign-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='mod'><h4 ><a class='secnum' href='#mod' style='min-width:133pt'>20.7.2.2.4</a> <span class='texttt'>shared_ptr</span> modifiers <a class='abbr_ref' href='util.smartptr.shared.mod'>[util.smartptr.shared.mod]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,shared_ptr'></a></span><code class='itemdecl'>
void swap(shared_ptr&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='mod-1'><div class='marginalizedparent'><a class='marginalized' href='#mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Exchanges the contents of <span class='texttt'>*this</span> and <span class='texttt'>r</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
void reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='mod-2'><div class='marginalizedparent'><a class='marginalized' href='#mod-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr().swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y&gt; void reset(Y* p);
</code></p><div class='itemdescr'></div><div class='para' id='mod-3'><div class='marginalizedparent'><a class='marginalized' href='#mod-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p).swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y, class D&gt; void reset(Y* p, D d);
</code></p><div class='itemdescr'></div><div class='para' id='mod-4'><div class='marginalizedparent'><a class='marginalized' href='#mod-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p, d).swap(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,reset'></a></span><code class='itemdecl'>
template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);
</code></p><div class='itemdescr'></div><div class='para' id='mod-5'><div class='marginalizedparent'><a class='marginalized' href='#mod-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>shared_ptr(p, d, a).swap(*this)</span>.
</p></div></div></div><div id='obs'><h4 ><a class='secnum' href='#obs' style='min-width:133pt'>20.7.2.2.5</a> <span class='texttt'>shared_ptr</span> observers <a class='abbr_ref' href='util.smartptr.shared.obs'>[util.smartptr.shared.obs]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,get'></a></span><span class='indexparent'><a class='index' id='get,shared_ptr'></a></span><code class='itemdecl'>
T* get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-1'><div class='marginalizedparent'><a class='marginalized' href='#obs-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  the stored pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator*'></a></span><span class='indexparent'><a class='index' id='operator*,shared_ptr'></a></span><code class='itemdecl'>
T&amp; operator*() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-2'><div class='marginalizedparent'><a class='marginalized' href='#obs-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>get() != 0</span>.</p></div></div><div class='para' id='obs-3'><div class='marginalizedparent'><a class='marginalized' href='#obs-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>*get()</span>.</p></div></div><div class='para' id='obs-4'><div class='marginalizedparent'><a class='marginalized' href='#obs-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> When <span class='texttt'>T</span> is <span class='texttt'>void</span>, it is unspecified whether this
member function is declared. If it is declared, it is unspecified what its
return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator->'></a></span><span class='indexparent'><a class='index' id='operator->,shared_ptr'></a></span><code class='itemdecl'>
T* operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-5'><div class='marginalizedparent'><a class='marginalized' href='#obs-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>get() != 0</span>.</p></div></div><div class='para' id='obs-6'><div class='marginalizedparent'><a class='marginalized' href='#obs-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,use_count'></a></span><span class='indexparent'><a class='index' id='use_count,shared_ptr'></a></span><code class='itemdecl'>
long use_count() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-7'><div class='marginalizedparent'><a class='marginalized' href='#obs-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>  the number of <span class='texttt'>shared_ptr</span> objects, <span class='texttt'>*this</span> included,
that <i>share ownership</i> with <span class='texttt'>*this</span>, or <span class='texttt'>0</span> when <span class='texttt'>*this</span> is
<i>empty</i>.</p></div></div><div class='para' id='obs-8'><div class='marginalizedparent'><a class='marginalized' href='#obs-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>use_count()</span> is not necessarily
efficient.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,unique'></a></span><span class='indexparent'><a class='index' id='unique,shared_ptr'></a></span><code class='itemdecl'>
bool unique() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-9'><div class='marginalizedparent'><a class='marginalized' href='#obs-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>use_count() == 1</span>.</p></div></div><div class='para' id='obs-10'><div class='marginalizedparent'><a class='marginalized' href='#obs-10'>10</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>unique()</span> may be faster than <span class='texttt'>use_count()</span>.  If you are
using <span class='texttt'>unique()</span> to implement copy on write, do not rely on a
specific value when <span class='texttt'>get() == 0</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='obs-11'><div class='marginalizedparent'><a class='marginalized' href='#obs-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get() != 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='owner_before,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,owner_before'></a></span><code class='itemdecl'>
template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
</code></p><div class='itemdescr'></div><div class='para' id='obs-12'><div class='marginalizedparent'><a class='marginalized' href='#obs-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> An unspecified value such that</p><ul ><li id='obs-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#obs-12.1'>(12.1)</a></div><p ><span class='texttt'>x.owner_before(y)</span> defines a strict weak ordering as defined in <a href='alg.sorting'>[alg.sorting]</a>;</p></li><li id='obs-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#obs-12.2'>(12.2)</a></div><p >under the equivalence relation defined by <span class='texttt'>owner_before</span>,
<span class='texttt'>!a.owner_before(b) &amp;&amp; !b.owner_before(a)</span>, two <span class='texttt'>shared_ptr</span> or
<span class='texttt'>weak_ptr</span> instances are equivalent if and only if they share ownership or
are both empty.
</p></li></ul></div></div></div><div id='create'><h4 ><a class='secnum' href='#create' style='min-width:133pt'>20.7.2.2.6</a> <span class='texttt'>shared_ptr</span> creation <a class='abbr_ref' href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a></h4><p ><span class='indexparent'><a class='index' id='make_shared'></a></span><span class='indexparent'><a class='index' id='allocate_shared'></a></span><code class='itemdecl'>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='create-1'><div class='marginalizedparent'><a class='marginalized' href='#create-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>::new (pv) T(std::forward&lt;Args&gt;(args)...)</span>,
where <span class='texttt'>pv</span> has type <span class='texttt'>void*</span> and points to storage suitable
to hold an object of type <span class='texttt'>T</span>, shall be well formed. <span class='texttt'>A</span> shall
be an <i>allocator</i> (<a href='allocator.requirements'>[allocator.requirements]</a>). The copy constructor
and destructor of <span class='texttt'>A</span> shall not throw exceptions.</p></div></div><div class='para' id='create-2'><div class='marginalizedparent'><a class='marginalized' href='#create-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Allocates memory suitable for an object of type <span class='texttt'>T</span>
and constructs an object in that memory via the placement new expression
<span class='texttt'>::new (pv) T(std::forward&lt;Args&gt;(args)...)</span>.
The template <span class='texttt'>allocate_shared</span> uses a copy of <span class='texttt'>a</span> to
allocate memory. If an exception is thrown, the functions have no effect.</p></div></div><div class='para' id='create-3'><div class='marginalizedparent'><a class='marginalized' href='#create-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>shared_ptr</span> instance that stores and owns
the address of the newly constructed object of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='create-4'><div class='marginalizedparent'><a class='marginalized' href='#create-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() != 0 &amp;&amp; use_count() == 1</span></p></div></div><div class='para' id='create-5'><div class='marginalizedparent'><a class='marginalized' href='#create-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span>, or an exception thrown from
<span class='texttt'>A::allocate</span> or from the constructor of <span class='texttt'>T</span>.</p></div></div><div class='para' id='create-6'><div class='marginalizedparent'><a class='marginalized' href='#create-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> Implementations are encouraged, but not required, to
perform no more than one memory allocation. [&nbsp;<i>Note:</i> This provides
efficiency equivalent to an intrusive smart pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='create-7'><div class='marginalizedparent'><a class='marginalized' href='#create-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> These functions will typically allocate more memory
than <span class='texttt'>sizeof(T)</span> to allow for internal bookkeeping structures such
as the reference counts. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='cmp'><h4 ><a class='secnum' href='#cmp' style='min-width:133pt'>20.7.2.2.7</a> <span class='texttt'>shared_ptr</span> comparison <a class='abbr_ref' href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-1'><div class='marginalizedparent'><a class='marginalized' href='#cmp-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>a.get() == b.get()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-2'><div class='marginalizedparent'><a class='marginalized' href='#cmp-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>less&lt;V&gt;()(a.get(), b.get())</span>,
where <span class='texttt'>V</span> is the composite pointer type (<a href='expr.rel'>[expr.rel]</a>) of <span class='texttt'>T*</span> and <span class='texttt'>U*</span>.</p></div></div><div class='para' id='cmp-3'><div class='marginalizedparent'><a class='marginalized' href='#cmp-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>
Defining a comparison operator allows <span class='texttt'>shared_ptr</span> objects to be
used as keys in associative containers.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator=='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-4'><div class='marginalizedparent'><a class='marginalized' href='#cmp-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-5'><div class='marginalizedparent'><a class='marginalized' href='#cmp-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(bool)a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-6'><div class='marginalizedparent'><a class='marginalized' href='#cmp-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns
<span class='texttt'>less&lt;T*&gt;()(a.get(), nullptr)</span>.
The second function template returns
<span class='texttt'>less&lt;T*&gt;()(nullptr, a.get())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-7'><div class='marginalizedparent'><a class='marginalized' href='#cmp-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>nullptr &lt; a</span>.
The second function template returns <span class='texttt'>a &lt; nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-8'><div class='marginalizedparent'><a class='marginalized' href='#cmp-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(nullptr &lt; a)</span>.
The second function template returns <span class='texttt'>!(a &lt; nullptr)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt;
  bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template &lt;class T&gt;
  bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cmp-9'><div class='marginalizedparent'><a class='marginalized' href='#cmp-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
The first function template returns <span class='texttt'>!(a &lt; nullptr)</span>.
The second function template returns <span class='texttt'>!(nullptr &lt; a)</span>.
</p></div></div></div><div id='spec'><h4 ><a class='secnum' href='#spec' style='min-width:133pt'>20.7.2.2.8</a> <span class='texttt'>shared_ptr</span> specialized algorithms <a class='abbr_ref' href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,swap'></a></span><span class='indexparent'><a class='index' id='swap,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='spec-1'><div class='marginalizedparent'><a class='marginalized' href='#spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>a.swap(b)</span>.
</p></div></div></div><div id='cast'><h4 ><a class='secnum' href='#cast' style='min-width:133pt'>20.7.2.2.9</a> <span class='texttt'>shared_ptr</span> casts <a class='abbr_ref' href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,static_pointer_cast'></a></span><span class='indexparent'><a class='index' id='static_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cast-1'><div class='marginalizedparent'><a class='marginalized' href='#cast-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>static_cast&lt;T*&gt;(r.get())</span> shall
be well formed.</p></div></div><div class='para' id='cast-2'><div class='marginalizedparent'><a class='marginalized' href='#cast-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>r</span> is <i>empty</i>, an <i>empty</i>
<span class='texttt'>shared_ptr&lt;T&gt;</span>; otherwise, a <span class='texttt'>shared_ptr&lt;T&gt;</span> object that
stores <span class='texttt'>static_cast&lt;T*&gt;(r.get())</span> and <i>shares ownership</i>
with <span class='texttt'>r</span>.</p></div></div><div class='para' id='cast-3'><div class='marginalizedparent'><a class='marginalized' href='#cast-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>w.get() == static_cast&lt;T*&gt;(r.get())</span> and
<span class='texttt'>w.use_count() == r.use_count()</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='cast-4'><div class='marginalizedparent'><a class='marginalized' href='#cast-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</span>
will eventually result in undefined behavior, attempting to delete the
same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,dynamic_pointer_cast'></a></span><span class='indexparent'><a class='index' id='dynamic_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cast-5'><div class='marginalizedparent'><a class='marginalized' href='#cast-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>dynamic_cast&lt;T*&gt;(r.get())</span>
shall be well formed and shall have well defined behavior.</p></div></div><div class='para' id='cast-6'><div class='marginalizedparent'><a class='marginalized' href='#cast-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul ><li id='cast-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cast-6.1'>(6.1)</a></div><p >When <span class='texttt'>dynamic_cast&lt;T*&gt;(r.get())</span> returns a nonzero value, a
  <span class='texttt'>shared_ptr&lt;T&gt;</span> object that stores a copy of it and <i>shares
  ownership</i> with <span class='texttt'>r</span>;</p></li><li id='cast-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cast-6.2'>(6.2)</a></div><p >Otherwise, an <i>empty</i> <span class='texttt'>shared_ptr&lt;T&gt;</span> object.
</p></li></ul></div></div><div class='para' id='cast-7'><div class='marginalizedparent'><a class='marginalized' href='#cast-7'>7</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>w.get() == dynamic_cast&lt;T*&gt;(r.get())</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='cast-8'><div class='marginalizedparent'><a class='marginalized' href='#cast-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i>  The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</span> will eventually result in
undefined behavior, attempting to delete the same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_ptr,const_pointer_cast'></a></span><span class='indexparent'><a class='index' id='const_pointer_cast,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cast-9'><div class='marginalizedparent'><a class='marginalized' href='#cast-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>  The expression <span class='texttt'>const_cast&lt;T*&gt;(r.get())</span> shall
be well formed.</p></div></div><div class='para' id='cast-10'><div class='marginalizedparent'><a class='marginalized' href='#cast-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>r</span> is empty, an empty <span class='texttt'>shared_ptr&lt;T&gt;</span>; otherwise, a
<span class='texttt'>shared_ptr&lt;T&gt;</span> object that stores <span class='texttt'>const_cast&lt;T*&gt;(r.get())</span> and shares
ownership with <span class='texttt'>r</span>.</p></div></div><div class='para' id='cast-11'><div class='marginalizedparent'><a class='marginalized' href='#cast-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>w.get() == const_cast&lt;T*&gt;(r.get())</span> and
<span class='texttt'>w.use_count() == r.use_count()</span>, where <span class='texttt'>w</span> is the return value.</p></div></div><div class='para' id='cast-12'><div class='marginalizedparent'><a class='marginalized' href='#cast-12'>12</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The seemingly equivalent expression
<span class='texttt'>shared_ptr&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))</span> will eventually result in
undefined behavior, attempting to delete the same object twice. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='util.smartptr.getdeleter'><h4 ><a class='secnum' href='#util.smartptr.getdeleter' style='min-width:133pt'>20.7.2.2.10</a> get_deleter <a class='abbr_ref' href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a></h4><p ><span class='indexparent'><a class='index' id='shared_ptr,get_deleter'></a></span><span class='indexparent'><a class='index' id='get_deleter,shared_ptr'></a></span><code class='itemdecl'>
template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.smartptr.getdeleter-1'><div class='marginalizedparent'><a class='marginalized' href='#util.smartptr.getdeleter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>  If <span class='texttt'>p</span> <i>owns</i> a deleter <span class='texttt'>d</span> of type cv-unqualified
<span class='texttt'>D</span>, returns <span class='texttt'>&amp;d</span>; otherwise returns <span class='texttt'>0</span>. The returned
pointer remains valid as long as there exists a <span class='texttt'>shared_ptr</span> instance
that owns <span class='texttt'>d</span>. [&nbsp;<i>Note:</i> It is unspecified whether the pointer
remains valid longer than that. This can happen if the implementation doesn't destroy
the deleter until all <span class='texttt'>weak_ptr</span> instances that share ownership with
<span class='texttt'>p</span> have been destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='io'><h4 ><a class='secnum' href='#io' style='min-width:133pt'>20.7.2.2.11</a> <span class='texttt'>shared_ptr</span> I/O <a class='abbr_ref' href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a></h4><p ><span class='indexparent'><a class='index' id='operator<<,shared_ptr'></a></span><span class='indexparent'><a class='index' id='shared_ptr,operator<<'></a></span><code class='itemdecl'>
template&lt;class E, class T, class Y&gt;
  basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, shared_ptr&lt;Y&gt; const&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='io-1'><div class='marginalizedparent'><a class='marginalized' href='#io-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  <span class='texttt'>os &lt;&lt; p.get();</span>.</p></div></div><div class='para' id='io-2'><div class='marginalizedparent'><a class='marginalized' href='#io-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>  <span class='texttt'>os</span>.
</p></div></div></div></div></div></body></html>