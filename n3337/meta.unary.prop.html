<!DOCTYPE html><html lang='en'><head><title>[meta.unary.prop]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.9</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#unary.prop'>[meta]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.9.4</a> Unary type traits <a class='abbr_ref' href='meta.unary#prop'>[meta.unary]</a></h3><div id='meta.unary.prop'><h4 ><a class='secnum' style='min-width:118pt'>20.9.4.3</a> Type properties <a class='abbr_ref'>[meta.unary.prop]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this Clause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>49</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_literal_type;</span>        </td><td class='left'>
 <span class='texttt'>T</span> is a literal type (<a href='basic.types'>[basic.types]</a>)  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty&lt;B&gt;::value</span> is false. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> <span class='texttt'>&amp;&amp;</span>
  <span class='texttt'>T(-1) &lt; T(0)</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> <span class='texttt'>&amp;&amp;</span>
  <span class='texttt'>T(0) &lt; T(-1)</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 <i><span class='texttt'>see below</span></i>                          </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  For a complete type <span class='texttt'>T</span> and given<br/>
  <span class='texttt'>template &lt;class U&gt;</span>
  <span class='texttt'>struct test { U u; };</span>,<br/>
  <span class='texttt'>test&lt;T&gt;::~test()</span> is not deleted. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
  <span class='texttt'>struct</span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T,</span><br/>
  <span class='texttt'>Args...&gt;::value</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible&lt;T,</span> <span class='texttt'> Args...&gt;::value</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_nothrow_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) void, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr></table></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
is_const&lt;const volatile int&gt;::value     <span class='comment'>// true
</span>is_const&lt;const int*&gt;::value             <span class='comment'>// false
</span>is_const&lt;const int&amp;&gt;::value             <span class='comment'>// false
</span>is_const&lt;int[3]&gt;::value                 <span class='comment'>// false
</span>is_const&lt;const int[3]&gt;::value           <span class='comment'>// true
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
remove_const&lt;const volatile int&gt;::type  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const&lt;const int* const&gt;::type    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const&lt;const int&amp;&gt;::type          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const&lt;const int[3]&gt;::type        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Given the following function prototype:
</p><pre class='codeblock'>
template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre><p >the predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(create&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>