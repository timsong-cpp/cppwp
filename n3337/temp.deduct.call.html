<!DOCTYPE html><html lang='en'><head><title>[temp.deduct.call]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.8</a> Function template specializations <a class='abbr_ref' href='temp.fct.spec#temp.deduct.call'>[temp.fct.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.8.2</a> Template argument deduction <a class='abbr_ref' href='temp.deduct#call'>[temp.deduct]</a></h3><div id='temp.deduct.call'><h4 ><a class='secnum' style='min-width:118pt'>14.8.2.1</a> Deducing template arguments from a function call <a class='abbr_ref'>[temp.deduct.call]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Template argument deduction is done by comparing each function
template parameter type (call it
<span class='texttt'>P</span>)
with the type of the corresponding argument of the call (call it
<span class='texttt'>A</span>)
as described below.
If removing references and cv-qualifiers from <span class='texttt'>P</span> gives
<span class='texttt'>std::initializer_list&lt;<span class='math'><span class='mathalpha'>P</span><sup >'</sup></span>&gt;</span> for some <span class='texttt'><span class='math'><span class='mathalpha'>P</span><sup >'</sup></span></span> and the
argument is an initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), then deduction is
performed instead for each element of the initializer list, taking
<span class='texttt'><span class='math'><span class='mathalpha'>P</span><sup >'</sup></span></span> as a function template parameter type and the initializer
element as its argument. Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context (<a href='temp.deduct.type'>[temp.deduct.type]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);
f({1,2,3});                 <span class='comment'>// <span class='texttt'>T</span> deduced to <span class='texttt'>int</span>
</span>f({1,"asdf"});              <span class='comment'>// error: <span class='texttt'>T</span> deduced to both <span class='texttt'>int</span> and <span class='texttt'>const char*</span>
</span>
template&lt;class T&gt; void g(T);
g({1,2,3});                 <span class='comment'>// error: no argument deduced for <span class='texttt'>T</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
For a function parameter pack that occurs at the end of the <i ><a href='dcl.fct#nt:parameter-declaration-list'>parameter-declaration-list</a></i>,
the type <span class='texttt'>A</span> of each
remaining argument of the call is compared with the type <span class='texttt'>P</span>
of the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of the function parameter pack.
Each comparison deduces template arguments for subsequent positions in
the template parameter packs expanded by the function parameter pack.
For a function parameter pack that does not occur at the end of the 
<i ><a href='dcl.fct#nt:parameter-declaration-list'>parameter-declaration-list</a></i>, the type of the parameter pack is a non-deduced context.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types&amp; ...);
template&lt;class T1, class ... Types&gt; void g(T1, Types ...);

void h(int x, float&amp; y) {
  const int z = x;
  f(x, y, z);       <span class='comment'>// <span class='texttt'>Types</span> is deduced to <span class='texttt'>int</span>, <span class='texttt'>float</span>, <span class='texttt'>const int</span>
</span>  g(x, y, z);       <span class='comment'>// <span class='texttt'>T1</span> is deduced to <span class='texttt'>int</span>; <span class='texttt'>Types</span> is deduced to <span class='texttt'>float</span>, <span class='texttt'>int</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If
<span class='texttt'>P</span>
is not a reference type:</p><ul ><li ><p >If
<span class='texttt'>A</span>
is an array type, the pointer type produced by the array-to-pointer
standard conversion (<a href='conv.array'>[conv.array]</a>) is used in place of
<span class='texttt'>A</span>
for type deduction;
otherwise,
</p></li><li ><p >If
<span class='texttt'>A</span>
is a function type, the pointer type produced by the
function-to-pointer standard conversion (<a href='conv.func'>[conv.func]</a>) is used in place
of
<span class='texttt'>A</span>
for type
deduction; otherwise,
</p></li><li ><p >If
<span class='texttt'>A</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If
<span class='texttt'>P</span>
is a cv-qualified type, the top level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction.
If
<span class='texttt'>P</span>
is a reference type, the type
referred to by
<span class='texttt'>P</span>
is used for type deduction.
If <span class='texttt'>P</span> is an rvalue reference to a cv-unqualified template parameter and the argument is an
lvalue, the type “lvalue reference to <span class='texttt'>A</span>” is used in place of <span class='texttt'>A</span> for type
deduction. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; int f(T&amp;&amp;);
template &lt;class T&gt; int g(const T&amp;&amp;);
int i;
int n1 = f(i);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&amp;&gt;(int&amp;)</span>
</span>int n2 = f(0);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int&amp;&amp;)</span>
</span>int n3 = g(i);                  <span class='comment'>// error: would call <span class='texttt'>g&lt;int&gt;(const int&amp;&amp;)</span>, which
</span>                                <span class='comment'>// would bind an rvalue reference to an lvalue
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>
(after
the type
<span class='texttt'>A</span>
is transformed as described above).
However, there are
three cases that allow a difference:</p><ul ><li ><p >If the original
<span class='texttt'>P</span>
is a reference type, the deduced
<span class='texttt'>A</span>
(i.e.,
the type referred to by the reference) can be more cv-qualified than
the transformed <span class='texttt'>A</span>.
</p></li><li ><p >The transformed <span class='texttt'>A</span>
can be another pointer or pointer to member type that can be converted
to the deduced
<span class='texttt'>A</span>
via a qualification conversion (<a href='conv.qual'>[conv.qual]</a>).</p></li><li ><p >If
<span class='texttt'>P</span>
is a class and
<span class='texttt'>P</span>
has the form
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>,
then
the transformed <span class='texttt'>A</span>
can be a derived class of the
deduced
<span class='texttt'>A</span>.
Likewise, if
<span class='texttt'>P</span>
is a pointer to a class of the form
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>,
the transformed <span class='texttt'>A</span>
can be a pointer to a
derived class pointed to by the deduced
<span class='texttt'>A</span>.
</p></li></ul><p >[&nbsp;<i>Note:</i> as specified in <a href='temp.arg.explicit'>[temp.arg.explicit]</a>, implicit conversions will be
performed on a function argument to convert it to the type of the corresponding
function parameter if the parameter contains no <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
that participate in template argument deduction. Such conversions are also
allowed, in addition to the ones described in the preceding list. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails.
[&nbsp;<i>Note:</i>
If a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is not used in any of the function parameters of a function template,
or is used only in a non-deduced context, its corresponding
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
cannot be deduced from a function call and the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
must be explicitly specified.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >When P is a function type, pointer to function type, or pointer to member
function type:
</p><ul ><li ><p >If the argument is an overload set containing one or more function templates,
the parameter is treated as a non-deduced context.
</p></li><li ><p >If the argument is an overload set (not containing function templates), trial
argument deduction is attempted using each of the members of the set. If
deduction succeeds for only one of the overload set members, that member is
used as the argument value for the deduction. If deduction succeeds for more than
one member of the overload set the parameter is treated as a non-deduced context.</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Only one function of an overload set matches the call so the function
</span><span class='comment'>// parameter is a deduced context.
</span>template &lt;class T&gt; int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g);       <span class='comment'>// calls <span class='texttt'>f(int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Ambiguous deduction causes the second function parameter to be a
</span><span class='comment'>// non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='pnum'></span>
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// The overload set contains a template, causing the second function
</span><span class='comment'>// parameter to be a non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
char g(char);
template &lt;class T&gt; T g(T);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></div></div></div></body></html>