<!DOCTYPE html><html lang='en'><head><title>[stmt.stmt]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='stmt.stmt'><h1 ><a class='secnum' style='min-width:73pt'>6</a> Statements <a class='abbr_ref' href='./#stmt.stmt'>[stmt.stmt]</a></h1><p ><span class='indexparent'><a class='index' id='statement'></a></span></p><p ><span class='indexparent'><a class='index' id='block_statement'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Except as indicated, statements are executed in sequence.</p><pre class='bnf'><a id='nt:statement'>statement:</a>
    <i ><a href='stmt.label#nt:labeled-statement'>labeled-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.expr#nt:expression-statement'>expression-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.select#nt:selection-statement'>selection-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.jump#nt:jump-statement'>jump-statement</a></i>
    <i ><a href='stmt.dcl#nt:declaration-statement'>declaration-statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='except#nt:try-block'>try-block</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the respective statement.</p></div><div id='stmt.label'><h2 ><a class='secnum' href='#stmt.label' style='min-width:88pt'>6.1</a> Labeled statement <a class='abbr_ref' href='stmt.label'>[stmt.label]</a></h2><p ><span class='indexparent'><a class='index' id='statement,labeled'></a></span></p><div class='para' id='stmt.label-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.label-1'>1</a></div><p ><span class='indexparent'><a class='index' id='statement,labeled'></a></span><span class='indexparent'><a class='index' id=':,label_specifier'></a></span>A statement can be labeled.</p><pre class='bnf'><a id='nt:labeled-statement'>labeled-statement:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>:</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>case</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>:</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>default :</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the label. An identifier label declares the identifier. The only use of an
identifier label is as the target of a
<span class='indexparent'><a class='index' id='statement,goto'></a></span><span class='texttt'>goto</span>.
<span class='indexparent'><a class='index' id='label,scope_of'></a></span>The scope of a label is the function in which it appears. Labels shall
not be redeclared within a function. A label can be used in a
<span class='texttt'>goto</span> statement before its definition.
<span class='indexparent'><a class='index' id='name_space,label'></a></span>Labels have their own name space and do not interfere with other
identifiers.</p></div><div class='para' id='stmt.label-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.label-2'>2</a></div><p ><span class='indexparent'><a class='index' id='label,case'></a></span><span class='indexparent'><a class='index' id='label,default'></a></span>Case labels and default labels shall occur only in switch statements.</p></div></div><div id='stmt.expr'><h2 ><a class='secnum' href='#stmt.expr' style='min-width:88pt'>6.2</a> Expression statement <a class='abbr_ref' href='stmt.expr'>[stmt.expr]</a></h2><p ><span class='indexparent'><a class='index' id='statement,expression'></a></span></p><div class='para' id='stmt.expr-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.expr-1'>1</a></div><p >Expression statements have the form</p><pre class='bnf'><a id='nt:expression-statement'>expression-statement:</a>
    <i ><a href='expr.comma#nt:expression'>expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span></pre><p >The expression is
a discarded-value expression (Clause <a href='expr'>[expr]</a>).
All
<span class='indexparent'><a class='index' id='side_effects'></a></span>side effects from an expression statement
are completed before the next statement is executed.
<span class='indexparent'><a class='index' id='statement,null'></a></span><span class='indexparent'><a class='index' id='statement,empty'></a></span>An expression statement with the expression missing is called a null
statement.
[&nbsp;<i>Note:</i>
Most statements are expression statements — usually assignments or
function calls. A null statement is useful to carry a label just before
the <span class='texttt'>}</span> of a compound statement and to supply a null body to an
iteration statement such as a <span class='texttt'>while</span>
statement (<a href='stmt.while'>[stmt.while]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='stmt.block'><h2 ><a class='secnum' href='#stmt.block' style='min-width:88pt'>6.3</a> Compound statement or block <a class='abbr_ref' href='stmt.block'>[stmt.block]</a></h2><p ><span class='indexparent'><a class='index' id='statement,compound'></a></span><span class='indexparent'><a class='index' id='{},block_statement'></a></span>
</p><div class='para' id='stmt.block-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.block-1'>1</a></div><p >So that several statements can be used where one is expected, the
compound statement (also, and equivalently, called “block”) is
provided.</p><pre class='bnf'><a id='nt:compound-statement'>compound-statement:</a>
    <span class='terminal'>{</span> <i ><a href='stmt.block#nt:statement-seq'>statement-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:statement-seq'>statement-seq:</a>
    <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <i ><a href='stmt.block#nt:statement-seq'>statement-seq</a></i> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><p >A compound statement defines a block scope (<a href='basic.scope'>[basic.scope]</a>).
[&nbsp;<i>Note:</i>
A declaration is a <i ><a href='stmt.stmt#nt:statement'>statement</a></i> (<a href='stmt.dcl'>[stmt.dcl]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='stmt.select'><h2 ><a class='secnum' href='#stmt.select' style='min-width:88pt'>6.4</a> Selection statements <a class='abbr_ref' href='stmt.select'>[stmt.select]</a></h2><p ><span class='indexparent'><a class='index' id='statement,selection'></a></span></p><div class='para' id='stmt.select-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-1'>1</a></div><p >Selection statements choose one of several flows of control.</p><p ><span class='indexparent'><a class='index' id='statement,if'></a></span><span class='indexparent'><a class='index' id='statement,switch'></a></span></p><pre class='bnf'><a id='nt:selection-statement'>selection-statement:</a>
    <span class='terminal'>if (</span> <i ><a href='stmt.select#nt:condition'>condition</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <span class='terminal'>if (</span> <i ><a href='stmt.select#nt:condition'>condition</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i> <span class='terminal'>else</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <span class='terminal'>switch (</span> <i ><a href='stmt.select#nt:condition'>condition</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><pre class='bnf'><a id='nt:condition'>condition:</a>
    <i ><a href='expr.comma#nt:expression'>expression</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <span class='terminal'>=</span> <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><p >See <a href='dcl.meaning'>[dcl.meaning]</a> for the optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a condition.
In Clause <a href='stmt.stmt'>[stmt.stmt]</a>, the term <a class='hidden_link' href='#def:substatement' id='def:substatement'><i>substatement</i></a> refers to
the contained <i ><a href='stmt.stmt#nt:statement'>statement</a></i> or <i ><a href='stmt.stmt#nt:statement'>statements</a></i> that appear
in the syntax notation.
<span class='indexparent'><a class='index' id='scope,selection-statement'></a></span>The substatement in a <i ><a href='stmt.select#nt:selection-statement'>selection-statement</a></i> (each substatement,
in the <span class='texttt'>else</span> form of the <span class='texttt'>if</span> statement) implicitly defines
a block scope (<a href='basic.scope'>[basic.scope]</a>). If the substatement in a
selection-statement is a single statement and not a
<span class='grammarterm'>compound-statement,</span> it is as if it was rewritten to be a
compound-statement containing the original substatement.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
if (x)
  int i;
</pre><p >can be equivalently rewritten as</p><pre class='codeblock'>
if (x) {
  int i;
}
</pre><p >Thus after the <span class='texttt'>if</span> statement, <span class='texttt'>i</span> is no longer in scope.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.select-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-2'>2</a></div><p ><span class='indexparent'><a class='index' id='condition,rules_for'></a></span>The rules for <i ><a href='stmt.select#nt:condition'>conditions</a></i> apply both to
<i ><a href='stmt.select#nt:selection-statement'>selection-statements</a></i> and to the <span class='texttt'>for</span> and <span class='texttt'>while</span>
statements (<a href='stmt.iter'>[stmt.iter]</a>). The <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> shall not
specify a function or an array. If the <span class='texttt'>auto</span> <span class='rmfamily'></span><i> type-specifier</i> appears in
the <span class='rmfamily'></span><i> type-specifier-seq</i>,
the type of the identifier being declared is deduced from the initializer as described in <a href='dcl.spec.auto'>[dcl.spec.auto]</a>.</p></div><div class='para' id='stmt.select-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-3'>3</a></div><p ><span class='indexparent'><a class='index' id='statement,declaration_in_if'></a></span><span class='indexparent'><a class='index' id='statement,declaration_in_switch'></a></span>A name introduced by a declaration in a <i ><a href='stmt.select#nt:condition'>condition</a></i> (either
introduced by the <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> or the
<i ><a href='dcl.decl#nt:declarator'>declarator</a></i> of the condition) is in scope from its point of
declaration until the end of the substatements controlled by the
condition. If the name is re-declared in the outermost block of a
substatement controlled by the condition, the declaration that
re-declares the name is ill-formed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
if (int x = f()) {
  int x;            <span class='comment'>// ill-formed, redeclaration of <span class='texttt'>x</span>
</span>}
else {
  int x;            <span class='comment'>// ill-formed, redeclaration of <span class='texttt'>x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.select-4'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-4'>4</a></div><p >The value of a <i ><a href='stmt.select#nt:condition'>condition</a></i> that is an initialized declaration
in a statement other than a <span class='texttt'>switch</span> statement is the value of the
declared variable
contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
If that
conversion is ill-formed, the program is ill-formed. The value of a
<i ><a href='stmt.select#nt:condition'>condition</a></i> that is an initialized declaration in a
<span class='texttt'>switch</span> statement is the value of the declared variable if it has
integral or enumeration type, or of that variable implicitly converted
to integral or enumeration type otherwise. The value of a
<i ><a href='stmt.select#nt:condition'>condition</a></i> that is an expression is the value of the
expression, contextually converted to <span class='texttt'>bool</span>
for statements other
than <span class='texttt'>switch</span>;
if that conversion is ill-formed, the program is
ill-formed. The value of the condition will be referred to as simply
“the condition” where the usage is unambiguous.</p></div><div class='para' id='stmt.select-5'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-5'>5</a></div><p >If a <i ><a href='stmt.select#nt:condition'>condition</a></i> can be syntactically resolved as either an
expression or the declaration of a block-scope name, it is interpreted as a
declaration.</p></div><div class='para' id='stmt.select-6'><div class='marginalizedparent'><a class='marginalized' href='#stmt.select-6'>6</a></div><p >In the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='stmt.select#nt:condition'>condition</a></i>, each
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> shall be either a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
or <span class='texttt'>constexpr</span>.</p></div><div id='stmt.if'><h3 ><a class='secnum' href='#stmt.if' style='min-width:103pt'>6.4.1</a> The <span class='texttt'>if</span> statement <a class='abbr_ref' href='stmt.if'>[stmt.if]</a></h3><p ><span class='indexparent'><a class='index' id='statement,if'></a></span></p><div class='para' id='stmt.if-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.if-1'>1</a></div><p >If the condition (<a href='stmt.select'>[stmt.select]</a>) yields <span class='texttt'>true</span> the first
substatement is executed. If the <span class='texttt'>else</span> part of the selection
statement is present and the condition yields <span class='texttt'>false</span>, the second
substatement is executed. In the second form of <span class='texttt'>if</span> statement
(the one including <span class='texttt'>else</span>), if the first substatement is also an
<span class='texttt'>if</span> statement then that inner <span class='texttt'>if</span> statement shall contain
an <span class='texttt'>else</span> part.<a class='footnotenum' href='#footnote-85'>85</a></p></div><div class='footnote' id='footnote-85'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-85'>85)</a></div><p >In other words, the <span class='texttt'>else</span> is associated with the nearest un-elsed
<span class='texttt'>if</span>.</p></div></div><div id='stmt.switch'><h3 ><a class='secnum' href='#stmt.switch' style='min-width:103pt'>6.4.2</a> The <span class='texttt'>switch</span> statement <a class='abbr_ref' href='stmt.switch'>[stmt.switch]</a></h3><p ><span class='indexparent'><a class='index' id='statement,switch'></a></span></p><div class='para' id='stmt.switch-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-1'>1</a></div><p >The <span class='texttt'>switch</span> statement causes control to be transferred to one of
several statements depending on the value of a condition.</p></div><div class='para' id='stmt.switch-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-2'>2</a></div><p >The condition shall be of integral type, enumeration type, or of a class
type for which a single non-explicit conversion function to integral or enumeration
type exists (<a href='class.conv'>[class.conv]</a>). If the condition is of class type, the
condition is converted by calling that conversion function, and the
result of the conversion is used in place of the original condition for
the remainder of this section. Integral promotions are performed. Any
statement within the <span class='texttt'>switch</span> statement can be labeled with one or
more case labels as follows:</p><pre class='bnf'><span class='indexparent'><a class='index' id='label,case'></a></span><span class='terminal'>case</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>:</span></pre><p >where the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be
a converted constant expression (<a href='expr.const'>[expr.const]</a>) of the
promoted type of the switch condition. No two of the case constants in
the same switch shall have the same value after conversion to the
promoted type of the switch condition.</p></div><div class='para' id='stmt.switch-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-3'>3</a></div><p ><span class='indexparent'><a class='index' id='label,default'></a></span>There shall be at most one label of the form</p><pre class='codeblock'>
default :
</pre><p >within a <span class='texttt'>switch</span> statement.</p></div><div class='para' id='stmt.switch-4'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-4'>4</a></div><p >Switch statements can be nested; a <span class='texttt'>case</span> or <span class='texttt'>default</span> label
is associated with the smallest switch enclosing it.</p></div><div class='para' id='stmt.switch-5'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-5'>5</a></div><p >When the <span class='texttt'>switch</span> statement is executed, its condition is
evaluated and compared with each case constant.
<span class='indexparent'><a class='index' id='label,case'></a></span>If one of the case constants is equal to the value of the condition,
control is passed to the statement following the matched case label. If
no case constant matches the condition, and if there is a
<span class='indexparent'><a class='index' id='label,default'></a></span><span class='texttt'>default</span> label, control passes to the statement labeled by the
default label. If no case matches and if there is no <span class='texttt'>default</span>
then none of the statements in the switch is executed.</p></div><div class='para' id='stmt.switch-6'><div class='marginalizedparent'><a class='marginalized' href='#stmt.switch-6'>6</a></div><p ><span class='texttt'>case</span> and <span class='texttt'>default</span> labels in themselves do not alter the
flow of control, which continues unimpeded across such labels. To exit
from a switch, see <span class='texttt'>break</span>, <a href='stmt.break'>[stmt.break]</a>.
[&nbsp;<i>Note:</i>
Usually, the substatement that is the subject of a switch is compound
and <span class='texttt'>case</span> and <span class='texttt'>default</span> labels appear on the top-level
statements contained within the (compound) substatement, but this is not
required.
<span class='indexparent'><a class='index' id='statement,declaration_in_switch'></a></span>Declarations can appear in the substatement of a
<span class='grammarterm'>switch-statement</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='statement,selection'></a></span></p></div></div></div><div id='stmt.iter'><h2 ><a class='secnum' href='#stmt.iter' style='min-width:88pt'>6.5</a> Iteration statements <a class='abbr_ref' href='stmt.iter'>[stmt.iter]</a></h2><p ><span class='indexparent'><a class='index' id='statement,iteration'></a></span></p><div class='para' id='stmt.iter-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.iter-1'>1</a></div><p >Iteration statements specify looping.</p><p ><span class='indexparent'><a class='index' id='statement,while'></a></span><span class='indexparent'><a class='index' id='statement,do'></a></span><span class='indexparent'><a class='index' id='statement,for'></a></span></p><pre class='bnf'><a id='nt:iteration-statement'>iteration-statement:</a>
    <span class='terminal'>while (</span> <i ><a href='stmt.select#nt:condition'>condition</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <span class='terminal'>do</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i> <span class='terminal'>while (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>) ;</span>
    <span class='terminal'>for (</span> <i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i> <i ><a href='stmt.select#nt:condition'>condition</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span> <i ><a href='expr.comma#nt:expression'>expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i>
    <span class='terminal'>for (</span> <i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i> <span class='terminal'>:</span> <i ><a href='stmt.iter#nt:for-range-initializer'>for-range-initializer</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><pre class='bnf'><a id='nt:for-init-statement'>for-init-statement:</a>
    <i ><a href='stmt.expr#nt:expression-statement'>expression-statement</a></i>
    <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i></pre><pre class='bnf'><a id='nt:for-range-declaration'>for-range-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i></pre><pre class='bnf'><a id='nt:for-range-initializer'>for-range-initializer:</a>
    <i ><a href='expr.comma#nt:expression'>expression</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><p >See <a href='dcl.meaning'>[dcl.meaning]</a> for the optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a
<i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>.
[&nbsp;<i>Note:</i>
A <i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i> ends with a semicolon.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='stmt.iter-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.iter-2'>2</a></div><p >The substatement in an <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> implicitly defines
a block scope (<a href='basic.scope'>[basic.scope]</a>) which is entered and exited each time
through the loop.</p><p ><span class='indexparent'><a class='index' id='scope,iteration-statement'></a></span>If the substatement in an iteration-statement is a single statement and
not a <span class='grammarterm'>compound-statement,</span> it is as if it was rewritten to be
a compound-statement containing the original statement.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
while (--x &gt;= 0)
  int i;
</pre><p >can be equivalently rewritten as</p><pre class='codeblock'>
while (--x &gt;= 0) {
  int i;
}
</pre></div><div class='para' id='stmt.iter-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.iter-3'>3</a></div><p >Thus after the <span class='texttt'>while</span> statement, <span class='texttt'>i</span> is no longer in scope.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.iter-4'><div class='marginalizedparent'><a class='marginalized' href='#stmt.iter-4'>4</a></div><p >[&nbsp;<i>Note:</i>
The requirements on <i ><a href='stmt.select#nt:condition'>conditions</a></i> in iteration statements are
described in <a href='stmt.select'>[stmt.select]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='stmt.while'><h3 ><a class='secnum' href='#stmt.while' style='min-width:103pt'>6.5.1</a> The <span class='texttt'>while</span> statement <a class='abbr_ref' href='stmt.while'>[stmt.while]</a></h3><p ><span class='indexparent'><a class='index' id='statement,while'></a></span></p><div class='para' id='stmt.while-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.while-1'>1</a></div><p >In the <span class='texttt'>while</span> statement the substatement is executed repeatedly
until the value of the condition (<a href='stmt.select'>[stmt.select]</a>) becomes
<span class='texttt'>false</span>. The test takes place before each execution of the
substatement.</p></div><div class='para' id='stmt.while-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.while-2'>2</a></div><p ><span class='indexparent'><a class='index' id='statement,declaration_in_while'></a></span>When the condition of a <span class='texttt'>while</span> statement is a declaration, the scope of
the variable that is declared extends from its point of
declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) to the end of the <span class='texttt'>while</span>
<i ><a href='stmt.stmt#nt:statement'>statement</a></i>. A <span class='texttt'>while</span> statement of the form</p><pre class='codeblock'>
while (T t = x) <span class='grammarterm'>statement</span>
</pre><p >is equivalent to</p><pre class='codeblock'>
label:{                   <span class='comment'>// start of condition scope
</span>  T t = x;
  if (t) {
    <span class='grammarterm'>statement</span>
    goto label;
  }
}                   <span class='comment'>// end of condition scope
</span></pre><p >The variable created in a condition is destroyed and created with each
iteration of the loop.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  int val;
  A(int i) : val(i) { }
  ~A() { }
  operator bool() { return val != 0; }
};
int i = 1;
while (A a = i) {
  <span class='comment'>// ...
</span>  i = 0;
}
</pre><p >In the while-loop, the constructor and destructor are each called twice,
once for the condition that succeeds and once for the condition that
fails.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='stmt.do'><h3 ><a class='secnum' href='#stmt.do' style='min-width:103pt'>6.5.2</a> The <span class='texttt'>do</span> statement <a class='abbr_ref' href='stmt.do'>[stmt.do]</a></h3><p ><span class='indexparent'><a class='index' id='statement,do'></a></span></p><div class='para' id='stmt.do-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.do-1'>1</a></div><p >The expression is contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>);
if that conversion is ill-formed, the program is ill-formed.</p></div><div class='para' id='stmt.do-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.do-2'>2</a></div><p >In the <span class='texttt'>do</span> statement the substatement is executed repeatedly
until the value of the expression becomes <span class='texttt'>false</span>. The test takes
place after each execution of the statement.</p></div></div><div id='stmt.for'><h3 ><a class='secnum' href='#stmt.for' style='min-width:103pt'>6.5.3</a> The <span class='texttt'>for</span> statement <a class='abbr_ref' href='stmt.for'>[stmt.for]</a></h3><p ><span class='indexparent'><a class='index' id='statement,for'></a></span></p><div class='para' id='stmt.for-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.for-1'>1</a></div><p >The <span class='texttt'>for</span> statement</p><pre class='bnf'><span class='terminal'>for (</span> <i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i> <i ><a href='stmt.select#nt:condition'>condition</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span> <i ><a href='expr.comma#nt:expression'>expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><p >is equivalent to</p><pre class='bnf'><span class='terminal'>{</span>
&#9;<i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i>
&#9;<span class='terminal'>while (</span> <i ><a href='stmt.select#nt:condition'>condition</a></i> <span class='terminal'>) {</span>
&#9;&#9;<i ><a href='stmt.stmt#nt:statement'>statement</a></i>
&#9;&#9;<i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>;</span>
&#9;<span class='terminal'>}</span>
<span class='terminal'>}</span></pre><p >except that names declared in the <i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i> are in
the same declarative-region as those declared in the
<i ><a href='stmt.select#nt:condition'>condition</a></i>, and except that a
<span class='indexparent'><a class='index' id='statement,continue_in_for'></a></span><span class='texttt'>continue</span> in <i ><a href='stmt.stmt#nt:statement'>statement</a></i> (not enclosed in another
iteration statement) will execute <i ><a href='expr.comma#nt:expression'>expression</a></i> before
re-evaluating <i ><a href='stmt.select#nt:condition'>condition</a></i>.
[&nbsp;<i>Note:</i>
Thus the first statement specifies initialization for the loop; the
condition (<a href='stmt.select'>[stmt.select]</a>) specifies a test, made before each
iteration, such that the loop is exited when the condition becomes
<span class='texttt'>false</span>; the expression often specifies incrementing that is done
after each iteration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='stmt.for-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.for-2'>2</a></div><p >Either or both of the condition and the expression can be omitted. A
missing <i ><a href='stmt.select#nt:condition'>condition</a></i> makes the implied <span class='texttt'>while</span> Clause
equivalent to <span class='texttt'>while(true)</span>.</p></div><div class='para' id='stmt.for-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.for-3'>3</a></div><p ><span class='indexparent'><a class='index' id='statement,declaration_in_for'></a></span><span class='indexparent'><a class='index' id='for,scope_of_declaration_in'></a></span>If the <i ><a href='stmt.iter#nt:for-init-statement'>for-init-statement</a></i> is a declaration, the scope of the
name(s) declared extends to the end of the <span class='grammarterm'>for-statement</span>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int i = 42;
int a[10];

for (int i = 0; i &lt; 10; i++)
  a[i] = i;

int j = i;          <span class='comment'>// <span class='texttt'>j = 42</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='stmt.ranged'><h3 ><a class='secnum' href='#stmt.ranged' style='min-width:103pt'>6.5.4</a> The range-based <span class='texttt'>for</span> statement <a class='abbr_ref' href='stmt.ranged'>[stmt.ranged]</a></h3><p ><span class='indexparent'><a class='index' id='statement,range_based_for'></a></span></p><div class='para' id='stmt.ranged-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.ranged-1'>1</a></div><p >For a range-based <span class='texttt'>for</span> statement of the form</p><pre class='bnf'><span class='terminal'>for (</span> <i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i> : <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><p >let <i>range-init</i> be equivalent to the <i ><a href='expr.comma#nt:expression'>expression</a></i> surrounded
by parentheses<a class='footnotenum' href='#footnote-86'>86</a></p><pre class='bnf'><span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre><p >and for a range-based <span class='texttt'>for</span> statement of the form</p><pre class='bnf'><span class='terminal'>for</span> <span class='terminal'>(</span> <i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i> <span class='terminal'>:</span> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> <span class='terminal'>)</span> <i ><a href='stmt.stmt#nt:statement'>statement</a></i></pre><p >let <i>range-init</i> be equivalent to the <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>. In each case, a
range-based <span class='texttt'>for</span> statement
is equivalent to</p><pre class='codeblock'>
{
  auto &amp;&amp; __range = range-init;
  for ( auto __begin = begin-expr,
             __end = end-expr;
        __begin != __end;
        ++__begin ) {
    <i>for-range-declaration</i> = *__begin;
    <i>statement</i>
  }
}
</pre><p >where <span class='texttt'>__range</span>, <span class='texttt'>__begin</span>, and <span class='texttt'>__end</span> are variables defined for
exposition only, and <span class='texttt'>_RangeT</span> is the type of the
<i ><a href='expr.comma#nt:expression'>expression</a></i>, and <i>begin-expr</i> and <i>end-expr</i> are
determined as follows:</p><ul class='itemize'><li id='stmt.ranged-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#stmt.ranged-1.1'>(1.1)</a></div><p >if <span class='texttt'>_RangeT</span> is an array type, <i>begin-expr</i> and <i>end-expr</i> are
<span class='texttt'>__range</span> and <span class='texttt'>__range + __bound</span>, respectively, where <span class='texttt'>__bound</span> is
the array bound. If <span class='texttt'>_RangeT</span> is an array of unknown size or an array of
incomplete type, the program is ill-formed;</p></li><li id='stmt.ranged-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#stmt.ranged-1.2'>(1.2)</a></div><p >if <span class='texttt'>_RangeT</span> is a class type, the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-ids</a></i>
<span class='texttt'>begin</span> and <span class='texttt'>end</span> are looked up in the scope of class <span class='texttt'><span class='mbox'>_RangeT</span></span>
as if by class member access lookup (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), and if either
(or both) finds at least one declaration, <span class='grammarterm'>begin-expr</span> and
<span class='grammarterm'>end-expr</span> are <span class='texttt'>__range.begin()</span> and <span class='texttt'>__range.end()</span>,
respectively;</p></li><li id='stmt.ranged-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#stmt.ranged-1.3'>(1.3)</a></div><p >otherwise, <i>begin-expr</i> and <i>end-expr</i> are <span class='texttt'>begin(__range)</span>
and <span class='texttt'>end(__range)</span>, respectively, where <span class='texttt'>begin</span> and <span class='texttt'>end</span> are looked
up with argument-dependent lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>). For the purposes of this
name lookup, namespace <span class='texttt'>std</span> is an associated namespace.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int array[5] = { 1, 2, 3, 4, 5 };
for (int&amp; x : array)
  x *= 2;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='statement,iteration'></a></span></p></div><div class='para' id='stmt.ranged-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.ranged-2'>2</a></div><p >In the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>,
each <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> shall be either a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
or <span class='texttt'>constexpr</span>.</p></div><div class='footnote' id='footnote-86'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-86'>86)</a></div><p >this ensures that a top-level comma operator cannot be
reinterpreted as a delimiter between <i ><a href='dcl.decl#nt:init-declarator'>init-declarators</a></i> in the
declaration of <span class='texttt'>__range</span>.</p></div></div></div><div id='stmt.jump'><h2 ><a class='secnum' href='#stmt.jump' style='min-width:88pt'>6.6</a> Jump statements <a class='abbr_ref' href='stmt.jump'>[stmt.jump]</a></h2><p ><span class='indexparent'><a class='index' id='statement,jump'></a></span></p><div class='para' id='stmt.jump-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.jump-1'>1</a></div><p >Jump statements unconditionally transfer control.
<span class='indexparent'><a class='index' id='statement,jump'></a></span>
<span class='indexparent'><a class='index' id='statement,break'></a></span><span class='indexparent'><a class='index' id='statement,continue'></a></span><span class='indexparent'><a class='index' id='return_statement'></a></span><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><pre class='bnf'><a id='nt:jump-statement'>jump-statement:</a>
    <span class='terminal'>break ;</span>
    <span class='terminal'>continue ;</span>
    <span class='terminal'>return</span> <i ><a href='expr.comma#nt:expression'>expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <span class='terminal'>return</span> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> <span class='terminal'>;</span>
    <span class='terminal'>goto</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre></div><div class='para' id='stmt.jump-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.jump-2'>2</a></div><p ><span class='indexparent'><a class='index' id='local_variable,destruction_of'></a></span><span class='indexparent'><a class='index' id='scope,destructor_and_exit_from'></a></span>On exit from a scope (however accomplished), objects with automatic storage
duration (<a href='basic.stc.auto'>[basic.stc.auto]</a>) that have been constructed in that scope are destroyed
in the reverse order of their construction. [&nbsp;<i>Note:</i> For temporaries,
see <a href='class.temporary'>[class.temporary]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Transfer out of a loop, out of a block, or back
past
an initialized variable with automatic storage duration involves the
destruction of objects with automatic storage duration that are in
scope at the point transferred from but not at the point transferred to.
(See <a href='stmt.dcl'>[stmt.dcl]</a> for transfers into blocks).
[&nbsp;<i>Note:</i>
However, the program can be terminated (by calling
<span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='texttt'>std::exit()</span> or
<span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='texttt'>std::abort()</span> (<a href='support.start.term'>[support.start.term]</a>), for example) without
destroying class objects with automatic storage duration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='stmt.break'><h3 ><a class='secnum' href='#stmt.break' style='min-width:103pt'>6.6.1</a> The <span class='texttt'>break</span> statement <a class='abbr_ref' href='stmt.break'>[stmt.break]</a></h3><p ><span class='indexparent'><a class='index' id='statement,break'></a></span></p><div class='para' id='stmt.break-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.break-1'>1</a></div><p >The <span class='texttt'>break</span> statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><span class='indexparent'><a class='index' id='statement,switch'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or a <span class='texttt'>switch</span> statement and causes
termination of the smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or
<span class='texttt'>switch</span> statement; control passes to the statement following the
terminated statement, if any.</p></div></div><div id='stmt.cont'><h3 ><a class='secnum' href='#stmt.cont' style='min-width:103pt'>6.6.2</a> The <span class='texttt'>continue</span> statement <a class='abbr_ref' href='stmt.cont'>[stmt.cont]</a></h3><p ><span class='indexparent'><a class='index' id='statement,continue'></a></span></p><div class='para' id='stmt.cont-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.cont-1'>1</a></div><p >The
<span class='texttt'>continue</span>
statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>
and causes control to pass to the loop-continuation portion of the
smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>, that is, to the end
of the loop. More precisely, in each of the statements</p><div class='minipage'><pre class='codeblock'>
while (foo) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><div class='minipage'><pre class='codeblock'>
do {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
} while (foo);
</pre></div><div class='minipage'><pre class='codeblock'>
for (;;) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><p >a <span class='texttt'>continue</span> not contained in an enclosed iteration statement is
equivalent to <span class='texttt'>goto</span> <span class='texttt'>contin</span>.</p></div></div><div id='stmt.return'><h3 ><a class='secnum' href='#stmt.return' style='min-width:103pt'>6.6.3</a> The <span class='texttt'>return</span> statement <a class='abbr_ref' href='stmt.return'>[stmt.return]</a></h3><p ><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='function_return'></a></span>
</p><div class='para' id='stmt.return-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-1'>1</a></div><p >A function returns to its caller by the <span class='texttt'>return</span> statement.</p></div><div class='para' id='stmt.return-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-2'>2</a></div><p >A return statement
with neither an <i ><a href='expr.comma#nt:expression'>expression</a></i> nor a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
can be used only in functions
that do not return a value, that is, a function with the return type
<span class='texttt'>void</span>, a constructor (<a href='class.ctor'>[class.ctor]</a>), or a
destructor (<a href='class.dtor'>[class.dtor]</a>).
<span class='indexparent'><a class='index' id='return,constructor_and'></a></span><span class='indexparent'><a class='index' id='return,constructor_and'></a></span>A return statement with an expression of non-void type can be used only
in functions returning a value; the value of the expression is returned
to the caller of the function.
<span class='indexparent'><a class='index' id='conversion,return_type'></a></span>The value of the expression is implicitly converted to the return type of the
function in which it appears. A return statement can involve the
construction and copy or move of a temporary object (<a href='class.temporary'>[class.temporary]</a>).
[&nbsp;<i>Note:</i>
A copy or move operation associated with a return statement may be elided or
considered as an rvalue for the purpose of overload resolution in
selecting a constructor (<a href='class.copy'>[class.copy]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] A return statement with a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> initializes the object or reference to be returned from the function by copy-list-initialization (<a href='dcl.init.list'>[dcl.init.list]</a>) from the specified initializer list. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
std::pair&lt;std::string,int&gt; f(const char* p, int x) {
  return {p,x};
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >Flowing off the end of a function is equivalent to a <span class='texttt'>return</span> with
no value; this results in undefined behavior in a value-returning
function.</p></div><div class='para' id='stmt.return-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-3'>3</a></div><p >A return statement with an expression of type <span class='texttt'>void</span>
can be used only in functions with a return type of
<i>cv</i> <span class='texttt'>void</span>; the expression is evaluated just before the function
returns to its caller.</p></div></div><div id='stmt.goto'><h3 ><a class='secnum' href='#stmt.goto' style='min-width:103pt'>6.6.4</a> The <span class='texttt'>goto</span> statement <a class='abbr_ref' href='stmt.goto'>[stmt.goto]</a></h3><p ><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><div class='para' id='stmt.goto-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.goto-1'>1</a></div><p >The <span class='texttt'>goto</span> statement unconditionally transfers control to the
statement labeled by the identifier. The identifier shall be a
<span class='indexparent'><a class='index' id='label'></a></span>label (<a href='stmt.label'>[stmt.label]</a>) located in the current function.</p></div></div></div><div id='stmt.dcl'><h2 ><a class='secnum' href='#stmt.dcl' style='min-width:88pt'>6.7</a> Declaration statement <a class='abbr_ref' href='stmt.dcl'>[stmt.dcl]</a></h2><p ><span class='indexparent'><a class='index' id='statement,declaration'></a></span></p><div class='para' id='stmt.dcl-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.dcl-1'>1</a></div><p >A declaration statement introduces one or more new identifiers into a
block; it has the form</p><pre class='bnf'><a id='nt:declaration-statement'>declaration-statement:</a>
    <i ><a href='dcl.dcl#nt:block-declaration'>block-declaration</a></i></pre><p >If an identifier introduced by a declaration was previously declared in
an outer block,
<span class='indexparent'><a class='index' id='declaration_hiding'></a></span><span class='indexparent'><a class='index' id='name_hiding'></a></span><span class='indexparent'><a class='index' id='block_structure'></a></span>the outer declaration is hidden for the remainder of the block, after
which it resumes its force.</p></div><div class='para' id='stmt.dcl-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.dcl-2'>2</a></div><p ><span class='indexparent'><a class='index' id='block,initialization_in'></a></span><span class='indexparent'><a class='index' id='initialization,automatic'></a></span>Variables with automatic storage duration (<a href='basic.stc.auto'>[basic.stc.auto]</a>) are
initialized each time their <i ><a href='stmt.dcl#nt:declaration-statement'>declaration-statement</a></i> is executed.
<span class='indexparent'><a class='index' id='local_variable,destruction_of'></a></span>Variables with automatic storage duration declared in the block are
destroyed on exit from the block (<a href='stmt.jump'>[stmt.jump]</a>).</p></div><div class='para' id='stmt.dcl-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.dcl-3'>3</a></div><p ><span class='indexparent'><a class='index' id='initialization,jump_past'></a></span><span class='indexparent'><a class='index' id='goto,initialization_and'></a></span>It is possible to transfer into a block, but not in a way that bypasses
declarations with initialization. A program that jumps<a class='footnotenum' href='#footnote-87'>87</a>
from a point where a variable with automatic storage duration is
not in scope to a point where it is in scope is ill-formed unless the
variable has scalar type, class type with a trivial default constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the preceding types and is declared without an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> (<a href='dcl.init'>[dcl.init]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f() {
  <span class='comment'>// ... 
</span>  goto lx;          <span class='comment'>// ill-formed: jump into scope of <span class='texttt'>a</span>
</span>  <span class='comment'>// ...
</span>ly:
  X a = 1;
  <span class='comment'>// ...
</span>lx:
  goto ly;          <span class='comment'>// OK, jump implies destructor
</span>                    <span class='comment'>// call for <span class='texttt'>a</span> followed by construction
</span>                    <span class='comment'>// again immediately following label <span class='texttt'>ly</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.dcl-4'><div class='marginalizedparent'><a class='marginalized' href='#stmt.dcl-4'>4</a></div><p ><span class='indexparent'><a class='index' id='initialization,automatic'></a></span><span class='indexparent'><a class='index' id='initialization,local_static'></a></span>The zero-initialization (<a href='dcl.init'>[dcl.init]</a>) of all block-scope
variables with
static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>) or thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>) is performed before any
other initialization takes place. Constant initialization (<a href='basic.start.init'>[basic.start.init]</a>) of a
block-scope entity with static storage duration, if applicable, is performed before its block is first
entered. An implementation is permitted to perform early initialization
of other block-scope variables with static or thread storage duration under the same
conditions that an implementation is permitted to statically initialize
a variable with static or thread storage duration in namespace
scope (<a href='basic.start.init'>[basic.start.init]</a>). Otherwise such a variable is initialized
the first time control passes through its declaration; such a variable is
considered initialized upon the completion of its initialization. If the
initialization exits by throwing an exception, the initialization is not
complete, so it will be tried again the next time control enters the
declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<a class='footnotenum' href='#footnote-88'>88</a> If control re-enters the declaration recursively while
the variable is being initialized, the behavior is undefined.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int foo(int i) {
  static int s = foo(2*i);      <span class='comment'>// recursive call - undefined
</span>  return i+1;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.dcl-5'><div class='marginalizedparent'><a class='marginalized' href='#stmt.dcl-5'>5</a></div><p ><span class='indexparent'><a class='index' id='static,destruction_of_local'></a></span>The destructor for a block-scope object with static or thread storage duration will be
executed if and only if it was constructed.
[&nbsp;<i>Note:</i>
<a href='basic.start.term'>[basic.start.term]</a> describes the order in which block-scope objects with
static and thread storage duration are destroyed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-87'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-87'>87)</a></div><p >The transfer from the condition of a <span class='texttt'>switch</span> statement to a
<span class='texttt'>case</span> label is considered a jump in this respect.</p></div><div class='footnote' id='footnote-88'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-88'>88)</a></div><p >The implementation must not introduce any deadlock around execution of the initializer.</p></div></div><div id='stmt.ambig'><h2 ><a class='secnum' href='#stmt.ambig' style='min-width:88pt'>6.8</a> Ambiguity resolution <a class='abbr_ref' href='stmt.ambig'>[stmt.ambig]</a></h2><p ><span class='indexparent'><a class='index' id='ambiguity,declaration_versus_expression'></a></span></p><div class='para' id='stmt.ambig-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.ambig-1'>1</a></div><p >There is an ambiguity in the grammar involving
<i ><a href='stmt.expr#nt:expression-statement'>expression-statements</a></i> and <i ><a href='dcl.dcl#nt:declaration'>declarations</a></i>: An
<i ><a href='stmt.expr#nt:expression-statement'>expression-statement</a></i> with a function-style explicit type
conversion (<a href='expr.type.conv'>[expr.type.conv]</a>) as its leftmost subexpression can be
indistinguishable from a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> where the first
<i ><a href='dcl.decl#nt:declarator'>declarator</a></i> starts with a <span class='texttt'>(</span>. In those cases the
<i ><a href='stmt.stmt#nt:statement'>statement</a></i> is a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>. [&nbsp;<i>Note:</i> To
disambiguate, the whole <i ><a href='stmt.stmt#nt:statement'>statement</a></i> might have to be examined
to determine if it is an <i ><a href='stmt.expr#nt:expression-statement'>expression-statement</a></i> or a
<i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>. This disambiguates many examples.
[&nbsp;<i>Example:</i>
assuming <span class='texttt'>T</span> is a
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> (<a href='dcl.type'>[dcl.type]</a>),</p><pre class='codeblock'>
T(a)-&gt;m = 7;        <span class='comment'>// expression-statement
</span>T(a)++;             <span class='comment'>// expression-statement
</span>T(a,5)&lt;&lt;c;          <span class='comment'>// expression-statement
</span>
T(*d)(int);         <span class='comment'>//  declaration
</span>T(e)[5];            <span class='comment'>//  declaration
</span>T(f) = { 1, 2 };    <span class='comment'>//  declaration
</span>T(*g)(double(3));   <span class='comment'>//  declaration
</span></pre><p >In the last example above, <span class='texttt'>g</span>, which is a pointer to <span class='texttt'>T</span>,
is initialized to <span class='texttt'>double(3)</span>. This is of course ill-formed for
semantic reasons, but that does not affect the syntactic analysis.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='stmt.ambig-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.ambig-2'>2</a></div><p >The remaining cases are <i ><a href='dcl.dcl#nt:declaration'>declarations</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class T {
  <span class='comment'>// ...
</span>public:
  T();
  T(int);
  T(int, int);
};
T(a);               <span class='comment'>//  declaration
</span>T(*b)();            <span class='comment'>//  declaration
</span>T(c)=7;             <span class='comment'>//  declaration
</span>T(d),e,f=3;         <span class='comment'>//  declaration
</span>extern int h;
T(g)(h,2);          <span class='comment'>//  declaration
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='stmt.ambig-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.ambig-3'>3</a></div><p >The disambiguation is purely syntactic; that is, the meaning of the
names occurring in such a statement, beyond whether they are
<i ><a href='dcl.type.simple#nt:type-name'>type-names</a></i> or not, is not generally used in or changed by the
disambiguation. Class templates are instantiated as necessary to
determine if a qualified name is a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be
an ill-formed declaration. If, during parsing, a name in a template
parameter is bound differently than it would be bound during a trial
parse, the program is ill-formed. No diagnostic is required.
[&nbsp;<i>Note:</i>
This can occur only when the name is declared earlier in the
declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct T1 {
  T1 operator()(int x) { return T1(x); }
  int operator=(int x) { return x; }
  T1(int) { }
};
struct T2 { T2(int){ } };
int a, (*(*b)(T2))(int), c, d;

void f() {
  <span class='comment'>// disambiguation requires this to be parsed as a declaration:
</span>  T1(a) = 3,
  T2(4),                        <span class='comment'>// <span class='texttt'>T2</span> will be declared as
</span>  (*(*b)(T2(c)))(int(d));       <span class='comment'>// a variable of type <span class='texttt'>T1</span>
</span>                                <span class='comment'>// but this will not allow
</span>                                <span class='comment'>// the last part of the
</span>                                <span class='comment'>// declaration to parse
</span>                                <span class='comment'>// properly since it depends
</span>                                <span class='comment'>// on <span class='texttt'>T2</span> being a type-name
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='statement'></a></span>
</p></div></div></div></div></body></html>