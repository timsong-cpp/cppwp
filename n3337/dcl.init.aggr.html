<!DOCTYPE html><html lang='en'><head><title>[dcl.init.aggr]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Initializers <a class='abbr_ref' href='dcl.init#aggr'>[dcl.init]</a></h2><div id='dcl.init.aggr'><h3 ><a class='secnum' style='min-width:103pt'>8.5.1</a> Aggregates <a class='abbr_ref'>[dcl.init.aggr]</a></h3><p ><span class='indexparent'><a class='index' id='aggregate'></a></span><span class='indexparent'><a class='index' id='initialization,aggregate'></a></span><span class='indexparent'><a class='index' id='aggregate_initialization'></a></span><span class='indexparent'><a class='index' id='initialization,array'></a></span><span class='indexparent'><a class='index' id='initialization,class_object'></a></span><span class='indexparent'><a class='index' id='class_object_initialization'></a></span><span class='indexparent'><a class='index' id='{},initializer_list'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >An
<a class='hidden_link' href='#def:aggregate' id='def:aggregate'><i>aggregate</i></a>
is an array or a class (Clause <a href='class'>[class]</a>) with no
user-provided constructors (<a href='class.ctor'>[class.ctor]</a>),
no <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> for non-static data
members (<a href='class.mem'>[class.mem]</a>),
no private or protected non-static data members (Clause <a href='class.access'>[class.access]</a>),
no base classes (Clause <a href='class.derived'>[class.derived]</a>),
and no virtual functions (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >When an aggregate is initialized by an initializer list, as specified in <a href='dcl.init.list'>[dcl.init.list]</a>, the elements of the initializer list are taken as initializers
for the members of the aggregate,
in increasing subscript or member order.
Each member is copy-initialized from the corresponding <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>. If the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is an expression and a narrowing conversion (<a href='dcl.init.list'>[dcl.init.list]</a>) is required to convert the expression, the program is ill-formed. [&nbsp;<i>Note:</i> If an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is itself an initializer list, the member is list-initialized, which will result in a recursive application of the rules in this section if the member is an aggregate. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a = { 1, { 2, 3 } };
</pre><p >initializes
<span class='texttt'>a.x</span>
with 1,
<span class='texttt'>a.b.i</span>
with 2,
<span class='texttt'>a.b.j</span>
with 3.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >An aggregate that is a class can also be initialized with a single
expression not enclosed in braces, as described in <a href='dcl.init'>[dcl.init]</a>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >An array of unknown size initialized with a
brace-enclosed
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
containing
<span class='texttt'>n</span>
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>,
where
<span class='texttt'>n</span>
shall be greater than zero, is defined as having
<span class='texttt'>n</span>
elements (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x[] = { 1, 3, 5 };
</pre><p >declares and initializes
<span class='texttt'>x</span>
as a one-dimensional array that has three elements
since no size was specified and there are three initializers.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
An empty initializer list
<span class='texttt'>{}</span>
shall not be used as the <span class='grammarterm'>initializer-clause </span>
for an array of unknown bound.<a class='footnotenum' href='#footnote-104'>104</a></p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Static data members and anonymous bit-fields are not considered
members of the class for purposes of aggregate initialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  int i;
  static int s;
  int j;
  int :17;
  int k;
} a = { 1, 2, 3 };
</pre><p >Here, the second initializer 2 initializes
<span class='texttt'>a.j</span>
and not the static data member
<span class='texttt'>A::s</span>, and the third initializer 3 initializes <span class='texttt'>a.k</span>
and not the anonymous bit-field before it.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >An
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
is ill-formed if the number of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> 
exceeds the number of members or elements to initialize.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
char cv[4] = { 'a', 's', 'd', 'f', 0 };     <span class='comment'>// error
</span></pre><p >is ill-formed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If there are fewer
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> 
in the list than there are members in the aggregate,
then each member not explicitly initialized
shall be
initialized from an empty initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S { int a; const char* b; int c; };
S ss = { 1, "asdf" };
</pre><p >initializes
<span class='texttt'>ss.a</span>
with 1,
<span class='texttt'>ss.b</span>
with <span class='texttt'>"asdf"</span>,
and
<span class='texttt'>ss.c</span>
with the value of an expression of the form
<span class='texttt'>int()</span>,
that is,
<span class='texttt'>0</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >If an aggregate class <span class='texttt'>C</span> contains a subaggregate member
<span class='texttt'>m</span> that has no members for purposes of aggregate initialization,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for <span class='texttt'>m</span> shall not be
omitted from an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> for an object of type
<span class='texttt'>C</span> unless the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> for all
members of <span class='texttt'>C</span> following <span class='texttt'>m</span> are also omitted.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S { } s;
struct A {
  S s1;
  int i1;
  S s2;
  int i2;
  S s3;
  int i3;
} a = {
  { },      <span class='comment'>// Required initialization
</span>  0,
  s,        <span class='comment'>// Required initialization
</span>  0
};          <span class='comment'>// Initialization not required for <span class='texttt'>A::s3</span> because <span class='texttt'>A::i3</span> is also not initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >If an incomplete or empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
leaves a member of reference type uninitialized, the program is ill-formed.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >When initializing a multi-dimensional array,
the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initialize the elements with the last (rightmost) index of the array
varying the fastest (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x[2][2] = { 3, 1, 4, 2 };
</pre><p >initializes
<span class='texttt'>x[0][0]</span>
to
<span class='texttt'>3</span>,
<span class='texttt'>x[0][1]</span>
to
<span class='texttt'>1</span>,
<span class='texttt'>x[1][0]</span>
to
<span class='texttt'>4</span>,
and
<span class='texttt'>x[1][1]</span>
to
<span class='texttt'>2</span>.
On the other hand,</p><pre class='codeblock'>
float y[4][3] = {
  { 1 }, { 2 }, { 3 }, { 4 }
};
</pre><p >initializes the first column of
<span class='texttt'>y</span>
(regarded as a two-dimensional array)
and leaves the rest zero.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >In a declaration of the form</p><pre class='codeblock'>
T x = { a };
</pre><p >braces can be elided in an
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
as follows.<a class='footnotenum' href='#footnote-105'>105</a>
If the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
begins with a left brace,
then the succeeding comma-separated list of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initializes the members of a subaggregate;
it is erroneous for there to be more
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
than members.
If, however, the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
for a subaggregate does not begin with a left brace,
then only enough
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
from the list are taken to initialize the members of the subaggregate;
any remaining
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
are left to initialize the next member of the aggregate
of which the current subaggregate is a member.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
float y[4][3] = {
  { 1, 3, 5 },
  { 2, 4, 6 },
  { 3, 5, 7 },
};
</pre><p >is a completely-braced initialization:
1, 3, and 5 initialize the first row of the array
<span class='texttt'>y[0]</span>,
namely
<span class='texttt'>y[0][0]</span>,
<span class='texttt'>y[0][1]</span>,
and
<span class='texttt'>y[0][2]</span>.
Likewise the next two lines initialize
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
The initializer ends early and therefore
<span class='texttt'>y[3]</span>s
elements are initialized as if explicitly initialized with an
expression of the form
<span class='texttt'>float()</span>,
that is, are initialized with
<span class='texttt'>0.0</span>.
In the following example, braces in the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
are elided;
however the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
has the same effect as the completely-braced
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
of the above example,</p><pre class='codeblock'>
float y[4][3] = {
  1, 3, 5, 2, 4, 6, 3, 5, 7
};
</pre><p >The initializer for
<span class='texttt'>y</span>
begins with a left brace, but the one for
<span class='texttt'>y[0]</span>
does not,
therefore three elements from the list are used.
Likewise the next three are taken successively for
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >All implicit type conversions (Clause <a href='conv'>[conv]</a>) are considered when
initializing the aggregate member with an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.
If the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
can initialize a member, the member is initialized.
Otherwise, if the member is itself a subaggregate,
brace elision is assumed and the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is considered for the initialization of the first member of the subaggregate.
[&nbsp;<i>Note:</i> As specified above, brace elision cannot apply to
subaggregates with no members for purposes of aggregate initialization; an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for the entire subobject is
required.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  int i;
  operator int();
};
struct B {
  A a1, a2;
  int z;
};
A a;
B b = { 4, a, a };
</pre><p >Braces are elided around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for
<span class='texttt'>b.a1.i</span>.
<span class='texttt'>b.a1.i</span>
is initialized with 4,
<span class='texttt'>b.a2</span>
is initialized with
<span class='texttt'>a</span>,
<span class='texttt'>b.z</span>
is initialized with whatever
<span class='texttt'>a.operator int()</span>
returns.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='initialization,array_of_class_objects'></a></span>[&nbsp;<i>Note:</i>
An aggregate array or an aggregate class may contain members of a
class type with a user-provided constructor (<a href='class.ctor'>[class.ctor]</a>).
Initialization of these aggregate objects is described in <a href='class.expl.init'>[class.expl.init]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >[&nbsp;<i>Note:</i> Whether the initialization of aggregates with static storage duration is static or dynamic is specified in <a href='basic.start.init'>[basic.start.init]</a> and <a href='stmt.dcl'>[stmt.dcl]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p ><span class='indexparent'><a class='index' id='initialization,union'></a></span>When a union is initialized with a brace-enclosed initializer,
the braces shall only contain an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for the first non-static data member of the union.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1;                        <span class='comment'>// error
</span>u d = { 0, "asdf" };            <span class='comment'>// error
</span>u e = { "asdf" };               <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >[&nbsp;<i>Note:</i>
As described above,
the braces around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for a union member can be omitted if the
union is a member of another aggregate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-104'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-104'>104)</a></div><p >The syntax provides for empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-lists</a></i>,
but nonetheless C++ does not have zero length arrays.</p></div><div class='footnote' id='footnote-105'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-105'>105)</a></div><p >Braces cannot be elided in other uses of list-initialization.</p></div></div></div></body></html>