<!DOCTYPE html><html lang='en'><head><title>[over.call.func]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.3</a> Overload resolution <a class='abbr_ref' href='over.match#over.call.func'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>13.3.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs#over.call.func'>[over.match.funcs]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>13.3.1.1</a> Function call syntax <a class='abbr_ref' href='over.match.call#over.call.func'>[over.match.call]</a></h4><div id='over.call.func'><h4 ><a class='secnum' style='min-width:133pt'>13.3.1.1.1</a> Call to named function <a class='abbr_ref'>[over.call.func]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Of interest in <a href='over.call.func'>[over.call.func]</a> are only those function calls in
which the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
ultimately contains a name that
denotes one or more functions that might be called.
Such a
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>,
perhaps nested arbitrarily deep in
parentheses, has one of the following forms:</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>:
    <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
    <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
    <i ><a href='expr.prim#nt:primary-expression'>primary-expression</a></i></pre><p >These represent two syntactic subcategories of function calls:
qualified function calls and unqualified function calls.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >In qualified function calls, the name to be resolved is an
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
and is preceded by an
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
operator.
Since the
construct
<span class='texttt'>A-&gt;B</span>
is generally equivalent to
<span class='texttt'>(*A).B</span>,
the rest of
Clause <a href='over'>[over]</a> assumes, without loss of generality, that all member
function calls have been normalized to the form that uses an
object and the
<span class='texttt'>.</span>
operator.
Furthermore, Clause <a href='over'>[over]</a> assumes that
the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
that is the left operand of the
<span class='texttt'>.</span>
operator
has type “<i>cv</i> <span class='texttt'>T</span>”
where
<span class='texttt'>T</span>
denotes a class<a class='footnotenum' href='#footnote-125'>125</a>.
Under this
assumption, the
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
in the call is looked up as a
member function of
<span class='texttt'>T</span>
following the rules for looking up names in
classes (<a href='class.member.lookup'>[class.member.lookup]</a>).
The function declarations found by that lookup constitute the set of
candidate functions.
The argument list is the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call augmented by the addition of the left operand of
the
<span class='texttt'>.</span>
operator in the normalized member function call as the
implied object argument (<a href='over.match.funcs'>[over.match.funcs]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >In unqualified function calls, the name is not qualified by an
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
operator and has the more general form of a
<i ><a href='expr.prim#nt:primary-expression'>primary-expression</a></i>.
The name is looked up in the context of the function
call following the normal rules for name lookup in function
calls (<a href='basic.lookup'>[basic.lookup]</a>).
The function declarations found by that lookup constitute the
set of candidate functions.
Because of the rules for name lookup, the set of candidate functions
consists (1) entirely of non-member functions or (2) entirely of
member functions of some class
<span class='texttt'>T</span>.
In case (1),
the argument list is
the same as the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call.
In case (2), the argument list is the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
in the call augmented by the addition of an implied object
argument as in a qualified function call.
If the keyword
<span class='texttt'>this</span> (<a href='class.this'>[class.this]</a>) is in scope and refers to
class
<span class='texttt'>T</span>,
or a derived class of
<span class='texttt'>T</span>,
then the implied object argument is
<span class='texttt'>(*this)</span>.
If the keyword
<span class='texttt'>this</span>
is not in
scope or refers to another class, then
a contrived object of type
<span class='texttt'>T</span>
becomes the implied object
argument<a class='footnotenum' href='#footnote-126'>126</a>.
If the argument list is augmented by a contrived object and overload
resolution selects one of the non-static member functions of
<span class='texttt'>T</span>,
the call is ill-formed.</p></div><div class='footnote' id='footnote-125'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-125'>125)</a></div><p >Note that cv-qualifiers on the type of objects are
significant in overload
resolution for
both glvalue and class prvalue objects.</p></div><div class='footnote' id='footnote-126'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-126'>126)</a></div><p >An implied object argument must be contrived to
correspond to the implicit object
parameter attributed to member functions during overload resolution.
It is not
used in
the call to the selected function.
Since the member functions all have the
same implicit
object parameter, the contrived object will not be the cause to select or
reject a
function.</p></div></div></div></body></html>