<!DOCTYPE html><html lang='en'><head><title>[meta.type.synop]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.15</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#type.synop'>[meta]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>23.15.2</a> Header <span class='texttt'>&lt;type_&shy;traits&gt;</span> synopsis <a class='abbr_ref'>[meta.type.synop]</a></h3><span class='indexparent'><a class='index' id=':<type_traits>'></a></span><span class='indexparent'><a class='index' id='lib:<type_traits>'></a></span><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='meta.help'>[meta.help]</a>, helper class
</span>  template &lt;class T, T v&gt; struct integral_constant;

  template &lt;bool B&gt;
    using bool_constant = integral_constant&lt;bool, B&gt;;
  using true_type  = bool_constant&lt;true&gt;;
  using false_type = bool_constant&lt;false&gt;;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories
</span>  template &lt;class T&gt; struct is_void;
  template &lt;class T&gt; struct is_null_pointer;
  template &lt;class T&gt; struct is_integral;
  template &lt;class T&gt; struct is_floating_point;
  template &lt;class T&gt; struct is_array;
  template &lt;class T&gt; struct is_pointer;
  template &lt;class T&gt; struct is_lvalue_reference;
  template &lt;class T&gt; struct is_rvalue_reference;
  template &lt;class T&gt; struct is_member_object_pointer;
  template &lt;class T&gt; struct is_member_function_pointer;
  template &lt;class T&gt; struct is_enum;
  template &lt;class T&gt; struct is_union;
  template &lt;class T&gt; struct is_class;
  template &lt;class T&gt; struct is_function;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories
</span>  template &lt;class T&gt; struct is_reference;
  template &lt;class T&gt; struct is_arithmetic;
  template &lt;class T&gt; struct is_fundamental;
  template &lt;class T&gt; struct is_object;
  template &lt;class T&gt; struct is_scalar;
  template &lt;class T&gt; struct is_compound;
  template &lt;class T&gt; struct is_member_pointer;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties
</span>  template &lt;class T&gt; struct is_const;
  template &lt;class T&gt; struct is_volatile;
  template &lt;class T&gt; struct is_trivial;
  template &lt;class T&gt; struct is_trivially_copyable;
  template &lt;class T&gt; struct is_standard_layout;
  template &lt;class T&gt; struct is_pod;
  template &lt;class T&gt; struct is_empty;
  template &lt;class T&gt; struct is_polymorphic;
  template &lt;class T&gt; struct is_abstract;
  template &lt;class T&gt; struct is_final;
  template &lt;class T&gt; struct is_aggregate;

  template &lt;class T&gt; struct is_signed;
  template &lt;class T&gt; struct is_unsigned;

  template &lt;class T, class... Args&gt; struct is_constructible;
  template &lt;class T&gt; struct is_default_constructible;
  template &lt;class T&gt; struct is_copy_constructible;
  template &lt;class T&gt; struct is_move_constructible;

  template &lt;class T, class U&gt; struct is_assignable;
  template &lt;class T&gt; struct is_copy_assignable;
  template &lt;class T&gt; struct is_move_assignable;

  template &lt;class T, class U&gt; struct is_swappable_with;
  template &lt;class T&gt; struct is_swappable;

  template &lt;class T&gt; struct is_destructible;

  template &lt;class T, class... Args&gt; struct is_trivially_constructible;
  template &lt;class T&gt; struct is_trivially_default_constructible;
  template &lt;class T&gt; struct is_trivially_copy_constructible;
  template &lt;class T&gt; struct is_trivially_move_constructible;

  template &lt;class T, class U&gt; struct is_trivially_assignable;
  template &lt;class T&gt; struct is_trivially_copy_assignable;
  template &lt;class T&gt; struct is_trivially_move_assignable;
  template &lt;class T&gt; struct is_trivially_destructible;

  template &lt;class T, class... Args&gt; struct is_nothrow_constructible;
  template &lt;class T&gt; struct is_nothrow_default_constructible;
  template &lt;class T&gt; struct is_nothrow_copy_constructible;
  template &lt;class T&gt; struct is_nothrow_move_constructible;

  template &lt;class T, class U&gt; struct is_nothrow_assignable;
  template &lt;class T&gt; struct is_nothrow_copy_assignable;
  template &lt;class T&gt; struct is_nothrow_move_assignable;

  template &lt;class T, class U&gt; struct is_nothrow_swappable_with;
  template &lt;class T&gt; struct is_nothrow_swappable;

  template &lt;class T&gt; struct is_nothrow_destructible;

  template &lt;class T&gt; struct has_virtual_destructor;

  template &lt;class T&gt; struct has_unique_object_representations;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries
</span>  template &lt;class T&gt; struct alignment_of;
  template &lt;class T&gt; struct rank;
  template &lt;class T, unsigned I = 0&gt; struct extent;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations
</span>  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;

  template &lt;class Fn, class... ArgTypes&gt; struct is_invocable;
  template &lt;class R, class Fn, class... ArgTypes&gt; struct is_invocable_r;

  template &lt;class Fn, class... ArgTypes&gt; struct is_nothrow_invocable;
  template &lt;class R, class Fn, class... ArgTypes&gt; struct is_nothrow_invocable_r;

  <span class='comment'>// <a href='meta.trans.cv'>[meta.trans.cv]</a>, const-volatile modifications
</span>  template &lt;class T&gt; struct remove_const;
  template &lt;class T&gt; struct remove_volatile;
  template &lt;class T&gt; struct remove_cv;
  template &lt;class T&gt; struct add_const;
  template &lt;class T&gt; struct add_volatile;
  template &lt;class T&gt; struct add_cv;

  template &lt;class T&gt;
    using remove_const_t    = typename remove_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_cv_t       = typename remove_cv&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_const_t       = typename add_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_volatile_t    = typename add_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_cv_t          = typename add_cv&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ref'>[meta.trans.ref]</a>, reference modifications
</span>  template &lt;class T&gt; struct remove_reference;
  template &lt;class T&gt; struct add_lvalue_reference;
  template &lt;class T&gt; struct add_rvalue_reference;

  template &lt;class T&gt;
    using remove_reference_t     = typename remove_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.sign'>[meta.trans.sign]</a>, sign modifications
</span>  template &lt;class T&gt; struct make_signed;
  template &lt;class T&gt; struct make_unsigned;

  template &lt;class T&gt;
    using make_signed_t   = typename make_signed&lt;T&gt;::type;
  template &lt;class T&gt;
    using make_unsigned_t = typename make_unsigned&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.arr'>[meta.trans.arr]</a>, array modifications
</span>  template &lt;class T&gt; struct remove_extent;
  template &lt;class T&gt; struct remove_all_extents;

  template &lt;class T&gt;
    using remove_extent_t      = typename remove_extent&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ptr'>[meta.trans.ptr]</a>, pointer modifications
</span>  template &lt;class T&gt; struct remove_pointer;
  template &lt;class T&gt; struct add_pointer;

  template &lt;class T&gt;
    using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_pointer_t    = typename add_pointer&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations
</span>  template &lt;size_t Len,
            size_t Align = <span class='textit'>default-alignment</span>&gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    struct aligned_storage;
  template &lt;size_t Len, class... Types&gt; struct aligned_union;
  template &lt;class T&gt; struct decay;
  template &lt;bool, class T = void&gt; struct enable_if;
  template &lt;bool, class T, class F&gt; struct conditional;
  template &lt;class... T&gt; struct common_type;
  template &lt;class T&gt; struct underlying_type;
  template &lt;class Fn, class... ArgTypes&gt; struct invoke_result;

  template &lt;size_t Len,
            size_t Align = <span class='textit'>default-alignment</span>&gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    using aligned_storage_t = typename aligned_storage&lt;Len, Align&gt;::type;
  template &lt;size_t Len, class... Types&gt;
    using aligned_union_t   = typename aligned_union&lt;Len, Types...&gt;::type;
  template &lt;class T&gt;
    using decay_t           = typename decay&lt;T&gt;::type;
  template &lt;bool b, class T = void&gt;
    using enable_if_t       = typename enable_if&lt;b, T&gt;::type;
  template &lt;bool b, class T, class F&gt;
    using conditional_t     = typename conditional&lt;b, T, F&gt;::type;
  template &lt;class... T&gt;
    using common_type_t     = typename common_type&lt;T...&gt;::type;
  template &lt;class T&gt;
    using underlying_type_t = typename underlying_type&lt;T&gt;::type;
  template &lt;class Fn, class... ArgTypes&gt;
    using invoke_result_t   = typename invoke_result&lt;Fn, ArgTypes...&gt;::type;
  template &lt;class...&gt;
    using void_t            = void;

  <span class='comment'>// <a href='meta.logical'>[meta.logical]</a>, logical operator traits
</span>  template&lt;class... B&gt; struct conjunction;
  template&lt;class... B&gt; struct disjunction;
  template&lt;class B&gt; struct negation;

  <span class='comment'>// <a href='meta.endian'>[meta.endian]</a>, endian
</span>  enum class endian {
    little = <span class='textit'><span class='texttt'>see below</span></span>,
    big    = <span class='textit'><span class='texttt'>see below</span></span>,
    native = <span class='textit'><span class='texttt'>see below</span></span>
  };

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories
</span>  template &lt;class T&gt; inline constexpr bool is_void_v
    = is_void&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_null_pointer_v
    = is_null_pointer&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_integral_v
    = is_integral&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_floating_point_v
    = is_floating_point&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_array_v
    = is_array&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_pointer_v
    = is_pointer&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_lvalue_reference_v
    = is_lvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_rvalue_reference_v
    = is_rvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_member_object_pointer_v
    = is_member_object_pointer&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_member_function_pointer_v
    = is_member_function_pointer&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_enum_v
    = is_enum&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_union_v
    = is_union&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_class_v
    = is_class&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_function_v
    = is_function&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories
</span>  template &lt;class T&gt; inline constexpr bool is_reference_v
    = is_reference&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_arithmetic_v
    = is_arithmetic&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_fundamental_v
    = is_fundamental&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_object_v
    = is_object&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_scalar_v
    = is_scalar&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_compound_v
    = is_compound&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_member_pointer_v
    = is_member_pointer&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties
</span>  template &lt;class T&gt; inline constexpr bool is_const_v
    = is_const&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_volatile_v
    = is_volatile&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivial_v
    = is_trivial&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_copyable_v
    = is_trivially_copyable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_standard_layout_v
    = is_standard_layout&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_pod_v
    = is_pod&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_empty_v
    = is_empty&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_polymorphic_v
    = is_polymorphic&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_abstract_v
    = is_abstract&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_final_v
    = is_final&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_aggregate_v
    = is_aggregate&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_signed_v
    = is_signed&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_unsigned_v
    = is_unsigned&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; inline constexpr bool is_constructible_v
    = is_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_default_constructible_v
    = is_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_copy_constructible_v
    = is_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_move_constructible_v
    = is_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; inline constexpr bool is_assignable_v
    = is_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_copy_assignable_v
    = is_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_move_assignable_v
    = is_move_assignable&lt;T&gt;::value;
  template &lt;class T, class U&gt; inline constexpr bool is_swappable_with_v
    = is_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_swappable_v
    = is_swappable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_destructible_v
    = is_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; inline constexpr bool is_trivially_constructible_v
    = is_trivially_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; inline constexpr bool is_trivially_assignable_v
    = is_trivially_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_trivially_destructible_v
    = is_trivially_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; inline constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; inline constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable&lt;T&gt;::value;
  template &lt;class T, class U&gt; inline constexpr bool is_nothrow_swappable_with_v
    = is_nothrow_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_swappable_v
    = is_nothrow_swappable&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool has_virtual_destructor_v
    = has_virtual_destructor&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr bool has_unique_object_representations_v
    = has_unique_object_representations&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries
</span>  template &lt;class T&gt; inline constexpr size_t alignment_of_v
    = alignment_of&lt;T&gt;::value;
  template &lt;class T&gt; inline constexpr size_t rank_v
    = rank&lt;T&gt;::value;
  template &lt;class T, unsigned I = 0&gt; inline constexpr size_t extent_v
    = extent&lt;T, I&gt;::value;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations
</span>  template &lt;class T, class U&gt; inline constexpr bool is_same_v
    = is_same&lt;T, U&gt;::value;
  template &lt;class Base, class Derived&gt; inline constexpr bool is_base_of_v
    = is_base_of&lt;Base, Derived&gt;::value;
  template &lt;class From, class To&gt; inline constexpr bool is_convertible_v
    = is_convertible&lt;From, To&gt;::value;
  template &lt;class Fn, class... ArgTypes&gt; inline constexpr bool is_invocable_v
    = is_invocable&lt;Fn, ArgTypes...&gt;::value;
  template &lt;class R, class Fn, class... ArgTypes&gt; inline constexpr bool is_invocable_r_v
    = is_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
  template &lt;class Fn, class... ArgTypes&gt; inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable&lt;Fn, ArgTypes...&gt;::value;
  template &lt;class R, class Fn, class... ArgTypes&gt; inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;

  <span class='comment'>// <a href='meta.logical'>[meta.logical]</a>, logical operator traits
</span>  template&lt;class... B&gt; inline constexpr bool conjunction_v = conjunction&lt;B...&gt;::value;
  template&lt;class... B&gt; inline constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;
  template&lt;class B&gt; inline constexpr bool negation_v = negation&lt;B&gt;::value;
}</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/78f8e15e9acb75272c0c32cd7df9085e81668b1e/source/utilities.tex#L15506'>#</a></div><div id='1.sentence-1' class='sentence'>The behavior of a program that adds specializations for any of
the templates defined in this subclause is undefined unless otherwise specified<a class='hidden_link' href='#1.sentence-1'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/78f8e15e9acb75272c0c32cd7df9085e81668b1e/source/utilities.tex#L15510'>#</a></div><div id='2.sentence-1' class='sentence'>Unless otherwise specified, an incomplete type may be used
to instantiate a template in this subclause<a class='hidden_link' href='#2.sentence-1'>.</a></div></div></div></body></html>