<!DOCTYPE html><html lang='en'><head><title>[basic.scope.pdecl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.3</a> Scope <a class='abbr_ref' href='basic.scope#pdecl'>[basic.scope]</a></h2><div id='basic.scope.pdecl'><h3 ><a class='secnum' style='min-width:103pt'>3.3.2</a> Point of declaration <a class='abbr_ref'>[basic.scope.pdecl]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,point_of_declaration'></a></span>The <a id='point_of_declaration'><i>point of declaration</i></a> for a name is immediately after its
complete declarator (Clause <a href='dcl.decl'>[dcl.decl]</a>) and before its
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> (if any), except as noted below. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
unsigned char x = 12;{ unsigned char x = x; }
</pre><p >Here the second <span class='texttt'>x</span> is initialized with its own (indeterminate)
value. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='name_hiding'></a></span>a name from an outer scope remains visible up
to the point of declaration of the name that hides it.[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
const int  i = 2;{ int  i[i]; }
</pre><p >declares a block-scope array of two integers. <i>&nbsp;—&nbsp;end example</i>&nbsp;] <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The point of declaration for a class or class template first declared by a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> is immediately after the <i ><a href='lex.name#nt:identifier'>identifier</a></i> or
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> (if any) in its <i ><a href='class#nt:class-head'>class-head</a></i>
(Clause <a href='class'>[class]</a>). The point of declaration for an enumeration is
immediately after the <i ><a href='lex.name#nt:identifier'>identifier</a></i> (if any) in either its
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> (<a href='dcl.enum'>[dcl.enum]</a>) or its first
<i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> (<a href='dcl.enum'>[dcl.enum]</a>), whichever comes first.
The point of declaration of an alias or alias template immediately
follows the <i ><a href='dcl.name#nt:type-id'>type-id</a></i> to which the
alias refers.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The point of declaration of a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that does not name a
constructor is immediately after the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='declaration,enumerator_point_of'></a></span>The point of declaration for an enumerator is immediately after its
<i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i>.[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
const int x = 12;{ enum { x = x }; }
</pre><p >Here, the enumerator <span class='texttt'>x</span> is initialized with the value of the
constant <span class='texttt'>x</span>, namely 12. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >After the point of declaration of a class member, the member name can be
looked up in the scope of its class. [&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>this is true even if the class is an incomplete class. For example,</p><pre class='codeblock'>
struct X {
  enum E { z = 16 };
  int b[X::z];      <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The point of declaration of a class first declared in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is as follows:</p><ul ><li ><p >for a declaration of the form</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre><p >the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is declared to be a
<i ><a href='class#nt:class-name'>class-name</a></i> in the scope that contains the declaration,
otherwise
</p></li><li ><p >for an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> of the form</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><p >if the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is used in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>
of a function defined in namespace scope, the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is
declared as a <i ><a href='class#nt:class-name'>class-name</a></i> in the namespace that contains the
declaration; otherwise, except as a friend declaration, the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is declared in the smallest namespace or block
scope that contains the declaration. [&nbsp;<i>Note:</i><span class='space'></span>
These rules also apply within templates. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> Other
forms of <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> do not declare a new name,
and therefore must refer to an existing <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>.
See <a href='basic.lookup.elab'>[basic.lookup.elab]</a> and <a href='dcl.type.elab'>[dcl.type.elab]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The point of declaration for an
<span class='grammarterm'>injected-class-name</span> (Clause <a href='class'>[class]</a>) is immediately following
the opening brace of the class definition.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The point of declaration for a function-local predefined
variable (<a href='dcl.fct.def'>[dcl.fct.def]</a>) is immediately before the
<i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> of a function definition.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >The point of declaration for a template parameter is immediately after its complete
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef unsigned char T;
template&lt;class T
  = T     <span class='comment'>// lookup finds the typedef name of <span class='texttt'>unsigned char</span>
</span>  , T     <span class='comment'>// lookup finds the template parameter
</span>    N = 0&gt; struct A { };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Friend declarations refer to functions or classes that are
members of the nearest enclosing namespace, but they do not introduce
new names into that namespace (<a href='namespace.memdef'>[namespace.memdef]</a>). Function
declarations at block scope and variable declarations with the
<span class='texttt'>extern</span> specifier at block scope refer to declarations that are
members of an enclosing namespace, but they do not introduce new names
into that scope.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> For point of instantiation of a template,
see <a href='temp.point'>[temp.point]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='scope,declarations_and'></a></span></p></div></div></div></body></html>