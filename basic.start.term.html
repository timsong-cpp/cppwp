<!DOCTYPE html><html lang='en'><head><title>[basic.start.term]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.6</a> Start and termination <a class='abbr_ref' href='basic.start#term'>[basic.start]</a></h2><div id='basic.start.term'><h3 ><a class='secnum' style='min-width:103pt'>3.6.4</a> Termination <a class='abbr_ref'>[basic.start.term]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/basic.tex#L2720'>#</a></div><p ><span class='indexparent'><a class='index' id='program,termination'></a></span><span class='indexparent'><a class='index' id='object,destructor_static'></a></span><span class='indexparent'><a class='index' id='main(),return_from'></a></span>Destructors (<a href='class.dtor'>[class.dtor]</a>) for initialized objects
(that is, objects whose lifetime (<a href='basic.life'>[basic.life]</a>) has begun)
with static storage duration
are called as a result of returning from <span class='texttt'>main</span> and as a result of calling
<span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='texttt'>std::exit</span> (<a href='support.start.term'>[support.start.term]</a>).
Destructors for initialized objects with thread storage duration within a given thread
are called as a result of returning from the initial function of that thread and as a
result of that thread calling <span class='texttt'>std::exit</span>.
The completions of the destructors for all initialized objects with thread storage
duration within that thread are sequenced before the initiation of the destructors of
any object with static storage duration.
If the completion of the constructor or dynamic initialization of an object with thread
storage duration is sequenced before that of another, the completion of the destructor
of the second is sequenced before the initiation of the destructor of the first.
If the completion of the constructor or dynamic initialization of an object with static
storage duration is sequenced before that of another, the completion of the destructor
of the second is sequenced before the initiation of the destructor of the first.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> This definition permits concurrent destruction. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] If an object is
initialized statically, the object is destroyed in the same order as if
the object was dynamically initialized. For an object of array or class
type, all subobjects of that object are destroyed before any block-scope
object with static storage duration initialized during the construction
of the subobjects is destroyed.
If the destruction of an object with static or thread storage duration
exits via an exception,
<span class='texttt'>std::terminate</span> is called (<a href='except.terminate'>[except.terminate]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/basic.tex#L2753'>#</a></div><p >If a function contains a block-scope object of static or thread storage duration that has been
destroyed and the function is called during the destruction of an object with static or
thread storage duration, the program has undefined behavior if the flow of control
passes through the definition of the previously destroyed block-scope object. Likewise, the
behavior is undefined if the block-scope object is used indirectly (i.e., through a
pointer) after its destruction.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/basic.tex#L2761'>#</a></div><p ><span class='indexparent'><a class='index' id='atexit'></a></span><span class='indexparent'><a class='index' id='atexit'></a></span>If the completion of the initialization of an object with static storage
duration is sequenced before a call to <span class='texttt'>std::atexit</span> (see
<span class='texttt'>&lt;cstdlib&gt;</span>, <a href='support.start.term'>[support.start.term]</a>), the call to the function passed to
<span class='texttt'>std::atexit</span> is sequenced before the call to the destructor for the object. If a
call to <span class='texttt'>std::atexit</span> is sequenced before the completion of the initialization of
an object with static storage duration, the call to the destructor for the
object is sequenced before the call to the function passed to <span class='texttt'>std::atexit</span>. If a
call to <span class='texttt'>std::atexit</span> is sequenced before another call to <span class='texttt'>std::atexit</span>, the
call to the function passed to the second <span class='texttt'>std::atexit</span> call is sequenced before
the call to the function passed to the first <span class='texttt'>std::atexit</span> call.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/basic.tex#L2775'>#</a></div><p >If there is a use of a standard library object or function not permitted within signal
handlers (<a href='support.runtime'>[support.runtime]</a>) that does not happen before (<a href='intro.multithread'>[intro.multithread]</a>)
completion of destruction of objects with static storage duration and execution of
<span class='texttt'>std::atexit</span> registered functions (<a href='support.start.term'>[support.start.term]</a>), the program has
undefined behavior. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> If there is a use of an object with static storage
duration that does not happen before the object's destruction, the program has undefined
behavior. Terminating every thread before a call to <span class='texttt'>std::exit</span> or the exit from
<span class='texttt'>main</span> is sufficient, but not necessary, to satisfy these requirements. These
requirements permit thread managers as static-storage-duration objects. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ffb9408d01061c336807333bf2cd2743acb8df14/source/basic.tex#L2786'>#</a></div><p ><span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='termination,program'></a></span>Calling the function <span class='texttt'>std::abort()</span> declared in
<span class='indexparent'><a class='index' id='cstdlib'></a></span><span class='texttt'>&lt;cstdlib&gt;</span> terminates the program without executing any destructors
and without calling
the functions passed to <span class='texttt'>std::atexit()</span> or <span class='texttt'>std::at_quick_exit()</span>.<span class='indexparent'><a class='index' id='program,termination'></a></span></p></div></div></div></body></html>