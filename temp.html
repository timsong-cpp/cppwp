<!DOCTYPE html><html lang='en'><head><title>[temp]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='temp'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><p ><span class='indexparent'><a class='index' id='template'></a></span></p><p ><span class='indexparent'><a class='index' id='parameterized type'></a></span><span class='indexparent'><a class='index' id='type generator'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <i>template</i> defines a family of classes or functions or an alias for a
family of types.</p><p ><span class='indexparent'><a class='index' id='template'></a></span></p><pre class='bnf'><a id='template-declaration'>template-declaration:</a>
  <span class='terminal'>template &lt;</span> <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> <span class='terminal'>&gt;</span> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><pre class='bnf'><a id='template-parameter-list'>template-parameter-list:</a>
  <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
  <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> <span class='terminal'>,</span> <i ><a href='temp.param#template-parameter'>template-parameter</a></i></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> The <span class='texttt'>&gt;</span> token following the
<span class='small'></span><span class='rmfamily'></span><i> template-parameter-list</i> of a
<span class='small'></span><span class='rmfamily'></span><i> template-declaration</i>
may be the product of replacing a
<span class='texttt'>&gt;&gt;</span> token by two consecutive <span class='texttt'>&gt;</span>
tokens (<a href='temp.names'>[temp.names]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >The
<i ><a href='dcl.dcl#declaration'>declaration</a></i>
in a
<i ><a href='temp#template-declaration'>template-declaration</a></i>
shall</p><ul ><li ><p >declare or define a function, a class, or a variable, or</p></li><li ><p >define a member function, a member class, a member enumeration, or a static data member of a
class template or of a class nested within a class template, or</p></li><li ><p >define a member template of a class or class template, or</p></li><li ><p >be a <i ><a href='temp.deduct.guide#deduction-guide'>deduction-guide</a></i>, or</p></li><li ><p >be an <i ><a href='dcl.dcl#alias-declaration'>alias-declaration</a></i>.
</p></li></ul><p >A <i ><a href='temp#template-declaration'>template-declaration</a></i> is a <i ><a href='dcl.dcl#declaration'>declaration</a></i>.
<span class='indexparent'><a class='index' id='template!definition~of'></a></span>A <i ><a href='temp#template-declaration'>template-declaration</a></i> is also a definition
if its <i ><a href='dcl.dcl#declaration'>declaration</a></i> defines a function, a class, a variable, or a
static data member. A declaration introduced by a template declaration of a
<span class='indexparent'><a class='index' id='variable template!definition~of'></a></span><span class='indexparent'><a class='index' id='template!variable'></a></span><span class='indexparent'><a class='index' id='template!static data member'></a></span>variable is a <i>variable template</i>. A variable template at class scope is a
<i>static data member template</i>.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt;
  constexpr T pi = T(3.1415926535897932385L);
template&lt;class T&gt;
T circular_area(T r) {
  return pi&lt;T&gt; * r * r;
}
struct matrix_constants {
  template&lt;class T&gt;
   using pauli = hermitian_matrix&lt;T, 2&gt;;
  template&lt;class T&gt;
   constexpr pauli&lt;T&gt; sigma1 = { { 0, 1 }, { 1, 0 } };
  template&lt;class T&gt;
   constexpr pauli&lt;T&gt; sigma2 = { { 0, -1i }, { 1i, 0 } };
  template&lt;class T&gt;
   constexpr pauli&lt;T&gt; sigma3 = { { 1, 0 }, { 0, -1 } };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A
<i ><a href='temp#template-declaration'>template-declaration</a></i>
can appear only as a namespace scope or class scope declaration.
In a function template declaration, the last component of the
<i ><a href='dcl.decl#declarator-id'>declarator-id</a></i>
shall not be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
That last component may be an <i ><a href='lex.name#identifier'>identifier</a></i>, an <i ><a href='over.oper#operator-function-id'>operator-function-id</a></i>,
a <i ><a href='class.conv.fct#conversion-function-id'>conversion-function-id</a></i>, or a <i ><a href='over.literal#literal-operator-id'>literal-operator-id</a></i>. In
a class template declaration, if the
class name
is a
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>,
the declaration declares a class template partial specialization (<a href='temp.class.spec'>[temp.class.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >In a
<i ><a href='temp#template-declaration'>template-declaration</a></i>,
explicit specialization, or explicit instantiation the
<i ><a href='dcl.decl#init-declarator-list'>init-declarator-list</a></i>
in the declaration shall contain at most one declarator.
When such a declaration is used to declare a class template,
no declarator is permitted.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='template~name!linkage~of'></a></span>A template name has linkage (<a href='basic.link'>[basic.link]</a>).
Specializations (explicit or implicit) of
a template that has internal linkage are
distinct from all specializations in other translation
units.
A template, a template explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>), and a class
template partial specialization shall not have C linkage. Use of a linkage specification
other than <span class='texttt'>"C"</span> or <span class='texttt'>"C++"</span> with any of these constructs is
conditionally-supported, with
<span class='indexparent'><a class='index' id='semantics of linkage specification on templates'></a></span>implementation-defined semantics.
Template definitions shall obey the one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
Default arguments for function templates and for member functions of
class templates are considered definitions for the purpose of template
instantiation (<a href='temp.decls'>[temp.decls]</a>) and must also obey the one-definition rule.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A class template shall not have the same name as any other
template, class, function, variable, enumeration, enumerator, namespace, or
type in the same scope (<a href='basic.scope'>[basic.scope]</a>), except as specified in (<a href='temp.class.spec'>[temp.class.spec]</a>).
Except that a function template can be overloaded either by non-template
functions (<a href='dcl.fct'>[dcl.fct]</a>) with the same name or by other function templates
with the same name (<a href='temp.over'>[temp.over]</a>),
a template name declared in namespace scope or in class scope shall be unique
in that scope.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='entity!templated'></a></span>A <a id='templated entity'><i>templated entity</i></a> is</p><ul ><li ><p >a template,
</p></li><li ><p >an entity defined (<a href='basic.def'>[basic.def]</a>) or created (<a href='class.temporary'>[class.temporary]</a>)
      in a templated entity,
</p></li><li ><p >a member of a templated entity,
</p></li><li ><p >an enumerator for an enumeration that is a templated entity, or
</p></li><li ><p >the closure type of a <i ><a href='expr.prim.lambda#lambda-expression'>lambda-expression</a></i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>)
      appearing in the declaration of a templated entity.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
A local class, a local variable, or a friend function defined in a
templated entity is a templated entity.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A function template, member function of a class template, variable template,
or static data
member of a class template shall be defined in every translation unit in
which it is implicitly instantiated (<a href='temp.inst'>[temp.inst]</a>) unless the
corresponding specialization is explicitly instantiated (<a href='temp.explicit'>[temp.explicit]</a>)
in some translation unit; no diagnostic is required.</p></div><div id='param'><h2 ><a class='secnum' href='#param' style='min-width:88pt'>14.1</a> Template parameters <a class='abbr_ref' href='temp.param'>[temp.param]</a></h2><div class='para' id='param-1'><div class='marginalizedparent'><a class='marginalized' href='#param-1'>1</a></div><p >The syntax for
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
is:</p><pre class='bnf'><a id='template-parameter'>template-parameter:</a>
  <i ><a href='temp.param#type-parameter'>type-parameter</a></i>
  <i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i></pre><pre class='bnf'><a id='type-parameter'>type-parameter:</a>
  <i ><a href='temp.param#type-parameter-key'>type-parameter-key</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='temp.param#type-parameter-key'>type-parameter-key</a></i> <i ><a href='lex.name#identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>=</span> <i ><a href='dcl.name#type-id'>type-id</a></i>
  <span class='terminal'>template &lt;</span> <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> <span class='terminal'>&gt;</span> <i ><a href='temp.param#type-parameter-key'>type-parameter-key</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <span class='terminal'>template &lt;</span> <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> <span class='terminal'>&gt;</span> <i ><a href='temp.param#type-parameter-key'>type-parameter-key</a></i> <i ><a href='lex.name#identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>=</span> <i ><a href='expr.prim.id#id-expression'>id-expression</a></i></pre><pre class='bnf'><a id='type-parameter-key'>type-parameter-key:</a>
  <span class='terminal'>class</span>
  <span class='terminal'>typename</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> The <span class='texttt'>&gt;</span> token following the
<span class='small'></span><span class='rmfamily'></span><i> template-parameter-list</i> of a
<span class='small'></span><span class='rmfamily'></span><i> type-parameter</i>
may be the product of replacing a
<span class='texttt'>&gt;&gt;</span> token by two consecutive <span class='texttt'>&gt;</span>
tokens (<a href='temp.names'>[temp.names]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='param-2'><div class='marginalizedparent'><a class='marginalized' href='#param-2'>2</a></div><p >There is no semantic difference between
<span class='texttt'>class</span>
and
<span class='texttt'>typename</span>
in a
<i ><a href='temp.param#type-parameter-key'>type-parameter-key</a></i>.
<span class='texttt'>typename</span>
followed by an
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
names a template type parameter.
<span class='texttt'>typename</span>
followed by a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
denotes the type in a non-type<a class='footnotenum' href='#footnote-135'>135</a>
<i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i>.
A <i ><a href='temp.param#template-parameter'>template-parameter</a></i> of the form
<span class='texttt'>class</span> <i ><a href='lex.name#identifier'>identifier</a></i> is a <i ><a href='temp.param#type-parameter'>type-parameter</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  class T { <span class='comment'>/* ... */</span> };
  int i;

  template&lt;class T, T i&gt; void f(T t) {
    T t1 = i;      <span class='comment'>// template-parameters <span class='texttt'>T</span> and <span class='texttt'>i</span>
</span>    ::T t2 = ::i;  <span class='comment'>// global namespace members <span class='texttt'>T</span> and <span class='texttt'>i</span>
</span>  }
</pre><p >Here, the template <span class='texttt'>f</span> has a <i ><a href='temp.param#type-parameter'>type-parameter</a></i>
called <span class='texttt'>T</span>, rather than an unnamed non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i> of class <span class='texttt'>T</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
A storage class shall not be specified in a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
declaration.
Types shall not be defined in a <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
declaration.</p></div><div class='para' id='param-3'><div class='marginalizedparent'><a class='marginalized' href='#param-3'>3</a></div><p >A
<i ><a href='temp.param#type-parameter'>type-parameter</a></i>
whose identifier does not follow an ellipsis
defines its
<i ><a href='lex.name#identifier'>identifier</a></i>
to be a
<i ><a href='dcl.typedef#typedef-name'>typedef-name</a></i>
(if declared without
<span class='texttt'>template</span>)
or
<i ><a href='temp.names#template-name'>template-name</a></i>
(if declared with
<span class='texttt'>template</span>)
in the scope of the template declaration.
[&nbsp;<i>Note:</i><span class='space'></span>
A template argument may be a class template or alias template.
For example,</p><pre class='codeblock'>
template&lt;class T&gt; class myarray { <span class='comment'>/* ... */</span> };

template&lt;class K, class V, template&lt;class T&gt; class C = myarray&gt;
class Map {
  C&lt;K&gt; key;
  C&lt;V&gt; value;
};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='param-4'><div class='marginalizedparent'><a class='marginalized' href='#param-4'>4</a></div><p >A non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall have one of the following (optionally
<span class='grammarterm'>cv-qualified</span>)
types:</p><ul ><li ><p >integral or enumeration type,</p></li><li ><p >pointer to object or pointer to function,</p></li><li ><p >lvalue reference to object or lvalue reference to function,</p></li><li ><p >pointer to member,</p></li><li ><p ><span class='texttt'>std::nullptr_t</span>, or</p></li><li ><p >a type that contains a placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
</p></li></ul></div><div class='para' id='param-5'><div class='marginalizedparent'><a class='marginalized' href='#param-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Other types are disallowed either explicitly below or implicitly by
the rules governing the form of
<i ><a href='temp.names#template-argument'>template-arguments</a></i> (<a href='temp.arg'>[temp.arg]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The top-level
<span class='grammarterm'>cv-qualifiers</span>
on the
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
are ignored when determining its type.</p></div><div class='para' id='param-6'><div class='marginalizedparent'><a class='marginalized' href='#param-6'>6</a></div><p >A non-type non-reference
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is a prvalue.
It shall not be assigned to or in any other way have its value changed.
A non-type non-reference
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
cannot have its address taken.
When a non-type non-reference
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is used as an initializer for a reference, a temporary is always used.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;const X&amp; x, int i&gt; void f() {
  i++;                          <span class='comment'>// error: change of template-parameter value
</span>
  &amp;x;                           <span class='comment'>// OK
</span>  &amp;i;                           <span class='comment'>// error: address of non-reference template-parameter
</span>
  int&amp; ri = i;                  <span class='comment'>// error: non-const reference bound to temporary
</span>  const int&amp; cri = i;           <span class='comment'>// OK: const reference bound to temporary
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-7'><div class='marginalizedparent'><a class='marginalized' href='#param-7'>7</a></div><p >A non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall not be declared to have floating point, class, or void type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;double d&gt; class X;     <span class='comment'>// error
</span>template&lt;double* pd&gt; class Y;   <span class='comment'>// OK
</span>template&lt;double&amp; rd&gt; class Z;   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-8'><div class='marginalizedparent'><a class='marginalized' href='#param-8'>8</a></div><p >A non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
<span class='indexparent'><a class='index' id='array!template parameter~of~type'></a></span>of type “array of <span class='texttt'>T</span>” or
<span class='indexparent'><a class='index' id='function!template parameter~of~type'></a></span>of function type <span class='texttt'>T</span>
is adjusted to be of type “pointer to <span class='texttt'>T</span>”.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;int* a&gt;   struct R { <span class='comment'>/* ... */</span> };
template&lt;int b[5]&gt; struct S { <span class='comment'>/* ... */</span> };
int p;
R&lt;&amp;p&gt; w;                        <span class='comment'>// OK
</span>S&lt;&amp;p&gt; x;                        <span class='comment'>// OK due to parameter adjustment
</span>int v[5];
R&lt;v&gt; y;                         <span class='comment'>// OK due to implicit argument conversion
</span>S&lt;v&gt; z;                         <span class='comment'>// OK due to both adjustment and conversion
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-9'><div class='marginalizedparent'><a class='marginalized' href='#param-9'>9</a></div><p >A
<i>default template-argument</i>
is a
<i ><a href='temp.names#template-argument'>template-argument</a></i> (<a href='temp.arg'>[temp.arg]</a>) specified after
<span class='texttt'>=</span>
in a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>.
A default
<span class='grammarterm'>template-argument</span>
may be specified for any kind of
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
(type, non-type, template)
that is not a template parameter pack (<a href='temp.variadic'>[temp.variadic]</a>).
A default
<i ><a href='temp.names#template-argument'>template-argument</a></i>
may be specified in a template declaration.
A default
<i ><a href='temp.names#template-argument'>template-argument</a></i>
shall not be specified in the
<i ><a href='temp#template-parameter-list'>template-parameter-lists</a></i>
of the definition of a member of a class template that appears outside
of the member's class.
A default
<i ><a href='temp.names#template-argument'>template-argument</a></i>
shall not be specified in a friend class template declaration.
If a friend function template declaration
specifies a default
<i ><a href='temp.names#template-argument'>template-argument</a></i>,
that declaration shall be a definition and shall be the only declaration of
the function template in the translation unit.</p></div><div class='para' id='param-10'><div class='marginalizedparent'><a class='marginalized' href='#param-10'>10</a></div><p >The set of default
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
available for use is obtained by merging the default arguments
from all prior declarations of the template in the
same way default function arguments are (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1, class T2 = int&gt; class A;
template&lt;class T1 = int, class T2&gt; class A;
</pre><p >is equivalent to</p><pre class='codeblock'>
template&lt;class T1 = int, class T2 = int&gt; class A;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-11'><div class='marginalizedparent'><a class='marginalized' href='#param-11'>11</a></div><p >If a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
of a class template, variable template, or alias template has a default
<i ><a href='temp.names#template-argument'>template-argument</a></i>,
each subsequent
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall either have a default
<i ><a href='temp.names#template-argument'>template-argument</a></i>
supplied
or be a template parameter pack. If a <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
of a primary class template, primary variable template, or alias template
is a template parameter pack, it shall be the last
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>.
A template parameter pack of a function template shall not be followed by
another
template parameter unless that template parameter can be deduced from the
parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>) of the function template or has a
default argument (<a href='temp.deduct'>[temp.deduct]</a>).
A template parameter of a deduction guide template (<a href='temp.deduct.guide'>[temp.deduct.guide]</a>)
that does not have a default argument
shall be deducible
from the parameter-type-list
of the deduction guide template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1 = int, class T2&gt; class B;   <span class='comment'>// error
</span>
<span class='comment'>// <span class='texttt'>U</span> can be neither deduced from the parameter-type-list nor specified
</span>template&lt;class... T, class... U&gt; void f() { } <span class='comment'>// error
</span>template&lt;class... T, class U&gt; void g() { }    <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-12'><div class='marginalizedparent'><a class='marginalized' href='#param-12'>12</a></div><p >A
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall
not be given default arguments by two different declarations in the same scope.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T = int&gt; class X;
template&lt;class T = int&gt; class X { <span class='comment'>/*... */</span> }; <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='<!template~and'></a></span></p></div><div class='para' id='param-13'><div class='marginalizedparent'><a class='marginalized' href='#param-13'>13</a></div><p >When parsing a
default
<i ><a href='temp.names#template-argument'>template-argument</a></i>
for a non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>,
the first non-nested
<span class='texttt'>&gt;</span>
is taken as the end of the
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
rather than a greater-than operator.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;int i = 3 &gt; 4 &gt;        <span class='comment'>// syntax error
</span>class X { <span class='comment'>/* ... */</span> };

template&lt;int i = (3 &gt; 4) &gt;      <span class='comment'>// OK
</span>class Y { <span class='comment'>/* ... */</span> };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-14'><div class='marginalizedparent'><a class='marginalized' href='#param-14'>14</a></div><p >A
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
of a template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is permitted to have a default
<i ><a href='temp.names#template-argument'>template-argument</a></i>.
When such default arguments are specified, they apply to the template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
in the scope of the template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T = float&gt; struct B {};
template &lt;template &lt;class TT = float&gt; class T&gt; struct A {
  inline void f();
  inline void g();
};
template &lt;template &lt;class TT&gt; class T&gt; void A&lt;T&gt;::f() {
  T&lt;&gt; t;            <span class='comment'>// error - <span class='texttt'>TT</span> has no default template argument
</span>}
template &lt;template &lt;class TT = char&gt; class T&gt; void A&lt;T&gt;::g() {
    T&lt;&gt; t;          <span class='comment'>// OK - <span class='texttt'>T&lt;char&gt;</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='param-15'><div class='marginalizedparent'><a class='marginalized' href='#param-15'>15</a></div><p >If a <i ><a href='temp.param#template-parameter'>template-parameter</a></i> is a
<i ><a href='temp.param#type-parameter'>type-parameter</a></i> with an ellipsis prior to its
optional <i ><a href='lex.name#identifier'>identifier</a></i> or is a
<i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> that declares a parameter
pack (<a href='dcl.fct'>[dcl.fct]</a>), then the <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is a template parameter pack (<a href='temp.variadic'>[temp.variadic]</a>).
A template parameter pack that is a <i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> whose type
contains one or more unexpanded parameter packs is a pack expansion. Similarly,
a template parameter pack that is a <i ><a href='temp.param#type-parameter'>type-parameter</a></i> with a
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> containing one or more unexpanded
parameter packs is a pack expansion. A template parameter pack that is a pack
expansion shall not expand a parameter pack declared in the same
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class... Types&gt; class Tuple;                <span class='comment'>// <span class='texttt'>Types</span> is a template type parameter pack
</span>                                                      <span class='comment'>// but not a pack expansion
</span>template &lt;class T, int... Dims&gt; struct multi_array;   <span class='comment'>// <span class='texttt'>Dims</span> is a non-type template parameter pack
</span>                                                      <span class='comment'>// but not a pack expansion
</span>template&lt;class... T&gt; struct value_holder {
  template&lt;T... Values&gt; struct apply { };             <span class='comment'>// <span class='texttt'>Values</span> is a non-type template parameter pack
</span>                                                      <span class='comment'>// and a pack expansion
</span>};
template&lt;class... T, T... Values&gt; struct static_array;<span class='comment'>// error: <span class='texttt'>Values</span> expands template type parameter
</span>                                                      <span class='comment'>// pack <span class='texttt'>T</span> within the same template parameter list
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-135'><div class='marginalizedparent'><a class='marginalized' href='#footnote-135'>135)</a></div><p >Since template
<span class='grammarterm'>template-parameters</span>
and template
<span class='grammarterm'>template-arguments</span>
are treated as types for descriptive purposes, the terms
<span class='grammarterm'>non-type parameter</span>
and
<span class='grammarterm'>non-type argument</span>
are used to refer to non-type, non-template parameters and arguments.</p></div></div><div id='names'><h2 ><a class='secnum' href='#names' style='min-width:88pt'>14.2</a> Names of template specializations <a class='abbr_ref' href='temp.names'>[temp.names]</a></h2><div class='para' id='names-1'><div class='marginalizedparent'><a class='marginalized' href='#names-1'>1</a></div><p >A template specialization (<a href='temp.spec'>[temp.spec]</a>) can be referred to by a
<i ><a href='temp.names#template-id'>template-id</a></i>:</p><pre class='bnf'><a id='simple-template-id'>simple-template-id:</a>
  <i ><a href='temp.names#template-name'>template-name</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span></pre><pre class='bnf'><a id='template-id'>template-id:</a>
  <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
  <i ><a href='over.oper#operator-function-id'>operator-function-id</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span>
  <i ><a href='over.literal#literal-operator-id'>literal-operator-id</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span></pre><pre class='bnf'><a id='template-name'>template-name:</a>
  <i ><a href='lex.name#identifier'>identifier</a></i></pre><pre class='bnf'><a id='template-argument-list'>template-argument-list:</a>
  <i ><a href='temp.names#template-argument'>template-argument</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i> <span class='terminal'>,</span> <i ><a href='temp.names#template-argument'>template-argument</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='template-argument'>template-argument:</a>
  <i ><a href='expr.const#constant-expression'>constant-expression</a></i>
  <i ><a href='dcl.name#type-id'>type-id</a></i>
  <i ><a href='expr.prim.id#id-expression'>id-expression</a></i></pre><p >[&nbsp;<i>Note:</i><span class='space'></span>
The name lookup rules (<a href='basic.lookup'>[basic.lookup]</a>) are used to associate the use of
a name with a template declaration;
that is, to identify a name as a
<i ><a href='temp.names#template-name'>template-name</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='names-2'><div class='marginalizedparent'><a class='marginalized' href='#names-2'>2</a></div><p >For a
<i ><a href='temp.names#template-name'>template-name</a></i>
to be explicitly qualified by the template arguments,
the name must be known to refer to a template.</p></div><div class='para' id='names-3'><div class='marginalizedparent'><a class='marginalized' href='#names-3'>3</a></div><p ><span class='indexparent'><a class='index' id='<!template~and'></a></span>After name lookup (<a href='basic.lookup'>[basic.lookup]</a>) finds that a name is a
<i ><a href='temp.names#template-name'>template-name</a></i>
or that an <i ><a href='over.oper#operator-function-id'>operator-function-id</a></i> or a <i ><a href='over.literal#literal-operator-id'>literal-operator-id</a></i> refers to a set of
overloaded functions any member of which is a function template,
if this is followed by a
<span class='texttt'>&lt;</span>,
the
<span class='texttt'>&lt;</span>
is always taken as the delimiter of a
<i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>
and never as the less-than operator.
When parsing a <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>,
the first non-nested
<span class='texttt'>&gt;</span><a class='footnotenum' href='#footnote-136'>136</a>
is taken as the ending delimiter
rather than a greater-than operator.
Similarly, the first non-nested <span class='texttt'>&gt;&gt;</span> is treated as two
consecutive but distinct <span class='texttt'>&gt;</span> tokens, the first of which is taken
as the end of the <span class='small'></span><span class='rmfamily'></span><i> template-argument-list</i> and completes
the <span class='small'></span><span class='rmfamily'></span><i> template-id</i>. [&nbsp;<i>Note:</i><span class='space'></span> The second <span class='texttt'>&gt;</span>
token produced by this replacement rule may terminate an enclosing
<span class='small'></span><span class='rmfamily'></span><i> template-id</i> construct or it may be part of a different
construct (e.g. a cast).<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;int i&gt; class X <span class='texttt'>{ /* ... */ };</span>

X&lt; 1&gt;2 &gt; x1;                        <span class='comment'>// syntax error
</span>X&lt;(1&gt;2)&gt; x2;                        <span class='comment'>// OK
</span>
template&lt;class T&gt; class Y <span class='texttt'>{ /* ... */ };</span>
Y&lt;X&lt;1&gt;&gt; x3;                         <span class='comment'>// OK, same as <span class='texttt'>Y&lt;X&lt;1&gt; &gt; x3;</span>
</span>Y&lt;X&lt;6&gt;&gt;1&gt;&gt; x4;                      <span class='comment'>// syntax error
</span>Y&lt;X&lt;(6&gt;&gt;1)&gt;&gt; x5;                    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='names-4'><div class='marginalizedparent'><a class='marginalized' href='#names-4'>4</a></div><p >When the name of a member template specialization appears after
<span class='texttt'>.</span>
or
<span class='texttt'>-&gt;</span>
in a
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i>
or after a
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
in a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>,
and the
object expression of the
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i>
is type-dependent
or
the <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> in the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
refers to a dependent type, but the name is not
a member of the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>),
the member template name must be prefixed by the keyword
<span class='texttt'>template</span>.
Otherwise the name is assumed to name a non-template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  template&lt;std::size_t&gt; X* alloc();
  template&lt;std::size_t&gt; static X* adjust();
};
template&lt;class T&gt; void f(T* p) {
  T* p1 = p-&gt;alloc&lt;200&gt;();          <span class='comment'>// ill-formed: <span class='texttt'>&lt;</span> means less than
</span>  T* p2 = p-&gt;template alloc&lt;200&gt;(); <span class='comment'>// OK: <span class='texttt'>&lt;</span> starts template argument list
</span>  T::adjust&lt;100&gt;();                 <span class='comment'>// ill-formed: <span class='texttt'>&lt;</span> means less than
</span>  T::template adjust&lt;100&gt;();        <span class='comment'>// OK: <span class='texttt'>&lt;</span> starts template argument list
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='names-5'><div class='marginalizedparent'><a class='marginalized' href='#names-5'>5</a></div><p >A name prefixed by the keyword
<span class='texttt'>template</span>
shall be a <i ><a href='temp.names#template-id'>template-id</a></i> or the name shall refer to a class template.
[&nbsp;<i>Note:</i><span class='space'></span>
The keyword
<span class='texttt'>template</span>
may not be applied to non-template members of class templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
As is the case with the
<span class='texttt'>typename</span>
prefix, the
<span class='texttt'>template</span>
prefix is allowed in cases where it is not strictly
necessary; i.e., when the <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> or
the expression on the left of
the
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
is not dependent on a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>, or the use does not appear in the
scope of a template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class U&gt; void f(U);
};

template &lt;class T&gt; void f(T t) {
  A&lt;T&gt; a;
  a.template f&lt;&gt;(t);                <span class='comment'>// OK: calls template
</span>  a.template f(t);                  <span class='comment'>// error: not a <span class='grammarterm'>template-id</span>
</span>}

template &lt;class T&gt; struct B {
  template &lt;class T2&gt; struct C { };
};

<span class='comment'>// OK: <span class='texttt'>T::template C</span> names a class template:
</span>template &lt;class T, template &lt;class X&gt; class TT = T::template C&gt; struct D { };
D&lt;B&lt;int&gt; &gt; db;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='names-6'><div class='marginalizedparent'><a class='marginalized' href='#names-6'>6</a></div><p ><span class='indexparent'><a class='index' id='specialization!class template'></a></span>A
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
that names a class template specialization is a
<i ><a href='class#class-name'>class-name</a></i>
(Clause <a href='class'>[class]</a>).</p></div><div class='para' id='names-7'><div class='marginalizedparent'><a class='marginalized' href='#names-7'>7</a></div><p >A <i ><a href='temp.names#template-id'>template-id</a></i> that names an alias template
specialization is a <i ><a href='dcl.type.simple#type-name'>type-name</a></i>.</p></div><div class='footnote' id='footnote-136'><div class='marginalizedparent'><a class='marginalized' href='#footnote-136'>136)</a></div><p >A <span class='texttt'>&gt;</span> that encloses the <span class='grammarterm'>type-id</span>
of a <span class='texttt'>dynamic_cast</span>, <span class='texttt'>static_cast</span>, <span class='texttt'>reinterpret_cast</span>
or <span class='texttt'>const_cast</span>, or which encloses the <span class='grammarterm'>template-arguments</span>
of a subsequent <span class='grammarterm'>template-id</span>, is considered nested for the purpose
of this description.
</p></div></div><div id='arg'><h2 ><a class='secnum' href='#arg' style='min-width:88pt'>14.3</a> Template arguments <a class='abbr_ref' href='temp.arg'>[temp.arg]</a></h2><div class='para' id='arg-1'><div class='marginalizedparent'><a class='marginalized' href='#arg-1'>1</a></div><p ><span class='indexparent'><a class='index' id='argument!template'></a></span>There are three forms of
<i ><a href='temp.names#template-argument'>template-argument</a></i>,
corresponding to the three forms of
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>:
type, non-type and template.
The type and form of each
<i ><a href='temp.names#template-argument'>template-argument</a></i>
specified in a
<i ><a href='temp.names#template-id'>template-id</a></i>
shall match the type and form specified for the corresponding
parameter declared by the template in its
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>.
When the parameter declared by the template is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), it will correspond to zero or more
<i ><a href='temp.names#template-argument'>template-arguments</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};

Array&lt;int&gt; v1(20);
typedef std::complex&lt;double&gt; dcomplex;  <span class='comment'>// <span class='texttt'>std::complex</span> is a standard
</span>                                        <span class='comment'>// library template
</span>Array&lt;dcomplex&gt; v2(30);
Array&lt;dcomplex&gt; v3(40);

void bar() {
  v1[3] = 7;
  v2[3] = v3.elem(4) = dcomplex(7,8);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-2'><div class='marginalizedparent'><a class='marginalized' href='#arg-2'>2</a></div><p >In a
<i ><a href='temp.names#template-argument'>template-argument</a></i>,
an ambiguity between a
<i ><a href='dcl.name#type-id'>type-id</a></i>
and an expression is resolved to a
<i ><a href='dcl.name#type-id'>type-id</a></i>,
regardless of the form of the corresponding
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>.<a class='footnotenum' href='#footnote-137'>137</a>
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f();
template&lt;int I&gt; void f();

void g() {
  f&lt;int()&gt;();       <span class='comment'>// <span class='texttt'>int()</span> is a type-id: call the first <span class='texttt'>f()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-3'><div class='marginalizedparent'><a class='marginalized' href='#arg-3'>3</a></div><p >The name of a
<i ><a href='temp.names#template-argument'>template-argument</a></i>
shall be accessible at the point where it is used as a
<i ><a href='temp.names#template-argument'>template-argument</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
If the name of the
<i ><a href='temp.names#template-argument'>template-argument</a></i>
is accessible at the point where it is used as a
<i ><a href='temp.names#template-argument'>template-argument</a></i>,
there is no further access restriction in the resulting instantiation where the
corresponding
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
name is used.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T t;
};

class Y {
private:
  struct S { <span class='comment'>/* ... */</span> };
  X&lt;S&gt; x;           <span class='comment'>// OK: <span class='texttt'>S</span> is accessible
</span>                    <span class='comment'>// <span class='texttt'>X&lt;Y::S&gt;</span> has a static member of type <span class='texttt'>Y::S</span>
</span>                    <span class='comment'>// OK: even though <span class='texttt'>Y::S</span> is private
</span>};

X&lt;Y::S&gt; y;          <span class='comment'>// error: <span class='texttt'>S</span> not accessible
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
For a
<i ><a href='temp.names#template-argument'>template-argument</a></i>
that is a class type or a class template, the template
definition has no special access rights to the
members of the <i ><a href='temp.names#template-argument'>template-argument</a></i>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;template &lt;class TT&gt; class T&gt; class A {
  typename T&lt;int&gt;::S s;
};

template &lt;class U&gt; class B {
private:
  struct S { <span class='comment'>/* ... */</span> };
};

A&lt;B&gt; b;             <span class='comment'>// ill-formed: <span class='texttt'>A</span> has no access to <span class='texttt'>B::S</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-4'><div class='marginalizedparent'><a class='marginalized' href='#arg-4'>4</a></div><p >When template argument packs or default
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
are used, a
<i ><a href='temp.names#template-argument'>template-argument</a></i>
list can be empty.
In that case the empty
<span class='texttt'>&lt;&gt;</span>
brackets shall still be used as the
<span class='grammarterm'>template-argument-list.</span>
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T = char&gt; class String;
String&lt;&gt;* p;                    <span class='comment'>// OK: <span class='texttt'>String&lt;char&gt;</span>
</span>String* q;                      <span class='comment'>// syntax error
</span>template&lt;class ... Elements&gt; class Tuple;
Tuple&lt;&gt;* t;                     <span class='comment'>// OK: <span class='texttt'>Elements</span> is empty
</span>Tuple* u;                       <span class='comment'>// syntax error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-5'><div class='marginalizedparent'><a class='marginalized' href='#arg-5'>5</a></div><p >An explicit destructor call (<a href='class.dtor'>[class.dtor]</a>) for an object that has a type
that is a class template specialization may explicitly specify the
<i ><a href='temp.names#template-argument'>template-arguments</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  ~A();
};
void f(A&lt;int&gt;* p, A&lt;int&gt;* q) {
  p-&gt;A&lt;int&gt;::~A();              <span class='comment'>// OK: destructor call
</span>  q-&gt;A&lt;int&gt;::~A&lt;int&gt;();         <span class='comment'>// OK: destructor call
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-6'><div class='marginalizedparent'><a class='marginalized' href='#arg-6'>6</a></div><p >If the use of a
<i ><a href='temp.names#template-argument'>template-argument</a></i>
gives rise to an ill-formed construct in the instantiation of a
template specialization, the program is ill-formed.</p></div><div class='para' id='arg-7'><div class='marginalizedparent'><a class='marginalized' href='#arg-7'>7</a></div><p >When the template in a
<i ><a href='temp.names#template-id'>template-id</a></i>
is an overloaded function template, both non-template functions in the overload
set and function templates in the overload set for
which the
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
do not match the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
are ignored.
If none of the function templates have matching
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>,
the program is ill-formed.</p></div><div class='para' id='arg-8'><div class='marginalizedparent'><a class='marginalized' href='#arg-8'>8</a></div><p >When a <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i> does not name a function,
a default <i ><a href='temp.names#template-argument'>template-argument</a></i> is
implicitly instantiated (<a href='temp.inst'>[temp.inst]</a>)
when the value of that default argument is needed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename T, typename U = int&gt; struct S { };
S&lt;bool&gt;* p; <span class='comment'>// the type of <span class='texttt'>p</span> is <span class='texttt'>S&lt;bool, int&gt;*</span>
</span></pre><p >The default argument for <span class='texttt'>U</span> is instantiated to form the type <span class='texttt'>S&lt;bool, int&gt;*</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg-9'><div class='marginalizedparent'><a class='marginalized' href='#arg-9'>9</a></div><p >A <i ><a href='temp.names#template-argument'>template-argument</a></i> followed by an ellipsis is
a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).</p></div><div class='footnote' id='footnote-137'><div class='marginalizedparent'><a class='marginalized' href='#footnote-137'>137)</a></div><p >There is no such ambiguity in a default
<span class='grammarterm'>template-argument</span>
because the form of the
<span class='grammarterm'>template-parameter</span>
determines the allowable forms of the
<span class='grammarterm'>template-argument</span>.</p></div><div id='arg.type'><h3 ><a class='secnum' href='#arg.type' style='min-width:103pt'>14.3.1</a> Template type arguments <a class='abbr_ref' href='temp.arg.type'>[temp.arg.type]</a></h3><div class='para' id='arg.type-1'><div class='marginalizedparent'><a class='marginalized' href='#arg.type-1'>1</a></div><p >A
<i ><a href='temp.names#template-argument'>template-argument</a></i>
for a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
which is a type
shall be a
<i ><a href='dcl.name#type-id'>type-id</a></i>.</p></div><div class='para' id='arg.type-2'><div class='marginalizedparent'><a class='marginalized' href='#arg.type-2'>2</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; class X { };
template &lt;class T&gt; void f(T t) { }
struct { } unnamed_obj;

void f() {
  struct A { };
  enum { e1 };
  typedef struct { } B;
  B b;
  X&lt;A&gt; x1;          <span class='comment'>// OK
</span>  X&lt;A*&gt; x2;         <span class='comment'>// OK
</span>  X&lt;B&gt; x3;          <span class='comment'>// OK
</span>  f(e1);            <span class='comment'>// OK
</span>  f(unnamed_obj);   <span class='comment'>// OK
</span>  f(b);             <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
A template type argument may be an incomplete type (<a href='basic.types'>[basic.types]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='arg.nontype'><h3 ><a class='secnum' href='#arg.nontype' style='min-width:103pt'>14.3.2</a> Template non-type arguments <a class='abbr_ref' href='temp.arg.nontype'>[temp.arg.nontype]</a></h3><div class='para' id='arg.nontype-1'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-1'>1</a></div><p >If the type of a <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
contains a placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>, <a href='temp.param'>[temp.param]</a>),
the deduced parameter type is determined
from the type of the <i ><a href='temp.names#template-argument'>template-argument</a></i>
by placeholder type deduction (<a href='dcl.type.auto.deduct'>[dcl.type.auto.deduct]</a>).
If a deduced parameter type is not permitted
for a <i ><a href='temp.param#template-parameter'>template-parameter</a></i> declaration (<a href='temp.param'>[temp.param]</a>),
the program is ill-formed.</p></div><div class='para' id='arg.nontype-2'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-2'>2</a></div><p >A
<i ><a href='temp.names#template-argument'>template-argument</a></i>
for a non-type
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall be
a converted
constant expression (<a href='expr.const'>[expr.const]</a>)
of the type of the <i ><a href='temp.param#template-parameter'>template-parameter</a></i>.
For a non-type <i ><a href='temp.param#template-parameter'>template-parameter</a></i> of reference or pointer type,
the value of the constant expression shall not refer to
(or for a pointer type, shall not be the address of):</p><ul ><li ><p >a subobject (<a href='intro.object'>[intro.object]</a>),
</p></li><li ><p >a temporary object (<a href='class.temporary'>[class.temporary]</a>),
</p></li><li ><p >a string literal (<a href='lex.string'>[lex.string]</a>),
</p></li><li ><p >the result of a <span class='texttt'>typeid</span> expression (<a href='expr.typeid'>[expr.typeid]</a>), or
</p></li><li ><p >a predefined <span class='texttt'>__func__</span> variable (<a href='dcl.fct.def.general'>[dcl.fct.def.general]</a>).
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
If the <i ><a href='temp.names#template-argument'>template-argument</a></i>
represents a set of overloaded functions
(or a pointer or member pointer to such),
the matching function is selected from the set (<a href='over.over'>[over.over]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.nontype-3'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;const int* pci&gt; struct X { <span class='comment'>/* ... */</span> };
int ai[10];
X&lt;ai&gt; xi;                       <span class='comment'>// array to pointer and qualification conversions
</span>
struct Y { <span class='comment'>/* ... */</span> };
template&lt;const Y&amp; b&gt; struct Z { <span class='comment'>/* ... */</span> };
Y y;
Z&lt;y&gt; z;                         <span class='comment'>// no conversion, but note extra cv-qualification
</span>
template&lt;int (&amp;pa)[5]&gt; struct W { <span class='comment'>/* ... */</span> };
int b[5];
W&lt;b&gt; w;                         <span class='comment'>// no conversion
</span>
void f(char);
void f(int);

template&lt;void (*pf)(int)&gt; struct A { <span class='comment'>/* ... */</span> };

A&lt;&amp;f&gt; a;                        <span class='comment'>// selects <span class='texttt'>f(int)</span>
</span>
template&lt;auto n&gt; struct B { <span class='comment'>/* ... */</span> };
B&lt;5&gt; b1;   <span class='comment'>// OK: template parameter type is <span class='texttt'>int</span>
</span>B&lt;'a'&gt; b2; <span class='comment'>// OK: template parameter type is <span class='texttt'>char</span>
</span>B&lt;2.5&gt; b3; <span class='comment'>// error: template parameter type cannot be <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg.nontype-4'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A string literal (<a href='lex.string'>[lex.string]</a>)
is not an acceptable
<i ><a href='temp.names#template-argument'>template-argument</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T, const char* p&gt; class X {
  <span class='comment'>/* ... */</span>
};

X&lt;int, "Studebaker"&gt; x1;        <span class='comment'>// error: string literal as template-argument
</span>
const char p[] = "Vivisectionist";
X&lt;int,p&gt; x2;                    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.nontype-5'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The address of an array element or non-static data member is not an acceptable
<i ><a href='temp.names#template-argument'>template-argument</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;int* p&gt; class X { };

int a[10];
struct S { int m; static int s; } s;

X&lt;&amp;a[2]&gt; x3;                    <span class='comment'>// error: address of array element
</span>X&lt;&amp;s.m&gt; x4;                     <span class='comment'>// error: address of non-static member
</span>X&lt;&amp;s.s&gt; x5;                     <span class='comment'>// OK: address of static member
</span>X&lt;&amp;S::s&gt; x6;                    <span class='comment'>// OK: address of static member
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.nontype-6'><div class='marginalizedparent'><a class='marginalized' href='#arg.nontype-6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A temporary object
is not an acceptable
<i ><a href='temp.names#template-argument'>template-argument</a></i>
when the corresponding
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
has reference type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;const int&amp; CRI&gt; struct B { <span class='comment'>/* ... */</span> };

B&lt;1&gt; b2;                        <span class='comment'>// error: temporary would be required for template argument
</span>
int c = 1;
B&lt;c&gt; b1;                        <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='arg.template'><h3 ><a class='secnum' href='#arg.template' style='min-width:103pt'>14.3.3</a> Template template arguments <a class='abbr_ref' href='temp.arg.template'>[temp.arg.template]</a></h3><div class='para' id='arg.template-1'><div class='marginalizedparent'><a class='marginalized' href='#arg.template-1'>1</a></div><p >A
<i ><a href='temp.names#template-argument'>template-argument</a></i>
for a template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall be the name of a class template or an alias template, expressed as
<i ><a href='expr.prim.id#id-expression'>id-expression</a></i>.
When the <i ><a href='temp.names#template-argument'>template-argument</a></i> names a class
template, only primary class templates are considered when matching the template template
argument with the corresponding parameter; partial specializations are not
considered even if their parameter lists match that of the template template
parameter.</p></div><div class='para' id='arg.template-2'><div class='marginalizedparent'><a class='marginalized' href='#arg.template-2'>2</a></div><p >Any partial specializations (<a href='temp.class.spec'>[temp.class.spec]</a>) associated with the
primary class template or primary variable template are considered when a
specialization based on the template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is instantiated.
If a specialization is not visible at the point of instantiation,
and it would have been selected had it been visible, the program is ill-formed;
no diagnostic is required.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class A {     <span class='comment'>// primary template
</span>  int x;
};
template&lt;class T&gt; class A&lt;T*&gt; { <span class='comment'>// partial specialization
</span>  long x;
};
template&lt;template&lt;class U&gt; class V&gt; class C {
  V&lt;int&gt;  y;
  V&lt;int*&gt; z;
};
C&lt;A&gt; c;                         <span class='comment'>// <span class='texttt'>V&lt;int&gt;</span> within <span class='texttt'>C&lt;A&gt;</span> uses the primary template,
</span>                                <span class='comment'>// so <span class='texttt'>c.y.x</span> has type <span class='texttt'>int</span>
</span>                                <span class='comment'>// <span class='texttt'>V&lt;int*&gt;</span> within <span class='texttt'>C&lt;A&gt;</span> uses the partial specialization,
</span>                                <span class='comment'>// so <span class='texttt'>c.z.x</span> has type <span class='texttt'>long</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg.template-3'><div class='marginalizedparent'><a class='marginalized' href='#arg.template-3'>3</a></div><p >A <i ><a href='temp.names#template-argument'>template-argument</a></i> matches a template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i> <span class='texttt'>P</span> when each of the template
parameters in the <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> of the
<i ><a href='temp.names#template-argument'>template-argument</a></i>'s corresponding class template or alias template
<span class='texttt'>A</span> matches the corresponding template parameter in the
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> of <span class='texttt'>P</span>. 
Two template parameters match if they are of the same kind (type, non-type, template),
for non-type <i ><a href='temp.param#template-parameter'>template-parameters</a></i>, their types are
equivalent (<a href='temp.over.link'>[temp.over.link]</a>), and for template <i ><a href='temp.param#template-parameter'>template-parameters</a></i>,
each of their corresponding <i ><a href='temp.param#template-parameter'>template-parameters</a></i> matches, recursively.
When <span class='texttt'>P</span>'s <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> contains a template parameter
pack (<a href='temp.variadic'>[temp.variadic]</a>), the template parameter pack will match zero or more template
parameters or template parameter packs in the <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i> of
<span class='texttt'>A</span> with the same type and form as the template parameter pack in <span class='texttt'>P</span>
(ignoring whether those template parameters are template parameter packs).</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class A { <span class='comment'>/* ... */</span> };
template&lt;class T, class U = T&gt; class B { <span class='comment'>/* ... */</span> };
template &lt;class ... Types&gt; class C { <span class='comment'>/* ... */</span> };

template&lt;template&lt;class&gt; class P&gt; class X { <span class='comment'>/* ... */</span> };
template&lt;template&lt;class ...&gt; class Q&gt; class Y { <span class='comment'>/* ... */</span> };

X&lt;A&gt; xa;            <span class='comment'>// OK
</span>X&lt;B&gt; xb;            <span class='comment'>// ill-formed: default arguments for the parameters of a template argument are ignored
</span>X&lt;C&gt; xc;            <span class='comment'>// ill-formed: a template parameter pack does not match a template parameter
</span>
Y&lt;A&gt; ya;            <span class='comment'>// OK
</span>Y&lt;B&gt; yb;            <span class='comment'>// OK
</span>Y&lt;C&gt; yc;            <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; struct eval;

template &lt;template &lt;class, class...&gt; class TT, class T1, class... Rest&gt;
struct eval&lt;TT&lt;T1, Rest...&gt;&gt; { };

template &lt;class T1&gt; struct A;
template &lt;class T1, class T2&gt; struct B;
template &lt;int N&gt; struct C;
template &lt;class T1, int N&gt; struct D;
template &lt;class T1, class T2, int N = 17&gt; struct E;

eval&lt;A&lt;int&gt;&gt; eA;                <span class='comment'>// OK: matches partial specialization of <span class='texttt'>eval</span>
</span>eval&lt;B&lt;int, float&gt;&gt; eB;         <span class='comment'>// OK: matches partial specialization of <span class='texttt'>eval</span>
</span>eval&lt;C&lt;17&gt;&gt; eC;                 <span class='comment'>// error: <span class='texttt'>C</span> does not match <span class='texttt'>TT</span> in partial specialization
</span>eval&lt;D&lt;int, 17&gt;&gt; eD;            <span class='comment'>// error: <span class='texttt'>D</span> does not match <span class='texttt'>TT</span> in partial specialization
</span>eval&lt;E&lt;int, float&gt;&gt; eE;         <span class='comment'>// error: <span class='texttt'>E</span> does not match <span class='texttt'>TT</span> in partial specialization
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='type'><h2 ><a class='secnum' href='#type' style='min-width:88pt'>14.4</a> Type equivalence <a class='abbr_ref' href='temp.type'>[temp.type]</a></h2><div class='para' id='type-1'><div class='marginalizedparent'><a class='marginalized' href='#type-1'>1</a></div><p ><span class='indexparent'><a class='index' id='equivalence!template type'></a></span>Two <i ><a href='temp.names#template-id'>template-ids</a></i> refer to the same
class, function, or variable if
</p><ul ><li ><p >their <i ><a href='temp.names#template-name'>template-names</a></i>,
<i ><a href='over.oper#operator-function-id'>operator-function-ids</a></i>, or <i ><a href='over.literal#literal-operator-id'>literal-operator-ids</a></i>
refer to the same template and
</p></li><li ><p >their corresponding type <i ><a href='temp.names#template-argument'>template-arguments</a></i> are the
same type and
</p></li><li ><p >their corresponding non-type
template arguments of
integral or enumeration type have identical values and
</p></li><li ><p >their corresponding non-type <i ><a href='temp.names#template-argument'>template-arguments</a></i> of
pointer type refer to the same object or function or are both the null
pointer value and
</p></li><li ><p >their corresponding non-type <i ><a href='temp.names#template-argument'>template-arguments</a></i> of
pointer-to-member type refer to the same class member or are both the null member
pointer value and
</p></li><li ><p >their corresponding non-type <i ><a href='temp.names#template-argument'>template-arguments</a></i> of
reference type refer to the same object or function and
</p></li><li ><p >their corresponding template <i ><a href='temp.names#template-argument'>template-arguments</a></i> refer
to the same template.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class E, int size&gt; class buffer { <span class='comment'>/* ... */</span> };
buffer&lt;char,2*512&gt; x;
buffer&lt;char,1024&gt; y;
</pre><p >declares
<span class='texttt'>x</span>
and
<span class='texttt'>y</span>
to be of the same type, and</p><pre class='codeblock'>
template&lt;class T, void(*err_fct)()&gt; class list { <span class='comment'>/* ... */</span> };
list&lt;int,&amp;error_handler1&gt; x1;
list&lt;int,&amp;error_handler2&gt; x2;
list&lt;int,&amp;error_handler2&gt; x3;
list&lt;char,&amp;error_handler2&gt; x4;
</pre><p >declares
<span class='texttt'>x2</span>
and
<span class='texttt'>x3</span>
to be of the same type.
Their type differs from the types of
<span class='texttt'>x1</span>
and
<span class='texttt'>x4</span>.</p><pre class='codeblock'>
template&lt;class T&gt; struct X { };
template&lt;class&gt; struct Y { };
template&lt;class T&gt; using Z = Y&lt;T&gt;;
X&lt;Y&lt;int&gt; &gt; y;
X&lt;Z&lt;int&gt; &gt; z;
</pre><p >declares <span class='texttt'>y</span> and <span class='texttt'>z</span> to be of the same type.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='type-2'><div class='marginalizedparent'><a class='marginalized' href='#type-2'>2</a></div><p >If an expression <span class='math'><span class='mathalpha'>e</span></span> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>),
<span class='texttt'>decltype(<span class='math'><span class='mathalpha'>e</span></span>)</span>
denotes a unique dependent type. Two such <i ><a href='dcl.type.simple#decltype-specifier'>decltype-specifiers</a></i>
refer to the same type only if their <i ><a href='expr.comma#expression'>expressions</a></i> are
equivalent (<a href='temp.over.link'>[temp.over.link]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> however, such a type may be aliased,
e.g., by a <i ><a href='dcl.typedef#typedef-name'>typedef-name</a></i>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='decls'><h2 ><a class='secnum' href='#decls' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls'>[temp.decls]</a></h2><div class='para' id='decls-1'><div class='marginalizedparent'><a class='marginalized' href='#decls-1'>1</a></div><p >A
<i ><a href='temp.names#template-id'>template-id</a></i>,
that is, the
<i ><a href='temp.names#template-name'>template-name</a></i>
followed by a
<i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>
shall not be specified in the declaration of a primary template declaration.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2, I&gt; { };     <span class='comment'>// error
</span>template&lt;class T1, int I&gt; void sort&lt;T1, I&gt;(T1 data[I]);         <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
However, this syntax is allowed in class template partial specializations (<a href='temp.class.spec'>[temp.class.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='decls-2'><div class='marginalizedparent'><a class='marginalized' href='#decls-2'>2</a></div><p >For purposes of name lookup and instantiation,
default arguments and <i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of function
templates and default arguments and <i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of
member functions of class templates are considered definitions;
each default argument or <i ><a href='except.spec#exception-specification'>exception-specification</a></i> is a separate
definition which is unrelated to
the function template definition or to any other default arguments or
<i ><a href='except.spec#exception-specification'>exception-specifications</a></i>.
For the purpose of instantiation, the substatements of a constexpr if
statement (<a href='stmt.if'>[stmt.if]</a>) are considered definitions.</p></div><div class='para' id='decls-3'><div class='marginalizedparent'><a class='marginalized' href='#decls-3'>3</a></div><p >Because an <i ><a href='dcl.dcl#alias-declaration'>alias-declaration</a></i> cannot declare a
<i ><a href='temp.names#template-id'>template-id</a></i>, it is not possible to partially or
explicitly specialize an alias template.</p></div><div id='class'><h3 ><a class='secnum' href='#class' style='min-width:103pt'>14.5.1</a> Class templates <a class='abbr_ref' href='temp.class'>[temp.class]</a></h3><div class='para' id='class-1'><div class='marginalizedparent'><a class='marginalized' href='#class-1'>1</a></div><p >A class
<i>template</i>
defines the layout and operations
for an unbounded set of related types.
[&nbsp;<i>Example:</i><span class='space'></span>
a single class template
<span class='texttt'>List</span>
might provide a common definition for
list of
<span class='texttt'>int</span>,
list of
<span class='texttt'>float</span>,
and list of pointers to
<span class='texttt'>Shape</span>s.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
An array class template might be declared like this:</p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};
</pre></div><div class='para' id='class-2'><div class='marginalizedparent'><a class='marginalized' href='#class-2'>2</a></div><p >The prefix
<span class='texttt'>template</span>
<span class='texttt'>&lt;class</span>
<span class='texttt'>T&gt;</span>
specifies that a template is being declared and that a
<i ><a href='dcl.type.simple#type-name'>type-name</a></i>
<span class='texttt'>T</span>
will be used in the declaration.
In other words,
<span class='texttt'>Array</span>
is a parameterized type with
<span class='texttt'>T</span>
as its parameter.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class-3'><div class='marginalizedparent'><a class='marginalized' href='#class-3'>3</a></div><p >When a member function, a member class, a member enumeration, a static data member or
a member template of a class
template is defined outside of the class template definition,
the member definition is defined as a template definition in which the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
are those of the class template.
The names of the template parameters used in the definition of the member may
be different from the template parameter names used in the class
template definition.
The template argument list following the class template name in the member
definition shall name the parameters in the same order as the one used in
the template parameter list of the member. Each template
parameter pack shall be expanded with an ellipsis in the template
argument list.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1, class T2&gt; struct A {
  void f1();
  void f2();
};

template&lt;class T2, class T1&gt; void A&lt;T2,T1&gt;::f1() { }    <span class='comment'>// OK
</span>template&lt;class T2, class T1&gt; void A&lt;T1,T2&gt;::f2() { }    <span class='comment'>// error
</span></pre><pre class='codeblock'>
template&lt;class ... Types&gt; struct B {
  void f3();
  void f4();
};

template&lt;class ... Types&gt; void B&lt;Types ...&gt;::f3() { }    <span class='comment'>// OK
</span>template&lt;class ... Types&gt; void B&lt;Types&gt;::f4() { }        <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class-4'><div class='marginalizedparent'><a class='marginalized' href='#class-4'>4</a></div><p >In a redeclaration, partial
specialization,
explicit specialization or explicit
instantiation of a class template, the
<i ><a href='class#class-key'>class-key</a></i>
shall agree in kind with the original class template declaration (<a href='dcl.type.elab'>[dcl.type.elab]</a>).</p></div><div id='mem.func'><h4 ><a class='secnum' href='#mem.func' style='min-width:118pt'>14.5.1.1</a> Member functions of class templates <a class='abbr_ref' href='temp.mem.func'>[temp.mem.func]</a></h4><div class='para' id='mem.func-1'><div class='marginalizedparent'><a class='marginalized' href='#mem.func-1'>1</a></div><p ><span class='indexparent'><a class='index' id='template!member~function'></a></span>A member function
of a class template
may be defined outside of the class
template definition in which it is declared.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};
</pre><p >declares three function templates.
The subscript function might be defined like this:</p><pre class='codeblock'>
template&lt;class T&gt; T&amp; Array&lt;T&gt;::operator[](int i) {
  if (i&lt;0 || sz&lt;=i) error("Array: range error");
  return v[i];
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem.func-2'><div class='marginalizedparent'><a class='marginalized' href='#mem.func-2'>2</a></div><p >The
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
for a member function of a class template are determined by the
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
of the type of the object for which the member function is called.
[&nbsp;<i>Example:</i><span class='space'></span>
the
<i ><a href='temp.names#template-argument'>template-argument</a></i>
for
<span class='texttt'>Array&lt;T&gt;&nbsp;::&nbsp;operator&nbsp;[]&nbsp;()</span>
will be determined by the
<span class='texttt'>Array</span>
to which the subscripting operation is applied.</p><pre class='codeblock'>
Array&lt;int&gt; v1(20);
Array&lt;dcomplex&gt; v2(30);

v1[3] = 7;                      <span class='comment'>// <span class='texttt'>Array&lt;int&gt;::operator[]()</span>
</span>v2[3] = dcomplex(7,8);          <span class='comment'>// <span class='texttt'>Array&lt;dcomplex&gt;::operator[]()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='mem.class'><h4 ><a class='secnum' href='#mem.class' style='min-width:118pt'>14.5.1.2</a> Member classes of class templates <a class='abbr_ref' href='temp.mem.class'>[temp.mem.class]</a></h4><div class='para' id='mem.class-1'><div class='marginalizedparent'><a class='marginalized' href='#mem.class-1'>1</a></div><p >A member class of a class template may be defined outside the class template
definition in which it is declared.
[&nbsp;<i>Note:</i><span class='space'></span>
The member class must be defined before its first use that requires
an instantiation (<a href='temp.inst'>[temp.inst]</a>).
For example,</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  class B;
};
A&lt;int&gt;::B* b1;                  <span class='comment'>// OK: requires <span class='texttt'>A</span> to be defined but not <span class='texttt'>A::B</span>
</span>template&lt;class T&gt; class A&lt;T&gt;::B { };
A&lt;int&gt;::B  b2;                  <span class='comment'>// OK: requires <span class='texttt'>A::B</span> to be defined
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='static'><h4 ><a class='secnum' href='#static' style='min-width:118pt'>14.5.1.3</a> Static data members of class templates <a class='abbr_ref' href='temp.static'>[temp.static]</a></h4><div class='para' id='static-1'><div class='marginalizedparent'><a class='marginalized' href='#static-1'>1</a></div><p ><span class='indexparent'><a class='index' id='member!template~and static'></a></span>A definition for a static data member or static data member template may be
provided in a namespace scope enclosing the definition of the static member's
class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T s;
};
template&lt;class T&gt; T X&lt;T&gt;::s = 0;

struct limits {
  template&lt;class T&gt;
    static const T min;           <span class='comment'>// declaration
</span>};

template&lt;class T&gt;
  const T limits::min = { };      <span class='comment'>// definition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='static-2'><div class='marginalizedparent'><a class='marginalized' href='#static-2'>2</a></div><p >An explicit specialization of a static data member declared as an array of unknown
bound can have a different bound from its definition, if any. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  static int i[];
};
template &lt;class T&gt; int A&lt;T&gt;::i[4];    <span class='comment'>// 4 elements
</span>template &lt;&gt; int A&lt;int&gt;::i[] = { 1 };  <span class='comment'>// OK: 1 element
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='mem.enum'><h4 ><a class='secnum' href='#mem.enum' style='min-width:118pt'>14.5.1.4</a> Enumeration members of class templates <a class='abbr_ref' href='temp.mem.enum'>[temp.mem.enum]</a></h4><div class='para' id='mem.enum-1'><div class='marginalizedparent'><a class='marginalized' href='#mem.enum-1'>1</a></div><p >An enumeration member of a class template may be defined outside the class
template definition. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  enum E : T;
};
A&lt;int&gt; a;
template&lt;class T&gt; enum A&lt;T&gt;::E : T { e1, e2 };
A&lt;int&gt;::E e = A&lt;int&gt;::e1;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='mem'><h3 ><a class='secnum' href='#mem' style='min-width:103pt'>14.5.2</a> Member templates <a class='abbr_ref' href='temp.mem'>[temp.mem]</a></h3><div class='para' id='mem-1'><div class='marginalizedparent'><a class='marginalized' href='#mem-1'>1</a></div><p >A template can be declared within a class or class template; such a template
is called a member template.
A member template can be defined within or outside its class definition or
class template definition.
A member template of a class template that is defined outside of its class
template definition shall be specified with the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
of the class template followed by the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
of the member template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct string {
  template&lt;class T2&gt; int compare(const T2&amp;);
  template&lt;class T2&gt; string(const string&lt;T2&gt;&amp; s) { <span class='comment'>/* ... */</span> }
};

template&lt;class T&gt; template&lt;class T2&gt; int string&lt;T&gt;::compare(const T2&amp; s) {
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-2'><div class='marginalizedparent'><a class='marginalized' href='#mem-2'>2</a></div><p >A local class of non-closure type shall not have member templates.
Access control rules (Clause <a href='class.access'>[class.access]</a>)
apply to member template names.
A destructor shall not be a member
template.
A non-template member function (<a href='dcl.fct'>[dcl.fct]</a>) with a given name
and type and a member function template of the same name, which could be
used to generate a specialization of the same type, can both be
declared in a class.
When both exist, a use of that name and type refers to the
non-template member unless an explicit template argument list is supplied.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class T2&gt; void f(T2);
};

template &lt;&gt; void A&lt;int&gt;::f(int) { }                     <span class='comment'>// non-template member function
</span>template &lt;&gt; template &lt;&gt; void A&lt;int&gt;::f&lt;&gt;(int) { }       <span class='comment'>// member function template specialization
</span>
int main() {
  A&lt;char&gt; ac;
  ac.f(1);          <span class='comment'>// non-template
</span>  ac.f('c');        <span class='comment'>// template
</span>  ac.f&lt;&gt;(1);        <span class='comment'>// template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-3'><div class='marginalizedparent'><a class='marginalized' href='#mem-3'>3</a></div><p >A member function template shall not be virtual.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct AA {
  template &lt;class C&gt; virtual void g(C);   <span class='comment'>// error
</span>  virtual void f();                       <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-4'><div class='marginalizedparent'><a class='marginalized' href='#mem-4'>4</a></div><p >A specialization of
a member function template does not override a virtual function from a
base class.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class B {
  virtual void f(int);
};

class D : public B {
  template &lt;class T&gt; void f(T); <span class='comment'>// does not override <span class='texttt'>B::f(int)</span>
</span>  void f(int i) { f&lt;&gt;(i); }     <span class='comment'>// overriding function that calls
</span>                                <span class='comment'>// the template instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-5'><div class='marginalizedparent'><a class='marginalized' href='#mem-5'>5</a></div><p >A specialization of a
conversion function template
is referenced in
the same way as a non-template conversion function that converts to
the same type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T*();
};
template &lt;class T&gt; A::operator T*(){ return 0; }
template &lt;&gt; A::operator char*(){ return 0; }    <span class='comment'>// specialization
</span>template A::operator void*();                   <span class='comment'>// explicit instantiation
</span>
int main() {
  A a;
  int* ip;
  ip = a.operator int*();       <span class='comment'>// explicit call to template operator
</span>                                <span class='comment'>// <span class='texttt'>A::operator int*()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Because the explicit template argument list follows the function template
name, and because conversion member function templates and constructor
member function templates are called without using a function name,
there is no way to provide an explicit template argument list for these
function templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-6'><div class='marginalizedparent'><a class='marginalized' href='#mem-6'>6</a></div><p >A specialization of a
conversion function template
is not found by name
lookup.
Instead, any
conversion function templates
visible in the
context of the use are considered.
For each such operator, if argument
deduction succeeds (<a href='temp.deduct.conv'>[temp.deduct.conv]</a>), the resulting specialization is
used as if found by name lookup.</p></div><div class='para' id='mem-7'><div class='marginalizedparent'><a class='marginalized' href='#mem-7'>7</a></div><p >A <i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i> in a derived class cannot refer to a specialization
of a
conversion function template
in a base class.</p></div><div class='para' id='mem-8'><div class='marginalizedparent'><a class='marginalized' href='#mem-8'>8</a></div><p >Overload resolution (<a href='over.ics.rank'>[over.ics.rank]</a>) and partial
ordering (<a href='temp.func.order'>[temp.func.order]</a>) are used to select the best conversion function
among multiple
specializations of conversion function templates
and/or non-template
conversion functions.</p></div></div><div id='variadic'><h3 ><a class='secnum' href='#variadic' style='min-width:103pt'>14.5.3</a> Variadic templates <a class='abbr_ref' href='temp.variadic'>[temp.variadic]</a></h3><div class='para' id='variadic-1'><div class='marginalizedparent'><a class='marginalized' href='#variadic-1'>1</a></div><p >A <i>template parameter pack</i> is a template parameter
that accepts zero or more template arguments. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; struct Tuple { };

Tuple&lt;&gt; t0;                     <span class='comment'>// <span class='texttt'>Types</span> contains no arguments
</span>Tuple&lt;int&gt; t1;                  <span class='comment'>// <span class='texttt'>Types</span> contains one argument: <span class='texttt'>int</span>
</span>Tuple&lt;int, float&gt; t2;           <span class='comment'>// <span class='texttt'>Types</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>float</span>
</span>Tuple&lt;0&gt; error;                 <span class='comment'>// error: 0 is not a type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='variadic-2'><div class='marginalizedparent'><a class='marginalized' href='#variadic-2'>2</a></div><p >A <i>function parameter pack</i> is a function parameter
that accepts zero or more function arguments. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... args);

f();                <span class='comment'>// OK: <span class='texttt'>args</span> contains no arguments
</span>f(1);               <span class='comment'>// OK: <span class='texttt'>args</span> contains one argument: <span class='texttt'>int</span>
</span>f(2, 1.0);          <span class='comment'>// OK: <span class='texttt'>args</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='variadic-3'><div class='marginalizedparent'><a class='marginalized' href='#variadic-3'>3</a></div><p >A <i>parameter pack</i> is either a template parameter
pack or a function parameter pack.</p></div><div class='para' id='variadic-4'><div class='marginalizedparent'><a class='marginalized' href='#variadic-4'>4</a></div><p >A <i>pack expansion</i>
consists of a <i>pattern</i> and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:</p><ul ><li ><p >In a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>); the pattern is the
<i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> without the ellipsis.</p></li><li ><p >In a template parameter pack that is a pack expansion (<a href='temp.param'>[temp.param]</a>):</p><ul ><li ><p >if the template parameter pack is a <i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i>;
the pattern is the <i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> without the ellipsis;</p></li><li ><p >if the template parameter pack is a <i ><a href='temp.param#type-parameter'>type-parameter</a></i> with a
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>; the pattern is the corresponding
<i ><a href='temp.param#type-parameter'>type-parameter</a></i> without the ellipsis.
</p></li></ul></li><li ><p >In an <i ><a href='dcl.init#initializer-list'>initializer-list</a></i> (<a href='dcl.init'>[dcl.init]</a>);
the pattern is an <i ><a href='dcl.init#initializer-clause'>initializer-clause</a></i>.</p></li><li ><p >In a <i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i> (Clause <a href='class.derived'>[class.derived]</a>);
the pattern is a <i ><a href='class.derived#base-specifier'>base-specifier</a></i>.</p></li><li ><p >In a <i ><a href='class.base.init#mem-initializer-list'>mem-initializer-list</a></i> (<a href='class.base.init'>[class.base.init]</a>) for a
<i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i> whose <i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i> denotes a
base class; the pattern is the <i ><a href='class.base.init#mem-initializer'>mem-initializer</a></i>.</p></li><li ><p >In a <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i> (<a href='temp.arg'>[temp.arg]</a>);
the pattern is a <i ><a href='temp.names#template-argument'>template-argument</a></i>.</p></li><li ><p >In a <i ><a href='except.spec#dynamic-exception-specification'>dynamic-exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>);
the pattern is a <i ><a href='dcl.name#type-id'>type-id</a></i>.</p></li><li ><p >In an <i ><a href='dcl.attr.grammar#attribute-list'>attribute-list</a></i> (<a href='dcl.attr.grammar'>[dcl.attr.grammar]</a>); the pattern is
an <i ><a href='dcl.attr.grammar#attribute'>attribute</a></i>.</p></li><li ><p >In an <i ><a href='dcl.attr.grammar#alignment-specifier'>alignment-specifier</a></i> (<a href='dcl.align'>[dcl.align]</a>); the pattern is
the <i ><a href='dcl.attr.grammar#alignment-specifier'>alignment-specifier</a></i> without the ellipsis.</p></li><li ><p >In a <i ><a href='expr.prim.lambda#capture-list'>capture-list</a></i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>); the pattern is
a <i ><a href='expr.prim.lambda#capture'>capture</a></i>.</p></li><li ><p >In a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>); the pattern is an
<i ><a href='lex.name#identifier'>identifier</a></i>.</p></li><li ><p >In a <i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i> (<a href='expr.prim.fold'>[expr.prim.fold]</a>);
the pattern is the <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
that contains an unexpanded parameter pack.
</p></li></ul></div><div class='para' id='variadic-5'><div class='marginalizedparent'><a class='marginalized' href='#variadic-5'>5</a></div><p >For the purpose of determining whether a parameter pack satisfies a rule
regarding entities other than parameter packs, the parameter pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... rest);
template&lt;class ... Types&gt; void g(Types ... rest) {
  f(&amp;rest ...);     <span class='comment'>// “<span class='texttt'>&amp;rest ...</span>” is a pack expansion; “<span class='texttt'>&amp;rest</span>” is its pattern
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='variadic-6'><div class='marginalizedparent'><a class='marginalized' href='#variadic-6'>6</a></div><p >A parameter pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a parameter pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more parameter packs that
are not expanded by a nested pack expansion; such parameter packs are called
<i>unexpanded</i> parameter packs in the pattern. All of the parameter packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a parameter pack that is not expanded is
ill-formed. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;typename...&gt; struct Tuple {};
template&lt;typename T1, typename T2&gt; struct Pair {};

template&lt;class ... Args1&gt; struct zip {
  template&lt;class ... Args2&gt; struct with {
    typedef Tuple&lt;Pair&lt;Args1, Args2&gt; ... &gt; type;
  };
};

typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;
    <span class='comment'>// <span class='texttt'>T1</span> is <span class='texttt'>Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</span>
</span>typedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;
    <span class='comment'>// error: different number of arguments specified for <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span>
</span>
template&lt;class ... Args&gt;
  void g(Args ... args) {               <span class='comment'>// OK: <span class='texttt'>Args</span> is expanded by the function parameter pack <span class='texttt'>args</span>
</span>    f(const_cast&lt;const Args*&gt;(&amp;args)...); <span class='comment'>// OK: “<span class='texttt'>Args</span>” and “<span class='texttt'>args</span>” are expanded
</span>    f(5 ...);                             <span class='comment'>// error: pattern does not contain any parameter packs
</span>    f(args);                              <span class='comment'>// error: parameter pack “<span class='texttt'>args</span>” is not expanded
</span>    f(h(args ...) + args ...);            <span class='comment'>// OK: first “<span class='texttt'>args</span>” expanded within <span class='texttt'>h</span>, second
</span>                                          <span class='comment'>// “<span class='texttt'>args</span>” expanded within <span class='texttt'>f</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='variadic-7'><div class='marginalizedparent'><a class='marginalized' href='#variadic-7'>7</a></div><p >The instantiation of a pack expansion
that is neither a <span class='texttt'>sizeof...</span> expression
nor a <i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i>
produces a
list
<span class='math'><span class='mathtt'>E</span><sub >1</sub>, <span class='mathtt'>E</span><sub >2</sub>, ..., <span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>,
where
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters. Each
<span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern and
replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
Such an element, in the context of the instantiation, is interpreted as
follows:</p><ul ><li ><p >if the pack is a template parameter pack, the element is a template
parameter (<a href='temp.param'>[temp.param]</a>) of the corresponding kind (type or
non-type) designating the type or value from the template
argument; otherwise,</p></li><li ><p >if the pack is a function parameter pack, the element is an
<i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
designating the function parameter that resulted from
the instantiation of the pattern where the pack is declared.
</p></li></ul><p >All of the <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> become elements in the enclosing list.
[&nbsp;<i>Note:</i><span class='space'></span> The variety of list varies with the context:
<i ><a href='expr.post#expression-list'>expression-list</a></i>,
<i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i>,
<i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>, etc.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
When <span class='math'><span class='mathalpha'>N</span></span> is zero, the instantiation of the expansion produces an empty list.
Such an instantiation does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the list entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class... T&gt; struct X : T... { };
template&lt;class... T&gt; void f(T... values) {
  X&lt;T...&gt; x(values...);
}

template void f&lt;&gt;();  <span class='comment'>// OK: <span class='texttt'>X&lt;&gt;</span> has no base classes
</span>                      <span class='comment'>// <span class='texttt'>x</span> is a variable of type <span class='texttt'>X&lt;&gt;</span> that is value-initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='variadic-8'><div class='marginalizedparent'><a class='marginalized' href='#variadic-8'>8</a></div><p >The instantiation of a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>) produces
an integral constant containing the number of elements in the parameter pack
it expands.</p></div><div class='para' id='variadic-9'><div class='marginalizedparent'><a class='marginalized' href='#variadic-9'>9</a></div><p >The instantiation of a <i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i> produces:</p><ul ><li ><p ><span class='texttt'>((</span><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>
           <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >2</sub></span><span class='texttt'>)</span>
           <i>op</i> <span class='math'>⋯</span><span class='texttt'>)</span>
           <i>op</i> <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>
for a unary left fold,
</p></li><li ><p ><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>     <i>op</i>
<span class='texttt'>(</span><span class='math'>⋯</span>           <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span>-1</sub></span> <i>op</i>
         <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span><span class='texttt'>))</span>
for a unary right fold,
</p></li><li ><p ><span class='texttt'>(((</span><span class='math'><span class='mathtt'>E</span></span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >1</sub></span><span class='texttt'>)</span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >2</sub></span><span class='texttt'>)</span>
            <i>op</i> <span class='math'>⋯</span><span class='texttt'>)</span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>
for a binary left fold, and
</p></li><li ><p ><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>     <i>op</i>
<span class='texttt'>(</span><span class='math'>⋯</span>           <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span>-1</sub></span> <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>   <i>op</i>
         <span class='math'><span class='mathtt'>E</span></span><span class='texttt'>)))</span>
for a binary right fold.
</p></li></ul><p >In each case,
<i>op</i> is the <i ><a href='expr.prim.fold#fold-operator'>fold-operator</a></i>,
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters,
and each <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern
and replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
For a binary fold-expression,
<span class='math'><span class='mathtt'>E</span></span> is generated
by instantiating the <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
that did not contain an unexpanded parameter pack.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename ...Args&gt;
  bool all(Args ...args) { return (... &amp;&amp; args); }

bool b = all(true, true, true, false);
</pre><p >Within the instantiation of <span class='texttt'>all</span>,
the returned expression expands to
<span class='texttt'>((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false</span>,
which evaluates to <span class='texttt'>false</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
If <span class='math'><span class='mathalpha'>N</span></span> is zero for a unary fold-expression,
the value of the expression is shown in Table <a href='#tab:fold.empty'>[tab:fold.empty]</a>;
if the operator is not listed in Table <a href='#tab:fold.empty'>[tab:fold.empty]</a>,
the instantiation is ill-formed.</p><div class='numberedTable' id='tab:fold.empty'>Table <a href='#tab:fold.empty'>12</a> — Value of folding empty sequences<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Operator</b></td><td colspan='1' class='center'><b>Value when parameter pack is empty</b></td></tr><tr class='capsep'><td class='left'>

<span class='texttt'>&amp;&amp;</span>    </td><td class='left'> <span class='texttt'>true</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>||</span>      </td><td class='left'> <span class='texttt'>false</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>,</span>       </td><td class='left'> <span class='texttt'>void()</span> </td></tr></table></div></div></div><div id='friend'><h3 ><a class='secnum' href='#friend' style='min-width:103pt'>14.5.4</a> Friends <a class='abbr_ref' href='temp.friend'>[temp.friend]</a></h3><div class='para' id='friend-1'><div class='marginalizedparent'><a class='marginalized' href='#friend-1'>1</a></div><p ><span class='indexparent'><a class='index' id='friend!template~and'></a></span>A friend of a class or class template can be a function template or
class template, a specialization of a function template or class
template, or a non-template function or class.
For a friend function declaration that is not a template declaration:</p><ul ><li ><p >if the name of the friend is a qualified or unqualified <i ><a href='temp.names#template-id'>template-id</a></i>,
the friend declaration refers to a specialization of a function
template, otherwise,
</p></li><li ><p >if the name of the friend is a <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> and a matching non-template
function is found in the specified class or namespace, the friend
declaration refers to that function, otherwise,
</p></li><li ><p >if the name of the friend is a <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> and a matching
function template
is found in the specified class
or namespace, the friend declaration refers to
the deduced specialization of that function template (<a href='temp.deduct.decl'>[temp.deduct.decl]</a>), otherwise,
</p></li><li ><p >the name shall be an <i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i> that declares (or redeclares) a
non-template function.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class task;
template&lt;class T&gt; task&lt;T&gt;* preempt(task&lt;T&gt;*);

template&lt;class T&gt; class task {
  friend void next_time();
  friend void process(task&lt;T&gt;*);
  friend task&lt;T&gt;* preempt&lt;T&gt;(task&lt;T&gt;*);
  template&lt;class C&gt; friend int func(C);

  friend class task&lt;int&gt;;
  template&lt;class P&gt; friend class frd;
};
</pre><p >Here,
each specialization of the
<span class='texttt'>task</span>
class template has the function
<span class='texttt'>next_time</span>
as a friend;
because
<span class='texttt'>process</span>
does not have explicit
<i ><a href='temp.names#template-argument'>template-arguments</a></i>,
each specialization of the
<span class='texttt'>task</span>
class template has an appropriately typed function
<span class='texttt'>process</span>
as a friend, and this friend is not a function template specialization;
because the friend
<span class='texttt'>preempt</span>
has an explicit
<i ><a href='temp.names#template-argument'>template-argument</a></i>
<span class='texttt'>T</span>,
each specialization of the
<span class='texttt'>task</span>
class template has the appropriate specialization of the function
template
<span class='texttt'>preempt</span>
as a friend;
and each specialization of the
<span class='texttt'>task</span>
class template has all specializations of the function template
<span class='texttt'>func</span>
as friends.
Similarly,
each specialization of the
<span class='texttt'>task</span>
class template has the class template specialization
<span class='texttt'>task&lt;int&gt;</span>
as a friend, and has all specializations of the class template
<span class='texttt'>frd</span>
as friends.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='friend-2'><div class='marginalizedparent'><a class='marginalized' href='#friend-2'>2</a></div><p >A friend template may be declared within a class or class template.
A friend function template may be defined within a class or class
template, but a friend class template may not be defined in a class
or class template.
In these cases, all specializations of the friend class or friend function
template are friends of the class or class template granting friendship.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class A {
  template&lt;class T&gt; friend class B;                 <span class='comment'>// OK
</span>  template&lt;class T&gt; friend void f(T)<span class='texttt'>{ /* ... */ }</span>  <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='friend-3'><div class='marginalizedparent'><a class='marginalized' href='#friend-3'>3</a></div><p >A template friend declaration specifies that all specializations of that
template, whether they are implicitly instantiated (<a href='temp.inst'>[temp.inst]</a>), partially
specialized (<a href='temp.class.spec'>[temp.class.spec]</a>) or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
are friends of the class containing the template friend declaration.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class X {
  template&lt;class T&gt; friend struct A;
  class Y { };
};

template&lt;class T&gt; struct A { X::Y ab; };            <span class='comment'>// OK
</span>template&lt;class T&gt; struct A&lt;T*&gt; { X::Y ab; };        <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='friend-4'><div class='marginalizedparent'><a class='marginalized' href='#friend-4'>4</a></div><p >When a function is defined in a friend function declaration in a class
template, the function is instantiated when the function is
odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>). The
same restrictions on multiple declarations and definitions that apply
to non-template function declarations and definitions also apply to
these implicit definitions.</p></div><div class='para' id='friend-5'><div class='marginalizedparent'><a class='marginalized' href='#friend-5'>5</a></div><p >A member of a class template may be declared to be a friend of a
non-template class.
In this case,
the corresponding member of every specialization of
the primary class template and
class template partial specializations thereof
is a friend of the class granting friendship.
For
explicit specializations and
specializations of partial specializations,
the corresponding member is the member (if any)
that has the same name, kind (type, function, class template, or function
template), template parameters, and signature as the member of the class
template instantiation that would otherwise have been generated.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B { };
  void f();
  struct D {
    void g();
  };
};
template&lt;&gt; struct A&lt;int&gt; {
  struct B { };
  int f();
  struct D {
    void g();
  };
};

class C {
  template&lt;class T&gt; friend struct A&lt;T&gt;::B;    <span class='comment'>// grants friendship to <span class='texttt'>A&lt;int&gt;::B</span> even though
</span>                                              <span class='comment'>// it is not a specialization of <span class='texttt'>A&lt;T&gt;::B</span>
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::f();    <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::f()</span>
</span>                                              <span class='comment'>// because its return type does not match
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::D::g(); <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::D::g()</span>
</span>                                              <span class='comment'>// because <span class='texttt'>A&lt;int&gt;::D</span> is not a specialization of <span class='texttt'>A&lt;T&gt;::D</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='friend-6'><div class='marginalizedparent'><a class='marginalized' href='#friend-6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A friend declaration may first declare a member of an enclosing namespace scope (<a href='temp.inject'>[temp.inject]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='friend-7'><div class='marginalizedparent'><a class='marginalized' href='#friend-7'>7</a></div><p >A friend template shall not be declared in a local class.</p></div><div class='para' id='friend-8'><div class='marginalizedparent'><a class='marginalized' href='#friend-8'>8</a></div><p >Friend declarations shall not declare partial specializations.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class A { };
class X {
  template&lt;class T&gt; friend class A&lt;T*&gt;; <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='friend-9'><div class='marginalizedparent'><a class='marginalized' href='#friend-9'>9</a></div><p >When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, nor shall the inline specifier be used in such a
declaration.</p></div></div><div id='class.spec'><h3 ><a class='secnum' href='#class.spec' style='min-width:103pt'>14.5.5</a> Class template partial specializations <a class='abbr_ref' href='temp.class.spec'>[temp.class.spec]</a></h3><div class='para' id='class.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization!class template partial'></a></span><span class='indexparent'><a class='index' id='template!primary'></a></span>A
<i>primary</i>
class template declaration is one in which the class template name is an
identifier.
A template declaration in which the class template name is a
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
is a
<i>partial specialization</i>
of the class template named in the
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
A partial specialization of a class template provides an alternative definition
of the template that is used instead of the primary definition when the
arguments in a specialization match those given in the partial
specialization (<a href='temp.class.spec.match'>[temp.class.spec.match]</a>).
The primary template shall be declared before any specializations of
that template.
A partial specialization shall be declared before the first use of a class template
specialization that would make use of the partial specialization as the result of
an implicit or explicit instantiation in every translation unit in which such a use
occurs; no diagnostic is required.</p></div><div class='para' id='class.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-2'>2</a></div><p >Each class template partial specialization is a distinct template and
definitions shall be provided for the members of a template partial
specialization (<a href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a>).</p></div><div class='para' id='class.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A             { };
template&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { };
template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { };
template&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { };
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { };
</pre><p >The first declaration declares the primary (unspecialized) class template.
The second and subsequent declarations declare partial specializations of
the primary template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-4'>4</a></div><p >The template parameters are specified in the angle bracket enclosed list
that immediately follows the keyword
<span class='texttt'>template</span>.
For partial specializations, the template argument list is explicitly
written immediately following the class template name.
For primary templates, this list is implicitly described by the
template parameter list.
Specifically, the order of the template arguments is the sequence in
which they appear in the template parameter list.
[&nbsp;<i>Example:</i><span class='space'></span>
the template argument list for the primary template in the example
above is
<span class='texttt'>&lt;T1,</span>
<span class='texttt'>T2,</span>
<span class='texttt'>I&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
The template argument list shall not be specified in the primary template
declaration.
For example,</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2, I&gt;  { };    <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.spec-5'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-5'>5</a></div><p >A class template partial specialization may be declared or redeclared in any
namespace scope in which the corresponding primary template
may be defined (<a href='namespace.memdef'>[namespace.memdef]</a> and <a href='temp.mem'>[temp.mem]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct C {
    template&lt;class T2&gt; struct B { };
  };
};

<span class='comment'>// partial specialization of <span class='texttt'>A&lt;T&gt;::C::B&lt;T2&gt;</span>
</span>template&lt;class T&gt; template&lt;class T2&gt;
  struct A&lt;T&gt;::C::B&lt;T2*&gt; { };

A&lt;short&gt;::C::B&lt;int*&gt; absip;     <span class='comment'>// uses partial specialization
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec-6'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-6'>6</a></div><p >Partial specialization declarations themselves are not found by name lookup.
Rather, when the primary template name is used, any previously-declared partial
specializations of the primary template are also considered.
One consequence is
that a
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i>
which refers to a class template does not restrict the set of partial specializations
which may be found through the
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T1, class T2&gt; class A { };         <span class='comment'>// primary template
</span>}

using N::A;                             <span class='comment'>// refers to the primary template
</span>
namespace N {
  template&lt;class T&gt; class A&lt;T, T*&gt; { }; <span class='comment'>// partial specialization
</span>}

A&lt;int,int*&gt; a;                  <span class='comment'>// uses the partial specialization, which is found through
</span>                                <span class='comment'>// the using declaration which refers to the primary template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec-7'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-7'>7</a></div><p >A non-type argument is non-specialized if it is the name of a non-type
parameter.
All other non-type arguments are specialized.</p></div><div class='para' id='class.spec-8'><div class='marginalizedparent'><a class='marginalized' href='#class.spec-8'>8</a></div><p >Within the argument list of a class template partial specialization,
the following restrictions apply:</p><ul ><li ><p >The type of a template parameter corresponding to a specialized non-type argument
shall not be dependent on a parameter of the specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T, T t&gt; struct C {};
template &lt;class T&gt; struct C&lt;T, 1&gt;;                  <span class='comment'>// error
</span>
template&lt; int X, int (*array_ptr)[X] &gt; class A {};
int array[5];
template&lt; int X &gt; class A&lt;X,&amp;array&gt; { };            <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >The specialization shall be more specialized than the primary
template (<a href='temp.class.order'>[temp.class.order]</a>).</p></li><li ><p >The template parameter list of a specialization shall not contain default
template argument values.<a class='footnotenum' href='#footnote-138'>138</a>
</p></li><li ><p >An argument shall not contain an unexpanded parameter pack. If
an argument is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>), it shall be
the last argument in the template argument list.
</p></li></ul></div><div class='footnote' id='footnote-138'><div class='marginalizedparent'><a class='marginalized' href='#footnote-138'>138)</a></div><p >There is no way in which they could be used.</p></div><div id='class.spec.match'><h4 ><a class='secnum' href='#class.spec.match' style='min-width:118pt'>14.5.5.1</a> Matching of class template partial specializations <a class='abbr_ref' href='temp.class.spec.match'>[temp.class.spec.match]</a></h4><div class='para' id='class.spec.match-1'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.match-1'>1</a></div><p >When a class template is used in a context that requires an instantiation of
the class,
it is necessary to determine whether the instantiation is to be generated
using the primary template or one of the partial specializations.
This is done by matching the template arguments of the class template
specialization with the template argument lists of the partial
specializations.</p><ul ><li ><p >If exactly one matching specialization is found, the instantiation is
generated from that specialization.
</p></li><li ><p >If more than one matching specialization is found,
the partial order rules (<a href='temp.class.order'>[temp.class.order]</a>) are used to determine
whether one of the specializations is more specialized than the
others.
If none of the specializations is more specialized than all of the
other matching specializations, then the use of the class template
is ambiguous and the program is ill-formed.
</p></li><li ><p >If no matches are found, the instantiation is generated from the
primary template.
</p></li></ul></div><div class='para' id='class.spec.match-2'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.match-2'>2</a></div><p >A partial specialization matches a given actual template argument
list if the template arguments of the partial specialization can be
deduced from the actual template argument list (<a href='temp.deduct'>[temp.deduct]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A             { };    <span class='comment'>// #1
</span>template&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { };    <span class='comment'>// #2
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { };    <span class='comment'>// #3
</span>template&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { };    <span class='comment'>// #4
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { };    <span class='comment'>// #5
</span>
A&lt;int, int, 1&gt;   a1;            <span class='comment'>// uses #1
</span>A&lt;int, int*, 1&gt;  a2;            <span class='comment'>// uses #2, <span class='texttt'>T</span> is <span class='texttt'>int</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int, char*, 5&gt; a3;            <span class='comment'>// uses #4, <span class='texttt'>T</span> is <span class='texttt'>char</span>
</span>A&lt;int, char*, 1&gt; a4;            <span class='comment'>// uses #5, <span class='texttt'>T1</span> is <span class='texttt'>int</span>, <span class='texttt'>T2</span> is <span class='texttt'>char</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int*, int*, 2&gt; a5;            <span class='comment'>// ambiguous: matches #3 and #5
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec.match-3'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.match-3'>3</a></div><p >If the template arguments of a partial specialization cannot be deduced
because of the structure of its <i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
and the <i ><a href='temp.names#template-id'>template-id</a></i>,
the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;int I, int J&gt; struct A {};
template &lt;int I&gt; struct A&lt;I+5, I*2&gt; {};     <span class='comment'>// error
</span>
template &lt;int I&gt; struct A&lt;I, I&gt; {};         <span class='comment'>// OK
</span>
template &lt;int I, int J, int K&gt; struct B {};
template &lt;int I&gt; struct B&lt;I, I*2, 2&gt; {};    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec.match-4'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.match-4'>4</a></div><p >In a type name that refers to a class template specialization, (e.g.,
<span class='texttt'>A&lt;int, int, 1&gt;</span>)
the argument list shall match the template parameter list of the primary
template.
The template arguments of a specialization are deduced from the arguments
of the primary template.</p></div></div><div id='class.order'><h4 ><a class='secnum' href='#class.order' style='min-width:118pt'>14.5.5.2</a> Partial ordering of class template specializations <a class='abbr_ref' href='temp.class.order'>[temp.class.order]</a></h4><div class='para' id='class.order-1'><div class='marginalizedparent'><a class='marginalized' href='#class.order-1'>1</a></div><p ><span class='indexparent'><a class='index' id='more~specialized!class~template'></a></span>For two class template partial specializations,
the first is <i>more specialized</i> than the second if, given the following
rewrite to two function templates, the first function template is more
specialized than the second according to the ordering rules for function
templates (<a href='temp.func.order'>[temp.func.order]</a>):</p><ul ><li ><p >Each of the two
function templates has the same template parameters as
the corresponding partial specialization.
</p></li><li ><p >Each function template
has a single function parameter
whose type is a class template specialization where the template arguments
are the corresponding template parameters from the function template
for each template argument
in the <i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>
of the <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
of the partial specialization.
</p></li></ul></div><div class='para' id='class.order-2'><div class='marginalizedparent'><a class='marginalized' href='#class.order-2'>2</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;int I, int J, class T&gt; class X { };
template&lt;int I, int J&gt;          class X&lt;I, J, int&gt; { }; <span class='comment'>// #1
</span>template&lt;int I&gt;                 class X&lt;I, I, int&gt; { }; <span class='comment'>// #2
</span>
template&lt;int I0, int J0&gt; void f(X&lt;I0, J0, int&gt;);        <span class='comment'>// A
</span>template&lt;int I0&gt;         void f(X&lt;I0, I0, int&gt;);        <span class='comment'>// B
</span>
template &lt;auto v&gt;    class Y { };
template &lt;auto* p&gt;   class Y&lt;p&gt; { };                    <span class='comment'>// #3
</span>template &lt;auto** pp&gt; class Y&lt;pp&gt; { };                   <span class='comment'>// #4
</span>
template &lt;auto* p0&gt;   void g(Y&lt;p0&gt;);                    <span class='comment'>// C
</span>template &lt;auto** pp0&gt; void g(Y&lt;pp0&gt;);                   <span class='comment'>// D
</span></pre><p >According to the ordering rules for function templates,
the function template
<span class='texttt'>B</span>
is more specialized than the function template
<span class='texttt'>A</span>
and
the function template
<span class='texttt'>D</span>
is more specialized than the function template
<span class='texttt'>C</span>.
Therefore,
the partial specialization
<span class='texttt'>#2</span>
is more specialized than the partial specialization
<span class='texttt'>#1</span>
and
the partial specialization
<span class='texttt'>#4</span>
is more specialized than the partial specialization
<span class='texttt'>#3</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='class.spec.mfunc'><h4 ><a class='secnum' href='#class.spec.mfunc' style='min-width:118pt'>14.5.5.3</a> Members of class template specializations <a class='abbr_ref' href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a></h4><div class='para' id='class.spec.mfunc-1'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.mfunc-1'>1</a></div><p >The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.
A class template specialization is a distinct template.
The members of the class template partial specialization are
unrelated to the members of the primary template.
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class
template partial specialization.
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
<span class='comment'>// primary template
</span>template&lt;class T, int I&gt; struct A {
  void f();
};

template&lt;class T, int I&gt; void A&lt;T,I&gt;::f() { }

<span class='comment'>// class template partial specialization
</span>template&lt;class T&gt; struct A&lt;T,2&gt; {
  void f();
  void g();
  void h();
};

<span class='comment'>// member of class template partial specialization
</span>template&lt;class T&gt; void A&lt;T,2&gt;::g() { }

<span class='comment'>// explicit specialization
</span>template&lt;&gt; void A&lt;char,2&gt;::h() { }

int main() {
  A&lt;char,0&gt; a0;
  A&lt;char,2&gt; a2;
  a0.f();                       <span class='comment'>// OK, uses definition of primary template's member
</span>  a2.g();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// partial specialization's member
</span>  a2.h();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// explicit specialization's member
</span>  a2.f();                       <span class='comment'>// ill-formed, no definition of <span class='texttt'>f</span> for <span class='texttt'>A&lt;T,2&gt;</span>
</span>                                <span class='comment'>// the primary template is not used here
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.spec.mfunc-2'><div class='marginalizedparent'><a class='marginalized' href='#class.spec.mfunc-2'>2</a></div><p >If a member template of a class template is partially specialized,
the member template partial specializations are member templates of
the enclosing class template;
if the enclosing class template is instantiated (<a href='temp.inst'>[temp.inst]</a>, <a href='temp.explicit'>[temp.explicit]</a>),
a declaration for every member template partial specialization is also
instantiated as part of creating the members of the class template
specialization.
If the primary member template is explicitly specialized for a given
(implicit) specialization of the enclosing class template,
the partial specializations of the member template are ignored for this
specialization of the enclosing class template.
If a partial specialization of the member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are
still considered for this specialization of the enclosing class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  template&lt;class T2&gt; struct B {};                     <span class='comment'>// #1
</span>  template&lt;class T2&gt; struct B&lt;T2*&gt; {};                <span class='comment'>// #2
</span>};

template&lt;&gt; template&lt;class T2&gt; struct A&lt;short&gt;::B {};  <span class='comment'>// #3
</span>
A&lt;char&gt;::B&lt;int*&gt;  abcip;  <span class='comment'>// uses #2
</span>A&lt;short&gt;::B&lt;int*&gt; absip;  <span class='comment'>// uses #3
</span>A&lt;char&gt;::B&lt;int&gt;  abci;    <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='fct'><h3 ><a class='secnum' href='#fct' style='min-width:103pt'>14.5.6</a> Function templates <a class='abbr_ref' href='temp.fct'>[temp.fct]</a></h3><div class='para' id='fct-1'><div class='marginalizedparent'><a class='marginalized' href='#fct-1'>1</a></div><p >A function template defines an unbounded set of related functions.
[&nbsp;<i>Example:</i><span class='space'></span>
a family of sort functions might be declared like this:</p><pre class='codeblock'>
template&lt;class T&gt; class Array { };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='fct-2'><div class='marginalizedparent'><a class='marginalized' href='#fct-2'>2</a></div><p >A function template can be overloaded with other function templates
and with non-template functions (<a href='dcl.fct'>[dcl.fct]</a>).
A non-template function is not
related to a function template
(i.e., it is never considered to be a specialization),
even if it has the same name and type
as a potentially generated function template specialization.<a class='footnotenum' href='#footnote-139'>139</a></p></div><div class='footnote' id='footnote-139'><div class='marginalizedparent'><a class='marginalized' href='#footnote-139'>139)</a></div><p >That is,
declarations of non-template functions do not merely guide
overload resolution of
function template specializations
with the same name.
If such a non-template function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in a program, it must be defined;
it will not be implicitly instantiated using the function template definition.</p></div><div id='over.link'><h4 ><a class='secnum' href='#over.link' style='min-width:118pt'>14.5.6.1</a> Function template overloading <a class='abbr_ref' href='temp.over.link'>[temp.over.link]</a></h4><div class='para' id='over.link-1'><div class='marginalizedparent'><a class='marginalized' href='#over.link-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading'></a></span>It is possible to overload function templates so that two different
function template specializations have the same type.
[&nbsp;<i>Example:</i><span class='space'></span></p><div class='minipage'><pre class='codeblock'>
<span class='comment'>// file1.c
</span>template&lt;class T&gt;
  void f(T*);
void g(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int*)</span>
</span>}
</pre></div><div class='minipage'><pre class='codeblock'>
<span class='comment'>// file2.c
</span>template&lt;class T&gt;
  void f(T);
void h(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int*&gt;(int*)</span>
</span>}
</pre></div><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='over.link-2'><div class='marginalizedparent'><a class='marginalized' href='#over.link-2'>2</a></div><p >Such specializations are distinct functions and do not violate the one-definition
rule (<a href='basic.def.odr'>[basic.def.odr]</a>).</p></div><div class='para' id='over.link-3'><div class='marginalizedparent'><a class='marginalized' href='#over.link-3'>3</a></div><p >The signature of a function template
is defined in <a href='intro.defs'>[intro.defs]</a>.
The names of the template parameters are significant only for establishing
the relationship between the template parameters and the rest of the
signature.
[&nbsp;<i>Note:</i><span class='space'></span>
Two distinct function templates may have identical function return types and
function parameter lists, even if overload resolution alone cannot distinguish
them.</p><pre class='codeblock'>
template&lt;class T&gt; void f();
template&lt;int I&gt; void f();       <span class='comment'>// OK: overloads the first template
</span>                                <span class='comment'>// distinguishable with an explicit template argument list
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='over.link-4'><div class='marginalizedparent'><a class='marginalized' href='#over.link-4'>4</a></div><p >When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template.
This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;int I, int J&gt; A&lt;I+J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// #1
</span>template &lt;int K, int L&gt; A&lt;K+L&gt; f(A&lt;K&gt;, A&lt;L&gt;);   <span class='comment'>// same as #1
</span>template &lt;int I, int J&gt; A&lt;I-J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// different from #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Most expressions that use template parameters use non-type template
parameters, but it is possible for an expression to reference a type
parameter.
For example, a template type parameter can be used in the
<span class='texttt'>sizeof</span> operator.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='over.link-5'><div class='marginalizedparent'><a class='marginalized' href='#over.link-5'>5</a></div><p >Two expressions involving template parameters are considered
<i>equivalent</i>
if two function definitions containing the expressions would satisfy
the one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>), except that the tokens used
to name the template parameters may differ as long as a token used to
name a template parameter in one expression is replaced by another token
that names the same template parameter in the other expression. For
determining whether two dependent names (<a href='temp.dep'>[temp.dep]</a>) are
equivalent, only the name itself is considered, not the result of name
lookup in the context of the template. If multiple declarations of the
same function template differ in the result of this name lookup, the
result for the first declaration is used.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;int I, int J&gt; void f(A&lt;I+J&gt;);         <span class='comment'>// #1
</span>template &lt;int K, int L&gt; void f(A&lt;K+L&gt;);         <span class='comment'>// same as #1
</span>
template &lt;class T&gt; decltype(g(T())) h();
int g(int);
template &lt;class T&gt; decltype(g(T())) h()         <span class='comment'>// redeclaration of <span class='texttt'>h()</span> uses the earlier lookup
</span>  { return g(T()); }                            <span class='comment'>// ...although the lookup here does find <span class='texttt'>g(int)</span>
</span>int i = h&lt;int&gt;();                               <span class='comment'>// template argument substitution fails; <span class='texttt'>g(int)</span>
</span>                                                <span class='comment'>// was not in scope at the first declaration of <span class='texttt'>h()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
Two expressions involving template parameters that are not equivalent are
<i>functionally equivalent</i>
if, for any given set of template arguments, the evaluation of the
expression results in the same value.</p></div><div class='para' id='over.link-6'><div class='marginalizedparent'><a class='marginalized' href='#over.link-6'>6</a></div><p >Two function templates are
<i>equivalent</i>
if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter
lists that are equivalent using the rules described above to compare
expressions involving
template parameters.
Two function templates are
<i>functionally equivalent</i>
if they are equivalent except that one or more
expressions
that involve template parameters in the return types and parameter
lists are functionally equivalent using the rules described above to
compare expressions involving
template parameters.
If a program contains declarations of function templates that are
functionally equivalent but not equivalent, the program is ill-formed;
no diagnostic is required.</p></div><div class='para' id='over.link-7'><div class='marginalizedparent'><a class='marginalized' href='#over.link-7'>7</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
This rule guarantees that equivalent declarations will be linked with
one another, while not requiring implementations to use heroic efforts
to guarantee that functionally equivalent declarations will be treated
as distinct.
For example, the last two declarations are functionally
equivalent and would cause a program to be ill-formed:</p><pre class='codeblock'>
<span class='comment'>// Guaranteed to be the same
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);

<span class='comment'>// Guaranteed to be different
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+11&gt;);

<span class='comment'>// Ill-formed, no diagnostic required
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='func.order'><h4 ><a class='secnum' href='#func.order' style='min-width:118pt'>14.5.6.2</a> Partial ordering of function templates <a class='abbr_ref' href='temp.func.order'>[temp.func.order]</a></h4><div class='para' id='func.order-1'><div class='marginalizedparent'><a class='marginalized' href='#func.order-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading!resolution!template'></a></span><span class='indexparent'><a class='index' id='ordering!function template partial'></a></span>If a function template is overloaded,
the use of a function template specialization might be ambiguous because
template argument deduction (<a href='temp.deduct'>[temp.deduct]</a>) may associate the function
template specialization with more than one function template declaration.
<i>Partial ordering</i>
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:</p><ul ><li ><p >during overload resolution for a call to a function template specialization (<a href='over.match.best'>[over.match.best]</a>);
</p></li><li ><p >when the address of a function template specialization is taken;
</p></li><li ><p >when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>);
</p></li><li ><p >when a friend function declaration (<a href='temp.friend'>[temp.friend]</a>), an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) refers to
a function template specialization.
</p></li></ul></div><div class='para' id='func.order-2'><div class='marginalizedparent'><a class='marginalized' href='#func.order-2'>2</a></div><p >Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type.
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.</p></div><div class='para' id='func.order-3'><div class='marginalizedparent'><a class='marginalized' href='#func.order-3'>3</a></div><p >To produce the transformed template, for each type, non-type, or template
template parameter (including template parameter packs (<a href='temp.variadic'>[temp.variadic]</a>)
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template.
[&nbsp;<i>Note:</i><span class='space'></span>
The type replacing the placeholder
in the type of the value synthesized for a non-type template parameter
is also a unique synthesized type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If only one of the function templates <i>M</i> is a non-static
member of some class <i>A</i>, <i>M</i> is considered to have
a new first parameter inserted in its function
parameter list. Given <i>cv</i> as the cv-qualifiers of <i>M</i>
(if any), the new parameter is of type “rvalue reference to
<i>cv</i> <i>A</i>” if the optional <i ><a href='dcl.decl#ref-qualifier'>ref-qualifier</a></i> of
<i>M</i> is <span class='texttt'>&amp;&amp;</span> or if <i>M</i> has no
<i ><a href='dcl.decl#ref-qualifier'>ref-qualifier</a></i> and the first parameter of the other
template has rvalue reference type. Otherwise, the new parameter is
of type “lvalue reference to <i>cv</i> <i>A</i>”.
[&nbsp;<i>Note:</i><span class='space'></span> This allows a non-static
member to be ordered with respect to a nonmember function and for the results
to be equivalent to the ordering of two equivalent nonmembers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { };
template&lt;class T&gt; struct B {
  template&lt;class R&gt; int operator*(R&amp;);              <span class='comment'>// #1
</span>};

template&lt;class T, class R&gt; int operator*(T&amp;, R&amp;);   <span class='comment'>// #2
</span>
<span class='comment'>// The declaration of <span class='texttt'>B::operator*</span> is transformed into the equivalent of
</span><span class='comment'>// <span class='texttt'>template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;// #1a
</span>
int main() {
  A a;
  B&lt;A&gt; b;
  b * a;                                            <span class='comment'>// calls #1a
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='func.order-4'><div class='marginalizedparent'><a class='marginalized' href='#func.order-4'>4</a></div><p >Using the transformed function template's function type,
perform type deduction against the other template as described in <a href='temp.deduct.partial'>[temp.deduct.partial]</a>.</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A { A(); };

template&lt;class T&gt; void f(T);
template&lt;class T&gt; void f(T*);
template&lt;class T&gt; void f(const T*);

template&lt;class T&gt; void g(T);
template&lt;class T&gt; void g(T&amp;);

template&lt;class T&gt; void h(const T&amp;);
template&lt;class T&gt; void h(A&lt;T&gt;&amp;);

void m() {
  const int* p;
  f(p);             <span class='comment'>// <span class='texttt'>f(const T*)</span> is more specialized than <span class='texttt'>f(T)</span> or <span class='texttt'>f(T*)</span>
</span>  float x;
  g(x);             <span class='comment'>// Ambiguous: <span class='texttt'>g(T)</span> or <span class='texttt'>g(T&amp;)</span>
</span>  A&lt;int&gt; z;
  h(z);             <span class='comment'>// overload resolution selects <span class='texttt'>h(A&lt;T&gt;&amp;)</span>
</span>  const A&lt;int&gt; z2;
  h(z2);            <span class='comment'>// <span class='texttt'>h(const T&amp;)</span> is called because <span class='texttt'>h(A&lt;T&gt;&amp;)</span> is not callable
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='func.order-5'><div class='marginalizedparent'><a class='marginalized' href='#func.order-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Since partial ordering in a call context considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);            <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T*, int=1);    <span class='comment'>// #2
</span>template&lt;class T&gt; void g(T);            <span class='comment'>// #3
</span>template&lt;class T&gt; void g(T*, ...);      <span class='comment'>// #4
</span>
</pre><pre class='codeblock'>
int main() {
  int* ip;
  f(ip);            <span class='comment'>// calls #2
</span>  g(ip);            <span class='comment'>// calls #4
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class U&gt; struct A { };

template&lt;class T, class U&gt; void f(U, A&lt;U, T&gt;* p = 0); <span class='comment'>// #1
</span>template&lt;         class U&gt; void f(U, A&lt;U, U&gt;* p = 0); <span class='comment'>// #2
</span>template&lt;class T         &gt; void g(T, T = T());        <span class='comment'>// #3
</span>template&lt;class T, class... U&gt; void g(T, U ...);       <span class='comment'>// #4
</span>
void h() {
  f&lt;int&gt;(42, (A&lt;int, int&gt;*)0);                        <span class='comment'>// calls #2
</span>  f&lt;int&gt;(42);                                         <span class='comment'>// error: ambiguous
</span>  g(42);                                              <span class='comment'>// error: ambiguous
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T, U...);        <span class='comment'>// #1
</span>template&lt;class T            &gt; void f(T);              <span class='comment'>// #2
</span>template&lt;class T, class... U&gt; void g(T*, U...);       <span class='comment'>// #3
</span>template&lt;class T            &gt; void g(T);              <span class='comment'>// #4
</span>
void h(int i) {
  f(&amp;i);                                              <span class='comment'>// error: ambiguous
</span>  g(&amp;i);                                              <span class='comment'>// OK: calls #3
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='alias'><h3 ><a class='secnum' href='#alias' style='min-width:103pt'>14.5.7</a> Alias templates <a class='abbr_ref' href='temp.alias'>[temp.alias]</a></h3><div class='para' id='alias-1'><div class='marginalizedparent'><a class='marginalized' href='#alias-1'>1</a></div><p >A <i ><a href='temp#template-declaration'>template-declaration</a></i> in which the <i ><a href='dcl.dcl#declaration'>declaration</a></i> is an
<i ><a href='dcl.dcl#alias-declaration'>alias-declaration</a></i> (Clause <a href='dcl.dcl'>[dcl.dcl]</a>) declares the
<i ><a href='lex.name#identifier'>identifier</a></i> to be a <a id='alias template'><i>alias template</i></a>.
An alias template is a name for a family of
types. The name of the alias template is a <i ><a href='temp.names#template-name'>template-name</a></i>.</p></div><div class='para' id='alias-2'><div class='marginalizedparent'><a class='marginalized' href='#alias-2'>2</a></div><p >When a <i ><a href='temp.names#template-id'>template-id</a></i> refers to the specialization of
an alias template, it is equivalent to the associated type obtained by
substitution of its <i ><a href='temp.names#template-argument'>template-arguments</a></i> for the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i> in the <i ><a href='dcl.name#type-id'>type-id</a></i> of
the alias template.
[&nbsp;<i>Note:</i><span class='space'></span> An alias template name is never deduced.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct Alloc { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; using Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;
Vec&lt;int&gt; v;         <span class='comment'>// same as <span class='texttt'>vector&lt;int, Alloc&lt;int&gt;&gt; v;</span>
</span>
template&lt;class T&gt;
  void process(Vec&lt;T&gt;&amp; v)
  { <span class='comment'>/* ... */</span> }

template&lt;class T&gt;
  void process(vector&lt;T, Alloc&lt;T&gt;&gt;&amp; w)
  { <span class='comment'>/* ... */</span> }     <span class='comment'>// error: redefinition
</span>
template&lt;template&lt;class&gt; class TT&gt;
  void f(TT&lt;int&gt;);

f(v);               <span class='comment'>// error: <span class='texttt'>Vec</span> not deduced
</span>
template&lt;template&lt;class,class&gt; class TT&gt;
  void g(TT&lt;int, Alloc&lt;int&gt;&gt;);
g(v);               <span class='comment'>// OK: <span class='texttt'>TT</span> = <span class='texttt'>vector</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='alias-3'><div class='marginalizedparent'><a class='marginalized' href='#alias-3'>3</a></div><p >However, if the <i ><a href='temp.names#template-id'>template-id</a></i> is dependent, subsequent template
argument substitution still applies to the <i ><a href='temp.names#template-id'>template-id</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename...&gt; using void_t = void;
template&lt;typename T&gt; void_t&lt;typename T::foo&gt; f();
f&lt;int&gt;(); <span class='comment'>// error, <span class='texttt'>int</span> does not have a nested type <span class='texttt'>foo</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='alias-4'><div class='marginalizedparent'><a class='marginalized' href='#alias-4'>4</a></div><p >The <i ><a href='dcl.name#type-id'>type-id</a></i> in an alias template declaration shall not refer to
the alias template being declared. The type produced by an alias template
specialization shall not directly or indirectly make use of that specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct A;
template &lt;class T&gt; using B = typename A&lt;T&gt;::U;
template &lt;class T&gt; struct A {
  typedef B&lt;T&gt; U;
};
B&lt;short&gt; b;         <span class='comment'>// error: instantiation of <span class='texttt'>B&lt;short&gt;</span> uses own type via <span class='texttt'>A&lt;short&gt;::U</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='res'><h2 ><a class='secnum' href='#res' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref' href='temp.res'>[temp.res]</a></h2><div class='para' id='res-1'><div class='marginalizedparent'><a class='marginalized' href='#res-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading!resolution!template name'></a></span><span class='indexparent'><a class='index' id='lookup!template name'></a></span>Three kinds of names can be used within a template definition:</p><ul ><li ><p >The name of the template itself,
and names declared within the template itself.
</p></li><li ><p >Names dependent on a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i> (<a href='temp.dep'>[temp.dep]</a>).
</p></li><li ><p >Names from scopes which are visible within the template definition.
</p></li></ul></div><div class='para' id='res-2'><div class='marginalizedparent'><a class='marginalized' href='#res-2'>2</a></div><p >A name used in a template declaration or definition and that is
dependent on a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is assumed not to name a type unless
the applicable name lookup finds a type name or the name
is qualified by the keyword
<span class='texttt'>typename</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
<span class='comment'>// no <span class='texttt'>B</span> declared here
</span>
class X;

template&lt;class T&gt; class Y {
  class Z;                      <span class='comment'>// forward declaration of member class
</span>
  void f() {
    X* a1;                      <span class='comment'>// declare pointer to <span class='texttt'>X</span>
</span>    T* a2;                      <span class='comment'>// declare pointer to <span class='texttt'>T</span>
</span>    Y* a3;                      <span class='comment'>// declare pointer to <span class='texttt'>Y&lt;T&gt;</span>
</span>    Z* a4;                      <span class='comment'>// declare pointer to <span class='texttt'>Z</span>
</span>    typedef typename T::A TA;
    TA* a5;                     <span class='comment'>// declare pointer to <span class='texttt'>T</span>'s <span class='texttt'>A</span>
</span>    typename T::A* a6;          <span class='comment'>// declare pointer to <span class='texttt'>T</span>'s <span class='texttt'>A</span>
</span>    T::A* a7;                   <span class='comment'>// <span class='texttt'>T::A</span> is not a type name:
</span>                                <span class='comment'>// multiply <span class='texttt'>T::A</span> by <span class='texttt'>a7</span>; ill-formed,
</span>                                <span class='comment'>// no visible declaration of <span class='texttt'>a7</span>
</span>    B* a8;                      <span class='comment'>// <span class='texttt'>B</span> is not a type name:
</span>                                <span class='comment'>// multiply <span class='texttt'>B</span> by <span class='texttt'>a8</span>; ill-formed,
</span>                                <span class='comment'>// no visible declarations of <span class='texttt'>B</span> and <span class='texttt'>a8</span>
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-3'><div class='marginalizedparent'><a class='marginalized' href='#res-3'>3</a></div><p >When a <span class='small'></span><span class='rmfamily'></span><i> qualified-id</i> is intended to refer to a type
that is not a member of the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>)
and its <span class='small'></span><span class='rmfamily'></span><i> nested-name-specifier</i>
refers to a dependent type,
it shall be
prefixed by the keyword <span class='texttt'>typename</span>, forming a
<span class='small'></span><span class='rmfamily'></span><i> typename-specifier</i>.
If the <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> in a <i ><a href='temp.res#typename-specifier'>typename-specifier</a></i>
does not denote a type
or a class template,
the program is ill-formed.</p><pre class='bnf'><a id='typename-specifier'>typename-specifier:</a>
  <span class='terminal'>typename</span> <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#identifier'>identifier</a></i>
  <span class='terminal'>typename</span> <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i></pre></div><div class='para' id='res-4'><div class='marginalizedparent'><a class='marginalized' href='#res-4'>4</a></div><p >If a specialization of a template is instantiated for a set of
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
such that the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
prefixed by
<span class='texttt'>typename</span>
does not denote a type
or a class template,
the specialization is ill-formed.
The usual qualified name lookup (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>) is used to find the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
even in the presence of
<span class='texttt'>typename</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct X { };
  int X;
};
struct B {
  struct X { };
};
template&lt;class T&gt; void f(T t) {
  typename T::X x;
}
void foo() {
  A a;
  B b;
  f(b);             <span class='comment'>// OK: <span class='texttt'>T::X</span> refers to <span class='texttt'>B::X</span>
</span>  f(a);             <span class='comment'>// error: <span class='texttt'>T::X</span> refers to the data member <span class='texttt'>A::X</span> not the struct <span class='texttt'>A::X</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-5'><div class='marginalizedparent'><a class='marginalized' href='#res-5'>5</a></div><p >A qualified name used as the name in a
<i ><a href='class.base.init#mem-initializer-id'>mem-initializer-id</a></i>,
a
<i ><a href='class.derived#base-specifier'>base-specifier</a></i>,
or an
<i ><a href='dcl.type.elab#elaborated-type-specifier'>elaborated-type-specifier</a></i>
is implicitly assumed to name a type, without the use of the
<span class='texttt'>typename</span>
keyword.
In a <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> that immediately contains a <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
that depends on a template parameter, the <i ><a href='lex.name#identifier'>identifier</a></i> or <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
is implicitly assumed to name a type, without the use of the <span class='texttt'>typename</span> keyword.
[&nbsp;<i>Note:</i><span class='space'></span>
The
<span class='texttt'>typename</span>
keyword is not permitted by the syntax of these constructs.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='res-6'><div class='marginalizedparent'><a class='marginalized' href='#res-6'>6</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated
that refers to a <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
that denotes a type
or a class template,
and the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> refers to a member of an unknown specialization,
the <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> shall either be
prefixed by <span class='texttt'>typename</span> or shall be used in a context in which it
implicitly names a type as described above. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; void f(int i) {
  T::x * i;         <span class='comment'>// <span class='texttt'>T::x</span> must not be a type
</span>}

struct Foo {
  typedef int x;
};

struct Bar {
  static int const x = 5;
};

int main() {
  f&lt;Bar&gt;(1);        <span class='comment'>// OK
</span>  f&lt;Foo&gt;(1);        <span class='comment'>// error: <span class='texttt'>Foo::x</span> is a type
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-7'><div class='marginalizedparent'><a class='marginalized' href='#res-7'>7</a></div><p >Within the definition of a class template or within the definition of a
member of a class template following the <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i>, the keyword
<span class='texttt'>typename</span>
is not required when referring to the name of a previously
declared member of the class template that declares a type
or a class template.
[&nbsp;<i>Note:</i><span class='space'></span> such names can be found using unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>),
class member lookup (<a href='class.qual'>[class.qual]</a>) into the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>),
or class member access expression lookup (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>) when the
type of the object expression is the current instantiation (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  typedef int B;
  B b;              <span class='comment'>// OK, no typename required
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-8'><div class='marginalizedparent'><a class='marginalized' href='#res-8'>8</a></div><p ><span class='indexparent'><a class='index' id='checking!syntax'></a></span><span class='indexparent'><a class='index' id='checking!point~of error'></a></span>Knowing which names are type names allows the syntax of every template
to be checked.
The program is ill-formed, no diagnostic required, if:</p><ul ><li ><p >no valid specialization can be generated for a template
or a substatement of a constexpr if statement (<a href='stmt.if'>[stmt.if]</a>) within a template
and the template is not instantiated, or
</p></li><li ><p >every valid specialization of a variadic template requires an empty template
parameter pack, or
</p></li><li ><p >a hypothetical instantiation of a template
immediately following its definition
would be ill-formed
due to a construct that does not depend on a template parameter, or
</p></li><li ><p >the interpretation of such a construct
in the hypothetical instantiation
is different from
the interpretation of the corresponding construct
in any actual instantiation of the template.
[&nbsp;<i>Note:</i><span class='space'></span>
This can happen in situations including the following:
</p><ul ><li ><p >a type used in a non-dependent name is incomplete at the point at which a
template is defined but is complete at the point at which an instantiation is
performed, or</p></li><li ><p >an instantiation uses a default argument or default template argument
that had not been defined at the point at which the template was defined, or</p></li><li ><p >constant expression evaluation (<a href='expr.const'>[expr.const]</a>) within the template
instantiation uses
  </p><ul ><li ><p >the value of a <span class='texttt'>const</span> object of integral or unscoped enumeration type or
  </p></li><li ><p >the value of a <span class='texttt'>constexpr</span> object or
  </p></li><li ><p >the value of a reference or
  </p></li><li ><p >the definition of a <span class='texttt'>constexpr</span> function,
  </p></li></ul><p >and that entity was not defined when the template was defined, or</p></li><li ><p >a class template specialization or variable template specialization that
is specified by a non-dependent <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i> is used by
the template, and either it is instantiated from a partial specialization that
was not defined when the template was defined or it names an explicit
specialization that was not declared when the template was defined.
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >Otherwise, no diagnostic shall be issued for a template
for which a valid specialization can be generated.
[&nbsp;<i>Note:</i><span class='space'></span>
If a template is instantiated, errors will be diagnosed according
to the other rules in this Standard.
Exactly when these errors are diagnosed is a quality of implementation issue.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int j;
template&lt;class T&gt; class X {
  void f(T t, int i, char* p) {
    t = i;          <span class='comment'>// diagnosed if <span class='texttt'>X::f</span> is instantiated
</span>                    <span class='comment'>// and the assignment to <span class='texttt'>t</span> is an error
</span>    p = i;          <span class='comment'>// may be diagnosed even if <span class='texttt'>X::f</span> is
</span>                    <span class='comment'>// not instantiated
</span>    p = j;          <span class='comment'>// may be diagnosed even if <span class='texttt'>X::f</span> is
</span>                    <span class='comment'>// not instantiated
</span>  }
  void g(T t) {
    +;              <span class='comment'>// may be diagnosed even if <span class='texttt'>X::g</span> is
</span>                    <span class='comment'>// not instantiated
</span>  }
};

template&lt;class... T&gt; struct A {
  void operator++(int, T... t);                 <span class='comment'>// error: too many parameters
</span>};
template&lt;class... T&gt; union X : T... { };        <span class='comment'>// error: union with base class
</span>template&lt;class... T&gt; struct A : T...,  T... { };<span class='comment'>// error: duplicate base class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-9'><div class='marginalizedparent'><a class='marginalized' href='#res-9'>9</a></div><p >When looking for the declaration of a name used in a template definition,
the usual lookup rules (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)
are used for non-dependent names.
The lookup of names dependent on the template parameters
is postponed until the actual template argument is known (<a href='temp.dep'>[temp.dep]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt; class Set {
  T* p;
  int cnt;
public:
  Set();
  Set&lt;T&gt;(const Set&lt;T&gt;&amp;);
  void printall() {
    for (int i = 0; i&lt;cnt; i++)
      cout &lt;&lt; p[i] &lt;&lt; '\n';
  }
};
</pre><p >in the example,
<span class='texttt'>i</span>
is the local variable
<span class='texttt'>i</span>
declared in
<span class='texttt'>printall</span>,
<span class='texttt'>cnt</span>
is the member
<span class='texttt'>cnt</span>
declared in
<span class='texttt'>Set</span>,
and
<span class='texttt'>cout</span>
is the standard output stream declared in
<span class='texttt'>iostream</span>.
However, not every declaration can be found this way; the resolution of
some names must be postponed
until the actual
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
are known.
For example, even though the name
<span class='texttt'>operator&lt;&lt;</span>
is known within the definition of
<span class='texttt'>printall()</span>
and a declaration of it can be found in
<span class='texttt'>&lt;iostream&gt;</span>,
the actual declaration of
<span class='texttt'>operator&lt;&lt;</span>
needed to print
<span class='texttt'>p[i]</span>
cannot be known until it is known what type
<span class='texttt'>T</span>
is (<a href='temp.dep'>[temp.dep]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-10'><div class='marginalizedparent'><a class='marginalized' href='#res-10'>10</a></div><p >If a name does not depend on a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
(as defined in <a href='temp.dep'>[temp.dep]</a>), a declaration (or set of declarations) for that
name shall be in scope at the point where the name appears in the template
definition; the name is bound to the declaration (or declarations) found
at that point and this binding is not affected by declarations that are
visible at the point of instantiation.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f(char);

template&lt;class T&gt; void g(T t) {
  f(1);             <span class='comment'>// <span class='texttt'>f(char)</span>
</span>  f(T(1));          <span class='comment'>// dependent
</span>  f(t);             <span class='comment'>// dependent
</span>  dd++;             <span class='comment'>// not dependent
</span>                    <span class='comment'>// error: declaration for dd not found
</span>}

enum E { e };
void f(E);

double dd;
void h() {
  g(e);             <span class='comment'>// will cause one call of <span class='texttt'>f(char)</span> followed
</span>                    <span class='comment'>// by two calls of <span class='texttt'>f(E)</span>
</span>  g('a');           <span class='comment'>// will cause three calls of <span class='texttt'>f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='res-11'><div class='marginalizedparent'><a class='marginalized' href='#res-11'>11</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For purposes of name lookup, default arguments and
<i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of function templates and default
arguments and <i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of
member functions of class templates are considered definitions (<a href='temp.decls'>[temp.decls]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='local'><h3 ><a class='secnum' href='#local' style='min-width:103pt'>14.6.1</a> Locally declared names <a class='abbr_ref' href='temp.local'>[temp.local]</a></h3><div class='para' id='local-1'><div class='marginalizedparent'><a class='marginalized' href='#local-1'>1</a></div><p >Like normal (non-template) classes, class templates have an
injected-class-name (Clause <a href='class'>[class]</a>).
The
injected-class-name can be used
as a <i ><a href='temp.names#template-name'>template-name</a></i> or a <i ><a href='dcl.type.simple#type-name'>type-name</a></i>.
When it is used with a
<i ><a href='temp.names#template-argument-list'>template-argument-list</a></i>,
as a <i ><a href='temp.names#template-argument'>template-argument</a></i> for a template <i ><a href='temp.param#template-parameter'>template-parameter</a></i>,
or as the final identifier in the <i ><a href='dcl.type.elab#elaborated-type-specifier'>elaborated-type-specifier</a></i> of
a friend class template declaration,
it refers to the
class template itself. Otherwise, it is equivalent to the <i ><a href='temp.names#template-name'>template-name</a></i>
followed by the <i ><a href='temp.param#template-parameter'>template-parameters</a></i> of the class template
enclosed in <span class='texttt'>&lt;&gt;</span>.</p></div><div class='para' id='local-2'><div class='marginalizedparent'><a class='marginalized' href='#local-2'>2</a></div><p >Within the scope of a class template specialization or
partial specialization, when the injected-class-name is
used as a <i ><a href='dcl.type.simple#type-name'>type-name</a></i>,
it is equivalent to the <i ><a href='temp.names#template-name'>template-name</a></i> followed by the
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
of the class template specialization or partial
specialization enclosed in
<span class='texttt'>&lt;&gt;</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;template&lt;class&gt; class T&gt; class A { };
template&lt;class T&gt; class Y;
template&lt;&gt; class Y&lt;int&gt; {
  Y* p;                               <span class='comment'>// meaning <span class='texttt'>Y&lt;int&gt;</span>
</span>  Y&lt;char&gt;* q;                         <span class='comment'>// meaning <span class='texttt'>Y&lt;char&gt;</span>
</span>  A&lt;Y&gt;* a;                            <span class='comment'>// meaning <span class='texttt'>A&lt;::Y&gt;</span>
</span>  class B {
    template&lt;class&gt; friend class Y;   <span class='comment'>// meaning <span class='texttt'>::Y</span>
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-3'><div class='marginalizedparent'><a class='marginalized' href='#local-3'>3</a></div><p >The injected-class-name of a class template or class
template specialization can be used either
as a <i ><a href='temp.names#template-name'>template-name</a></i> or a <i ><a href='dcl.type.simple#type-name'>type-name</a></i>
wherever it is in scope.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct Base {
  Base* p;
};

template &lt;class T&gt; struct Derived: public Base&lt;T&gt; {
  typename Derived::Base* p;    <span class='comment'>// meaning <span class='texttt'>Derived::Base&lt;T&gt;</span>
</span>};

template&lt;class T, template&lt;class&gt; class U = T::template Base&gt; struct Third { };
Third&lt;Base&lt;int&gt; &gt; t;            <span class='comment'>// OK: default argument uses injected-class-name as a template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-4'><div class='marginalizedparent'><a class='marginalized' href='#local-4'>4</a></div><p >A lookup that finds an injected-class-name (<a href='class.member.lookup'>[class.member.lookup]</a>) can result in an ambiguity in
certain cases (for example, if it is found in more than one
base class).
If all of the injected-class-names that are
found refer to specializations of the same class template,
and if the name
is used as a <i ><a href='temp.names#template-name'>template-name</a></i>,
the reference refers to the class template itself and not a
specialization thereof, and is not ambiguous.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct Base { };
template &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; {
  typename Derived::Base b;             <span class='comment'>// error: ambiguous
</span>  typename Derived::Base&lt;double&gt; d;     <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-5'><div class='marginalizedparent'><a class='marginalized' href='#local-5'>5</a></div><p >When the normal name of the template (i.e., the name from
the enclosing scope, not the injected-class-name) is
used,
it always refers to the class template itself and not a
specialization of the template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  X* p;             <span class='comment'>// meaning <span class='texttt'>X&lt;T&gt;</span>
</span>  X&lt;T&gt;* p2;
  X&lt;int&gt;* p3;
  ::X* p4;          <span class='comment'>// error: missing template argument list
</span>                    <span class='comment'>// <span class='texttt'>::X</span> does not refer to the injected-class-name
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-6'><div class='marginalizedparent'><a class='marginalized' href='#local-6'>6</a></div><p >A
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall not be redeclared within its scope (including nested scopes).
A
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
shall not have the same name as the template name.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T, int i&gt; class Y {
  int T;            <span class='comment'>// error: template-parameter redeclared
</span>  void f() {
    char T;         <span class='comment'>// error: template-parameter redeclared
</span>  }
};

template&lt;class X&gt; class X;      <span class='comment'>// error: template-parameter redeclared
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-7'><div class='marginalizedparent'><a class='marginalized' href='#local-7'>7</a></div><p >In the definition of a member of
a class template that appears outside of the class template definition,
the name of a member of the class template hides the name of a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
of any enclosing class templates (but not a <i ><a href='temp.param#template-parameter'>template-parameter</a></i> of the
member if the member is a class or function template).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B <span class='texttt'>{ /* ... */ };</span>
  typedef void C;
  void f();
  template&lt;class U&gt; void g(U);
};

template&lt;class B&gt; void A&lt;B&gt;::f() {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>, not the template parameter
</span>}

template&lt;class B&gt; template&lt;class C&gt; void A&lt;B&gt;::g(C) {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>, not the template parameter
</span>  C c;              <span class='comment'>// the template parameter <span class='texttt'>C</span>, not <span class='texttt'>A</span>'s <span class='texttt'>C</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-8'><div class='marginalizedparent'><a class='marginalized' href='#local-8'>8</a></div><p >In the definition of a member of a class template that appears outside of the
namespace containing the class template definition,
the name of a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
hides the name of a member of this namespace.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  class C { };
  template&lt;class T&gt; class B {
    void f(T);
  };
}
template&lt;class C&gt; void N::B&lt;C&gt;::f(C) {
  C b;              <span class='comment'>// <span class='texttt'>C</span> is the template parameter, not <span class='texttt'>N::C</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-9'><div class='marginalizedparent'><a class='marginalized' href='#local-9'>9</a></div><p >In the definition of a class template or in the definition of a member of such
a template that appears outside of the template definition,
for each non-dependent base class (<a href='temp.dep.type'>[temp.dep.type]</a>),
if the name of the base class
or the name of a member of the
base class is the same as the name of a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>,
the base class name or member name hides the
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
name (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct B { <span class='comment'>/* ... */</span> };
  int a;
  int Y;
};

template&lt;class B, class a&gt; struct X : A {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>
</span>  a b;              <span class='comment'>// error: <span class='texttt'>A</span>'s <span class='texttt'>a</span> isn't a type name
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dep'><h3 ><a class='secnum' href='#dep' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref' href='temp.dep'>[temp.dep]</a></h3><div class='para' id='dep-1'><div class='marginalizedparent'><a class='marginalized' href='#dep-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name!dependent'></a></span>Inside a template, some constructs have semantics which may differ from one
instantiation to another.
Such a construct
<i>depends</i>
on the template parameters.
In particular, types and expressions may depend on the type
and/or
value of
template parameters (as determined by the template arguments) and this determines
the context for name lookup for certain names.
An expressions may be
<span class='grammarterm'>type-dependent</span>
(that is, its type may depend on a template parameter) or
<span class='grammarterm'>value-dependent</span>
(that is, its value when evaluated as a constant expression (<a href='expr.const'>[expr.const]</a>)
may depend on a template parameter)
as described in this subclause.
In an expression of the form:</p><pre class='bnf'><i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><p >where the
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i>
is an
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>,
the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
denotes a
<span class='indexparent'><a class='index' id='name!dependent'></a></span><i>dependent name</i>
if</p><ul ><li ><p >any of the expressions in the <i ><a href='expr.post#expression-list'>expression-list</a></i> is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>),</p></li><li ><p >any of the expressions
or <i ><a href='dcl.init#braced-init-list'>braced-init-lists</a></i>
in the
<i ><a href='expr.post#expression-list'>expression-list</a></i>
is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>), or</p></li><li ><p >the <i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
is a <i ><a href='temp.names#template-id'>template-id</a></i> in which any of the template arguments depends
on a template parameter.
</p></li></ul><p >If an operand of an operator is a type-dependent expression, the operator
also denotes a dependent name.
Such names are unbound and
are looked up at the point of the template instantiation (<a href='temp.point'>[temp.point]</a>) in
both the context of the template definition and the
context of the point of instantiation.</p></div><div class='para' id='dep-2'><div class='marginalizedparent'><a class='marginalized' href='#dep-2'>2</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct X : B&lt;T&gt; {
  typename T::A* pa;
  void f(B&lt;T&gt;* pb) {
    static int i = B&lt;T&gt;::i;
    pb-&gt;j++;
  }
};
</pre><p >the base class name
<span class='texttt'>B&lt;T&gt;</span>,
the type name
<span class='texttt'>T::A</span>,
the names
<span class='texttt'>B&lt;T&gt;::i</span>
and
<span class='texttt'>pb-&gt;j</span>
explicitly depend on the
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dep-3'><div class='marginalizedparent'><a class='marginalized' href='#dep-3'>3</a></div><p >In the definition of a class or class template,
the scope of a dependent base class (<a href='temp.dep.type'>[temp.dep.type]</a>)
is not examined during unqualified
name lookup either at the point of definition of the
class template or member or during an instantiation of
the class template or member.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef double A;
template&lt;class T&gt; class B {
  typedef int A;
};
template&lt;class T&gt; struct X : B&lt;T&gt; {
  A a;              <span class='comment'>// <span class='texttt'>a</span> has type <span class='texttt'>double</span>
</span>};
</pre><p >The type name
<span class='texttt'>A</span>
in the definition of
<span class='texttt'>X&lt;T&gt;</span>
binds to the typedef name defined in the global
namespace scope, not to the typedef name
defined in the base class
<span class='texttt'>B&lt;T&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct B { <span class='comment'>/* ... */</span> };
  int a;
  int Y;
};

int a;

template&lt;class T&gt; struct Y : T {
  struct B { <span class='comment'>/* ... */</span> };
  B b;                          <span class='comment'>// The <span class='texttt'>B</span> defined in <span class='texttt'>Y</span>
</span>  void f(int i) { a = i; }      <span class='comment'>// <span class='texttt'>::a</span>
</span>  Y* p;                         <span class='comment'>// <span class='texttt'>Y&lt;T&gt;</span>
</span>};

Y&lt;A&gt; ya;
</pre><p >The members
<span class='texttt'>A::B</span>,
<span class='texttt'>A::a</span>,
and
<span class='texttt'>A::Y</span>
of the template argument
<span class='texttt'>A</span>
do not affect the binding of names in
<span class='texttt'>Y&lt;A&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='dep.type'><h4 ><a class='secnum' href='#dep.type' style='min-width:118pt'>14.6.2.1</a> Dependent types <a class='abbr_ref' href='temp.dep.type'>[temp.dep.type]</a></h4><div class='para' id='dep.type-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-1'>1</a></div><p >A name refers to the
<i>current instantiation</i>
if it is</p><ul ><li ><p >in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause <a href='class'>[class]</a>) of the class template or nested class,
</p></li><li ><p >in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization),
</p></li><li ><p >in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
</p></li><li ><p >in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization).
If the <i>n</i>th template parameter is
a parameter pack, the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the parameter pack.
</p></li></ul></div><div class='para' id='dep.type-2'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-2'>2</a></div><p >The template argument list of a primary template is a
template argument list in which the
<i>n</i>th
template argument has the value of the
<i>n</i>th
template parameter of the class template.
If the <i>n</i>th template parameter is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the template parameter pack.</p></div><div class='para' id='dep.type-3'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-3'>3</a></div><p >A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  A* p1;                        <span class='comment'>// <span class='texttt'>A</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is the current instantiation
</span>  A&lt;T*&gt; p3;                     <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is not the current instantiation
</span>  ::A&lt;T&gt;* p4;                   <span class='comment'>// <span class='texttt'>::A&lt;T&gt;</span> is the current instantiation
</span>  class B {
    B* p1;                      <span class='comment'>// <span class='texttt'>B</span> is the current instantiation
</span>    A&lt;T&gt;::B* p2;                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::B</span> is the current instantiation
</span>    typename A&lt;T*&gt;::B* p3;      <span class='comment'>// <span class='texttt'>A&lt;T*&gt;::B</span> is not the
</span>                                <span class='comment'>// current instantiation
</span>  };
};

template &lt;class T&gt; class A&lt;T*&gt; {
  A&lt;T*&gt;* p1;                    <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is not the current instantiation
</span>};

template &lt;class T1, class T2, int I&gt; struct B {
  B&lt;T1, T2, I&gt;* b1;             <span class='comment'>// refers to the current instantiation
</span>  B&lt;T2, T1, I&gt;* b2;             <span class='comment'>// not the current instantiation
</span>  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B&lt;my_T1, T2, my_I&gt;* b3;       <span class='comment'>// refers to the current instantiation
</span>  B&lt;my_T1, T2, my_I2&gt;* b4;      <span class='comment'>// not the current instantiation
</span>  B&lt;my_T1, T2, my_I3&gt;* b5;      <span class='comment'>// refers to the current instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dep.type-4'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-4'>4</a></div><p ><span class='indexparent'><a class='index' id='base class!dependent'></a></span>A <i>dependent base class</i> is a base class that is a dependent type and is
not the current instantiation.
[&nbsp;<i>Note:</i><span class='space'></span>
a base class can be the current instantiation in the case of a nested class
naming an enclosing class as a base.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  typedef int M;
  struct B {
    typedef void M;
    struct C;
  };
};

template&lt;class T&gt; struct A&lt;T&gt;::B::C : A&lt;T&gt; {
  M m; <span class='comment'>// OK, <span class='texttt'>A&lt;T&gt;::M</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dep.type-5'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-5'>5</a></div><p ><span class='indexparent'><a class='index' id='instantiation!member of the current'></a></span>A name is a
<i>member of the current instantiation</i>
if it is</p><ul ><li ><p >An unqualified name that, when looked up, refers to
at least one member of a class that is
the current instantiation or a non-dependent base class thereof.
[&nbsp;<i>Note:</i><span class='space'></span>
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li ><p >A
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation
and that, when looked up, refers to at least one member of a class that is
the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i><span class='space'></span> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >An <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) for which the type of the object expression is the
current instantiation, and the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i>, when looked
up (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), refers to at least one member of a class
that is the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i><span class='space'></span> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  static const int i = 5;
  int n1[i];        <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>  int n2[A::i];     <span class='comment'>// <span class='texttt'>A::i</span> refers to a member of the current instantiation
</span>  int n3[A&lt;T&gt;::i];  <span class='comment'>// <span class='texttt'>A&lt;T&gt;::i</span> refers to a member of the current instantiation
</span>  int f();
};

template &lt;class T&gt; int A&lt;T&gt;::f() {
  return i;         <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='instantiation!dependent member of the current'></a></span>A name is a <i>dependent member of the current instantiation</i> if it is a
member of the current instantiation that, when looked up, refers to at least
one member of a class that is the current instantiation.</p></div><div class='para' id='dep.type-6'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-6'>6</a></div><p >A name is a
<i>member of an unknown specialization</i>
if it is</p><ul ><li ><p >A
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
names a dependent type that is not the current instantiation.</p></li><li ><p >A <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> does not
find any member of a class that is the current instantiation or a non-dependent
base class thereof.</p></li><li ><p >An <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) in which either
</p><ul ><li ><p >the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> does not find a member of a class that is
the current instantiation or a non-dependent base class thereof; or</p></li><li ><p >the type of the object expression is dependent and is not the current
instantiation.
</p></li></ul></li></ul></div><div class='para' id='dep.type-7'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-7'>7</a></div><p >If a <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the <i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> is not instantiated; no
diagnostic required. Similarly, if the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class A {
  typedef int type;
  void f() {
    A&lt;T&gt;::type i;           <span class='comment'>// OK: refers to a member of the current instantiation
</span>    typename A&lt;T&gt;::other j; <span class='comment'>// error: neither a member of the current instantiation nor
</span>                            <span class='comment'>// a member of an unknown specialization
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dep.type-8'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-8'>8</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> or class member access expression, the name in the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  int m;
};

struct B {
  int m;
};

template&lt;typename T&gt;
struct C : A, T {
  int f() { return this-&gt;m; }  <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>  int g() { return m; }        <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>};

template int C&lt;B&gt;::f();        <span class='comment'>// error: finds both <span class='texttt'>A::m</span> and <span class='texttt'>B::m</span>
</span>template int C&lt;B&gt;::g();        <span class='comment'>// OK: transformation to class member access syntax
</span>                               <span class='comment'>// does not occur in the template definition context; see <a href='class.mfct.non-static'>[class.mfct.non-static]</a>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dep.type-9'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-9'>9</a></div><p >A type is dependent if it is
</p><ul ><li ><p >a template parameter,
</p></li><li ><p >a member of an unknown specialization,
</p></li><li ><p >a nested class or enumeration that is a dependent member of the current
instantiation,
</p></li><li ><p >a cv-qualified type where the cv-unqualified type is dependent,
</p></li><li ><p >a compound type constructed from any dependent type,
</p></li><li ><p >an array type whose element type is dependent or whose
bound (if any) is value-dependent,
</p></li><li ><p >a
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent or is a pack expansion, or
</p></li><li ><p >denoted by <span class='texttt'>decltype(</span><i ><a href='expr.comma#expression'>expression</a></i><span class='texttt'>)</span>,
where <i ><a href='expr.comma#expression'>expression</a></i> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
</p></li></ul></div><div class='para' id='dep.type-10'><div class='marginalizedparent'><a class='marginalized' href='#dep.type-10'>10</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='dep.expr'><h4 ><a class='secnum' href='#dep.expr' style='min-width:118pt'>14.6.2.2</a> Type-dependent expressions <a class='abbr_ref' href='temp.dep.expr'>[temp.dep.expr]</a></h4><div class='para' id='dep.expr-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-1'>1</a></div><p >Except as described below, an expression is type-dependent if any
subexpression is type-dependent.</p></div><div class='para' id='dep.expr-2'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-2'>2</a></div><p ><span class='texttt'>this</span>
is type-dependent if the class type of the enclosing member function is
dependent (<a href='temp.dep.type'>[temp.dep.type]</a>).</p></div><div class='para' id='dep.expr-3'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-3'>3</a></div><p >An
<i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
is type-dependent if it contains</p><ul ><li ><p >an
<i ><a href='lex.name#identifier'>identifier</a></i>
associated by name lookup with one or more declarations
declared with a dependent type,</p></li><li ><p >an
<i ><a href='lex.name#identifier'>identifier</a></i>
associated by name lookup with
a non-type <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
declared with a type
that contains a placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>),</p></li><li ><p >an <i ><a href='lex.name#identifier'>identifier</a></i> associated by name lookup with one or more
declarations of member functions of the current instantiation declared
with a return type that contains a placeholder type,</p></li><li ><p >an <i ><a href='lex.name#identifier'>identifier</a></i> associated by name lookup with a decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>) whose <i ><a href='dcl.init#brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
is type-dependent,</p></li><li ><p >the
<i ><a href='lex.name#identifier'>identifier</a></i>
<span class='texttt'>__func__</span> (<a href='dcl.fct.def.general'>[dcl.fct.def.general]</a>), where any enclosing function is a
template, a member of a class template, or a generic lambda,</p></li><li ><p >a
<i ><a href='temp.names#template-id'>template-id</a></i>
that is dependent,</p></li><li ><p >a
<i ><a href='class.conv.fct#conversion-function-id'>conversion-function-id</a></i>
that specifies a dependent type, or</p></li><li ><p >a
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
or a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
that names a member of an unknown specialization;
</p></li></ul><p >or if it names a dependent member of the current instantiation that is a static
data member of type
“array of unknown bound of <span class='texttt'>T</span>” for some <span class='texttt'>T</span> (<a href='temp.static'>[temp.static]</a>).
Expressions of the following forms are type-dependent only if the type
specified by the
<i ><a href='dcl.name#type-id'>type-id</a></i>,
<i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i>
or
<i ><a href='expr.new#new-type-id'>new-type-id</a></i>
is dependent, even if any subexpression is type-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.new#new-type-id'>new-type-id</a></i> <i ><a href='expr.new#new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.new#new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>dynamic_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i></pre></div><div class='para' id='dep.expr-4'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-4'>4</a></div><p >Expressions of the following forms are never type-dependent (because the type
of the expression cannot be dependent):</p><pre class='bnf'><i ><a href='lex.literal.kinds#literal'>literal</a></i>
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.post#pseudo-destructor-name'>pseudo-destructor-name</a></i>
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.post#pseudo-destructor-name'>pseudo-destructor-name</a></i>
<span class='terminal'>sizeof</span> <i ><a href='expr.unary#unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#identifier'>identifier</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete [ ]</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
<span class='terminal'>throw</span> <i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dep.expr-5'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-5'>5</a></div><p >A class member access expression (<a href='expr.ref'>[expr.ref]</a>) is
type-dependent if
the expression refers to a member of the current instantiation and
the type of the referenced member is dependent, or the class member access
expression refers to a member of an unknown specialization.
[&nbsp;<i>Note:</i><span class='space'></span>
In an expression of the form
<span class='texttt'>x.y</span>
or
<span class='texttt'>xp-&gt;y</span>
the type of the expression is usually the type of the member
<span class='texttt'>y</span>
of the class of
<span class='texttt'>x</span>
(or the class pointed to by
<span class='texttt'>xp</span>).
However, if
<span class='texttt'>x</span>
or
<span class='texttt'>xp</span>
refers to a dependent type that is not the current instantiation,
the type of
<span class='texttt'>y</span>
is always dependent. If
<span class='texttt'>x</span>
or <span class='texttt'>xp</span>
refers to a non-dependent type or refers to the current instantiation, the
type of
<span class='texttt'>y</span>
is the type of the class member access expression.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dep.expr-6'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-6'>6</a></div><p >A <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i> is type-dependent if any element is
type-dependent or is a pack expansion.</p></div><div class='para' id='dep.expr-7'><div class='marginalizedparent'><a class='marginalized' href='#dep.expr-7'>7</a></div><p >A <i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i> is type-dependent.</p></div></div><div id='dep.constexpr'><h4 ><a class='secnum' href='#dep.constexpr' style='min-width:118pt'>14.6.2.3</a> Value-dependent expressions <a class='abbr_ref' href='temp.dep.constexpr'>[temp.dep.constexpr]</a></h4><div class='para' id='dep.constexpr-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.constexpr-1'>1</a></div><p >Except as described below, an expression used in a context where a
constant expression is required is value-dependent if any
subexpression is value-dependent.</p></div><div class='para' id='dep.constexpr-2'><div class='marginalizedparent'><a class='marginalized' href='#dep.constexpr-2'>2</a></div><p >An
<i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
is value-dependent if:</p><ul ><li ><p >it is type-dependent,
</p></li><li ><p >it is the name of a non-type template parameter,
</p></li><li ><p >it names a static data member that is a dependent member of the current
instantiation and is not initialized in a <i ><a href='class.mem#member-declarator'>member-declarator</a></i>,
</p></li><li ><p >it names a static member function that is a dependent member of the current
instantiation, or
</p></li><li ><p >it is a constant with literal type and is initialized with an
expression that is value-dependent.
</p></li></ul><p >Expressions of the following form are value-dependent if the
<i ><a href='expr.unary#unary-expression'>unary-expression</a></i> or <i ><a href='expr.comma#expression'>expression</a></i>
is type-dependent or the
<i ><a href='dcl.name#type-id'>type-id</a></i>
is dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <i ><a href='expr.unary#unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dep.constexpr-3'><div class='marginalizedparent'><a class='marginalized' href='#dep.constexpr-3'>3</a></div><p >Expressions of the following form are value-dependent if either the
<i ><a href='dcl.name#type-id'>type-id</a></i>
or
<i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i>
is dependent or the
<i ><a href='expr.comma#expression'>expression</a></i>
or
<i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
is value-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i></pre></div><div class='para' id='dep.constexpr-4'><div class='marginalizedparent'><a class='marginalized' href='#dep.constexpr-4'>4</a></div><p >Expressions of the following form are value-dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#identifier'>identifier</a></i> <span class='terminal'>)</span>
<i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i></pre></div><div class='para' id='dep.constexpr-5'><div class='marginalizedparent'><a class='marginalized' href='#dep.constexpr-5'>5</a></div><p >An expression of the form <span class='texttt'>&amp;</span><i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> where the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> names a dependent member of the current
instantiation is value-dependent.</p></div></div><div id='dep.temp'><h4 ><a class='secnum' href='#dep.temp' style='min-width:118pt'>14.6.2.4</a> Dependent template arguments <a class='abbr_ref' href='temp.dep.temp'>[temp.dep.temp]</a></h4><div class='para' id='dep.temp-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.temp-1'>1</a></div><p >A type
<i ><a href='temp.names#template-argument'>template-argument</a></i>
is dependent if the type it specifies is dependent.</p></div><div class='para' id='dep.temp-2'><div class='marginalizedparent'><a class='marginalized' href='#dep.temp-2'>2</a></div><p >A non-type
<i ><a href='temp.names#template-argument'>template-argument</a></i>
is dependent if its type is dependent or the constant
expression it specifies is value-dependent.</p></div><div class='para' id='dep.temp-3'><div class='marginalizedparent'><a class='marginalized' href='#dep.temp-3'>3</a></div><p >Furthermore, a non-type
<i ><a href='temp.names#template-argument'>template-argument</a></i>
is dependent if the corresponding non-type <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is of reference or pointer type and the <i ><a href='temp.names#template-argument'>template-argument</a></i>
designates or points to a member of the current instantiation or a member of
a dependent type.</p></div><div class='para' id='dep.temp-4'><div class='marginalizedparent'><a class='marginalized' href='#dep.temp-4'>4</a></div><p >A template
<i ><a href='temp.names#template-argument'>template-argument</a></i>
is dependent if it names a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
or is a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
that refers to a member of an unknown specialization.</p></div></div></div><div id='nondep'><h3 ><a class='secnum' href='#nondep' style='min-width:103pt'>14.6.3</a> Non-dependent names <a class='abbr_ref' href='temp.nondep'>[temp.nondep]</a></h3><div class='para' id='nondep-1'><div class='marginalizedparent'><a class='marginalized' href='#nondep-1'>1</a></div><p >Non-dependent names used in a template definition are found using the
usual name lookup and bound at the point they are used.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void g(double);
void h();

template&lt;class T&gt; class Z {
public:
  void f() {
    g(1);           <span class='comment'>// calls <span class='texttt'>g(double)</span>
</span>    h++;            <span class='comment'>// ill-formed: cannot increment function;
</span>                    <span class='comment'>// this could be diagnosed either here or
</span>                    <span class='comment'>// at the point of instantiation
</span>  }
};

void g(int);        <span class='comment'>// not in scope at the point of the template
</span>                    <span class='comment'>// definition, not considered for the call <span class='texttt'>g(1)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dep.res'><h3 ><a class='secnum' href='#dep.res' style='min-width:103pt'>14.6.4</a> Dependent name resolution <a class='abbr_ref' href='temp.dep.res'>[temp.dep.res]</a></h3><div class='para' id='dep.res-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.res-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name!dependent'></a></span>In resolving dependent names, names from the following sources are considered:</p><ul ><li ><p >Declarations that are visible at the point of definition of the
template.
</p></li><li ><p >Declarations from namespaces associated with the types of the
function arguments both from the instantiation context (<a href='temp.point'>[temp.point]</a>)
and from the definition context.
</p></li></ul></div><div id='point'><h4 ><a class='secnum' href='#point' style='min-width:118pt'>14.6.4.1</a> Point of instantiation <a class='abbr_ref' href='temp.point'>[temp.point]</a></h4><div class='para' id='point-1'><div class='marginalizedparent'><a class='marginalized' href='#point-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation!point~of'></a></span>For a function template specialization, a member function template
specialization, or a specialization for a member function or static data member
of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization and
the context from which it is referenced depends on a template parameter,
the point of instantiation of the specialization is the point of instantiation
of the enclosing specialization.
Otherwise, the point of instantiation for such a specialization immediately
follows the namespace scope declaration
or definition that refers to the specialization.</p></div><div class='para' id='point-2'><div class='marginalizedparent'><a class='marginalized' href='#point-2'>2</a></div><p >If a function template or member function of a class template is called
in a way which uses the definition of a default argument of that function
template or member function,
the point of instantiation of the default argument is the point of
instantiation of the function template or member function specialization.</p></div><div class='para' id='point-3'><div class='marginalizedparent'><a class='marginalized' href='#point-3'>3</a></div><p >For an <i ><a href='except.spec#exception-specification'>exception-specification</a></i> of a function template
specialization or specialization of a member function of a class template, if
the <i ><a href='except.spec#exception-specification'>exception-specification</a></i> is implicitly instantiated because
it is needed by another template specialization and the context that requires
it depends on a template parameter, the point of instantiation of the
<i ><a href='except.spec#exception-specification'>exception-specification</a></i> is the point of instantiation of the
specialization that requires it. Otherwise, the point of instantiation for such
an <i ><a href='except.spec#exception-specification'>exception-specification</a></i> immediately follows the namespace
scope declaration or definition that requires the
<i ><a href='except.spec#exception-specification'>exception-specification</a></i>.</p></div><div class='para' id='point-4'><div class='marginalizedparent'><a class='marginalized' href='#point-4'>4</a></div><p >For a class template specialization, a class member template specialization,
or a specialization for a class member of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization,
if the context from which the specialization is referenced depends on a
template parameter,
and if the specialization is not instantiated previous to the instantiation of
the enclosing template,
the point of instantiation is immediately before the point of instantiation of
the enclosing template.
Otherwise, the point of instantiation for such a specialization immediately
precedes the namespace scope declaration
or definition that refers to the specialization.</p></div><div class='para' id='point-5'><div class='marginalizedparent'><a class='marginalized' href='#point-5'>5</a></div><p >If a virtual function is implicitly instantiated, its point of instantiation
is immediately following the point of instantiation of its enclosing class
template specialization.</p></div><div class='para' id='point-6'><div class='marginalizedparent'><a class='marginalized' href='#point-6'>6</a></div><p >An explicit instantiation definition is an instantiation
point for the specialization or specializations specified by the explicit
instantiation.</p></div><div class='para' id='point-7'><div class='marginalizedparent'><a class='marginalized' href='#point-7'>7</a></div><p >The instantiation context of an expression that depends on the template
arguments is the set of declarations with external linkage declared prior to the
point of instantiation of the template specialization in the same translation
unit.</p></div><div class='para' id='point-8'><div class='marginalizedparent'><a class='marginalized' href='#point-8'>8</a></div><p >A specialization for a function template, a member function template,
or of a member function or static data member of a class template may have
multiple points of instantiations within a translation unit, and in addition
to the points of instantiation described above, for any such specialization
that has a point of instantiation within the translation unit, the end of the
translation unit is also considered a point of instantiation.
A specialization for a class template has at most one point of instantiation
within a translation unit.
A specialization for any template may have points of instantiation in multiple
translation units.
If two different points of instantiation give a template specialization
different meanings according to the one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>),
the program is ill-formed, no diagnostic required.</p></div></div><div id='dep.candidate'><h4 ><a class='secnum' href='#dep.candidate' style='min-width:118pt'>14.6.4.2</a> Candidate functions <a class='abbr_ref' href='temp.dep.candidate'>[temp.dep.candidate]</a></h4><div class='para' id='dep.candidate-1'><div class='marginalizedparent'><a class='marginalized' href='#dep.candidate-1'>1</a></div><p ><span class='indexparent'><a class='index' id='functions!candidate'></a></span>For a function call where the <i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> is a
dependent name,
the candidate functions are found using the usual lookup
rules (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except that:</p><ul ><li ><p >For the part of the lookup using unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>),
only function declarations
from the template definition context are found.
</p></li><li ><p >For the part of the lookup using associated namespaces (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>),
only function declarations found in either the template
definition context or the template instantiation context are found.
</p></li></ul><p >If
the call would be ill-formed or would find a better match had the lookup
within the associated namespaces considered all the function declarations with
external linkage introduced in those namespaces in all translation units,
not just considering those declarations found in the template definition and
template instantiation contexts, then the program has undefined behavior.</p></div></div></div><div id='inject'><h3 ><a class='secnum' href='#inject' style='min-width:103pt'>14.6.5</a> Friend names declared within a class template <a class='abbr_ref' href='temp.inject'>[temp.inject]</a></h3><div class='para' id='inject-1'><div class='marginalizedparent'><a class='marginalized' href='#inject-1'>1</a></div><p >Friend classes or functions can be declared within a class template.
When a template is instantiated, the names of its friends are treated
as if the specialization had been explicitly declared at its point of
instantiation.</p></div><div class='para' id='inject-2'><div class='marginalizedparent'><a class='marginalized' href='#inject-2'>2</a></div><p >As with non-template classes, the names of namespace-scope friend
functions of a class template specialization are not visible during
an ordinary lookup unless explicitly declared at namespace scope (<a href='class.friend'>[class.friend]</a>).
Such names may be found under the rules for associated
classes (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>).<a class='footnotenum' href='#footnote-140'>140</a>
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename T&gt; struct number {
  number(int);
  friend number gcd(number x, number y) { return 0; };
};

void g() {
  number&lt;double&gt; a(3), b(4);
  a = gcd(a,b);     <span class='comment'>// finds <span class='texttt'>gcd</span> because <span class='texttt'>number&lt;double&gt;</span> is an
</span>                    <span class='comment'>// associated class, making <span class='texttt'>gcd</span> visible
</span>                    <span class='comment'>// in its namespace (global scope)
</span>  b = gcd(3,4);     <span class='comment'>// ill-formed; <span class='texttt'>gcd</span> is not visible
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-140'><div class='marginalizedparent'><a class='marginalized' href='#footnote-140'>140)</a></div><p >Friend declarations do not
introduce new names into any scope, either
when the template is declared or when it is instantiated.</p></div></div></div><div id='spec'><h2 ><a class='secnum' href='#spec' style='min-width:88pt'>14.7</a> Template instantiation and specialization <a class='abbr_ref' href='temp.spec'>[temp.spec]</a></h2><div class='para' id='spec-1'><div class='marginalizedparent'><a class='marginalized' href='#spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization!template'></a></span>The act of instantiating a function, a class, a member of a class template or
a member template is referred to as
<i>template instantiation</i>.</p></div><div class='para' id='spec-2'><div class='marginalizedparent'><a class='marginalized' href='#spec-2'>2</a></div><p >A function instantiated from a function template is called an instantiated
function.
A class instantiated from a class template is called an instantiated class.
A member function, a member class, a member enumeration, or a static data member of a class template
instantiated from the member definition of the class template is called,
respectively, an instantiated member function, member class, member enumeration, or static data
member.
A member function instantiated from a member function template is called an
instantiated member function.
A member class instantiated from a member class template is called an
instantiated member class.</p></div><div class='para' id='spec-3'><div class='marginalizedparent'><a class='marginalized' href='#spec-3'>3</a></div><p >An explicit specialization may be declared for a function template,
a class template, a member of a class template or a member template.
An explicit specialization declaration is introduced by
<span class='texttt'>template&lt;&gt;</span>.
In an explicit specialization declaration for a class template,
a member of a class template or a class member template,
the name of the class that is explicitly specialized shall be a
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
In the explicit specialization declaration for a function template or
a member function template,
the name of the function or member function explicitly specialized may be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T = int&gt; struct A {
  static int x;
};
template&lt;class U&gt; void g(U) { }

template&lt;&gt; struct A&lt;double&gt; { };        <span class='comment'>// specialize for <span class='texttt'>T == double</span>
</span>template&lt;&gt; struct A&lt;&gt; { };              <span class='comment'>// specialize for <span class='texttt'>T == int</span>
</span>template&lt;&gt; void g(char) { }             <span class='comment'>// specialize for <span class='texttt'>U == char</span>
</span>                                        <span class='comment'>// <span class='texttt'>U</span> is deduced from the parameter type
</span>template&lt;&gt; void g&lt;int&gt;(int) { }         <span class='comment'>// specialize for <span class='texttt'>U == int</span>
</span>template&lt;&gt; int A&lt;char&gt;::x = 0;          <span class='comment'>// specialize for <span class='texttt'>T == char</span>
</span>
template&lt;class T = int&gt; struct B {
  static int x;
};
template&lt;&gt; int B&lt;&gt;::x = 1;              <span class='comment'>// specialize for <span class='texttt'>T == int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='spec-4'><div class='marginalizedparent'><a class='marginalized' href='#spec-4'>4</a></div><p >An instantiated template specialization can be either implicitly
instantiated (<a href='temp.inst'>[temp.inst]</a>) for a given argument list or be explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>).
A specialization is a class, function, or class member that is either
instantiated or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>).</p></div><div class='para' id='spec-5'><div class='marginalizedparent'><a class='marginalized' href='#spec-5'>5</a></div><p >For a given template and a given set of
<i ><a href='temp.names#template-argument'>template-arguments</a></i>,
</p><ul ><li ><p >an explicit instantiation definition shall appear at most once in a program,
</p></li><li ><p >an explicit specialization shall be defined at most once
in a program (according to <a href='basic.def.odr'>[basic.def.odr]</a>), and
</p></li><li ><p >both an explicit instantiation and a declaration of an
explicit specialization shall not appear in a program unless
the explicit instantiation follows a declaration of the explicit
specialization.
</p></li></ul><p >An implementation is not required to diagnose a violation of this rule.</p></div><div class='para' id='spec-6'><div class='marginalizedparent'><a class='marginalized' href='#spec-6'>6</a></div><p >Each class template specialization instantiated from a template has its own
copy of any static members.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T s;
};
template&lt;class T&gt; T X&lt;T&gt;::s = 0;
X&lt;int&gt; aa;
X&lt;char*&gt; bb;
</pre><p ><span class='texttt'>X&lt;int&gt;</span>
has a static member
<span class='texttt'>s</span>
of type
<span class='texttt'>int</span>
and
<span class='texttt'>X&lt;char*&gt;</span>
has a static member
<span class='texttt'>s</span>
of type
<span class='texttt'>char*</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='spec-7'><div class='marginalizedparent'><a class='marginalized' href='#spec-7'>7</a></div><p >If a function declaration acquired its function type through
a dependent type (<a href='temp.dep.type'>[temp.dep.type]</a>) without using the syntactic form of
a function declarator, the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  static T t;
};
typedef int function();
A&lt;function&gt; a;                  <span class='comment'>// ill-formed: would declare <span class='texttt'>A&lt;function&gt;::t</span>
</span>                                <span class='comment'>// as a static member function
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='inst'><h3 ><a class='secnum' href='#inst' style='min-width:103pt'>14.7.1</a> Implicit instantiation <a class='abbr_ref' href='temp.inst'>[temp.inst]</a></h3><div class='para' id='inst-1'><div class='marginalizedparent'><a class='marginalized' href='#inst-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation!template implicit'></a></span>Unless a class template specialization has been explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>) or explicitly
specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
the class template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a completely-defined
object type or when the completeness of the class type affects the semantics
of the program.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, if the semantics of an expression depend on the member or
base class lists of a class template specialization, the class template
specialization is implicitly generated. For instance, deleting a pointer
to class type depends on whether or not the class declares a destructor,
and a conversion between pointers to class type depends on the
inheritance relationship between the two classes involved.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class B { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; class D : public B&lt;T&gt; { <span class='comment'>/* ... */</span> };

void f(void*);
void f(B&lt;int&gt;*);

void g(D&lt;int&gt;* p, D&lt;char&gt;* pp, D&lt;double&gt;* ppp) {
  f(p);            <span class='comment'>// instantiation of <span class='texttt'>D&lt;int&gt;</span> required: call <span class='texttt'>f(B&lt;int&gt;*)</span>
</span>  B&lt;char&gt;* q = pp; <span class='comment'>// instantiation of <span class='texttt'>D&lt;char&gt;</span> required:
</span>                   <span class='comment'>// convert <span class='texttt'>D&lt;char&gt;*</span> to <span class='texttt'>B&lt;char&gt;*</span>
</span>  delete ppp;      <span class='comment'>// instantiation of <span class='texttt'>D&lt;double&gt;</span> required
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
If a class template has been declared, but not defined,
at the point of instantiation (<a href='temp.point'>[temp.point]</a>),
the instantiation yields an incomplete class type (<a href='basic.types'>[basic.types]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class X;

X&lt;char&gt; ch;      <span class='comment'>// error: incomplete type <span class='texttt'>X&lt;char&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Within a template declaration,
a local class (<a href='class.local'>[class.local]</a>) or enumeration and the members of
a local class are never considered to be entities that can be separately
instantiated (this includes their default arguments,
<i ><a href='except.spec#exception-specification'>exception-specifications</a></i>, and non-static data member
initializers, if any). As a result, the dependent names are looked up, the
semantic constraints are checked, and any templates used are instantiated as
part of the instantiation of the entity within which the local class or
enumeration is declared.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The implicit instantiation of a class template specialization causes
the implicit instantiation of the declarations, but not of the definitions,
default arguments, or <i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of the class member functions,
member classes, scoped member enumerations, static data members and member templates; and it causes the
implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions.
However, for the purpose of determining whether an instantiated redeclaration
of a member is valid according to <a href='class.mem'>[class.mem]</a>, a declaration that
corresponds to a definition in the template is considered to be a
definition.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class U&gt;
struct Outer {
  template&lt;class X, class Y&gt; struct Inner;
  template&lt;class Y&gt; struct Inner&lt;T, Y&gt;;         <span class='comment'>// #1a
</span>  template&lt;class Y&gt; struct Inner&lt;T, Y&gt; { };     <span class='comment'>// #1b; OK: valid redeclaration of #1a
</span>  template&lt;class Y&gt; struct Inner&lt;U, Y&gt; { };     <span class='comment'>// #2
</span>};

Outer&lt;int, int&gt; outer;                          <span class='comment'>// error at #2
</span></pre><p ><span class='texttt'>Outer&lt;int, int&gt;::Inner&lt;int, Y&gt;</span> is redeclared at #1b. (It is not defined
but noted as being associated with a definition in <span class='texttt'>Outer&lt;T, U&gt;</span>.) #2
is also a redeclaration of #1a. It is noted as associated with a definition,
so it is an invalid redeclaration of the same partial specialization.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='inst-2'><div class='marginalizedparent'><a class='marginalized' href='#inst-2'>2</a></div><p >Unless a member of a class template or a member template has been explicitly
instantiated or explicitly specialized,
the specialization of the member is implicitly instantiated when the
specialization is referenced in a context that requires the member definition
to exist;
in particular, the initialization (and any associated side effects) of a
static data member does not occur unless the static data member is itself used
in a way that requires the definition of the static data member to exist.</p></div><div class='para' id='inst-3'><div class='marginalizedparent'><a class='marginalized' href='#inst-3'>3</a></div><p >Unless a function template specialization has been explicitly instantiated or
explicitly specialized,
the function template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a function definition
to exist.
Unless a call is to a function template explicit specialization or
to a member function of an explicitly specialized class template,
a default argument for a function template or a member function of a
class template is implicitly instantiated when the function is
called in a context that requires the value of the default argument.</p></div><div class='para' id='inst-4'><div class='marginalizedparent'><a class='marginalized' href='#inst-4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct Z {
  void f();
  void g();
};

void h() {
  Z&lt;int&gt; a;         <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;int&gt;</span> required
</span>  Z&lt;char&gt;* p;       <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;char&gt;</span> not required
</span>  Z&lt;double&gt;* q;     <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;double&gt;</span> not required
</span>
  a.f();            <span class='comment'>// instantiation of <span class='texttt'>Z&lt;int&gt;::f()</span> required
</span>  p-&gt;g();           <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;char&gt;</span> required, and
</span>                    <span class='comment'>// instantiation of <span class='texttt'>Z&lt;char&gt;::g()</span> required
</span>}
</pre><p >Nothing in this example requires
<span class='texttt'>class</span>
<span class='texttt'>Z&lt;double&gt;</span>,
<span class='texttt'>Z&lt;int&gt;::g()</span>,
or
<span class='texttt'>Z&lt;char&gt;::f()</span>
to be implicitly instantiated.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='inst-5'><div class='marginalizedparent'><a class='marginalized' href='#inst-5'>5</a></div><p >Unless a variable template specialization has been explicitly instantiated or
explicitly specialized, the variable template specialization is implicitly
instantiated when the specialization is used. A default template argument for a
variable template is implicitly instantiated when the variable template is
referenced in a context that requires the value of the default argument.</p></div><div class='para' id='inst-6'><div class='marginalizedparent'><a class='marginalized' href='#inst-6'>6</a></div><p >If the function selected by overload resolution (<a href='over.match'>[over.match]</a>)
can be determined without instantiating a class template definition,
it is unspecified whether that instantiation actually takes place.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct S {
  operator int();
};

void f(int);
void f(S&lt;int&gt;&amp;);
void f(S&lt;float&gt;);

void g(S&lt;int&gt;&amp; sr) {
  f(sr);            <span class='comment'>// instantiation of <span class='texttt'>S&lt;int&gt;</span> allowed but not required
</span>                    <span class='comment'>// instantiation of <span class='texttt'>S&lt;float&gt;</span> allowed but not required
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='inst-7'><div class='marginalizedparent'><a class='marginalized' href='#inst-7'>7</a></div><p >If a function template or a member function template specialization is used in
a way that involves overload resolution,
a declaration of the specialization is implicitly instantiated (<a href='temp.over'>[temp.over]</a>).</p></div><div class='para' id='inst-8'><div class='marginalizedparent'><a class='marginalized' href='#inst-8'>8</a></div><p >An implementation shall not implicitly instantiate a function template,
a variable template,
a member template, a non-virtual member function, a member class, a
static data member of a class template, or a substatement of a constexpr if
statement (<a href='stmt.if'>[stmt.if]</a>), unless such instantiation is required.
It is unspecified whether or not an implementation implicitly instantiates a
virtual member function of a class template if the virtual member function would
not otherwise be instantiated.
The use of a template specialization in a default argument
shall not cause the template to be implicitly instantiated except that a
class template may be instantiated where its complete type is needed to determine
the correctness of the default argument.
The use of a default argument in a
function call causes specializations in the default argument to be implicitly
instantiated.</p></div><div class='para' id='inst-9'><div class='marginalizedparent'><a class='marginalized' href='#inst-9'>9</a></div><p >Implicitly instantiated class, function, and variable template specializations
are placed in the namespace where the template is defined.
Implicitly instantiated specializations for members of a class template are
placed in the namespace where the enclosing class template is defined.
Implicitly instantiated member templates are placed in the namespace where the
enclosing class or class template is defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class List {
  public:
    T* get();
  };
}

template&lt;class K, class V&gt; class Map {
public:
  N::List&lt;V&gt; lt;
  V get(K);
};

void g(Map&lt;const char*,int&gt;&amp; m) {
  int i = m.get("Nicholas");
}
</pre><p >a call of
<span class='texttt'>lt.get()</span>
from
<span class='texttt'>Map&lt;const char*,int&gt;::get()</span>
would place
<span class='texttt'>List&lt;int&gt;::get()</span>
in the namespace
<span class='texttt'>N</span>
rather than in the global namespace.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='inst-10'><div class='marginalizedparent'><a class='marginalized' href='#inst-10'>10</a></div><p >If a function template
<span class='texttt'>f</span>
is called in a way that requires a default argument to be used,
the dependent names are looked up, the semantics constraints are checked,
and the instantiation of any template used in the default argument
is done as if the default argument had been
an initializer used in a function template specialization with the same scope,
the same template parameters and the same access as that of the function template
<span class='texttt'>f</span>
used at that point, except that the scope in which a closure type is
declared (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>) – and therefore its associated namespaces –
remain as determined from the context of the definition for the default
argument.
This analysis is called
<i>default argument instantiation</i>.
The instantiated default argument is then used as the argument of
<span class='texttt'>f</span>.</p></div><div class='para' id='inst-11'><div class='marginalizedparent'><a class='marginalized' href='#inst-11'>11</a></div><p >Each default argument is instantiated independently.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T x, T y = ydef(T()), T z = zdef(T()));

class  A { };

A zdef(A);

void g(A a, A b, A c) {
  f(a, b, c);       <span class='comment'>// no default argument instantiation
</span>  f(a, b);          <span class='comment'>// default argument <span class='texttt'>z = zdef(T())</span> instantiated
</span>  f(a);             <span class='comment'>// ill-formed; <span class='texttt'>ydef</span> is not declared
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='inst-12'><div class='marginalizedparent'><a class='marginalized' href='#inst-12'>12</a></div><p >The <i ><a href='except.spec#exception-specification'>exception-specification</a></i> of a function template specialization
is not instantiated along with the function declaration; it is instantiated
when needed (<a href='except.spec'>[except.spec]</a>). If such an
<i ><a href='except.spec#exception-specification'>exception-specification</a></i> is needed but has not yet been
instantiated, the dependent names are looked up, the semantics constraints are
checked, and the instantiation of any template used in the
<i ><a href='except.spec#exception-specification'>exception-specification</a></i> is done as if it were being done as part
of instantiating the declaration of the specialization at that point.</p></div><div class='para' id='inst-13'><div class='marginalizedparent'><a class='marginalized' href='#inst-13'>13</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<a href='temp.point'>[temp.point]</a> defines the point of instantiation of a template specialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='inst-14'><div class='marginalizedparent'><a class='marginalized' href='#inst-14'>14</a></div><p >There is an <span class='indexparent'><a class='index' id='maximum depth of recursive template instantiations'></a></span>implementation-defined quantity
that specifies the limit on the total depth of recursive instantiations (<a href='implimits'>[implimits]</a>),
which could involve more than one template.
The result of an infinite recursion in instantiation is undefined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  X&lt;T&gt;* p;          <span class='comment'>// OK
</span>  X&lt;T*&gt; a;          <span class='comment'>// implicit generation of <span class='texttt'>X&lt;T&gt;</span> requires
</span>                    <span class='comment'>// the implicit instantiation of <span class='texttt'>X&lt;T*&gt;</span> which requires
</span>                    <span class='comment'>// the implicit instantiation of <span class='texttt'>X&lt;T**&gt;</span> which ...
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='explicit'><h3 ><a class='secnum' href='#explicit' style='min-width:103pt'>14.7.2</a> Explicit instantiation <a class='abbr_ref' href='temp.explicit'>[temp.explicit]</a></h3><div class='para' id='explicit-1'><div class='marginalizedparent'><a class='marginalized' href='#explicit-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation!explicit'></a></span>A class, function, variable, or member template specialization can be explicitly
instantiated from its template.
A member function, member class or static data member of a class template can
be explicitly instantiated from the member definition associated with its class
template. An explicit instantiation of a function template
or member function of a class template
shall not
use the <span class='texttt'>inline</span> or <span class='texttt'>constexpr</span> specifiers.</p></div><div class='para' id='explicit-2'><div class='marginalizedparent'><a class='marginalized' href='#explicit-2'>2</a></div><p >The syntax for explicit instantiation is:</p><pre class='bnf'><a id='explicit-instantiation'>explicit-instantiation:</a>
  <span class='terminal'>extern<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>template</span> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><p >There are two forms of explicit instantiation: an explicit instantiation
definition and an explicit instantiation declaration. An explicit instantiation
declaration begins with the <span class='texttt'>extern</span> keyword.</p></div><div class='para' id='explicit-3'><div class='marginalizedparent'><a class='marginalized' href='#explicit-3'>3</a></div><p >If the explicit instantiation is for a class or member class, the
<i ><a href='dcl.type.elab#elaborated-type-specifier'>elaborated-type-specifier</a></i> in the <i ><a href='dcl.dcl#declaration'>declaration</a></i> shall
include a <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>. If the explicit instantiation is for
a function or member function,
the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
in the
<i ><a href='dcl.dcl#declaration'>declaration</a></i>
shall be either a
<i ><a href='temp.names#template-id'>template-id</a></i>
or, where all template arguments can be deduced, a
<i ><a href='temp.names#template-name'>template-name</a></i> or <i ><a href='over.oper#operator-function-id'>operator-function-id</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
The declaration may declare a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>,
in which case the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
of the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
must be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the explicit instantiation is for a member function, a member class or
a static data member of a class template specialization,
the name of the class template specialization in the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
for the member name shall be a <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
If the explicit instantiation is for a variable, the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i> in the declaration shall be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
An explicit instantiation shall appear in an enclosing namespace
of its template. If the name declared in the explicit
instantiation is an unqualified name, the explicit instantiation
shall appear in the namespace where its template is declared or, if that
namespace is inline (<a href='namespace.def'>[namespace.def]</a>), any namespace from its enclosing
namespace set.
[&nbsp;<i>Note:</i><span class='space'></span>
Regarding qualified names in declarators, see <a href='dcl.meaning'>[dcl.meaning]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { void mf(); };
template class Array&lt;char&gt;;
template void Array&lt;int&gt;::mf();

template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }
template void sort(Array&lt;char&gt;&amp;);       <span class='comment'>// argument is deduced here
</span>
namespace N {
  template&lt;class T&gt; void f(T&amp;) { }
}
template void N::f&lt;int&gt;(int&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='explicit-4'><div class='marginalizedparent'><a class='marginalized' href='#explicit-4'>4</a></div><p >A declaration of a function template, a variable template, a member function
or static data member
of a class template, or a member function template of a class or class
template shall precede an explicit instantiation of that entity. A definition
of a class template, a member class of a class template, or a member class
template of a class or class template shall precede an explicit instantiation
of that entity unless the explicit instantiation is preceded by an explicit
specialization of the entity with the same template arguments.
If the
<i ><a href='dcl.dcl#declaration'>declaration</a></i>
of the explicit instantiation names an implicitly-declared special member
function (Clause <a href='special'>[special]</a>), the program is ill-formed.</p></div><div class='para' id='explicit-5'><div class='marginalizedparent'><a class='marginalized' href='#explicit-5'>5</a></div><p >For a given set of template arguments, if an explicit
instantiation of a template appears after a declaration of
an explicit specialization for that template, the explicit
instantiation has no effect. Otherwise, for an explicit instantiation
definition the definition of a
function template, a variable template, a member
function template, or a member function or static
data member of a class template shall be present in every
translation unit in which it is explicitly instantiated.</p></div><div class='para' id='explicit-6'><div class='marginalizedparent'><a class='marginalized' href='#explicit-6'>6</a></div><p >An explicit instantiation of a class, function template, or variable template
specialization is
placed in the namespace in which the template is defined.
An explicit instantiation for a member of a class template is placed in
the namespace where the enclosing class template is defined.
An explicit instantiation for a member template is placed in the namespace
where the enclosing class or class template is defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class Y { void mf() { } };
}

template class Y&lt;int&gt;;                  <span class='comment'>// error: class template <span class='texttt'>Y</span> not visible
</span>                                        <span class='comment'>// in the global namespace
</span>
using N::Y;
template class Y&lt;int&gt;;                  <span class='comment'>// error: explicit instantiation outside of the
</span>                                        <span class='comment'>// namespace of the template
</span>
template class N::Y&lt;char*&gt;;             <span class='comment'>// OK: explicit instantiation in namespace <span class='texttt'>N</span>
</span>template void N::Y&lt;double&gt;::mf();       <span class='comment'>// OK: explicit instantiation
</span>                                        <span class='comment'>// in namespace <span class='texttt'>N</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='explicit-7'><div class='marginalizedparent'><a class='marginalized' href='#explicit-7'>7</a></div><p >A trailing
<i ><a href='temp.names#template-argument'>template-argument</a></i>
can be left unspecified in an explicit instantiation of a function template
specialization or of a member function template specialization provided
it can be deduced from the type of a function parameter (<a href='temp.deduct'>[temp.deduct]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

<span class='comment'>// instantiate <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span> - template-argument deduced
</span>template void sort&lt;&gt;(Array&lt;int&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='explicit-8'><div class='marginalizedparent'><a class='marginalized' href='#explicit-8'>8</a></div><p >An explicit instantiation that names a class
template specialization is also an explicit
instantiation of the same kind (declaration or definition) of each
of its members (not including members inherited from base classes and members
that are templates) that has not been previously explicitly specialized in
the translation unit containing the explicit instantiation,
except as described below.
[&nbsp;<i>Note:</i><span class='space'></span> In addition, it will typically be an explicit instantiation of certain
implementation-dependent data about the class. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='explicit-9'><div class='marginalizedparent'><a class='marginalized' href='#explicit-9'>9</a></div><p >An explicit instantiation definition that names a class template
specialization explicitly instantiates the class template specialization
and is an explicit instantiation definition of only those
members that have been defined at the point of instantiation.</p></div><div class='para' id='explicit-10'><div class='marginalizedparent'><a class='marginalized' href='#explicit-10'>10</a></div><p >Except for inline functions and variables, declarations with types deduced from their
initializer or return value (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>), <span class='texttt'>const</span> variables of
literal types,
variables of reference types, and class template specializations,
explicit instantiation declarations have the
effect of suppressing the implicit instantiation of the entity to which they
refer. [&nbsp;<i>Note:</i><span class='space'></span> The intent is that an inline function that is the
subject of an explicit instantiation declaration will still be implicitly
instantiated when odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) so that the body can be considered for inlining, but
that no out-of-line copy of the inline function would be generated in the
translation unit.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='explicit-11'><div class='marginalizedparent'><a class='marginalized' href='#explicit-11'>11</a></div><p >If an entity is the subject of both an explicit instantiation declaration
and an explicit instantiation definition in the same translation unit, the
definition shall follow the declaration. An entity that is the subject of an
explicit instantiation declaration and that is also used
in a way that would otherwise cause an implicit instantiation (<a href='temp.inst'>[temp.inst]</a>)
in the translation unit
shall be the subject of an explicit instantiation definition somewhere in the
program; otherwise the program is ill-formed, no diagnostic required.
[&nbsp;<i>Note:</i><span class='space'></span> This rule does apply to inline functions even though an
explicit instantiation declaration of such an entity has no other normative
effect. This is needed to ensure that if the address of an inline function is
taken in a translation unit in which the implementation chose to suppress the
out-of-line body, another translation unit will supply the body.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An explicit instantiation declaration shall not name a specialization of a
template with internal linkage.</p></div><div class='para' id='explicit-12'><div class='marginalizedparent'><a class='marginalized' href='#explicit-12'>12</a></div><p >The usual access checking rules do not apply to names used to specify
explicit instantiations.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, the template arguments and names used in the function
declarator (including parameter types, return types and exception
specifications) may be private types or objects which would normally
not be accessible and the template may be a member template or member
function which would not normally be accessible.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='explicit-13'><div class='marginalizedparent'><a class='marginalized' href='#explicit-13'>13</a></div><p >An explicit instantiation does not constitute a use of a default argument,
so default argument instantiation is not done.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
char* p = 0;
template&lt;class T&gt; T g(T x = &amp;p) { return x; }
template int g&lt;int&gt;(int);       <span class='comment'>// OK even though <span class='texttt'>&amp;p</span> isn't an <span class='texttt'>int</span>.
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='expl.spec'><h3 ><a class='secnum' href='#expl.spec' style='min-width:103pt'>14.7.3</a> Explicit specialization <a class='abbr_ref' href='temp.expl.spec'>[temp.expl.spec]</a></h3><div class='para' id='expl.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization!template explicit'></a></span>An explicit specialization of any of the following:</p><ul ><li ><p >function template
</p></li><li ><p >class template
</p></li><li ><p >variable template
</p></li><li ><p >member function of a class template
</p></li><li ><p >static data member of a class template
</p></li><li ><p >member class of a class template
</p></li><li ><p >member enumeration of a class template
</p></li><li ><p >member class template of a class or class template
</p></li><li ><p >member function template of a class or class template
</p></li></ul><p >can be declared by a declaration introduced by
<span class='texttt'>template&lt;&gt;</span>;
that is:
<span class='indexparent'><a class='index' id='explicit-specialization'></a></span>
</p><pre class='bnf'><a id='explicit-specialization'>explicit-specialization:</a>
  <span class='terminal'>template &lt; &gt;</span> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class stream;

template&lt;&gt; class stream&lt;char&gt; { <span class='comment'>/* ... */</span> };

template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

template&lt;&gt; void sort&lt;char*&gt;(Array&lt;char*&gt;&amp;);
</pre><p >Given these declarations,
<span class='texttt'>stream&lt;char&gt;</span>
will be used as the definition of streams of
<span class='texttt'>char</span>s;
other streams will be handled by class template specializations instantiated
from the class template.
Similarly,
<span class='texttt'>sort&lt;char*&gt;</span>
will be used as the sort function for arguments
of type
<span class='texttt'>Array&lt;char*&gt;</span>;
other
<span class='texttt'>Array</span>
types will be sorted by functions generated from the template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-2'>2</a></div><p >An explicit specialization shall be declared in a namespace enclosing the specialized template.
An explicit specialization
whose <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> or <i ><a href='class#class-head-name'>class-head-name</a></i> is not qualified
shall be declared in the nearest enclosing namespace of the template,
or, if the namespace is inline (<a href='namespace.def'>[namespace.def]</a>), any namespace from its enclosing namespace set.
Such a declaration may also be a definition.
If the declaration is not a definition, the specialization may be
defined later (<a href='namespace.memdef'>[namespace.memdef]</a>).</p></div><div class='para' id='expl.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-3'>3</a></div><p >A declaration of a function template, class template, or variable template being explicitly
specialized shall precede the declaration of
the explicit
specialization.
[&nbsp;<i>Note:</i><span class='space'></span>
A declaration, but not a definition of the template is required.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The definition of a class or class template shall precede the
declaration of an explicit specialization for a member template of the class
or class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;&gt; class X&lt;int&gt; { <span class='comment'>/* ... */</span> };          <span class='comment'>// error: <span class='texttt'>X</span> not a template
</span>
template&lt;class T&gt; class X;

template&lt;&gt; class X&lt;char*&gt; { <span class='comment'>/* ... */</span> };        <span class='comment'>// OK: <span class='texttt'>X</span> is a template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-4'>4</a></div><p >A member function, a member function template, a member class,
a member enumeration, a
member class template,
a static data member, or a static data member template of a class template
may be explicitly specialized for a class specialization that is implicitly
instantiated;
in this case, the definition of the class template shall
precede the explicit specialization for the member of the class
template.
If such an explicit specialization for the member of a class template names an
implicitly-declared special member function (Clause <a href='special'>[special]</a>),
the program is ill-formed.</p></div><div class='para' id='expl.spec-5'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-5'>5</a></div><p >A member of an explicitly specialized class is not implicitly
instantiated from the member declaration of the class template;
instead, the member of the class template specialization shall itself be
explicitly defined if its definition is required.
In this case, the definition of the class template explicit specialization
shall be in scope at the point at which the member is defined.
The definition of an explicitly specialized class is unrelated to the
definition of a generated specialization.
That is, its members need
not have the same names, types, etc. as the members of a generated
specialization.
Members of an explicitly specialized
class template are defined in the same manner as members of normal classes, and
not using the <span class='texttt'>template&lt;&gt;</span> syntax.
The same is true when defining a member of an explicitly specialized member
class. However, <span class='texttt'>template&lt;&gt;</span> is used in defining a member of an explicitly
specialized member class template that is specialized as a class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B { };
  template&lt;class U&gt; struct C { };
};

template&lt;&gt; struct A&lt;int&gt; {
  void f(int);
};

void h() {
  A&lt;int&gt; a;
  a.f(16);          <span class='comment'>// <span class='texttt'>A&lt;int&gt;::f</span> must be defined somewhere
</span>}

<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> not used for a member of an
</span><span class='comment'>// explicitly specialized class template
</span>void A&lt;int&gt;::f(int) { <span class='comment'>/* ... */</span> }

template&lt;&gt; struct A&lt;char&gt;::B {
  void f();
};
<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> also not used when defining a member of
</span><span class='comment'>// an explicitly specialized member class
</span>void A&lt;char&gt;::B::f() { <span class='comment'>/* ... */</span> }

template&lt;&gt; template&lt;class U&gt; struct A&lt;char&gt;::C {
  void f();
};
<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> is used when defining a member of an explicitly
</span><span class='comment'>// specialized member class template specialized as a class template
</span>template&lt;&gt;
template&lt;class U&gt; void A&lt;char&gt;::C&lt;U&gt;::f() { <span class='comment'>/* ... */</span> }

template&lt;&gt; struct A&lt;short&gt;::B {
  void f();
};
template&lt;&gt; void A&lt;short&gt;::B::f() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>template&lt;&gt;</span> not permitted
</span>
template&lt;&gt; template&lt;class U&gt; struct A&lt;short&gt;::C {
  void f();
};
template&lt;class U&gt; void A&lt;short&gt;::C&lt;U&gt;::f() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>template&lt;&gt;</span> required
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-6'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-6'>6</a></div><p >If a template, a member template or a member of a class template is explicitly
specialized then that specialization shall be declared before the first use of
that specialization that would cause an implicit instantiation to take place,
in every translation unit in which such a use occurs;
no diagnostic is required.
If the program does not provide a definition for an explicit specialization and
either the specialization is used in a way that would cause an implicit
instantiation to take place or the member is a virtual member function,
the program is ill-formed, no diagnostic required.
An implicit instantiation is never generated for an explicit specialization
that is declared but not defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class String { };
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

void f(Array&lt;String&gt;&amp; v) {
  sort(v);          <span class='comment'>// use primary template
</span>                    <span class='comment'>// <span class='texttt'>sort(Array&lt;T&gt;&amp;)</span>, <span class='texttt'>T</span> is <span class='texttt'>String</span>
</span>}

template&lt;&gt; void sort&lt;String&gt;(Array&lt;String&gt;&amp; v); <span class='comment'>// error: specialization
</span>                                                <span class='comment'>// after use of primary template
</span>template&lt;&gt; void sort&lt;&gt;(Array&lt;char*&gt;&amp; v);        <span class='comment'>// OK: <span class='texttt'>sort&lt;char*&gt;</span> not yet used
</span>template&lt;class T&gt; struct A {
  enum E : T;
  enum class S : T;
};
template&lt;&gt; enum A&lt;int&gt;::E : int { eint };         <span class='comment'>// OK
</span>template&lt;&gt; enum class A&lt;int&gt;::S : int { sint };   <span class='comment'>// OK
</span>template&lt;class T&gt; enum A&lt;T&gt;::E : T { eT };
template&lt;class T&gt; enum class A&lt;T&gt;::S : T { sT };
template&lt;&gt; enum A&lt;char&gt;::E : char { echar };       <span class='comment'>// ill-formed, <span class='texttt'>A&lt;char&gt;::E</span> was instantiated
</span>                                                   <span class='comment'>// when <span class='texttt'>A&lt;char&gt;</span> was instantiated
</span>template&lt;&gt; enum class A&lt;char&gt;::S : char { schar }; <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-7'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-7'>7</a></div><p >The placement of explicit specialization declarations for function templates, class
templates, variable templates,
member functions of class templates, static data members of class
templates, member classes of class templates, member enumerations of class
templates, member class templates of class
templates, member function templates of class templates,
static data member templates of class templates,
member functions of
member templates of class templates, member functions of member templates of
non-template classes,
static data member templates of non-template classes,
member function templates of member classes of class
templates, etc., and the placement of partial specialization declarations
of class templates, variable templates,
member class templates of non-template classes,
static data member templates of non-template classes, member
class templates of class templates, etc., can affect whether a program is
well-formed according to the relative positioning of the explicit specialization
declarations and their points of instantiation in the translation unit as
specified above and below.
<span class='indexparent'><a class='index' id='immolation!self'></a></span>When writing a specialization, be careful about its location;
or to make it compile will be such a trial as to kindle its self-immolation.</p></div><div class='para' id='expl.spec-8'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-8'>8</a></div><p >A template explicit specialization is in the scope of the namespace in which
the template was defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class X { <span class='comment'>/* ... */</span> };
  template&lt;class T&gt; class Y { <span class='comment'>/* ... */</span> };

  template&lt;&gt; class X&lt;int&gt; { <span class='comment'>/* ... */</span> };          <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in same namespace
</span>  template&lt;&gt; class Y&lt;double&gt;;                   <span class='comment'>// forward declare intent to
</span>                                                <span class='comment'>// specialize for <span class='texttt'>double</span>
</span>}

template&lt;&gt; class N::Y&lt;double&gt; { <span class='comment'>/* ... */</span> };      <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in enclosing namespace
</span>template&lt;&gt; class N::Y&lt;short&gt; { <span class='comment'>/* ... */</span> };       <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in enclosing namespace
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-9'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-9'>9</a></div><p >A
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
that names a class template explicit specialization that has been declared but
not defined can be used exactly like the names of other incompletely-defined
classes (<a href='basic.types'>[basic.types]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X;      <span class='comment'>// <span class='texttt'>X</span> is a class template
</span>template&lt;&gt; class X&lt;int&gt;;

X&lt;int&gt;* p;                      <span class='comment'>// OK: pointer to declared class <span class='texttt'>X&lt;int&gt;</span>
</span>X&lt;int&gt; x;                       <span class='comment'>// error: object of incomplete class <span class='texttt'>X&lt;int&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-10'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-10'>10</a></div><p >A trailing
<i ><a href='temp.names#template-argument'>template-argument</a></i>
can be left unspecified in the
<i ><a href='temp.names#template-id'>template-id</a></i>
naming an explicit function template specialization
provided it can be deduced from the function argument type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);

<span class='comment'>// explicit specialization for <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span><span class='comment'>// with deduced template-argument of type <span class='texttt'>int</span>
</span>template&lt;&gt; void sort(Array&lt;int&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-11'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-11'>11</a></div><p >A function with the same name as a template and a type that exactly matches that
of a template specialization is not an explicit specialization (<a href='temp.fct'>[temp.fct]</a>).</p></div><div class='para' id='expl.spec-12'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-12'>12</a></div><p >An explicit specialization of a function or variable template is inline
only if it is declared with the <span class='texttt'>inline</span>
specifier or defined as deleted, and independently of whether its
function or variable template is inline.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T) { <span class='comment'>/* ... */</span> }
template&lt;class T&gt; inline T g(T) { <span class='comment'>/* ... */</span> }

template&lt;&gt; inline void f&lt;&gt;(int) { <span class='comment'>/* ... */</span> }   <span class='comment'>// OK: inline
</span>template&lt;&gt; int g&lt;&gt;(int) { <span class='comment'>/* ... */</span> }           <span class='comment'>// OK: not inline
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-13'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-13'>13</a></div><p >An explicit specialization of a static data member of a template
or an explicit specialization of a static data member template is a
definition if the declaration includes an initializer;
otherwise, it is a declaration.
[&nbsp;<i>Note:</i><span class='space'></span>
The definition of a static data member of a template
that requires default-initialization must use a <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i>:</p><pre class='codeblock'>
template&lt;&gt; X Q&lt;int&gt;::x;         <span class='comment'>// declaration
</span>template&lt;&gt; X Q&lt;int&gt;::x ();      <span class='comment'>// error: declares a function
</span>template&lt;&gt; X Q&lt;int&gt;::x { };     <span class='comment'>// definition
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='expl.spec-14'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-14'>14</a></div><p >A member or a member template of a class template may be explicitly specialized
for a given implicit instantiation of the class template, even if the member
or member template is defined in the class template definition.
An explicit specialization of a member or member template is specified using the
syntax for explicit specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  void f(T);
  template&lt;class X1&gt; void g1(T, X1);
  template&lt;class X2&gt; void g2(T, X2);
  void h(T) { }
};

<span class='comment'>// specialization
</span>template&lt;&gt; void A&lt;int&gt;::f(int);

<span class='comment'>// out of class member template definition
</span>template&lt;class T&gt; template&lt;class X1&gt; void A&lt;T&gt;::g1(T, X1) { }

<span class='comment'>// member template specialization
</span>template&lt;&gt; template&lt;class X1&gt; void A&lt;int&gt;::g1(int, X1);

<span class='comment'>//member template specialization
</span>template&lt;&gt; template&lt;&gt;
  void A&lt;int&gt;::g1(int, char);           <span class='comment'>// <span class='texttt'>X1</span> deduced as <span class='texttt'>char</span>
</span>template&lt;&gt; template&lt;&gt;
  void A&lt;int&gt;::g2&lt;char&gt;(int, char);     <span class='comment'>// <span class='texttt'>X2</span> specified as <span class='texttt'>char</span>
</span>
<span class='comment'>// member specialization even if defined in class definition
</span>template&lt;&gt; void A&lt;int&gt;::h(int) { }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-15'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-15'>15</a></div><p >A member or a member template may be nested within many enclosing class
templates.
In an explicit specialization for such a member,
the member declaration shall be preceded by a
<span class='texttt'>template&lt;&gt;</span>
for each enclosing class template that is explicitly specialized.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1&gt; class A {
  template&lt;class T2&gt; class B {
    void mf();
  };
};
template&lt;&gt; template&lt;&gt; class A&lt;int&gt;::B&lt;double&gt;;
template&lt;&gt; template&lt;&gt; void A&lt;char&gt;::B&lt;char&gt;::mf();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-16'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-16'>16</a></div><p >In an explicit specialization declaration for a member of a class template or
a member template that appears in namespace scope,
the member template and some of its enclosing class templates may remain
unspecialized,
except that the declaration shall not explicitly specialize a class member
template if its enclosing class templates are not explicitly specialized
as well.
In such explicit specialization declaration, the keyword
<span class='texttt'>template</span>
followed by a
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
shall be provided instead of the
<span class='texttt'>template&lt;&gt;</span>
preceding the explicit specialization declaration of the member.
The types of the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
in the
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
shall be the same as those specified in the primary template definition.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T1&gt; class A {
  template&lt;class T2&gt; class B {
    template&lt;class T3&gt; void mf1(T3);
    void mf2();
  };
};
template &lt;&gt; template &lt;class X&gt;
  class A&lt;int&gt;::B {
      template &lt;class T&gt; void mf1(T);
  };
template &lt;&gt; template &lt;&gt; template&lt;class T&gt;
  void A&lt;int&gt;::B&lt;double&gt;::mf1(T t) { }
template &lt;class Y&gt; template &lt;&gt;
  void A&lt;Y&gt;::B&lt;double&gt;::mf2() { }       <span class='comment'>// ill-formed; <span class='texttt'>B&lt;double&gt;</span> is specialized but
</span>                                        <span class='comment'>// its enclosing class template <span class='texttt'>A</span> is not
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='expl.spec-17'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-17'>17</a></div><p >A specialization of a member function template, member class template,
or static data member template of
a non-specialized class template is itself a template.</p></div><div class='para' id='expl.spec-18'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-18'>18</a></div><p >An explicit specialization declaration shall not be a friend declaration.</p></div><div class='para' id='expl.spec-19'><div class='marginalizedparent'><a class='marginalized' href='#expl.spec-19'>19</a></div><p >Default function arguments shall not be specified in a declaration or
a definition for one of the following explicit specializations:</p><ul ><li ><p >the explicit specialization of a function template;
</p></li><li ><p >the explicit specialization of a member function template;
</p></li><li ><p >the explicit specialization of a member function of a class template where
the class template specialization to which the member function specialization
belongs is implicitly instantiated.
[&nbsp;<i>Note:</i><span class='space'></span>
Default function arguments may be specified in the declaration or
definition of a member function of a class template specialization that is
explicitly specialized.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div></div><div id='fct.spec'><h2 ><a class='secnum' href='#fct.spec' style='min-width:88pt'>14.8</a> Function template specializations <a class='abbr_ref' href='temp.fct.spec'>[temp.fct.spec]</a></h2><div class='para' id='fct.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#fct.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='template!function'></a></span>A function instantiated from a function template is called a function template
specialization; so is an explicit specialization of a function template.
Template arguments can be explicitly specified when naming the function
template specialization, deduced from the context (e.g.,
deduced from the function arguments in a call to the function template
specialization, see <a href='temp.deduct'>[temp.deduct]</a>), or obtained from default template arguments.</p></div><div class='para' id='fct.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#fct.spec-2'>2</a></div><p >Each function template specialization instantiated from a template
has its own copy of any static variable.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T* p) {
  static T s;
};

void g(int a, char* b) {
  f(&amp;a);            <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int*)</span>
</span>  f(&amp;b);            <span class='comment'>// calls <span class='texttt'>f&lt;char*&gt;(char**)</span>
</span>}
</pre><p >Here
<span class='texttt'>f&lt;int&gt;(int*)</span>
has a static variable
<span class='texttt'>s</span>
of type
<span class='texttt'>int</span>
and
<span class='texttt'>f&lt;char*&gt;(char**)</span>
has a static variable
<span class='texttt'>s</span>
of type
<span class='texttt'>char*</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='arg.explicit'><h3 ><a class='secnum' href='#arg.explicit' style='min-width:103pt'>14.8.1</a> Explicit template argument specification <a class='abbr_ref' href='temp.arg.explicit'>[temp.arg.explicit]</a></h3><div class='para' id='arg.explicit-1'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specification!template argument'></a></span>Template arguments can be specified when referring to a function
template specialization by qualifying the function template
name with the list of
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
in the same way as
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
are specified in uses of a class template specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);
void f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {
  sort&lt;dcomplex&gt;(cv);           <span class='comment'>// <span class='texttt'>sort(Array&lt;dcomplex&gt;&amp;)</span>
</span>  sort&lt;int&gt;(ci);                <span class='comment'>// <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span>}
</pre><p >and</p><pre class='codeblock'>
template&lt;class U, class V&gt; U convert(V v);

void g(double d) {
  int i = convert&lt;int,double&gt;(d);       <span class='comment'>// <span class='texttt'>int convert(double)</span>
</span>  char c = convert&lt;char,double&gt;(d);     <span class='comment'>// <span class='texttt'>char convert(double)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg.explicit-2'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-2'>2</a></div><p >A template argument list may be specified when referring to a specialization
of a function template</p><ul ><li ><p >when a function is called,
</p></li><li ><p >when the address of a function is taken, when a function initializes a
reference to function, or when a pointer to member function is formed,
</p></li><li ><p >in an explicit specialization,
</p></li><li ><p >in an explicit instantiation, or
</p></li><li ><p >in a friend declaration.
</p></li></ul></div><div class='para' id='arg.explicit-3'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-3'>3</a></div><p >Trailing template arguments that can be deduced (<a href='temp.deduct'>[temp.deduct]</a>) or
obtained from default
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
may be omitted from the list of explicit
<i ><a href='temp.names#template-argument'>template-arguments</a></i>.
A trailing template parameter pack (<a href='temp.variadic'>[temp.variadic]</a>) not otherwise deduced will be
deduced to an empty sequence of template arguments.
If all of the template arguments can be deduced, they may all be omitted;
in this case, the empty template argument list
<span class='texttt'>&lt;&gt;</span>
itself may also be omitted.
In contexts where deduction is done and fails, or in contexts where
deduction is not done, if a template argument list is specified and it,
along with any default template arguments, identifies a single function
template specialization, then the
<i ><a href='temp.names#template-id'>template-id</a></i>
is an lvalue for the function template specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class X, class Y&gt; X f(Y);
template&lt;class X, class Y, class ... Z&gt; X g(Y);
void h() {
  int i = f&lt;int&gt;(5.6);          <span class='comment'>// <span class='texttt'>Y</span> is deduced to be <span class='texttt'>double</span>
</span>  int j = f(5.6);               <span class='comment'>// ill-formed: <span class='texttt'>X</span> cannot be deduced
</span>  f&lt;void&gt;(f&lt;int, bool&gt;);        <span class='comment'>// <span class='texttt'>Y</span> for outer <span class='texttt'>f</span> deduced to be
</span>                                <span class='comment'>// <span class='texttt'>int (*)(bool)</span>
</span>  f&lt;void&gt;(f&lt;int&gt;);              <span class='comment'>// ill-formed: <span class='texttt'>f&lt;int&gt;</span> does not denote a
</span>                                <span class='comment'>// single function template specialization
</span>  int k = g&lt;int&gt;(5.6);          <span class='comment'>// <span class='texttt'>Y</span> is deduced to be double, <span class='texttt'>Z</span> is deduced to an empty sequence
</span>  f&lt;void&gt;(g&lt;int, bool&gt;);        <span class='comment'>// <span class='texttt'>Y</span> for outer <span class='texttt'>f</span> is deduced to be
</span>                                <span class='comment'>// <span class='texttt'>int (*)(bool)</span>, <span class='texttt'>Z</span> is deduced to an empty sequence
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg.explicit-4'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
An empty template argument list can be used to indicate that a given
use refers to a specialization of a function template even when a
non-template function (<a href='dcl.fct'>[dcl.fct]</a>) is visible that would otherwise be used.
For example:</p><pre class='codeblock'>
template &lt;class T&gt; int f(T);    <span class='comment'>// #1
</span>int f(int);                     <span class='comment'>// #2
</span>int k = f(1);                   <span class='comment'>// uses #2
</span>int l = f&lt;&gt;(1);                 <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.explicit-5'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-5'>5</a></div><p >Template arguments that are present shall be specified in the declaration
order of their corresponding
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>.
The template argument list shall not specify more
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
than there are corresponding
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
unless one of the <i ><a href='temp.param#template-parameter'>template-parameters</a></i> is a template
parameter pack.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class X, class Y, class Z&gt; X f(Y,Z);
template&lt;class ... Args&gt; void f2();
void g() {
  f&lt;int,const char*,double&gt;("aa",3.0);
  f&lt;int,const char*&gt;("aa",3.0);       <span class='comment'>// <span class='texttt'>Z</span> is deduced to be <span class='texttt'>double</span>
</span>  f&lt;int&gt;("aa",3.0);             <span class='comment'>// <span class='texttt'>Y</span> is deduced to be <span class='texttt'>const char*</span>, and
</span>                                <span class='comment'>// <span class='texttt'>Z</span> is deduced to be <span class='texttt'>double</span>
</span>  f("aa",3.0);                  <span class='comment'>// error: <span class='texttt'>X</span> cannot be deduced
</span>  f2&lt;char, short, int, long&gt;(); <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='arg.explicit-6'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-6'>6</a></div><p >Implicit conversions (Clause <a href='conv'>[conv]</a>) will be performed on a function argument
to convert it to the type of the corresponding function parameter if
the parameter type contains no
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
that participate in template argument deduction.
[&nbsp;<i>Note:</i><span class='space'></span>
Template parameters do not participate in template argument deduction if
they are explicitly specified.
For example,</p><pre class='codeblock'>
template&lt;class T&gt; void f(T);

class Complex {
  Complex(double);
};

void g() {
  f&lt;Complex&gt;(1);                <span class='comment'>// OK, means <span class='texttt'>f&lt;Complex&gt;(Complex(1))</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.explicit-7'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-7'>7</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Because the explicit template argument list follows the function
template name, and because conversion member function templates and
constructor member function templates are called without using a
function name, there is no way to provide an explicit template
argument list for these function templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]

</p></div><div class='para' id='arg.explicit-8'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For simple function names, argument dependent lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)
applies even when the function name is not visible within the scope of the call.
This is because the call still has the syntactic form of a function call (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>).
But when a function template with explicit template arguments is used,
the call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call.
If no such name is visible,
the call is not syntactically well-formed and argument-dependent lookup
does not apply.
If some such name is visible,
argument dependent lookup applies and additional function templates
may be found in other namespaces.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  struct B { };
  template&lt;int X&gt; void f(B);
}
namespace C {
  template&lt;class T&gt; void f(T t);
}
void g(A::B b) {
  f&lt;3&gt;(b);                      <span class='comment'>// ill-formed: not a function call
</span>  A::f&lt;3&gt;(b);                   <span class='comment'>// well-formed
</span>  C::f&lt;3&gt;(b);                   <span class='comment'>// ill-formed; argument dependent lookup
</span>                                <span class='comment'>// applies only to unqualified names
</span>  using C::f;
  f&lt;3&gt;(b);                      <span class='comment'>// well-formed because <span class='texttt'>C::f</span> is visible; then
</span>                                <span class='comment'>// <span class='texttt'>A::f</span> is found by argument dependent lookup
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='arg.explicit-9'><div class='marginalizedparent'><a class='marginalized' href='#arg.explicit-9'>9</a></div><p >Template argument deduction can extend the sequence of template
arguments corresponding to a template parameter pack, even when the
sequence contains explicitly specified template arguments.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... values);

void g() {
  f&lt;int*, float*&gt;(0, 0, 0);     <span class='comment'>// <span class='texttt'>Types</span> is deduced to the sequence <span class='texttt'>int*</span>, <span class='texttt'>float*</span>, <span class='texttt'>int</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='deduct'><h3 ><a class='secnum' href='#deduct' style='min-width:103pt'>14.8.2</a> Template argument deduction <a class='abbr_ref' href='temp.deduct'>[temp.deduct]</a></h3><div class='para' id='deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct-1'>1</a></div><p >When a
function template
specialization is referenced, all of the
template arguments shall have values.
The values can be
explicitly specified or, in some cases, be deduced from the use
or obtained from default
<i ><a href='temp.names#template-argument'>template-arguments</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {
  sort(cv);                     <span class='comment'>// calls <span class='texttt'>sort(Array&lt;dcomplex&gt;&amp;)</span>
</span>  sort(ci);                     <span class='comment'>// calls <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span>}
</pre><p >and</p><pre class='codeblock'>
void g(double d) {
  int i = convert&lt;int&gt;(d);      <span class='comment'>// calls <span class='texttt'>convert&lt;int,double&gt;(double)</span>
</span>  int c = convert&lt;char&gt;(d);     <span class='comment'>// calls <span class='texttt'>convert&lt;char,double&gt;(double)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct-2'>2</a></div><p >When an explicit template argument list is specified, the template
arguments must be compatible with the template parameter list and must
result in a valid function type as described below; otherwise type
deduction fails.  Specifically, the following steps are performed when
evaluating an explicitly specified template argument list with respect
to a given function template:</p><ul ><li ><p >The specified template arguments must match the template parameters in
kind (i.e., type, non-type, template). There
must not be more arguments than there are parameters
unless at least one parameter is a template parameter pack, and there shall be
an argument for each non-pack parameter.
Otherwise, type deduction fails.</p></li><li ><p >Non-type arguments must match the types of the corresponding non-type
template parameters, or must be convertible to the types of the
corresponding non-type parameters as specified in <a href='temp.arg.nontype'>[temp.arg.nontype]</a>, otherwise type deduction fails.</p></li><li ><p >The specified template argument values are substituted for the
corresponding template parameters as specified below.
</p></li></ul></div><div class='para' id='deduct-3'><div class='marginalizedparent'><a class='marginalized' href='#deduct-3'>3</a></div><p >After this substitution is performed, the function parameter type
adjustments described in <a href='dcl.fct'>[dcl.fct]</a> are performed.
[&nbsp;<i>Example:</i><span class='space'></span>
A parameter type of “<span class='texttt'>void (const int, int[5])</span>” becomes
“<span class='texttt'>void(*)(int,int*)</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
A top-level qualifier in a function parameter declaration does not affect
the function type but still affects the type of the function parameter
variable within the function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; void f(T t);
template &lt;class X&gt; void g(const X x);
template &lt;class Z&gt; void h(Z, Z*);

int main() {
  <span class='comment'>// #1: function type is <span class='texttt'>f(int)</span>, <span class='texttt'>t</span> is non <span class='texttt'>const</span>
</span>  f&lt;int&gt;(1);

  <span class='comment'>// #2: function type is <span class='texttt'>f(int)</span>, <span class='texttt'>t</span> is <span class='texttt'>const</span>
</span>  f&lt;const int&gt;(1);

  <span class='comment'>// #3: function type is <span class='texttt'>g(int)</span>, <span class='texttt'>x</span> is <span class='texttt'>const</span>
</span>  g&lt;int&gt;(1);

  <span class='comment'>// #4: function type is <span class='texttt'>g(int)</span>, <span class='texttt'>x</span> is <span class='texttt'>const</span>
</span>  g&lt;const int&gt;(1);

  <span class='comment'>// #5: function type is <span class='texttt'>h(int, const int*)</span>
</span>  h&lt;const int&gt;(1,0);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct-4'><div class='marginalizedparent'><a class='marginalized' href='#deduct-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='texttt'>f&lt;int&gt;(1)</span> and <span class='texttt'>f&lt;const int&gt;(1)</span> call distinct functions
even though both of the functions called have the same function type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='deduct-5'><div class='marginalizedparent'><a class='marginalized' href='#deduct-5'>5</a></div><p >The resulting substituted and adjusted function type is used as
the type of the function template for template argument
deduction.  If a template argument has not been deduced and its
corresponding template parameter has a default argument, the
template argument is determined by substituting the template 
arguments determined for preceding template parameters into the
default argument. If the substitution results in an invalid type,
as described above, type deduction fails.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T, class U = double&gt;
void f(T t = 0, U u = 0);

void g() {
  f(1, 'c');        <span class='comment'>// <span class='texttt'>f&lt;int,char&gt;(1,'c')</span>
</span>  f(1);             <span class='comment'>// <span class='texttt'>f&lt;int,double&gt;(1,0)</span>
</span>  f();              <span class='comment'>// error: <span class='texttt'>T</span> cannot be deduced
</span>  f&lt;int&gt;();         <span class='comment'>// <span class='texttt'>f&lt;int,double&gt;(0,0)</span>
</span>  f&lt;int,char&gt;();    <span class='comment'>// <span class='texttt'>f&lt;int,char&gt;(0,0)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >When all template arguments have been deduced or obtained from
default template arguments, all uses of template parameters in
the template parameter list of the template and the function type
are replaced with the corresponding deduced
or default argument values. If the substitution results in an
invalid type, as described above, type deduction fails.</p></div><div class='para' id='deduct-6'><div class='marginalizedparent'><a class='marginalized' href='#deduct-6'>6</a></div><p >At certain points in the template argument deduction process it is necessary
to take a function type that makes use of template parameters and replace those
template parameters with the corresponding template arguments. This is done at
the beginning of template argument deduction when any explicitly specified
template arguments are substituted into the function type, and again at the end
of template argument deduction when any template arguments that were deduced or
obtained from default arguments are substituted.</p></div><div class='para' id='deduct-7'><div class='marginalizedparent'><a class='marginalized' href='#deduct-7'>7</a></div><p >The substitution occurs in all types and expressions that are used in the function
type and in template parameter declarations. The expressions include not only
constant expressions such as those that appear in array bounds or as nontype
template arguments but also general expressions (i.e., non-constant expressions)
inside <span class='texttt'>sizeof</span>, <span class='texttt'>decltype</span>, and other contexts that allow non-constant
expressions. The substitution proceeds in lexical order and stops when
a condition that causes deduction to fail is encountered. [&nbsp;<i>Note:</i><span class='space'></span> The equivalent substitution in exception specifications is
done only when the <i ><a href='except.spec#exception-specification'>exception-specification</a></i> is instantiated, at which point a program is ill-formed
if the substitution results in an invalid type or
expression. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A { using X = typename T::X; };
template &lt;class T&gt; typename T::X f(typename A&lt;T&gt;::X);
template &lt;class T&gt; void f(...) { }
template &lt;class T&gt; auto g(typename A&lt;T&gt;::X) -&gt; typename T::X;
template &lt;class T&gt; void g(...) { }

void h() {
  f&lt;int&gt;(0); <span class='comment'>// OK, substituting return type causes deduction to fail
</span>  g&lt;int&gt;(0); <span class='comment'>// error, substituting parameter type instantiates <span class='texttt'>A&lt;int&gt;</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct-8'><div class='marginalizedparent'><a class='marginalized' href='#deduct-8'>8</a></div><p >If a substitution results in an invalid type or expression, type deduction fails. An
invalid type or expression is one that would be ill-formed, with a diagnostic
required, if written using the substituted arguments. [&nbsp;<i>Note:</i><span class='space'></span> If no
diagnostic is required, the program is still ill-formed. Access checking is done
as part of the substitution
process. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Only invalid types and expressions in the immediate
context of the function type and its template parameter types can result in a deduction
failure. [&nbsp;<i>Note:</i><span class='space'></span> The evaluation of the substituted types and expressions can result
in side effects such as the instantiation of class template specializations and/or
function template specializations, the generation of implicitly-defined functions,
etc. Such side effects are not in the “immediate context” and can result in the
program being ill-formed.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct X { };
struct Y {
  Y(X){}
};

template &lt;class T&gt; auto f(T t1, T t2) -&gt; decltype(t1 + t2); <span class='comment'>// #1
</span>X f(Y, Y);  <span class='comment'>// #2
</span>
X x1, x2;
X x3 = f(x1, x2);  <span class='comment'>// deduction fails on #1 (cannot add <span class='texttt'>X+X</span>), calls #2</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i><span class='space'></span> Type deduction may fail for
the following reasons:</p><ul ><li ><p >Attempting to instantiate a pack expansion containing multiple parameter packs of differing lengths.
</p></li><li ><p >Attempting to create an array with an element type that is <span class='texttt'>void</span>, a
function type, a reference type, or an abstract class type, or attempting
to create an array with a size that is zero or negative.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; int f(T[5]);
int I = f&lt;int&gt;(0);
int j = f&lt;void&gt;(0);             <span class='comment'>// invalid array
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >Attempting to use a type that is not a class or enumeration type in a qualified name.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; int f(typename T::B*);
int i = f&lt;int&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >Attempting to use a type in a <i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i> of a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i> when
that type does not contain the specified member, or
</p><ul ><li ><p >the specified member is not a type where a type is required, or
</p></li><li ><p >the specified member is not a template where a template is required, or
</p></li><li ><p >the specified member is not a non-type where a non-type is required.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;int I&gt; struct X { };
template &lt;template &lt;class T&gt; class&gt; struct Z { };
template &lt;class T&gt; void f(typename T::Y*){}
template &lt;class T&gt; void g(X&lt;T::N&gt;*){}
template &lt;class T&gt; void h(Z&lt;T::template TT&gt;*){}
struct A {};
struct B { int Y; };
struct C {
  typedef int N;
};
struct D {
  typedef int TT;
};

int main() {
  <span class='comment'>// Deduction fails in each of these cases:
</span>  f&lt;A&gt;(0);  <span class='comment'>// <span class='texttt'>A</span> does not contain a member <span class='texttt'>Y</span>
</span>  f&lt;B&gt;(0);  <span class='comment'>// The <span class='texttt'>Y</span> member of <span class='texttt'>B</span> is not a type
</span>  g&lt;C&gt;(0);  <span class='comment'>// The <span class='texttt'>N</span> member of <span class='texttt'>C</span> is not a non-type
</span>  h&lt;D&gt;(0);  <span class='comment'>// The <span class='texttt'>TT</span> member of <span class='texttt'>D</span> is not a template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >Attempting to create a pointer to reference type.
</p></li><li ><p >Attempting to create a reference to <span class='texttt'>void</span>.
</p></li><li ><p >Attempting to create “pointer to member of <span class='texttt'>T</span>” when <span class='texttt'>T</span> is not a
class type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; int f(int T::*);
int i = f&lt;int&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >Attempting to give an invalid type to a non-type template parameter.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T, T&gt; struct S {};
template &lt;class T&gt; int f(S&lt;T, T()&gt;*);
struct X {};
int i0 = f&lt;X&gt;(0);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Attempting to perform an invalid conversion in either a template
argument expression, or an expression used in the function
declaration.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T, T*&gt; int f(int);
int i2 = f&lt;int,1&gt;(0);           <span class='comment'>// can't conv <span class='texttt'>1</span> to <span class='texttt'>int*</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Attempting to create a function type in which a parameter has a type
of <span class='texttt'>void</span>, or in which the return type is a function type
or array type.</p></li><li ><p >Attempting to create a function type in which a parameter type or the return type is an
abstract class type (<a href='class.abstract'>[class.abstract]</a>).
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='deduct-9'><div class='marginalizedparent'><a class='marginalized' href='#deduct-9'>9</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
In the following example,
assuming a <span class='texttt'>signed char</span>
cannot represent the value 1000,
a narrowing conversion (<a href='dcl.init.list'>[dcl.init.list]</a>)
would be required
to convert the <i ><a href='temp.names#template-argument'>template-argument</a></i>
of type <span class='texttt'>int</span> to <span class='texttt'>signed char</span>,
therefore substitution fails for the
second template (<a href='temp.arg.nontype'>[temp.arg.nontype]</a>).</p><pre class='codeblock'>
template &lt;int&gt; int f(int);
template &lt;signed char&gt; int f(int);
int i1 = f&lt;1000&gt;(0);         <span class='comment'>// OK
</span>int i2 = f&lt;1&gt;(0);            <span class='comment'>// ambiguous; not narrowing
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='deduct.call'><h4 ><a class='secnum' href='#deduct.call' style='min-width:118pt'>14.8.2.1</a> Deducing template arguments from a function call <a class='abbr_ref' href='temp.deduct.call'>[temp.deduct.call]</a></h4><div class='para' id='deduct.call-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-1'>1</a></div><p >Template argument deduction is done by comparing each function
template parameter type (call it
<span class='texttt'>P</span>)
that contains <i ><a href='temp.param#template-parameter'>template-parameters</a></i> that participate in template argument deduction
with the type of the corresponding argument of the call (call it
<span class='texttt'>A</span>)
as described below.
If removing references and cv-qualifiers from <span class='texttt'>P</span> gives
<span class='texttt'>std::initializer_list&lt;P<span class='math'>'</span>&gt;</span>
or <span class='texttt'>P<span class='math'>'</span>[N]</span>
for some <span class='texttt'>P<span class='math'>'</span></span> and <span class='texttt'>N</span> and the
argument is a non-empty initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), then deduction is
performed instead for each element of the initializer list, taking
<span class='texttt'>P<span class='math'>'</span></span> as a function template parameter type and the initializer
element as its argument,
and in the <span class='texttt'>P<span class='math'>'</span>[N]</span> case, if <span class='texttt'>N</span> is a non-type template parameter,
<span class='texttt'>N</span> is deduced from the length of the initializer list.
Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context (<a href='temp.deduct.type'>[temp.deduct.type]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);
f({1,2,3});                 <span class='comment'>// <span class='texttt'>T</span> deduced to <span class='texttt'>int</span>
</span>f({1,"asdf"});              <span class='comment'>// error: <span class='texttt'>T</span> deduced to both <span class='texttt'>int</span> and <span class='texttt'>const char*</span>
</span>
template&lt;class T&gt; void g(T);
g({1,2,3});                 <span class='comment'>// error: no argument deduced for <span class='texttt'>T</span>
</span>
template&lt;class T, int N&gt; void h(T const(&amp;)[N]);
h({1,2,3});                 <span class='comment'>// <span class='texttt'>T</span> deduced to <span class='texttt'>int</span>, <span class='texttt'>N</span> deduced to <span class='texttt'>3</span>
</span>
template&lt;class T&gt; void j(T const(&amp;)[3]);
j({42});                    <span class='comment'>// <span class='texttt'>T</span> deduced to <span class='texttt'>int</span>, array bound not considered
</span>
struct Aggr { int i; int j; };
template&lt;int N&gt; void k(Aggr const(&amp;)[N]);
k({1,2,3});                 <span class='comment'>// error: deduction fails, no conversion from <span class='texttt'>int</span> to <span class='texttt'>Aggr</span>
</span>k({{1},{2},{3}});           <span class='comment'>// OK, <span class='texttt'>N</span> deduced to <span class='texttt'>3</span>
</span>
template&lt;int M, int N&gt; void m(int const(&amp;)[M][N]);
m({{1,2},{3,4}});           <span class='comment'>// <span class='texttt'>M</span> and <span class='texttt'>N</span> both deduced to <span class='texttt'>2</span>
</span>
template&lt;class T, int N&gt; void n(T const(&amp;)[N], T);
n({{1},{2},{3}},Aggr());    <span class='comment'>// OK, <span class='texttt'>T</span> is <span class='texttt'>Aggr</span>, <span class='texttt'>N</span> is <span class='texttt'>3</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
For a function parameter pack that occurs at the end
of the <i ><a href='dcl.fct#parameter-declaration-list'>parameter-declaration-list</a></i>,
deduction is performed for each remaining argument of the call,
taking the type <span class='texttt'>P</span>
of the <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> of the function parameter pack
as the corresponding function template parameter type.
Each deduction deduces template arguments for subsequent positions in
the template parameter packs expanded by the function parameter pack.
When a function parameter pack appears in a non-deduced
context (<a href='temp.deduct.type'>[temp.deduct.type]</a>), the type of that parameter pack is
never deduced.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types&amp; ...);
template&lt;class T1, class ... Types&gt; void g(T1, Types ...);
template&lt;class T1, class ... Types&gt; void g1(Types ..., T1);

void h(int x, float&amp; y) {
  const int z = x;
  f(x, y, z);                  <span class='comment'>// <span class='texttt'>Types</span> is deduced to <span class='texttt'>int</span>, <span class='texttt'>float</span>, <span class='texttt'>const int</span>
</span>  g(x, y, z);                  <span class='comment'>// <span class='texttt'>T1</span> is deduced to <span class='texttt'>int</span>; <span class='texttt'>Types</span> is deduced to <span class='texttt'>float</span>, <span class='texttt'>int</span>
</span>  g1(x, y, z);                 <span class='comment'>// error: <span class='texttt'>Types</span> is not deduced
</span>  g1&lt;int, int, int&gt;(x, y, z);  <span class='comment'>// OK, no deduction occurs
</span>
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.call-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-2'>2</a></div><p >If
<span class='texttt'>P</span>
is not a reference type:</p><ul ><li ><p >If
<span class='texttt'>A</span>
is an array type, the pointer type produced by the array-to-pointer
standard conversion (<a href='conv.array'>[conv.array]</a>) is used in place of
<span class='texttt'>A</span>
for type deduction;
otherwise,
</p></li><li ><p >If
<span class='texttt'>A</span>
is a function type, the pointer type produced by the
function-to-pointer standard conversion (<a href='conv.func'>[conv.func]</a>) is used in place
of
<span class='texttt'>A</span>
for type
deduction; otherwise,
</p></li><li ><p >If
<span class='texttt'>A</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction.
</p></li></ul></div><div class='para' id='deduct.call-3'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-3'>3</a></div><p ><span class='indexparent'><a class='index' id='reference!forwarding'></a></span>If
<span class='texttt'>P</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction.
If
<span class='texttt'>P</span>
is a reference type, the type
referred to by
<span class='texttt'>P</span>
is used for type deduction.
A <a id='forwarding reference'><i>forwarding reference</i></a>
is an rvalue reference to a cv-unqualified template parameter.
If <span class='texttt'>P</span> is a forwarding reference and the argument is an
lvalue, the type “lvalue reference to <span class='texttt'>A</span>” is used in place of <span class='texttt'>A</span> for type
deduction. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; int f(T&amp;&amp; heisenreference);
template &lt;class T&gt; int g(const T&amp;&amp;);
int i;
int n1 = f(i);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&amp;&gt;(int&amp;)</span>
</span>int n2 = f(0);                  <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int&amp;&amp;)</span>
</span>int n3 = g(i);                  <span class='comment'>// error: would call <span class='texttt'>g&lt;int&gt;(const int&amp;&amp;)</span>, which
</span>                                <span class='comment'>// would bind an rvalue reference to an lvalue
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.call-4'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-4'>4</a></div><p >In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>
(after
the type
<span class='texttt'>A</span>
is transformed as described above).
However, there are
three cases that allow a difference:</p><ul ><li ><p >If the original
<span class='texttt'>P</span>
is a reference type, the deduced
<span class='texttt'>A</span>
(i.e.,
the type referred to by the reference) can be more cv-qualified than
the transformed <span class='texttt'>A</span>.
</p></li><li ><p >The transformed <span class='texttt'>A</span>
can be another pointer or pointer to member type that can be converted
to the deduced
<span class='texttt'>A</span>
via a function pointer conversion (<a href='conv.fctptr'>[conv.fctptr]</a>) and/or
qualification conversion (<a href='conv.qual'>[conv.qual]</a>).</p></li><li ><p >If
<span class='texttt'>P</span>
is a class and
<span class='texttt'>P</span>
has the form
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>,
then
the transformed <span class='texttt'>A</span>
can be a derived class of the
deduced
<span class='texttt'>A</span>.
Likewise, if
<span class='texttt'>P</span>
is a pointer to a class of the form
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>,
the transformed <span class='texttt'>A</span>
can be a pointer to a
derived class pointed to by the deduced
<span class='texttt'>A</span>.
</p></li></ul></div><div class='para' id='deduct.call-5'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-5'>5</a></div><p >These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails.
[&nbsp;<i>Note:</i><span class='space'></span>
If a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is not used in any of the function parameters of a function template,
or is used only in a non-deduced context, its corresponding
<i ><a href='temp.names#template-argument'>template-argument</a></i>
cannot be deduced from a function call and the
<i ><a href='temp.names#template-argument'>template-argument</a></i>
must be explicitly specified.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='deduct.call-6'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-6'>6</a></div><p >When
<span class='texttt'>P</span>
is a function type, function pointer type, or pointer to member
function type:
</p><ul ><li ><p >If the argument is an overload set containing one or more function templates,
the parameter is treated as a non-deduced context.
</p></li><li ><p >If the argument is an overload set (not containing function templates), trial
argument deduction is attempted using each of the members of the set. If
deduction succeeds for only one of the overload set members, that member is
used as the argument value for the deduction. If deduction succeeds for more than
one member of the overload set the parameter is treated as a non-deduced context.
</p></li></ul></div><div class='para' id='deduct.call-7'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-7'>7</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// Only one function of an overload set matches the call so the function
</span><span class='comment'>// parameter is a deduced context.
</span>template &lt;class T&gt; int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g);       <span class='comment'>// calls <span class='texttt'>f(int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.call-8'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-8'>8</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// Ambiguous deduction causes the second function parameter to be a
</span><span class='comment'>// non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.call-9'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-9'>9</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// The overload set contains a template, causing the second function
</span><span class='comment'>// parameter to be a non-deduced context.
</span>template &lt;class T&gt; int f(T, T (*p)(T));
char g(char);
template &lt;class T&gt; T g(T);
int i = f(1, g);    <span class='comment'>// calls <span class='texttt'>f(int, int (*)(int))</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.call-10'><div class='marginalizedparent'><a class='marginalized' href='#deduct.call-10'>10</a></div><p >If deduction succeeds for all parameters that contain
<i ><a href='temp.param#template-parameter'>template-parameters</a></i> that participate in template argument
deduction, and all template arguments are explicitly specified, deduced,
or obtained from default template arguments, remaining parameters are then
compared with the corresponding arguments. For each remaining parameter
<span class='texttt'>P</span> with a type that was non-dependent before substitution of any
explicitly-specified template arguments, if the corresponding argument
<span class='texttt'>A</span> cannot be implicitly converted to <span class='texttt'>P</span>, deduction fails.
[&nbsp;<i>Note:</i><span class='space'></span>
Parameters with dependent types in which no <i ><a href='temp.param#template-parameter'>template-parameters</a></i>
participate in template argument deduction, and parameters that became
non-dependent due to substitution of explicitly-specified template arguments,
will be checked during overload resolution.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  template &lt;class T&gt; struct Z {
    typedef typename T::x xx;
  };
  template &lt;class T&gt; typename Z&lt;T&gt;::xx f(void *, T); <span class='comment'>// #1
</span>  template &lt;class T&gt; void f(int, T);                 <span class='comment'>// #2
</span>  struct A {} a;
  int main() {
    f(1, a);       <span class='comment'>// OK, deduction fails for #1 because there is no conversion from int to void*
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='deduct.funcaddr'><h4 ><a class='secnum' href='#deduct.funcaddr' style='min-width:118pt'>14.8.2.2</a> Deducing template arguments taking the address of a function template <a class='abbr_ref' href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a></h4><div class='para' id='deduct.funcaddr-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.funcaddr-1'>1</a></div><p >Template arguments can be deduced from the type specified when taking
the address of an overloaded function (<a href='over.over'>[over.over]</a>).
The function template's function type and the specified type
are used as the types of
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
and the deduction is done as
described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='deduct.funcaddr-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.funcaddr-2'>2</a></div><p >A placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>) in the return type of a
function template is a non-deduced context. If template argument
deduction succeeds for such a function, the return type is determined
from instantiation of the function body.</p></div></div><div id='deduct.conv'><h4 ><a class='secnum' href='#deduct.conv' style='min-width:118pt'>14.8.2.3</a> Deducing conversion function template arguments <a class='abbr_ref' href='temp.deduct.conv'>[temp.deduct.conv]</a></h4><div class='para' id='deduct.conv-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-1'>1</a></div><p >Template argument deduction is done by comparing the return type of
the
conversion function template
(call it
<span class='texttt'>P</span>)
with the type that is
required as the result of the conversion (call it
<span class='texttt'>A</span>; see <a href='dcl.init'>[dcl.init]</a>, <a href='over.match.conv'>[over.match.conv]</a>, and <a href='over.match.ref'>[over.match.ref]</a>
for the determination of that type)
as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='deduct.conv-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-2'>2</a></div><p >If <span class='texttt'>P</span> is a reference type, the type referred to by <span class='texttt'>P</span> is used in place
of <span class='texttt'>P</span> for type deduction and for any further references to or transformations of
<span class='texttt'>P</span> in the remainder of this section.</p></div><div class='para' id='deduct.conv-3'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-3'>3</a></div><p >If
<span class='texttt'>A</span>
is not a reference type:</p><ul ><li ><p >If
<span class='texttt'>P</span>
is an array type, the pointer type produced by the
array-to-pointer standard conversion (<a href='conv.array'>[conv.array]</a>) is used in place of
<span class='texttt'>P</span>
for type
deduction; otherwise,
</p></li><li ><p >If
<span class='texttt'>P</span>
is a function type, the pointer type produced by the
function-to-pointer standard conversion (<a href='conv.func'>[conv.func]</a>) is used in place of
<span class='texttt'>P</span>
for
type deduction; otherwise,
</p></li><li ><p >If
<span class='texttt'>P</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>P</span>'s
type are ignored for type deduction.
</p></li></ul></div><div class='para' id='deduct.conv-4'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-4'>4</a></div><p >If
<span class='texttt'>A</span>
is a cv-qualified type, the top-level cv-qualifiers of
<span class='texttt'>A</span>'s
type are ignored for type deduction.
If
<span class='texttt'>A</span>
is a
reference type, the type referred to by
<span class='texttt'>A</span>
is used for type deduction.</p></div><div class='para' id='deduct.conv-5'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-5'>5</a></div><p >In general, the deduction process attempts to find template argument
values that will make the deduced
<span class='texttt'>A</span>
identical to
<span class='texttt'>A</span>.
However, there are four cases that allow a difference:</p><ul ><li ><p >If the original <span class='texttt'>A</span> is a reference type,
<span class='texttt'>A</span> can be more cv-qualified than the deduced <span class='texttt'>A</span>
(i.e., the type referred to by the reference)
</p></li><li ><p >If the original <span class='texttt'>A</span> is a function pointer type,
<span class='texttt'>A</span> can be “pointer to function”
even if the deduced <span class='texttt'>A</span> is “pointer to noexcept function”.
</p></li><li ><p >If the original <span class='texttt'>A</span> is a pointer to member function type,
<span class='texttt'>A</span> can be “pointer to member of type function”
even if the deduced <span class='texttt'>A</span> is “pointer to member of type noexcept function”.
</p></li><li ><p >The deduced <span class='texttt'>A</span>
can be another pointer or pointer to member type that
can be converted to <span class='texttt'>A</span> via a qualification conversion.
</p></li></ul></div><div class='para' id='deduct.conv-6'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-6'>6</a></div><p >These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
<span class='texttt'>A</span>,
the type deduction fails.</p></div><div class='para' id='deduct.conv-7'><div class='marginalizedparent'><a class='marginalized' href='#deduct.conv-7'>7</a></div><p >When the deduction process requires a qualification conversion for a
pointer or pointer to member type as described above, the following
process is used to determine the deduced template argument values:</p><p >If
<span class='texttt'>A</span>
is a type
<span class='list'></span><span class='item'></span><span class='relax'></span>
<span class='math'><span class='mathit'>cv</span><sub >1,0</sub></span> “pointer to <span class='math'>&hellip;</span>” <span class='math'><span class='mathit'>cv</span><sub >1,<span class='mathalpha'>n</span>-1</sub></span> “pointer to”
<span class='math'><span class='mathit'>cv</span><sub >1,<span class='mathalpha'>n</span></sub><span class='mathit'>T1</span></span>

and
<span class='texttt'>P</span>
is a type
<span class='list'></span><span class='item'></span><span class='relax'></span>
<span class='math'><span class='mathit'>cv</span><sub >2,0</sub></span> “pointer to <span class='math'>&hellip;</span>” <span class='math'><span class='mathit'>cv</span><sub >2,<span class='mathalpha'>n</span>-1</sub></span> “pointer to”
<span class='math'><span class='mathit'>cv</span><sub >2,<span class='mathalpha'>n</span></sub><span class='mathit'>T2</span></span>

The cv-unqualified
<span class='texttt'>T1</span>
and
<span class='texttt'>T2</span>
are used as the types of
<span class='texttt'>A</span>
and
<span class='texttt'>P</span>
respectively for type deduction.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; operator T***();
};
A a;
const int * const * const * p1 = a;     <span class='comment'>// <span class='texttt'>T</span> is deduced as <span class='texttt'>int</span>, not <span class='texttt'>const int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='deduct.partial'><h4 ><a class='secnum' href='#deduct.partial' style='min-width:118pt'>14.8.2.4</a> Deducing template arguments during partial ordering <a class='abbr_ref' href='temp.deduct.partial'>[temp.deduct.partial]</a></h4><div class='para' id='deduct.partial-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-1'>1</a></div><p >Template argument deduction is done by comparing certain types associated with
the two function templates being compared.</p></div><div class='para' id='deduct.partial-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-2'>2</a></div><p >Two sets of types are used to determine the partial ordering.  For each of
the templates involved there is the original function type and the
transformed function type.
[&nbsp;<i>Note:</i><span class='space'></span>
The creation of the transformed type is described in <a href='temp.func.order'>[temp.func.order]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The deduction process uses the
transformed type as the argument template and the original type of the
other template as the parameter template.  This process is done twice
for each type involved in the partial ordering comparison: once using
the transformed template-1 as the argument template and template-2 as
the parameter template and again using the transformed template-2 as
the argument template and template-1 as the parameter template.</p></div><div class='para' id='deduct.partial-3'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-3'>3</a></div><p >The types used to determine the ordering depend on the context in which
the partial ordering is done:</p><ul ><li ><p >In the context of a function call, the types used are those function parameter types
for which the function call has arguments.<a class='footnotenum' href='#footnote-141'>141</a>
</p></li><li ><p >In the context of a call to a conversion function, the return types of
the conversion function templates are used.
</p></li><li ><p >In other contexts (<a href='temp.func.order'>[temp.func.order]</a>) the function template's function
type is used.
</p></li></ul></div><div class='para' id='deduct.partial-4'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-4'>4</a></div><p >Each type nominated above from the parameter template and the corresponding type from the
argument template are used as the types of
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>.
If a particular <span class='texttt'>P</span> contains no <i ><a href='temp.param#template-parameter'>template-parameters</a></i>
that participate in template argument deduction, that <span class='texttt'>P</span> is not
used to determine the ordering.</p></div><div class='para' id='deduct.partial-5'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-5'>5</a></div><p >Before the partial ordering is done, certain transformations are performed
on the types used for partial ordering:</p><ul ><li ><p >If
<span class='texttt'>P</span>
is a reference type,
<span class='texttt'>P</span>
is replaced by the type referred to.
</p></li><li ><p >If
<span class='texttt'>A</span>
is a reference type,
<span class='texttt'>A</span>
is replaced by the type referred to.
</p></li></ul></div><div class='para' id='deduct.partial-6'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-6'>6</a></div><p >If both
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>
were reference types (before being replaced with the type referred to
above), determine which of the two types (if any) is more cv-qualified
than the other; otherwise the types are considered to be equally
cv-qualified for partial ordering purposes. The result of this
determination will be used below.</p></div><div class='para' id='deduct.partial-7'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-7'>7</a></div><p >Remove any top-level cv-qualifiers:
</p><ul ><li ><p >If
<span class='texttt'>P</span>
is a cv-qualified type,
<span class='texttt'>P</span>
is replaced by the cv-unqualified version of
<span class='texttt'>P</span>.
</p></li><li ><p >If
<span class='texttt'>A</span>
is a cv-qualified type,
<span class='texttt'>A</span>
is replaced by the cv-unqualified version of
<span class='texttt'>A</span>.
</p></li></ul></div><div class='para' id='deduct.partial-8'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-8'>8</a></div><p >If <span class='texttt'>A</span> was transformed from a function parameter pack and <span class='texttt'>P</span> is not
a parameter pack, type deduction fails. Otherwise, using
the resulting types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
the deduction is then done as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.
If <span class='texttt'>P</span> is a function parameter pack, the type <span class='texttt'>A</span> of each remaining
parameter type of the argument template is compared with the type <span class='texttt'>P</span> of
the <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> of the function parameter pack. Each comparison
deduces template arguments for subsequent positions in the template parameter
packs expanded by the function parameter pack.
If deduction succeeds for a given type,
the type from the argument template is considered to be at least as specialized
as the type from the parameter template.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class... Args&gt;           void f(Args... args);           <span class='comment'>// #1
</span>template&lt;class T1, class... Args&gt; void f(T1 a1, Args... args);    <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;      void f(T1 a1, T2 a2);           <span class='comment'>// #3
</span>
f();                  <span class='comment'>// calls #1
</span>f(1, 2, 3);           <span class='comment'>// calls #2
</span>f(1, 2);              <span class='comment'>// calls #3; non-variadic template #3 is more
</span>                      <span class='comment'>// specialized than the variadic templates #1 and #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.partial-9'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-9'>9</a></div><p >If, for a given type, deduction succeeds in both directions (i.e., the
types are identical after the transformations above)
and both <span class='texttt'>P</span> and <span class='texttt'>A</span> were reference types (before being replaced with the
type referred to above):</p><ul ><li ><p >if the type from the argument template was an lvalue reference and the type
from the parameter template was not,
the parameter type is not considered to be
at least as specialized as the argument type; otherwise,</p></li><li ><p >if the type from
the argument template is more cv-qualified than the type from the
parameter template (as described above),
the parameter type is not considered to be
at least as specialized as the argument type.
</p></li></ul></div><div class='para' id='deduct.partial-10'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-10'>10</a></div><p ><span class='indexparent'><a class='index' id='more~specialized!function~template'></a></span><span class='indexparent'><a class='index' id='at~least~as specialized~as'></a></span>Function template <span class='texttt'>F</span>
is <i>at least as specialized as</i>
function template <span class='texttt'>G</span> if,
for each pair of types used to determine the ordering,
the type from <span class='texttt'>F</span>
is at least as specialized as
the type from <span class='texttt'>G</span>.
<span class='texttt'>F</span>
is <i>more specialized than</i>
<span class='texttt'>G</span> if
<span class='texttt'>F</span>
is at least as specialized as
<span class='texttt'>G</span> and
<span class='texttt'>G</span>
is not at least as specialized as
<span class='texttt'>F</span>.</p></div><div class='para' id='deduct.partial-11'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-11'>11</a></div><p >In most cases, all template parameters must have values in order for
deduction to succeed, but for partial ordering purposes a template
parameter may remain without a value provided it is not used in the
types being used for partial ordering.
[&nbsp;<i>Note:</i><span class='space'></span>
A template parameter used in a non-deduced context is considered used.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; T f(int);        <span class='comment'>// #1
</span>template &lt;class T, class U&gt; T f(U); <span class='comment'>// #2
</span>void g() {
  f&lt;int&gt;(1);        <span class='comment'>// calls #1
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.partial-12'><div class='marginalizedparent'><a class='marginalized' href='#deduct.partial-12'>12</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Partial ordering of function templates containing
template parameter packs is independent of the number of deduced arguments
for those template parameter packs. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ...&gt; struct Tuple { };
template&lt;class ... Types&gt; void g(Tuple&lt;Types ...&gt;);                 <span class='comment'>// #1
</span>template&lt;class T1, class ... Types&gt; void g(Tuple&lt;T1, Types ...&gt;);   <span class='comment'>// #2
</span>template&lt;class T1, class ... Types&gt; void g(Tuple&lt;T1, Types&amp; ...&gt;);  <span class='comment'>// #3
</span>
g(Tuple&lt;&gt;());                   <span class='comment'>// calls #1
</span>g(Tuple&lt;int, float&gt;());         <span class='comment'>// calls #2
</span>g(Tuple&lt;int, float&amp;&gt;());        <span class='comment'>// calls #3
</span>g(Tuple&lt;int&gt;());                <span class='comment'>// calls #3
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-141'><div class='marginalizedparent'><a class='marginalized' href='#footnote-141'>141)</a></div><p >Default arguments
are not considered to be arguments in this context; they only become arguments
after a function has been selected.</p></div></div><div id='deduct.type'><h4 ><a class='secnum' href='#deduct.type' style='min-width:118pt'>14.8.2.5</a> Deducing template arguments from a type <a class='abbr_ref' href='temp.deduct.type'>[temp.deduct.type]</a></h4><div class='para' id='deduct.type-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-1'>1</a></div><p >Template arguments can be deduced in several different contexts, but
in each case a type that is specified in terms of template parameters
(call it
<span class='texttt'>P</span>)
is compared with an actual type (call it
<span class='texttt'>A</span>),
and an attempt is made to find template argument values (a type for a type
parameter, a value for a non-type parameter, or a template for a
template parameter) that will make
<span class='texttt'>P</span>,
after substitution of the deduced values (call it the deduced
<span class='texttt'>A</span>),
compatible with
<span class='texttt'>A</span>.</p></div><div class='para' id='deduct.type-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-2'>2</a></div><p >In some cases, the deduction is done using a single set of types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>,
in other cases, there will be a set of corresponding types
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>.
Type deduction is done
independently for each
<span class='texttt'>P/A</span>
pair, and the deduced template
argument values are then combined.
If type deduction cannot be done
for any
<span class='texttt'>P/A</span>
pair, or if for any pair the deduction leads to more than
one possible set of deduced values, or if different pairs yield
different deduced values, or if any template argument remains neither
deduced nor explicitly specified, template argument deduction fails.
The type of a type parameter
is only deduced from an array bound
if it is not otherwise deduced.</p></div><div class='para' id='deduct.type-3'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-3'>3</a></div><p >A given type
<span class='texttt'>P</span>
can be composed from a number of other
types, templates, and non-type values:</p><ul ><li ><p >A function type includes the types of each of the function parameters
and the return type.
</p></li><li ><p >A pointer to member type includes the type of the class object pointed to
and the type of the member pointed to.
</p></li><li ><p >A type that is a specialization of a class template (e.g.,
<span class='texttt'>A&lt;int&gt;</span>)
includes the types, templates, and non-type values referenced by the
template argument list of the specialization.
</p></li><li ><p >An array type includes the array element type and the value of the
array bound.
</p></li></ul></div><div class='para' id='deduct.type-4'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-4'>4</a></div><p >In most cases, the types, templates, and non-type values that are used
to compose
<span class='texttt'>P</span>
participate in template argument deduction.
That is,
they may be used to determine the value of a template argument, and
the value so determined must be consistent with the values determined
elsewhere.
In certain contexts, however, the value does not
participate in type deduction, but instead uses the values of template
arguments that were either deduced elsewhere or explicitly specified.
If a template parameter is used only in non-deduced contexts and is not
explicitly specified, template argument deduction fails.
[&nbsp;<i>Note:</i><span class='space'></span>
Under <a href='temp.deduct.call'>[temp.deduct.call]</a> and <a href='temp.deduct.partial'>[temp.deduct.partial]</a>,
if <span class='texttt'>P</span> contains no <i ><a href='temp.param#template-parameter'>template-parameters</a></i> that appear
in deduced contexts, no deduction is done, and so <span class='texttt'>P</span> and <span class='texttt'>A</span>
need not have the same form.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='deduct.type-5'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-5'>5</a></div><p >The non-deduced contexts are:</p><p ><span class='indexparent'><a class='index' id='context!non-deduced'></a></span></p><ul ><li ><p >The
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
of a type that was specified using a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>.
</p></li><li ><p >The <i ><a href='expr.comma#expression'>expression</a></i> of a <i ><a href='dcl.type.simple#decltype-specifier'>decltype-specifier</a></i>.
</p></li><li ><p >A non-type template argument or an array bound in which a subexpression
references a template parameter.
</p></li><li ><p >A template parameter used in the parameter type of a function parameter that
has a default argument that is being used in the call for which argument
deduction is being done.
</p></li><li ><p >A function parameter for which argument deduction cannot be done because the
associated function argument is a function, or a set of overloaded
functions (<a href='over.over'>[over.over]</a>), and one or more of the following apply:
</p><ul ><li ><p >more than one function matches the function parameter type (resulting in
an ambiguous deduction), or
</p></li><li ><p >no function matches the function parameter type, or
</p></li><li ><p >the set of functions supplied as an argument contains one or more function templates.
</p></li></ul></li><li ><p >A function parameter for which the associated argument is an initializer
list (<a href='dcl.init.list'>[dcl.init.list]</a>) but the parameter does not have
a type for which deduction from an initializer list is specified (<a href='temp.deduct.call'>[temp.deduct.call]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; void g(T);
g({1,2,3});                 <span class='comment'>// error: no argument deduced for <span class='texttt'>T</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >A function parameter pack that does not occur at the end of the 
<i ><a href='dcl.fct#parameter-declaration-list'>parameter-declaration-list</a></i>.
</p></li></ul></div><div class='para' id='deduct.type-6'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-6'>6</a></div><p >When a type name is specified in a way that includes a non-deduced
context, all of the types that comprise that type name are also
non-deduced.
However, a compound type can include both deduced and non-deduced types.
[&nbsp;<i>Example:</i><span class='space'></span>
If a type is specified as
<span class='texttt'>A&lt;T&gt;::B&lt;T2&gt;</span>,
both
<span class='texttt'>T</span>
and
<span class='texttt'>T2</span>
are non-deduced.
Likewise, if a type is specified as
<span class='texttt'>A&lt;I+J&gt;::X&lt;T&gt;</span>,
<span class='texttt'>I</span>,
<span class='texttt'>J</span>,
and
<span class='texttt'>T</span>
are non-deduced.
If a type is specified as
<span class='texttt'>void</span>
<span class='texttt'>f(typename</span>
<span class='texttt'>A&lt;T&gt;::B,</span>
<span class='texttt'>A&lt;T&gt;)</span>,
the
<span class='texttt'>T</span>
in
<span class='texttt'>A&lt;T&gt;::B</span>
is non-deduced but
the
<span class='texttt'>T</span>
in
<span class='texttt'>A&lt;T&gt;</span>
is deduced.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-7'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-7'>7</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
Here is an example in which different parameter/argument pairs produce
inconsistent template argument deductions:</p><pre class='codeblock'>
template&lt;class T&gt; void f(T x, T y) { <span class='comment'>/* ... */</span> }
struct A { <span class='comment'>/* ... */</span> };
struct B : A { <span class='comment'>/* ... */</span> };
void g(A a, B b) {
  f(a,b);           <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>A</span> or <span class='texttt'>B</span>
</span>  f(b,a);           <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>A</span> or <span class='texttt'>B</span>
</span>  f(a,a);           <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>A</span>
</span>  f(b,b);           <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>B</span>
</span>}
</pre><p >Here is an example where two template arguments are deduced from a
single function parameter/argument pair.
This can lead to conflicts
that cause type deduction to fail:</p><pre class='codeblock'>
template &lt;class T, class U&gt; void f(  T (*)( T, U, U )  );

int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);

void r() {
  f(g1);            <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>int</span> and <span class='texttt'>U</span> is <span class='texttt'>float</span>
</span>  f(g2);            <span class='comment'>// error: <span class='texttt'>T</span> could be <span class='texttt'>char</span> or <span class='texttt'>int</span>
</span>  f(g3);            <span class='comment'>// error: <span class='texttt'>U</span> could be <span class='texttt'>char</span> or <span class='texttt'>float</span>
</span>}
</pre><p >Here is an example where a qualification conversion applies between the
argument type on the function call and the deduced template argument type:</p><pre class='codeblock'>
template&lt;class T&gt; void f(const T*) { }
int* p;
void s() {
  f(p);             <span class='comment'>// <span class='texttt'>f(const int*)</span>
</span>}
</pre><p >Here is an example where the template argument is used to instantiate
a derived class type of the corresponding function parameter type:</p><pre class='codeblock'>
template &lt;class T&gt; struct B { };
template &lt;class T&gt; struct D : public B&lt;T&gt; {};
struct D2 : public B&lt;int&gt; {};
template &lt;class T&gt; void f(B&lt;T&gt;&amp;){}
void t() {
  D&lt;int&gt; d;
  D2     d2;
  f(d);             <span class='comment'>// calls <span class='texttt'>f(B&lt;int&gt;&amp;)</span>
</span>  f(d2);            <span class='comment'>// calls <span class='texttt'>f(B&lt;int&gt;&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-8'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-8'>8</a></div><p >A template type argument
<span class='texttt'>T</span>,
a template template argument
<span class='texttt'>TT</span>
or a template non-type argument
<span class='texttt'>i</span>
can be deduced if
<span class='texttt'>P</span>
and
<span class='texttt'>A</span>
have one of the following forms:</p><pre class='codeblock'>
T
<span class='grammarterm'>cv-list</span> T
T*
T&amp;
T&amp;&amp;
T[<span class='grammarterm'>integer-constant</span>]
<span class='grammarterm'>template-name</span>&lt;T&gt;  (where <span class='grammarterm'>template-name</span> refers to a class template)
<i>type</i>(T)
T()
T(T)
T <i>type</i>::*
<i>type</i> T::*
T T::*
T (<i>type</i>::*)()
<i>type</i> (T::*)()
<i>type</i> (<i>type</i>::*)(T)
<i>type</i> (T::*)(T)
T (<i>type</i>::*)(T)
T (T::*)()
T (T::*)(T)
<i>type</i>[i]
<span class='grammarterm'>template-name</span>&lt;i&gt;  (where <span class='grammarterm'>template-name</span> refers to a class template)
TT&lt;T&gt;
TT&lt;i&gt;
TT&lt;&gt;
</pre><p >where
<span class='texttt'>(T)</span>
represents
a parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>)
where at least one parameter type contains a
<span class='texttt'>T</span>,
and
<span class='texttt'>()</span>
represents
a parameter-type-list
where no parameter type contains a
<span class='texttt'>T</span>.
Similarly,
<span class='texttt'>&lt;T&gt;</span>
represents template argument lists where at least one argument contains a
<span class='texttt'>T</span>,
<span class='texttt'>&lt;i&gt;</span>
represents template argument lists where at least one argument contains an
<span class='texttt'>i</span>
and
<span class='texttt'>&lt;&gt;</span>
represents template argument lists where no argument contains a
<span class='texttt'>T</span>
or an
<span class='texttt'>i</span>.</p></div><div class='para' id='deduct.type-9'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-9'>9</a></div><p >If <span class='texttt'>P</span> has a form that contains <span class='texttt'>&lt;T&gt;</span>
or <span class='texttt'>&lt;i&gt;</span>, then each argument <span class='math'><span class='mathtt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> of the
respective template argument list of <span class='texttt'>P</span> is compared with the
corresponding argument <span class='math'><span class='mathtt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> of the corresponding
template argument list of <span class='texttt'>A</span>. If the template argument list
of <span class='texttt'>P</span> contains a pack expansion that is not the last
template argument, the entire template argument list is a non-deduced
context. If <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is a pack expansion, then the pattern
of <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is compared with each remaining argument in the
template argument list of <span class='texttt'>A</span>. Each comparison deduces
template arguments for subsequent positions in the template parameter
packs expanded by <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span>.
During partial ordering (<a href='temp.deduct.partial'>[temp.deduct.partial]</a>), if <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> was
originally a pack expansion:</p><ul ><li ><p >if <span class='texttt'>P</span> does not contain a template argument corresponding to
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> then <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is ignored;</p></li><li ><p >otherwise, if <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is not a pack expansion, template argument
deduction fails.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T1, class... Z&gt; class S;                               <span class='comment'>// #1
</span>template&lt;class T1, class... Z&gt; class S&lt;T1, const Z&amp;...&gt; { };          <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;   class S&lt;T1, const T2&amp;&gt; { };            <span class='comment'>// #3
</span>S&lt;int, const int&amp;&gt; s;         <span class='comment'>// both #2 and #3 match; #3 is more specialized
</span>
template&lt;class T, class... U&gt;            struct A { };                <span class='comment'>// #1
</span>template&lt;class T1, class T2, class... U&gt; struct A&lt;T1, T2*, U...&gt; { }; <span class='comment'>// #2
</span>template&lt;class T1, class T2&gt;             struct A&lt;T1, T2&gt; { };        <span class='comment'>// #3
</span>template struct A&lt;int, int*&gt;; <span class='comment'>// selects #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-10'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-10'>10</a></div><p >Similarly, if <span class='texttt'>P</span> has a form that contains
<span class='texttt'>(T)</span>, then each parameter type <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span>
of the respective parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>) of
<span class='texttt'>P</span> is compared with the corresponding parameter type
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> of the corresponding parameter-type-list
of <span class='texttt'>A</span>.
If <span class='texttt'>P</span> and <span class='texttt'>A</span> are function types that originated from deduction when
taking the address of a function template (<a href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a>) or when
deducing template arguments from a function declaration (<a href='temp.deduct.decl'>[temp.deduct.decl]</a>)
and <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> are parameters of the top-level
parameter-type-list of <span class='texttt'>P</span> and <span class='texttt'>A</span>, respectively,
<span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is adjusted if it is a forwarding reference (<a href='temp.deduct.call'>[temp.deduct.call]</a>)
and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is an lvalue reference, in which case the type of
<span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is changed to be the template parameter type (i.e., <span class='texttt'>T&amp;&amp;</span> is
changed to simply <span class='texttt'>T</span>). [&nbsp;<i>Note:</i><span class='space'></span> As a result, when <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='texttt'>T&amp;&amp;</span>
and <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is <span class='texttt'>X&amp;</span>, the adjusted <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> will be <span class='texttt'>T</span>,
causing <span class='texttt'>T</span> to be deduced as <span class='texttt'>X&amp;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; void f(T&amp;&amp;);
template &lt;&gt; void f(int&amp;) { }  <span class='comment'>// #1
</span>template &lt;&gt; void f(int&amp;&amp;) { } <span class='comment'>// #2
</span>void g(int i) {
  f(i);                       <span class='comment'>// calls <span class='texttt'>f&lt;int&amp;&gt;(int&amp;)</span>, i.e., #1
</span>  f(0);                       <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int&amp;&amp;)</span>, i.e., #2
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >If the <i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i>
corresponding to <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is a function parameter pack,
then the type of its <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> is compared with
each remaining parameter type in the parameter-type-list
of <span class='texttt'>A</span>. Each comparison deduces template arguments for
subsequent positions in the template parameter packs expanded by the
function parameter pack.
During partial ordering (<a href='temp.deduct.partial'>[temp.deduct.partial]</a>), if <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> was
originally a function parameter pack:</p><ul ><li ><p >if <span class='texttt'>P</span> does not contain a function parameter type corresponding to
<span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> then <span class='math'><span class='texttt'>A</span><sub ><span class='mathalpha'>i</span></sub></span> is ignored;</p></li><li ><p >otherwise, if <span class='math'><span class='texttt'>P</span><sub ><span class='mathalpha'>i</span></sub></span> is not a function parameter pack, template
argument deduction fails.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T*, U...) { }    <span class='comment'>// #1
</span>template&lt;class T&gt;             void f(T) { }           <span class='comment'>// #2
</span>template void f(int*);      <span class='comment'>// selects #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-11'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-11'>11</a></div><p >These forms can be used in the same way as
<span class='texttt'>T</span>
is for further composition of types.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
X&lt;int&gt; (*)(char[6])
</pre><p >is of the form</p><pre class='codeblock'>
<span class='grammarterm'>template-name</span>&lt;T&gt; (*)(<i>type</i>[i])
</pre><p >which is a variant of</p><pre class='codeblock'>
<i>type</i> (*)(T)
</pre><p >where type is
<span class='texttt'>X&lt;int&gt;</span>
and
<span class='texttt'>T</span>
is
<span class='texttt'>char[6]</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-12'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-12'>12</a></div><p >Template arguments cannot be deduced from function arguments involving
constructs other than the ones specified above.</p></div><div class='para' id='deduct.type-13'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-13'>13</a></div><p >When the value of the argument
corresponding to a non-type template parameter <span class='texttt'>P</span>
that is declared with a dependent type
is deduced from an expression,
the template parameters in the type of <span class='texttt'>P</span>
are deduced from the type of the value.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;long n&gt; struct A { };

template&lt;typename T&gt; struct C;
template&lt;typename T, T n&gt; struct C&lt;A&lt;n&gt;&gt; {
  using Q = T;
};

using R = long;
using R = C&lt;A&lt;2&gt;&gt;::Q;    <span class='comment'>// OK; <span class='texttt'>T</span> was deduced to <span class='texttt'>long</span> from the
</span>                         <span class='comment'>// template argument value in the type <span class='texttt'>A&lt;2&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The type of <span class='texttt'>N</span> in the type <span class='texttt'>T[N]</span> is <span class='texttt'>std::size_t</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename T&gt; struct S;
template&lt;typename T, T n&gt; struct S&lt;int[n]&gt; {
  using Q = T;
};

using V = decltype(sizeof 0);
using V = S&lt;int[42]&gt;::Q; <span class='comment'>// OK; <span class='texttt'>T</span> was deduced to <span class='texttt'>std::size_t</span> from the type <span class='texttt'>int[42]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-14'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-14'>14</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, T i&gt; void f(int (&amp;a)[i]);
int v[10];
void g() {
  f(v);                  <span class='comment'>// OK: <span class='texttt'>T</span> is <span class='texttt'>std::size_t</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-15'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-15'>15</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Except for reference and pointer types, a major array bound is not part of a
function parameter type and cannot be deduced from an argument:</p><pre class='codeblock'>
template&lt;int i&gt; void f1(int a[10][i]);
template&lt;int i&gt; void f2(int a[i][20]);
template&lt;int i&gt; void f3(int (&amp;a)[i][20]);

void g() {
  int v[10][20];
  f1(v);            <span class='comment'>// OK: <span class='texttt'>i</span> deduced to be <span class='texttt'>20</span>
</span>  f1&lt;20&gt;(v);        <span class='comment'>// OK
</span>  f2(v);            <span class='comment'>// error: cannot deduce template-argument <span class='texttt'>i</span>
</span>  f2&lt;10&gt;(v);        <span class='comment'>// OK
</span>  f3(v);            <span class='comment'>// OK: <span class='texttt'>i</span> deduced to be <span class='texttt'>10</span>
</span>}
</pre></div><div class='para' id='deduct.type-16'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-16'>16</a></div><p >If, in the declaration of a function template with a non-type
template parameter, the non-type template parameter
is used in a subexpression in the function parameter list,
the expression is a non-deduced context as specified above.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;int i&gt; class A { <span class='comment'>/* ... */</span> };
template &lt;int i&gt; void g(A&lt;i+1&gt;);
template &lt;int i&gt; void f(A&lt;i&gt;, A&lt;i+1&gt;);
void k() {
  A&lt;1&gt; a1;
  A&lt;2&gt; a2;
  g(a1);            <span class='comment'>// error: deduction fails for expression <span class='texttt'>i+1</span>
</span>  g&lt;0&gt;(a1);         <span class='comment'>// OK
</span>  f(a1, a2);        <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Template parameters do not participate in template argument deduction if
they are used only in non-deduced contexts.
For example,</p><pre class='codeblock'>
template&lt;int i, typename T&gt;
T deduce(typename A&lt;T&gt;::X x,    <span class='comment'>// <span class='texttt'>T</span> is not deduced here
</span>  T t,                          <span class='comment'>// but <span class='texttt'>T</span> is deduced here
</span>  typename B&lt;i&gt;::Y y);          <span class='comment'>// <span class='texttt'>i</span> is not deduced here
</span>A&lt;int&gt; a;
B&lt;77&gt;  b;

int    x = deduce&lt;77&gt;(a.xm, 62, b.ym);
<span class='comment'>// <span class='texttt'>T</span> is deduced to be <span class='texttt'>int</span>, <span class='texttt'>a.xm</span> must be convertible to
</span><span class='comment'>// <span class='texttt'>A&lt;int&gt;::X</span>
</span><span class='comment'>// <span class='texttt'>i</span> is explicitly specified to be <span class='texttt'>77</span>, <span class='texttt'>b.ym</span> must be convertible
</span><span class='comment'>// to <span class='texttt'>B&lt;77&gt;::Y</span>
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='deduct.type-17'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-17'>17</a></div><p >If <span class='texttt'>P</span> has a form that contains <span class='texttt'>&lt;i&gt;</span>, and
if the type of <span class='texttt'>i</span> differs from the type
of the corresponding template parameter
of the template named by the enclosing <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>,
deduction fails.
If <span class='texttt'>P</span> has a form that contains <span class='texttt'>[i]</span>, and if the type of
<span class='texttt'>i</span> is not an integral type, deduction fails.<a class='footnotenum' href='#footnote-142'>142</a>
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;int i&gt; class A { <span class='comment'>/* ... */</span> };
template&lt;short s&gt; void f(A&lt;s&gt;);
void k1() {
  A&lt;1&gt; a;
  f(a);             <span class='comment'>// error: deduction fails for conversion from <span class='texttt'>int</span> to <span class='texttt'>short</span>
</span>  f&lt;1&gt;(a);          <span class='comment'>// OK
</span>}

template&lt;const short cs&gt; class B { };
template&lt;short s&gt; void g(B&lt;s&gt;);
void k2() {
  B&lt;1&gt; b;
  g(b);             <span class='comment'>// OK: cv-qualifiers are ignored on template parameter types
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-18'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-18'>18</a></div><p >A
<i ><a href='temp.names#template-argument'>template-argument</a></i>
can be deduced from a function, pointer to function, or pointer to
member function type.</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(void(*)(T,int));
template&lt;class T&gt; void foo(T,int);
void g(int,int);
void g(char,int);

void h(int,int,int);
void h(char,int);
int m() {
  f(&amp;g);            <span class='comment'>// error: ambiguous
</span>  f(&amp;h);            <span class='comment'>// OK: void <span class='texttt'>h(char,int)</span> is a unique match
</span>  f(&amp;foo);          <span class='comment'>// error: type deduction fails because <span class='texttt'>foo</span> is a template
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-19'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-19'>19</a></div><p >A template
<i ><a href='temp.param#type-parameter'>type-parameter</a></i>
cannot be deduced from the type of a function default argument.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; void f(T = 5, T = 7);
void g() {
  f(1);             <span class='comment'>// OK: call <span class='texttt'>f&lt;int&gt;(1,7)</span>
</span>  f();              <span class='comment'>// error: cannot deduce <span class='texttt'>T</span>
</span>  f&lt;int&gt;();         <span class='comment'>// OK: call <span class='texttt'>f&lt;int&gt;(5,7)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-20'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-20'>20</a></div><p >The
<i ><a href='temp.names#template-argument'>template-argument</a></i>
corresponding to a template
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
is deduced from the type of the
<i ><a href='temp.names#template-argument'>template-argument</a></i>
of a class template specialization used in the argument list of a function call.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;template &lt;class T&gt; class X&gt; struct A { };
template &lt;template &lt;class T&gt; class X&gt; void f(A&lt;X&gt;) { }
template&lt;class T&gt; struct B { };
A&lt;B&gt; ab;
f(ab);              <span class='comment'>// calls <span class='texttt'>f(A&lt;B&gt;)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='deduct.type-21'><div class='marginalizedparent'><a class='marginalized' href='#deduct.type-21'>21</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Template argument deduction involving parameter
packs (<a href='temp.variadic'>[temp.variadic]</a>) can deduce zero or more arguments for
each parameter pack. <i>&nbsp;—&nbsp;end note</i>&nbsp;][&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class&gt; struct X { };
template&lt;class R, class ... ArgTypes&gt; struct X&lt;R(int, ArgTypes ...)&gt; { };
template&lt;class ... Types&gt; struct Y { };
template&lt;class T, class ... Types&gt; struct Y&lt;T, Types&amp; ...&gt; { };

template&lt;class ... Types&gt; int f(void (*)(Types ...));
void g(int, float);

X&lt;int&gt; x1;                      <span class='comment'>// uses primary template
</span>X&lt;int(int, float, double)&gt; x2;  <span class='comment'>// uses partial specialization; <span class='texttt'>ArgTypes</span> contains <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>X&lt;int(float, int)&gt; x3;          <span class='comment'>// uses primary template
</span>Y&lt;&gt; y1;                         <span class='comment'>// use primary template; <span class='texttt'>Types</span> is empty
</span>Y&lt;int&amp;, float&amp;, double&amp;&gt; y2;    <span class='comment'>// uses partial specialization; <span class='texttt'>T</span> is <span class='texttt'>int&amp;</span>, <span class='texttt'>Types</span> contains <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>Y&lt;int, float, double&gt; y3;       <span class='comment'>// uses primary template; <span class='texttt'>Types</span> contains <span class='texttt'>int</span>, <span class='texttt'>float</span>, <span class='texttt'>double</span>
</span>int fv = f(g);                  <span class='comment'>// OK; <span class='texttt'>Types</span> contains <span class='texttt'>int</span>, <span class='texttt'>float</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-142'><div class='marginalizedparent'><a class='marginalized' href='#footnote-142'>142)</a></div><p >Although the
<span class='grammarterm'>template-argument</span>
corresponding to a
<span class='grammarterm'>template-parameter</span>
of type
<span class='texttt'>bool</span>
may be deduced from an array bound, the resulting value will always be
<span class='texttt'>true</span>
because the array bound will be non-zero.</p></div></div><div id='deduct.decl'><h4 ><a class='secnum' href='#deduct.decl' style='min-width:118pt'>14.8.2.6</a> Deducing template arguments from a function declaration <a class='abbr_ref' href='temp.deduct.decl'>[temp.deduct.decl]</a></h4><div class='para' id='deduct.decl-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.decl-1'>1</a></div><p >In a declaration whose <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> refers to a specialization
of a function template, template argument deduction is performed to identify
the specialization to which the declaration refers. Specifically, this is done
for explicit instantiations (<a href='temp.explicit'>[temp.explicit]</a>), explicit specializations (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
and certain friend declarations (<a href='temp.friend'>[temp.friend]</a>). This is also done to
determine whether a deallocation function template specialization matches a placement
<span class='texttt'>operator new</span> (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>).
In all these cases, <span class='texttt'>P</span> is the type of the function template being considered
as a potential match and <span class='texttt'>A</span> is either the function type from the
declaration
or the type of the deallocation function that would match the placement
<span class='texttt'>operator new</span> as described in <a href='expr.new'>[expr.new]</a>. The
deduction is done as described in <a href='temp.deduct.type'>[temp.deduct.type]</a>.</p></div><div class='para' id='deduct.decl-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.decl-2'>2</a></div><p >If, for the set of function templates so considered, there is either no match or
more than one match after partial ordering has been considered (<a href='temp.func.order'>[temp.func.order]</a>),
deduction fails and, in the declaration cases, the
program is ill-formed.</p></div></div></div><div id='over'><h3 ><a class='secnum' href='#over' style='min-width:103pt'>14.8.3</a> Overload resolution <a class='abbr_ref' href='temp.over'>[temp.over]</a></h3><div class='para' id='over-1'><div class='marginalizedparent'><a class='marginalized' href='#over-1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading!resolution!function template'></a></span>A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name.
When a call to that name is written (explicitly, or implicitly using the
operator notation), template argument deduction (<a href='temp.deduct'>[temp.deduct]</a>)
and checking of any explicit template arguments (<a href='temp.arg'>[temp.arg]</a>) are performed
for each function template to find the template argument values (if any) that
can be used with that function template to instantiate a function template
specialization that can be invoked with the call arguments.
For each function template, if the argument deduction and checking succeeds,
the
<i ><a href='temp.names#template-argument'>template-arguments</a></i>
(deduced and/or explicit)
are used to synthesize the declaration of
a single function template specialization which is
added to the candidate functions set to be used in overload resolution.
If, for a given function template, argument deduction fails or
the synthesized function template specialization would be ill-formed,
no such function is added to the set of candidate functions for that template.
The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of
the same name.
The synthesized declarations are
treated like any other functions in
the remainder of overload resolution, except as explicitly noted
in <a href='over.match.best'>[over.match.best]</a>.<a class='footnotenum' href='#footnote-143'>143</a></p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            <span class='comment'>// <span class='texttt'>max(int a, int b)</span>
</span>  char m2 = max(c,d);           <span class='comment'>// <span class='texttt'>max(char a, char b)</span>
</span>  int m3 = max(a,c);            <span class='comment'>// error: cannot generate <span class='texttt'>max(int,char)</span>
</span>}
</pre></div><div class='para' id='over-2'><div class='marginalizedparent'><a class='marginalized' href='#over-2'>2</a></div><p >Adding the non-template function</p><pre class='codeblock'>
int max(int,int);
</pre><p >to the example above would resolve the third call, by providing a function that
could be called for
<span class='texttt'>max(a,c)</span>
after using the standard conversion of
<span class='texttt'>char</span>
to
<span class='texttt'>int</span>
for
<span class='texttt'>c</span>.</p></div><div class='para' id='over-3'><div class='marginalizedparent'><a class='marginalized' href='#over-3'>3</a></div><p >Here is an example involving conversions on a function argument involved in
<i ><a href='temp.names#template-argument'>template-argument</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; struct B { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; struct D : public B&lt;T&gt; { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void f(B&lt;T&gt;&amp;);

void g(B&lt;int&gt;&amp; bi, D&lt;int&gt;&amp; di) {
  f(bi);            <span class='comment'>// <span class='texttt'>f(bi)</span>
</span>  f(di);            <span class='comment'>// <span class='texttt'>f((B&lt;int&gt;&amp;)di)</span>
</span>}
</pre></div><div class='para' id='over-4'><div class='marginalizedparent'><a class='marginalized' href='#over-4'>4</a></div><p >Here is an example involving conversions on a function argument not involved in
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
deduction:</p><pre class='codeblock'>
template&lt;class T&gt; void f(T*,int);       <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T,char);       <span class='comment'>// #2
</span>
void h(int* pi, int i, char c) {
  f(pi,i);          <span class='comment'>// #1: <span class='texttt'>f&lt;int&gt;(pi,i)</span>
</span>  f(pi,c);          <span class='comment'>// #2: <span class='texttt'>f&lt;int*&gt;(pi,c)</span>
</span>
  f(i,c);           <span class='comment'>// #2: <span class='texttt'>f&lt;int&gt;(i,c);</span>
</span>  f(i,i);           <span class='comment'>// #2: <span class='texttt'>f&lt;int&gt;(i,char(i))</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='over-5'><div class='marginalizedparent'><a class='marginalized' href='#over-5'>5</a></div><p >Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions.
Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);    <span class='comment'>// declaration
</span>
void g() {
  f("Annemarie");               <span class='comment'>// call of <span class='texttt'>f&lt;const char*&gt;</span>
</span>}
</pre></div><div class='para' id='over-6'><div class='marginalizedparent'><a class='marginalized' href='#over-6'>6</a></div><p >The call of
<span class='texttt'>f</span>
is well-formed even if the template
<span class='texttt'>f</span>
is only declared and not defined at the point of the call.
The program will be ill-formed unless a specialization for
<span class='texttt'>f&lt;const char*&gt;</span>,
either implicitly or explicitly generated,
is present in some translation unit.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div><div class='footnote' id='footnote-143'><div class='marginalizedparent'><a class='marginalized' href='#footnote-143'>143)</a></div><p >The parameters of function template
specializations contain no
template parameter types.
The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions.
Non-deduced arguments allow the full range of conversions.
Note also that <a href='over.match.best'>[over.match.best]</a> specifies that a non-template function will
be given preference over a template specialization if the two functions
are otherwise equally good candidates for an overload match.</p></div></div></div><div id='deduct.guide'><h2 ><a class='secnum' href='#deduct.guide' style='min-width:88pt'>14.9</a> Deduction guides <a class='abbr_ref' href='temp.deduct.guide'>[temp.deduct.guide]</a></h2><p ><span class='indexparent'><a class='index' id='deduction!class template argument'></a></span>
</p><div class='para' id='deduct.guide-1'><div class='marginalizedparent'><a class='marginalized' href='#deduct.guide-1'>1</a></div><p >Deduction guides are used
when a <i ><a href='temp.names#template-name'>template-name</a></i> appears
as a type specifier
for a deduced class type (<a href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a>).
Deduction guides are not found by name lookup.
Instead, when performing class template argument deduction (<a href='over.match.class.deduct'>[over.match.class.deduct]</a>),
any deduction guides declared for the class template are considered.</p><pre class='bnf'><a id='deduction-guide'>deduction-guide:</a>
    <i ><a href='temp.names#template-name'>template-name</a></i> <span class='terminal'>(</span> <i ><a href='dcl.fct#parameter-declaration-clause'>parameter-declaration-clause</a></i> <span class='terminal'>) -&gt;</span> <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span></pre></div><div class='para' id='deduct.guide-2'><div class='marginalizedparent'><a class='marginalized' href='#deduct.guide-2'>2</a></div><p >The same restrictions apply
to the <i ><a href='dcl.fct#parameter-declaration-clause'>parameter-declaration-clause</a></i>
of a deduction guide
as in a function declaration (<a href='dcl.fct'>[dcl.fct]</a>).
The <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
shall name a class template specialization.
The <i ><a href='temp.names#template-name'>template-name</a></i>
shall be the same <i ><a href='lex.name#identifier'>identifier</a></i>
as the <i ><a href='temp.names#template-name'>template-name</a></i>
of the <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
A <i ><a href='temp.deduct.guide#deduction-guide'>deduction-guide</a></i>
shall be declared
in the same scope
as the corresponding class template.</p><p ><span class='indexparent'><a class='index' id='template'></a></span>
</p></div></div></div></div></body></html>