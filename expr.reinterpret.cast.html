<!DOCTYPE html><html lang='en'><head><title>[expr.reinterpret.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.reinterpret.cast'>[expr.post]</a></h2><div id='expr.reinterpret.cast'><h3 ><a class='secnum' style='min-width:103pt'>5.2.10</a> Reinterpret cast <a class='abbr_ref'>[expr.reinterpret.cast]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2379'>#</a></div><p ><span class='indexparent'><a class='index' id='expression,reinterpret_cast'></a></span><span class='indexparent'><a class='index' id='cast,reinterpret'></a></span>The result of the expression <span class='texttt'>reinterpret_&shy;cast&lt;T&gt;(v)</span> is the
result of converting the expression <span class='texttt'>v</span> to type <span class='texttt'>T</span>.
<span class='indexparent'><a class='index' id='cast,reinterpret,lvalue'></a></span><span class='indexparent'><a class='index' id='cast,lvalue'></a></span>If <span class='texttt'>T</span> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue;
if <span class='texttt'>T</span> is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue and the
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard conversions are
performed on the expression <span class='texttt'>v</span>. Conversions that can be performed explicitly
using <span class='texttt'>reinterpret_&shy;cast</span> are listed below. No other conversion can
be performed explicitly using <span class='texttt'>reinterpret_&shy;cast</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2395'>#</a></div><p >The <span class='texttt'>reinterpret_&shy;cast</span> operator shall not cast away constness (<a href='expr.const.cast'>[expr.const.cast]</a>).
An expression of integral, enumeration, pointer, or pointer-to-member type
can be explicitly converted to its own type; such a cast yields the value of
its operand.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2401'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The mapping performed by <span class='texttt'>reinterpret_&shy;cast</span> might, or might not, produce a
representation different from the original value.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2407'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,reinterpret,pointer_to_integer'></a></span><span class='indexparent'><a class='index' id='cast,pointer_to_integer'></a></span>A pointer can be explicitly converted to any integral type large enough
to hold it.
<span class='indexparent'><a class='index' id='conversion,implementation-defined_pointer_integer'></a></span>The mapping function is <span class='indexparent'><a class='index' id='mapping_of_pointer_to_integer'></a></span>implementation-defined.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
It is intended to be unsurprising to those who know the addressing
structure of the underlying machine.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] A value of type <span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span> can be converted to an integral
type; the conversion has the same meaning and validity as a conversion of
<span class='texttt'>(void*)0</span> to the integral type. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> A <span class='texttt'>reinterpret_&shy;cast</span>
cannot be used to convert a value of any type to the type
<span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span>. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2423'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,reinterpret,integer_to_pointer'></a></span><span class='indexparent'><a class='index' id='cast,integer_to_pointer'></a></span>A value of integral type or enumeration type can be explicitly converted
to a pointer. A pointer converted to an integer of sufficient size (if
any such exists on the implementation) and back to the same pointer type
will have its original value;
<span class='indexparent'><a class='index' id='conversion,implementation-defined_pointer_integer'></a></span>mappings between pointers and integers are otherwise
<span class='indexparent'><a class='index' id='conversions_between_pointers_and_integers'></a></span>implementation-defined.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> Except as described in <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>, the result of
such a conversion will not be a safely-derived pointer value. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2436'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,reinterpret,pointer-to-function'></a></span><span class='indexparent'><a class='index' id='cast,pointer-to-function'></a></span><span class='indexparent'><a class='index' id='cast,undefined_pointer-to-function'></a></span>A function pointer can be explicitly converted
to a function pointer of a different type.
<span class='indexparent'><a class='index' id='function_call,undefined'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The effect of calling a function through a pointer to a function
type (<a href='dcl.fct'>[dcl.fct]</a>) that is not the same as the type used in the
definition of the function is undefined.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
Except that converting
a prvalue of type “pointer to <span class='texttt'>T1</span>” to the type “pointer to
<span class='texttt'>T2</span>” (where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are function types) and
back to its original type yields the original pointer value, the result
of such a pointer conversion is unspecified.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
See also <a href='conv.ptr'>[conv.ptr]</a> for more details of pointer conversions.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2457'>#</a></div><p >An object pointer
can be explicitly converted to an object pointer of a different type.<a class='footnotenum' href='#footnote-73'>73</a>
When a prvalue <span class='texttt'>v</span> of object pointer type is converted to
the object pointer type “pointer to <i>cv</i> <span class='texttt'>T</span>”, the result is <span class='texttt'>static_&shy;cast&lt;<i>cv</i> T*&gt;(static_&shy;cast&lt;<i>cv</i> void*&gt;(v))</span>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Converting a prvalue of type “pointer to <span class='texttt'>T1</span>” to
the type “pointer to <span class='texttt'>T2</span>” (where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are
object types and where the alignment requirements of <span class='texttt'>T2</span> are no
stricter than those of <span class='texttt'>T1</span>) and back to its original type yields
the original pointer value.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2473'>#</a></div><p >Converting a function pointer to an object pointer
type or vice versa is
conditionally-supported. The meaning of such a conversion is
<span class='indexparent'><a class='index' id='converting_function_pointer_to_object_pointer_and_vice_versa'></a></span>implementation-defined,
except that if an implementation
supports conversions in both directions, converting a prvalue of one type to the other
type and back, possibly with different cv-qualification, shall yield the original
pointer value.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2483'>#</a></div><p >The null pointer value (<a href='conv.ptr'>[conv.ptr]</a>) is converted to the null pointer value
of the destination type.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
A null pointer constant of type <span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span> cannot be converted to a
pointer type, and a null pointer constant of integral type is not necessarily
converted to a null pointer value.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2492'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,reinterpret,pointer-to-member'></a></span><span class='indexparent'><a class='index' id='cast,pointer-to-member'></a></span>A prvalue of type “pointer to member of <span class='texttt'>X</span> of type <span class='texttt'>T1</span>”
can be explicitly converted to a prvalue of a different type “pointer to member of
<span class='texttt'>Y</span> of type <span class='texttt'>T2</span>” if <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are both
function types or both object types.<a class='footnotenum' href='#footnote-74'>74</a> The null member pointer value (<a href='conv.mem'>[conv.mem]</a>) is converted to the
null member pointer value of the destination type. The result of this
conversion is unspecified, except in the following cases:</p><ul class='itemize'><li id='10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.1'>(10.1)</a></div><p >converting a prvalue of type “pointer to member function” to a
different pointer to member function type and back to its original type
yields the original pointer to member value.</p></li><li id='10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.2'>(10.2)</a></div><p >converting a prvalue of type “pointer to data member of <span class='texttt'>X</span>
of type <span class='texttt'>T1</span>” to the type “pointer to data member of <span class='texttt'>Y</span>
of type <span class='texttt'>T2</span>” (where the alignment requirements of <span class='texttt'>T2</span> are
no stricter than those of <span class='texttt'>T1</span>) and back to its original type
yields the original pointer to member value.
</p></li></ul></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/expressions.tex#L2517'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,reinterpret,reference'></a></span><span class='indexparent'><a class='index' id='cast,reference'></a></span>A glvalue expression of type <span class='texttt'>T1</span> can be cast to the type
“reference to <span class='texttt'>T2</span>” if an expression of type “pointer to
<span class='texttt'>T1</span>” can be explicitly converted to the type “pointer to
<span class='texttt'>T2</span>” using a <span class='texttt'>reinterpret_&shy;cast</span>. The result refers to
the same object as the source glvalue, but with the specified
type. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> That is, for lvalues, a reference cast
<span class='texttt'>reinterpret_&shy;cast&lt;T&amp;&gt;(x)</span> has the same effect as the conversion
<span class='texttt'>*reinterpret_&shy;cast&lt;T*&gt;(&amp;x)</span> with the built-in <span class='texttt'>&amp;</span> and
<span class='texttt'>*</span> operators (and similarly for
<span class='texttt'>reinterpret_&shy;cast&lt;T&amp;&amp;&gt;(x)</span>). <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] No
temporary is created, no copy is made, and
constructors (<a href='class.ctor'>[class.ctor]</a>) or conversion
functions (<a href='class.conv'>[class.conv]</a>) are not called.<a class='footnotenum' href='#footnote-75'>75</a></p></div><div class='footnote' id='footnote-73'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-73'>73)</a></div><p >The
types may have different <i>cv</i>-qualifiers, subject to
the overall
restriction that a <span class='texttt'>reinterpret_&shy;cast</span> cannot cast away constness.</p></div><div class='footnote' id='footnote-74'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-74'>74)</a></div><p ><span class='texttt'>T1</span> and <span class='texttt'>T2</span> may have
different <i>cv</i>-qualifiers, subject to
the overall restriction that a <span class='texttt'>reinterpret_&shy;cast</span> cannot cast away
constness.</p></div><div class='footnote' id='footnote-75'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-75'>75)</a></div><p >This
is sometimes referred to as a <a class='hidden_link' href='#def:type_pun' id='def:type_pun'><i>type pun</i></a>.</p></div></div></div></body></html>