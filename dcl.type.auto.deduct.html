<!DOCTYPE html><html lang='en'><head><title>[dcl.type.auto.deduct]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.type.auto.deduct'>[dcl.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type#auto.deduct'>[dcl.type]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>7.1.7.4</a> The <span class='texttt'>auto</span> specifier <a class='abbr_ref' href='dcl.spec.auto#dcl.type.auto.deduct'>[dcl.spec.auto]</a></h4><div id='dcl.type.auto.deduct'><h4 ><a class='secnum' style='min-width:133pt'>7.1.7.4.1</a> Placeholder type deduction <a class='abbr_ref'>[dcl.type.auto.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,placeholder_type'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/declarations.tex#L1760'>#</a></div><p ><a class='hidden_link' href='#def:placeholder_type_deduction' id='def:placeholder_type_deduction'><i>Placeholder type deduction</i></a>
is the process by which
a type containing a placeholder type
is replaced by a deduced type.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/declarations.tex#L1766'>#</a></div><p >A type <span class='texttt'>T</span> containing a placeholder type,
and a corresponding initializer <span class='texttt'>e</span>,
are determined as follows:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >for a non-discarded <span class='texttt'>return</span> statement that occurs
in a function declared with a return type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared return type
and <span class='texttt'>e</span> is the operand of the <span class='texttt'>return</span> statement.
If the <span class='texttt'>return</span> statement
has no operand,
then <span class='texttt'>e</span> is <span class='texttt'>void()</span>;
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >for a variable declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the variable
and <span class='texttt'>e</span> is the initializer.
If the initialization is direct-list-initialization,
the initializer shall be a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
containing only a single <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
and <span class='texttt'>e</span> is the <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>;
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >for a non-type template parameter declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the non-type template parameter
and <span class='texttt'>e</span> is the corresponding template argument.
</p></li></ul><p >In the case of a <span class='texttt'>return</span> statement with no operand
or with an operand of type <span class='texttt'>void</span>,
<span class='texttt'>T</span> shall be either
<span class='texttt'>decltype(auto)</span> or <i>cv</i> <span class='texttt'>auto</span>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/declarations.tex#L1802'>#</a></div><p >If the deduction is for a <span class='texttt'>return</span> statement
and <span class='texttt'>e</span> is a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>),
the program is ill-formed.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/declarations.tex#L1807'>#</a></div><p >If the placeholder is the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, the
deduced type
<span class='math'><span class='mathtt'>T</span>'</span> replacing <span class='texttt'>T</span>
is determined using the rules for template argument deduction.
Obtain <span class='texttt'>P</span> from
<span class='texttt'>T</span> by replacing the occurrences of <span class='texttt'>auto</span> with either a new
invented type template parameter <span class='texttt'>U</span> or,
if the initialization is copy-list-initialization, with
<span class='texttt'>std::initializer_list&lt;U&gt;</span>. Deduce a value for <span class='texttt'>U</span> using the rules
of template argument deduction from a function call (<a href='temp.deduct.call'>[temp.deduct.call]</a>),
where <span class='texttt'>P</span> is a
function template parameter type and
the corresponding argument is <span class='texttt'>e</span>.
If the deduction fails, the declaration is ill-formed.
Otherwise, <span class='math'><span class='mathtt'>T</span>'</span> is obtained by
substituting the deduced <span class='texttt'>U</span> into <span class='texttt'>P</span>.
[ <i>Example:</i>
</p><pre class='codeblock'>
auto x1 = { 1, 2 };             <span class='comment'>// <span class='texttt'>decltype(x1)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x2 = { 1, 2.0 };           <span class='comment'>// error: cannot deduce element type
</span>auto x3{ 1, 2 };                <span class='comment'>// error: not a single element
</span>auto x4 = { 3 };                <span class='comment'>// <span class='texttt'>decltype(x4)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x5{ 3 };                   <span class='comment'>// <span class='texttt'>decltype(x5)</span> is <span class='texttt'>int</span>
</span></pre><p ><i> — end example</i> ]</p><p >[ <i>Example:</i>
</p><pre class='codeblock'>
const auto &amp;i = expr;</pre><p >The type of <span class='texttt'>i</span> is the deduced type of the parameter <span class='texttt'>u</span> in
the call <span class='texttt'>f(expr)</span> of the following invented function template:
</p><pre class='codeblock'>
template &lt;class U&gt; void f(const U&amp; u);</pre><p ><i> — end example</i> ]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/declarations.tex#L1845'>#</a></div><p >If the placeholder is the <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>,
<span class='texttt'>T</span> shall be the
placeholder alone. The type deduced for <span class='texttt'>T</span> is
determined as described in <a href='dcl.type.simple'>[dcl.type.simple]</a>, as though
<span class='texttt'>e</span> had
been the operand of the <span class='texttt'>decltype</span>. [ <i>Example:</i>
</p><pre class='codeblock'>
int i;
int&amp;&amp; f();
auto           x2a(i);          <span class='comment'>// <span class='texttt'>decltype(x2a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x2d(i);          <span class='comment'>// <span class='texttt'>decltype(x2d)</span> is <span class='texttt'>int</span>
</span>auto           x3a = i;         <span class='comment'>// <span class='texttt'>decltype(x3a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x3d = i;         <span class='comment'>// <span class='texttt'>decltype(x3d)</span> is <span class='texttt'>int</span>
</span>auto           x4a = (i);       <span class='comment'>// <span class='texttt'>decltype(x4a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x4d = (i);       <span class='comment'>// <span class='texttt'>decltype(x4d)</span> is <span class='texttt'>int&amp;</span>
</span>auto           x5a = f();       <span class='comment'>// <span class='texttt'>decltype(x5a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x5d = f();       <span class='comment'>// <span class='texttt'>decltype(x5d)</span> is <span class='texttt'>int&amp;&amp;</span>
</span>auto           x6a = { 1, 2 };  <span class='comment'>// <span class='texttt'>decltype(x6a)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>decltype(auto) x6d = { 1, 2 };  <span class='comment'>// error, <span class='texttt'>{ 1, 2 }</span> is not an expression
</span>auto          *x7a = &amp;i;        <span class='comment'>// <span class='texttt'>decltype(x7a)</span> is <span class='texttt'>int*</span>
</span>decltype(auto)*x7d = &amp;i;        <span class='comment'>// error, declared type is not plain <span class='texttt'>decltype(auto)</span>
</span></pre><p ><i> — end example</i> ]</p></div></div></div></body></html>