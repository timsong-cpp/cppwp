<!DOCTYPE html><html lang='en'><head><title>[class.friend]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>11</a> Member access control <a class='abbr_ref' href='./#class.access'>[class.access]</a></h1><div id='class.friend'><h2 ><a class='secnum' style='min-width:88pt'>11.3</a> Friends <a class='abbr_ref'>[class.friend]</a></h2><p ><span class='indexparent'><a class='index' id='friend_function,access_and'></a></span><span class='indexparent'><a class='index' id='access_control,friend_function'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A friend of a class is a function or class that is
given permission to use the private and protected member names from the class.
A class specifies its friends, if any, by way of friend declarations.
Such declarations give special access rights to the friends, but they
do not make the nominated friends members of the befriending class.
[&nbsp;<i>Example:</i>
the following example illustrates the differences between
members and friends:
<span class='indexparent'><a class='index' id='friend_function,member_function_and'></a></span><span class='indexparent'><a class='index' id='example,friend_function'></a></span><span class='indexparent'><a class='index' id='example,member_function'></a></span>
</p><pre class='codeblock'>
class X {
  int a;
  friend void friend_set(X*, int);
public:
  void member_set(int);
};

void friend_set(X* p, int i) { p-&gt;a = i; }
void X::member_set(int i) { a = i; }

void f() {
  X obj;
  friend_set(&amp;obj,10);
  obj.member_set(10);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='friend,class_access_and'></a></span>Declaring a class to be a friend implies that the names of private and
protected members from the class granting friendship can be accessed in the
<i ><a href='class.derived#nt:base-specifier'>base-specifiers</a></i> and member declarations of the befriended
class. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
  class B { };
  friend class X;
};

struct X : A::B {   <span class='comment'>// OK: <span class='texttt'>A::B</span> accessible to friend
</span>  A::B mx;          <span class='comment'>// OK: <span class='texttt'>A::B</span> accessible to member of friend
</span>  class Y {
    A::B my;        <span class='comment'>// OK: <span class='texttt'>A::B</span> accessible to nested member of friend
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class X {
  enum { a=100 };
  friend class Y;
};

class Y {
  int v[X::a];      <span class='comment'>// OK, <span class='texttt'>Y</span> is a friend of <span class='texttt'>X</span>
</span>};

class Z {
  int v[X::a];      <span class='comment'>// error: <span class='texttt'>X::a</span> is private
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >A class shall not be defined in a friend declaration. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class A {
  friend class B { }; <span class='comment'>// error: cannot define class in friend declaration
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A <span class='texttt'>friend</span> declaration that does not declare a function
shall have one of the following forms:</p><pre class='bnf'><span class='terminal'>friend</span> <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='temp.res#nt:typename-specifier'>typename-specifier</a></i> <span class='terminal'>;</span></pre><p >[&nbsp;<i>Note:</i> A <span class='texttt'>friend</span> declaration may be the
<a class='hidden_link' href='#def:declaration' id='def:declaration'><i>declaration</i></a> in a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>
(Clause <a href='temp'>[temp]</a>, <a href='temp.friend'>[temp.friend]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;] If the
type specifier in a <span class='texttt'>friend</span> declaration designates a (possibly
cv-qualified) class type, that class is declared as a friend; otherwise, the
<span class='texttt'>friend</span> declaration is ignored. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
class C;
typedef C Ct;

class X1 {
  friend C;         <span class='comment'>// OK: <span class='texttt'>class C</span> is a friend
</span>};

class X2 {
  friend Ct;        <span class='comment'>// OK: <span class='texttt'>class C</span> is a friend
</span>  friend D;         <span class='comment'>// error: no type-name <span class='texttt'>D</span> in scope
</span>  friend class D;   <span class='comment'>// OK: elaborated-type-specifier declares new class
</span>};

template &lt;typename T&gt; class R {
  friend T;
};

R&lt;C&gt; rc;            <span class='comment'>// <span class='texttt'>class C</span> is a friend of <span class='texttt'>R&lt;C&gt;</span>
</span>R&lt;int&gt; Ri;          <span class='comment'>// OK: <span class='texttt'>"friend int;"</span> is ignored
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='friend_function,linkage_of'></a></span>A function first declared in a friend declaration
has the linkage of the namespace of which it is a member (<a href='basic.link'>[basic.link]</a>).
Otherwise, the function retains its previous linkage (<a href='dcl.stc'>[dcl.stc]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='declaration,overloaded_name_and_friend'></a></span>When a
<span class='texttt'>friend</span>
declaration refers to an overloaded name or operator, only the function specified
by the parameter types becomes a friend.
A member function of a class
<span class='texttt'>X</span>
can be a friend of
a class
<span class='texttt'>Y</span>.
<span class='indexparent'><a class='index' id='member_function,friend'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class Y {
  friend char* X::foo(int);
  friend X::X(char);            <span class='comment'>// constructors can be friends
</span>  friend X::~X();               <span class='comment'>// destructors can be friends
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='friend_function,inline'></a></span>A function can be defined in a friend declaration of a class if and only if the
class is a non-local class (<a href='class.local'>[class.local]</a>), the function name is unqualified,
and the function has namespace scope.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class M {
  friend void f() { }           <span class='comment'>// definition of global <span class='texttt'>f</span>, a friend of <span class='texttt'>M</span>,
</span>                                <span class='comment'>// not the definition of a member function
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Such a function is implicitly an inline function (<a href='dcl.inline'>[dcl.inline]</a>).
A
<span class='texttt'>friend</span>
function defined in a class is in the (lexical) scope of the class in which it is defined.
A friend function defined outside the class is not (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>).</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >No
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
shall appear in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a friend declaration.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='friend,access_specifier_and'></a></span>A name nominated by a friend declaration shall be accessible in the scope of the
class containing the friend declaration.
The meaning of the friend declaration is the same whether the friend declaration
appears in the
<span class='texttt'>private</span>,
<span class='texttt'>protected</span>
or
<span class='texttt'>public</span> (<a href='class.mem'>[class.mem]</a>)
portion of the class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='friend,inheritance_and'></a></span>Friendship is neither inherited nor transitive.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
  friend class B;
  int a;
};

class B {
  friend class C;
};

class C  {
  void f(A* p) {
    p-&gt;a++;         <span class='comment'>// error: <span class='texttt'>C</span> is not a friend of <span class='texttt'>A</span>
</span>                    <span class='comment'>// despite being a friend of a friend
</span>  }
};

class D : public B  {
  void f(A* p) {
    p-&gt;a++;         <span class='comment'>// error: <span class='texttt'>D</span> is not a friend of <span class='texttt'>A</span>
</span>                    <span class='comment'>// despite being derived from a friend
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='local_class,friend'></a></span><span class='indexparent'><a class='index' id='friend,local_class_and'></a></span>If a friend declaration appears in a local class (<a href='class.local'>[class.local]</a>) and the
name specified is an unqualified name, a prior declaration is looked
up without considering scopes that are outside the innermost enclosing
non-class scope.
For a friend function declaration, if there is no
prior declaration, the program is ill-formed.
For a friend class
declaration, if there is no prior declaration, the class that is
specified belongs to the innermost enclosing non-class scope, but if it is
subsequently referenced, its name is not found by name lookup
until a matching declaration is provided in the innermost enclosing
non-class scope.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class X;
void a();
void f() {
  class Y;
  extern void b();
  class A {
  friend class X;   <span class='comment'>// OK, but <span class='texttt'>X</span> is a local class, not <span class='texttt'>::X</span>
</span>  friend class Y;   <span class='comment'>// OK
</span>  friend class Z;   <span class='comment'>// OK, introduces local class <span class='texttt'>Z</span>
</span>  friend void a();  <span class='comment'>// error, <span class='texttt'>::a</span> is not considered
</span>  friend void b();  <span class='comment'>// OK
</span>  friend void c();  <span class='comment'>// error
</span>  };
  X* px;            <span class='comment'>// OK, but <span class='texttt'>::X</span> is found
</span>  Z* pz;            <span class='comment'>// error, no <span class='texttt'>Z</span> is found
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>