<!DOCTYPE html><html lang='en'><head><title>[over.dcl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.2</a> Declaration matching <a class='abbr_ref'>[over.dcl]</a></h2><p ><span class='indexparent'><a class='index' id=':overloading,declaration_matching'></a></span><span class='indexparent'><a class='index' id=':scope,overloading_and'></a></span><span class='indexparent'><a class='index' id=':base_class,overloading_and'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/overloading.tex#L308'>#</a></div><p >Two function declarations of the same name refer to the same function if they
are in the same scope and have equivalent parameter declarations (<a href='over.load'>[over.load]</a>).
A function member of a derived class is
<span class='textit'>not</span>
in the same scope as a function member of the same name in a base class.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct B {
  int f(int);
};

struct D : B {
  int f(const char*);
};</pre><p ><span class='indexparent'><a class='index' id=':name_hiding,function'></a></span><span class='indexparent'><a class='index' id=':name_hiding,overloading_versus'></a></span>Here
<span class='texttt'>D&#x200b;::&#x200b;f(const char*)</span>
hides
<span class='texttt'>B&#x200b;::&#x200b;f(int)</span>
rather than overloading it.</p><p ><span class='indexparent'><a class='index' id=':Ben'></a></span></p><pre class='codeblock'>
void h(D* pd) {
  pd-&gt;f(1);                     <span class='comment'>// error:
</span>                                <span class='comment'>// <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;f(const char*)</span> hides <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f(int)</span>
</span>  pd-&gt;B::f(1);                  <span class='comment'>// OK
</span>  pd-&gt;f("Ben");                 <span class='comment'>// OK, calls <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;f</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/overloading.tex#L345'>#</a></div><p >A locally declared function is not in the same scope as a function in
a containing scope.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                    <span class='comment'>// error: <span class='tcode_in_codeblock'>f(int)</span> hides <span class='tcode_in_codeblock'>f(const char*)</span>
</span>                                <span class='comment'>// so there is no <span class='tcode_in_codeblock'>f(const char*)</span> in this scope
</span>}

void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);    <span class='comment'>// hides <span class='tcode_in_codeblock'>callee(int, int)</span>
</span>    callee(88, 99);             <span class='comment'>// error: only <span class='tcode_in_codeblock'>callee(int)</span> in scope
</span>  }
}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/overloading.tex#L368'>#</a></div><p ><span class='indexparent'><a class='index' id=':access_control,overloading_and'></a></span><span class='indexparent'><a class='index' id=':overloading,access_control_and'></a></span>Different versions of an overloaded member function can be given different
access rules.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
class buffer {
private:
    char* p;
    int size;
protected:
    buffer(int s, char* store) { size = s; p = store; }
public:
    buffer(int s) { p = new char[size = s]; }
};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div></body></html>