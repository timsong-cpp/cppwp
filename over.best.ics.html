<!DOCTYPE html><html lang='en'><head><title>[over.best.ics]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.4</a> Overload resolution <a class='abbr_ref' href='over.match#over.best.ics'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>12.4.3</a> Best viable function <a class='abbr_ref' href='over.match.best#over.best.ics'>[over.match.best]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>12.4.3.1</a> Implicit conversion sequences <a class='abbr_ref'>[over.best.ics]</a></h4><span class='indexparent'><a class='index' id=':overloading,resolution,implicit_conversions_and'></a></span>
<div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2228'>#</a></div><div id='1.sentence-1' class='sentence'>An <a class='hidden_link' href='#def:conversion_sequence,implicit' id='def:conversion_sequence,implicit'><i >implicit conversion sequence</i></a>
is a sequence of conversions used
to convert an argument in a function call to the type of the
corresponding parameter of the function being called<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>The
sequence of conversions is an implicit conversion as defined in
<a href='conv'>[conv]</a>, which means it is governed by the rules for
initialization of an object or reference by a single
expression (<a href='dcl.init'>[dcl.init]</a>, <a href='dcl.init.ref'>[dcl.init.ref]</a>)<a class='hidden_link' href='#1.sentence-2'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2239'>#</a></div><div id='2.sentence-1' class='sentence'>Implicit conversion sequences are concerned only with the type,
cv-qualification, and value category of the argument and how these
are converted to match the corresponding properties of the
parameter<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.note-1' class='note'>[&nbsp;<a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-2' class='sentence'>Other properties, such as the lifetime, storage class,
alignment, accessibility of the argument, whether the argument is a bit-field,
and whether a function is <a href='dcl.fct.def.delete'>deleted</a>, are ignored<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>So, although an implicit
conversion sequence can be defined for a given argument-parameter
pair, the conversion from the argument to the parameter might still
be ill-formed in the final analysis<a class='hidden_link' href='#2.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2254'>#</a></div><div id='3.sentence-1' class='sentence'>A
well-formed implicit conversion
sequence is one of the following forms:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div>a <a href='#over.ics.scs'>standard conversion sequence</a>,</li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div>a <a href='#over.ics.user'>user-defined conversion sequence</a>, or</li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div>an <a href='#over.ics.ellipsis'>ellipsis conversion sequence</a><a class='hidden_link' href='#3.sentence-1'>.</a></li></ul></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2267'>#</a></div><div id='4.sentence-1' class='sentence'>However, if the target is
<ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div>the first parameter of a constructor or</li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div>the implicit object parameter of a user-defined conversion function</li></ul>
and the constructor or user-defined conversion function is a candidate by
<ul class='itemize'><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><a href='over.match.ctor'>[over.match.ctor]</a>, when the argument is the temporary in the second
step of a class copy-initialization,</li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.conv'>[over.match.conv]</a>, or <a href='over.match.ref'>[over.match.ref]</a>
(in all cases), or</li><li id='4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.5'>(4.5)</a></div>the second phase of <a href='over.match.list'>[over.match.list]</a>
when the initializer list has exactly one element that
is itself an initializer list, and
the target is the first parameter of a constructor of class <span class='texttt'>X</span>, and
the conversion is to <span class='texttt'>X</span> or reference to <span class='mathit'>cv</span> <span class='texttt'>X</span>,</li></ul>
user-defined conversion sequences are not considered<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.note-1' class='note'>[&nbsp;<a class='note_link' href='#4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='4.sentence-2' class='sentence'>These rules prevent more than one user-defined conversion from being
applied during overload resolution, thereby avoiding infinite recursion<a class='hidden_link' href='#4.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='4.example-1' class='example'>[&nbsp;<a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> Y <span class='curlybracket'>{</span> Y<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='keyword'>operator</span> <span class='keyword'>int</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
Y y1 <span class='operator'>=</span> A<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;         <span class='comment'>// error: <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;<span class='tcode_in_codeblock'>operator</span><span class='indexparent'><a class='index' id=':operator'></a></span> int()</span> is not a candidate</span>

<span class='keyword'>struct</span> X <span class='curlybracket'>{</span> X<span class='parenthesis'>(</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> B <span class='curlybracket'>{</span> <span class='keyword'>operator</span> X<span class='parenthesis'>(</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
B b;
X x<span class='curlybracket'>{</span><span class='curlybracket'>{</span>b<span class='curlybracket'>}</span><span class='curlybracket'>}</span>;           <span class='comment'>// error: <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;<span class='tcode_in_codeblock'>operator</span><span class='indexparent'><a class='index' id=':operator_'></a></span> X()</span> is not a candidate</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2303'>#</a></div><div id='5.sentence-1' class='sentence'>For the case where the parameter type is a reference, see <a href='#over.ics.ref'>[over.ics.ref]</a><a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2306'>#</a></div><div id='6.sentence-1' class='sentence'>When the parameter type is not a reference, the implicit conversion
sequence models a copy-initialization of the parameter from the argument
expression<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>The implicit conversion sequence is the one required to convert the
argument expression to a prvalue of the type of
the parameter<a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.note-1' class='note'>[&nbsp;<a class='note_link' href='#6.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='6.sentence-3' class='sentence'>When the parameter has a class type, this is a conceptual conversion
defined for the purposes of <a href='over'>[over]</a>; the actual initialization is
defined in terms of constructors and is not a conversion<a class='hidden_link' href='#6.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='6.sentence-4' class='sentence'>
Any difference in top-level cv-qualification is
subsumed by the initialization itself and does not constitute a conversion<a class='hidden_link' href='#6.sentence-4'>.</a></div> <div id='6.example-1' class='example'>[&nbsp;<a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='6.sentence-5' class='sentence'>A parameter of type
<span class='texttt'>A</span>
can be initialized from an argument of type
<span class='texttt'><span class='keyword'>const</span> A</span><a class='hidden_link' href='#6.sentence-5'>.</a></div> <div id='6.sentence-6' class='sentence'>The implicit conversion sequence for that case is the identity sequence; it
contains no “conversion” from
<span class='texttt'><span class='keyword'>const</span> A</span>
to
<span class='texttt'>A</span><a class='hidden_link' href='#6.sentence-6'>.</a></div> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='6.sentence-7' class='sentence'>
When the parameter has a class type and the argument expression has the
same type, the implicit conversion sequence is an identity conversion<a class='hidden_link' href='#6.sentence-7'>.</a></div> <div id='6.sentence-8' class='sentence'>When the parameter has a class type and the argument expression has a
derived class type, the implicit conversion sequence is a
derived-to-base
<span class='indexparent'><a class='index' id=':conversion,derived-to-base'></a></span>conversion from the derived class to the base class<a class='hidden_link' href='#6.sentence-8'>.</a></div> <div id='6.note-2' class='note'>[&nbsp;<a class='note_link' href='#6.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='6.sentence-9' class='sentence'>There is no such standard conversion; this derived-to-base conversion exists
only in the description of implicit conversion sequences<a class='hidden_link' href='#6.sentence-9'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='6.sentence-10' class='sentence'>
A derived-to-base conversion has Conversion rank (<a href='#over.ics.scs'>[over.ics.scs]</a>)<a class='hidden_link' href='#6.sentence-10'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2344'>#</a></div><div id='7.sentence-1' class='sentence'>In all contexts, when converting to the implicit object parameter
or when converting to the left operand of an assignment operation
only standard conversion sequences are allowed<a class='hidden_link' href='#7.sentence-1'>.</a></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2349'>#</a></div><div id='8.sentence-1' class='sentence'>If no conversions are required to match an argument to a
parameter type, the implicit conversion sequence is the standard
conversion sequence consisting of the identity conversion (<a href='#over.ics.scs'>[over.ics.scs]</a>)<a class='hidden_link' href='#8.sentence-1'>.</a></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2354'>#</a></div><div id='9.sentence-1' class='sentence'>If no sequence of conversions can be found to convert an argument
to a parameter type, an implicit conversion sequence cannot be formed<a class='hidden_link' href='#9.sentence-1'>.</a></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2358'>#</a></div><div id='10.sentence-1' class='sentence'>If there are multiple well-formed implicit conversion sequences
converting the argument to the parameter type, the implicit
conversion sequence associated with the parameter is defined to be
the unique conversion sequence designated the
<a class='hidden_link' href='#def:conversion_sequence,ambiguous' id='def:conversion_sequence,ambiguous'><i >ambiguous conversion sequence</i></a><a class='hidden_link' href='#10.sentence-1'>.</a></div> <div id='10.sentence-2' class='sentence'>For the purpose of ranking implicit conversion sequences as described
in <a href='over.ics.rank'>[over.ics.rank]</a>, the ambiguous conversion sequence is treated
as a user-defined conversion sequence that is indistinguishable from any
other user-defined conversion sequence<a class='hidden_link' href='#10.sentence-2'>.</a></div> <div id='10.note-1' class='note'>[&nbsp;<a class='note_link' href='#10.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='10.sentence-3' class='sentence'>This rule prevents a function from becoming non-viable because of an ambiguous
conversion sequence for one of its parameters<a class='hidden_link' href='#10.sentence-3'>.</a></div> <div id='10.example-1' class='example'>[&nbsp;<a class='example_link' href='#10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>class</span> B;
<span class='keyword'>class</span> A <span class='curlybracket'>{</span> A <span class='parenthesis'>(</span>B<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;<span class='curlybracket'>}</span>;
<span class='keyword'>class</span> B <span class='curlybracket'>{</span> <span class='keyword'>operator</span> A <span class='parenthesis'>(</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
<span class='keyword'>class</span> C <span class='curlybracket'>{</span> C <span class='parenthesis'>(</span>B<span class='operator'>&amp;</span><span class='parenthesis'>)</span>; <span class='curlybracket'>}</span>;
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>A<span class='parenthesis'>)</span> <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>C<span class='parenthesis'>)</span> <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>
B b;
f<span class='parenthesis'>(</span>b<span class='parenthesis'>)</span>;               <span class='comment'>// error: ambiguous because there is a conversion <span class='tcode_in_codeblock'>b</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>C</span> (via constructor)</span>
                    <span class='comment'>// and an (ambiguous) conversion <span class='tcode_in_codeblock'>b</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A</span> (via constructor or conversion function)</span>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>B<span class='parenthesis'>)</span> <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>
f<span class='parenthesis'>(</span>b<span class='parenthesis'>)</span>;               <span class='comment'>// OK, unambiguous</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='10.sentence-4' class='sentence'>
If a function that uses the ambiguous conversion sequence is selected
as the best viable function, the call will be ill-formed because the conversion
of one of the arguments in the call is ambiguous<a class='hidden_link' href='#10.sentence-4'>.</a></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2391'>#</a></div><div id='11.sentence-1' class='sentence'>The three forms of implicit conversion sequences mentioned above
are defined in the following subclauses<a class='hidden_link' href='#11.sentence-1'>.</a></div></div><div id='over.ics.scs' class='section'><h4 ><a class='secnum' href='#over.ics.scs' style='min-width:133pt'>12.4.3.1.1</a> Standard conversion sequences <a class='abbr_ref' href='over.ics.scs'>[over.ics.scs]</a></h4><div class='para' id='over.ics.scs-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2397'>#</a></div><div id='over.ics.scs-1.sentence-1' class='sentence'>Table <a href='#tab:over.ics.scs'>16</a>
summarizes the conversions defined in <a href='conv'>[conv]</a> and
partitions them into four disjoint categories: Lvalue Transformation,
Qualification Adjustment, Promotion, and Conversion<a class='hidden_link' href='#over.ics.scs-1.sentence-1'>.</a></div> <div id='over.ics.scs-1.note-1' class='note'>[&nbsp;<a class='note_link' href='#over.ics.scs-1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='over.ics.scs-1.sentence-2' class='sentence'>These categories are orthogonal with respect to value category,
cv-qualification, and data representation: the Lvalue Transformations
do not change the cv-qualification or data
representation of the type; the Qualification Adjustments do not
change the value category or data representation of the type; and
the Promotions and Conversions do not change the
value category or cv-qualification of the type<a class='hidden_link' href='#over.ics.scs-1.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.scs-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2412'>#</a></div><div id='over.ics.scs-2.note-1' class='note'>[&nbsp;<a class='note_link' href='#over.ics.scs-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='over.ics.scs-2.sentence-1' class='sentence'>As described in <a href='conv'>[conv]</a>,
a standard conversion sequence either is the Identity conversion
by itself (that is, no conversion) or consists of one to three
conversions from the other
four categories<a class='hidden_link' href='#over.ics.scs-2.sentence-1'>.</a></div> <div id='over.ics.scs-2.sentence-2' class='sentence'>If there are two or more conversions in the sequence, the
conversions are applied in the canonical order:
<b>Lvalue Transformation</b>,
<b>Promotion</b>
or
<b>Conversion</b>,
<b>Qualification Adjustment</b><a class='hidden_link' href='#over.ics.scs-2.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.scs-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.scs-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2428'>#</a></div><div id='over.ics.scs-3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':conversion_rank'></a></span>Each conversion in Table <a href='#tab:over.ics.scs'>16</a>
also has an associated rank (Exact
Match, Promotion, or Conversion)<a class='hidden_link' href='#over.ics.scs-3.sentence-1'>.</a></div> <div id='over.ics.scs-3.sentence-2' class='sentence'>These are used
to <a href='over.ics.rank'>rank standard conversion sequences</a><a class='hidden_link' href='#over.ics.scs-3.sentence-2'>.</a></div> <div id='over.ics.scs-3.sentence-3' class='sentence'>The rank of a conversion sequence is determined by considering the
rank of each conversion in the sequence and the rank of any <a href='#over.ics.ref'>reference
binding</a><a class='hidden_link' href='#over.ics.scs-3.sentence-3'>.</a></div> <div id='over.ics.scs-3.sentence-4' class='sentence'>If any of those has Conversion rank, the
sequence has Conversion rank; otherwise, if any of those has Promotion rank,
the sequence has Promotion rank; otherwise, the sequence has Exact
Match rank<a class='hidden_link' href='#over.ics.scs-3.sentence-4'>.</a></div><div class='numberedTable' id='tab:over.ics.scs'>Table <a href='#tab:over.ics.scs'>16</a>: Conversions &emsp;&ensp;[tab:over.ics.scs]<br><table ><tr class='rowsep'><td class='left'><div id='over.ics.scs-3.sentence-5' class='sentence'><b>Conversion</b></div></td><td class='border center'><div id='over.ics.scs-3.sentence-6' class='sentence'><b>Category</b></div></td><td class='border center'><div id='over.ics.scs-3.sentence-7' class='sentence'><b>Rank</b></div></td><td class='border center'><div id='over.ics.scs-3.sentence-8' class='sentence'><b>Subclause</b></div></td></tr><tr class='capsep'><td class='left'><div id='over.ics.scs-3.sentence-9' class='sentence'>No conversions required</div></td><td class='border center'><div id='over.ics.scs-3.sentence-10' class='sentence'>Identity</div></td><td class='empty border center'></td><td class='empty border center'></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-11' class='sentence'>
Lvalue-to-rvalue conversion</div></td><td class='empty border center cline'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-12' class='sentence'><a href='conv.lval'>[conv.lval]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-13' class='sentence'>
Array-to-pointer conversion</div></td><td class='border center'><div id='over.ics.scs-3.sentence-14' class='sentence'>Lvalue Transformation</div></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-15' class='sentence'><a href='conv.array'>[conv.array]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-16' class='sentence'>
Function-to-pointer conversion</div></td><td class='empty border center'></td><td class='border center'><span style='position: relative; top: -1.5ex'>Exact Match</span></td><td class='border center cline'><div id='over.ics.scs-3.sentence-17' class='sentence'><a href='conv.func'>[conv.func]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-18' class='sentence'>
Qualification conversions</div></td><td class='empty border center cline'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-19' class='sentence'><a href='conv.qual'>[conv.qual]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-20' class='sentence'>
Function pointer conversion</div></td><td class='border center'><span style='position: relative; top: -1.5ex'>Qualification Adjustment</span></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-21' class='sentence'><a href='conv.fctptr'>[conv.fctptr]</a></div></td></tr><tr class='rowsep'><td class='left'><div id='over.ics.scs-3.sentence-22' class='sentence'>Integral promotions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center'><div id='over.ics.scs-3.sentence-23' class='sentence'><a href='conv.prom'>[conv.prom]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-24' class='sentence'>
Floating-point promotion</div></td><td class='border center'><span style='position: relative; top: -1.5ex'>Promotion</span></td><td class='border center'><span style='position: relative; top: -1.5ex'>Promotion</span></td><td class='border center cline'><div id='over.ics.scs-3.sentence-25' class='sentence'><a href='conv.fpprom'>[conv.fpprom]</a></div></td></tr><tr class='rowsep'><td class='left'><div id='over.ics.scs-3.sentence-26' class='sentence'>Integral conversions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center'><div id='over.ics.scs-3.sentence-27' class='sentence'><a href='conv.integral'>[conv.integral]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-28' class='sentence'>
Floating-point conversions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-29' class='sentence'><a href='conv.double'>[conv.double]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-30' class='sentence'>
Floating-integral conversions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-31' class='sentence'><a href='conv.fpint'>[conv.fpint]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-32' class='sentence'>
Pointer conversions</div></td><td class='border center'><span style='position: relative; top: -1.5ex'>Conversion</span></td><td class='border center'><span style='position: relative; top: -1.5ex'>Conversion</span></td><td class='border center cline'><div id='over.ics.scs-3.sentence-33' class='sentence'><a href='conv.ptr'>[conv.ptr]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-34' class='sentence'>
Pointer-to-member conversions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-35' class='sentence'><a href='conv.mem'>[conv.mem]</a></div></td></tr><tr ><td class='left cline'><div id='over.ics.scs-3.sentence-36' class='sentence'>
Boolean conversions</div></td><td class='empty border center'></td><td class='empty border center'></td><td class='border center cline'><div id='over.ics.scs-3.sentence-37' class='sentence'><a href='conv.bool'>[conv.bool]</a></div></td></tr></table></div></div></div><div id='over.ics.user' class='section'><h4 ><a class='secnum' href='#over.ics.user' style='min-width:133pt'>12.4.3.1.2</a> User-defined conversion sequences <a class='abbr_ref' href='over.ics.user'>[over.ics.user]</a></h4><div class='para' id='over.ics.user-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2464'>#</a></div><div id='over.ics.user-1.sentence-1' class='sentence'>A <a class='hidden_link' href='#def:conversion_sequence,user-defined' id='def:conversion_sequence,user-defined'><i >user-defined conversion sequence</i></a> consists of an initial
standard conversion sequence followed by a user-defined
conversion (<a href='class.conv'>[class.conv]</a>) followed by a second standard
conversion sequence<a class='hidden_link' href='#over.ics.user-1.sentence-1'>.</a></div> <div id='over.ics.user-1.sentence-2' class='sentence'>If the user-defined conversion is <a href='class.conv.ctor'>specified
by a constructor</a>, the initial standard
conversion sequence converts the source type to the type required
by the argument of the constructor<a class='hidden_link' href='#over.ics.user-1.sentence-2'>.</a></div> <div id='over.ics.user-1.sentence-3' class='sentence'>If the user-defined
conversion is specified by a <a href='class.conv.fct'>conversion function</a>, the
initial standard conversion sequence
converts the source type to the implicit object parameter of the
conversion function<a class='hidden_link' href='#over.ics.user-1.sentence-3'>.</a></div></div><div class='para' id='over.ics.user-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2479'>#</a></div><div id='over.ics.user-2.sentence-1' class='sentence'>The second standard conversion sequence converts the result of
the user-defined conversion to the target type for the sequence;
any reference binding is included in the second standard
conversion sequence<a class='hidden_link' href='#over.ics.user-2.sentence-1'>.</a></div> <div id='over.ics.user-2.sentence-2' class='sentence'>Since an implicit conversion sequence is an initialization, the
special rules for initialization by user-defined conversion apply
when selecting the best user-defined conversion for a
user-defined conversion sequence (see <a href='over.match.best'>[over.match.best]</a> and <a href='#over.best.ics'>[over.best.ics]</a>)<a class='hidden_link' href='#over.ics.user-2.sentence-2'>.</a></div></div><div class='para' id='over.ics.user-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2489'>#</a></div><div id='over.ics.user-3.sentence-1' class='sentence'>If the user-defined conversion is specified by a
specialization of a conversion function template,
the second standard conversion sequence shall have exact match rank<a class='hidden_link' href='#over.ics.user-3.sentence-1'>.</a></div></div><div class='para' id='over.ics.user-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.user-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2494'>#</a></div><div id='over.ics.user-4.sentence-1' class='sentence'>A conversion of an expression of class type
to the same class type is given Exact Match rank, and
a conversion of an expression of class type
to a base class of that type is given Conversion rank,
in spite of the
fact that a constructor (i.e., a user-defined conversion
function) is called for those cases<a class='hidden_link' href='#over.ics.user-4.sentence-1'>.</a></div></div></div><div id='over.ics.ellipsis' class='section'><h4 ><a class='secnum' href='#over.ics.ellipsis' style='min-width:133pt'>12.4.3.1.3</a> Ellipsis conversion sequences <a class='abbr_ref' href='over.ics.ellipsis'>[over.ics.ellipsis]</a></h4><div class='para' id='over.ics.ellipsis-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ellipsis-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2505'>#</a></div><div id='over.ics.ellipsis-1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':ellipsis,conversion_sequence'></a></span>An ellipsis conversion sequence occurs when an argument in a
function call is matched with the ellipsis parameter
specification of the function called (see <a href='expr.call'>[expr.call]</a>)<a class='hidden_link' href='#over.ics.ellipsis-1.sentence-1'>.</a></div></div></div><div id='over.ics.ref' class='section'><h4 ><a class='secnum' href='#over.ics.ref' style='min-width:133pt'>12.4.3.1.4</a> Reference binding <a class='abbr_ref' href='over.ics.ref'>[over.ics.ref]</a></h4><div class='para' id='over.ics.ref-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2513'>#</a></div><div id='over.ics.ref-1.sentence-1' class='sentence'>When a parameter of reference type <a href='dcl.init.ref'>binds directly</a> to an
argument expression, the implicit conversion sequence is the identity conversion,
unless the argument expression has a type that is a derived class of the parameter
type, in which case the implicit conversion sequence is a derived-to-base
Conversion (<a href='#over.best.ics'>[over.best.ics]</a>)<a class='hidden_link' href='#over.ics.ref-1.sentence-1'>.</a></div> <div id='over.ics.ref-1.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.ref-1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> B <span class='operator'>:</span> <span class='keyword'>public</span> A <span class='curlybracket'>{</span><span class='curlybracket'>}</span> b;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span>A<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> f<span class='parenthesis'>(</span>B<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>int</span> i <span class='operator'>=</span> f<span class='parenthesis'>(</span>b<span class='parenthesis'>)</span>;       <span class='comment'>// calls <span class='tcode_in_codeblock'>f(B&amp;)</span>, an exact match, rather than <span class='tcode_in_codeblock'>f(A&amp;)</span>, a conversion</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  <div id='over.ics.ref-1.sentence-2' class='sentence'>
If the parameter binds directly to the result of
applying a conversion function to the argument expression, the implicit
conversion sequence is a <a href='#over.ics.user'>user-defined conversion sequence</a>,
with the second standard conversion sequence either an identity conversion or,
if the conversion function returns an entity of a type that is a derived class
of the parameter type, a derived-to-base conversion<a class='hidden_link' href='#over.ics.ref-1.sentence-2'>.</a></div></div><div class='para' id='over.ics.ref-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2535'>#</a></div><div id='over.ics.ref-2.sentence-1' class='sentence'>When a parameter of reference type is not bound directly to an argument
expression, the conversion sequence is the one required to convert the argument
expression to the referenced type according to <a href='#over.best.ics'>[over.best.ics]</a><a class='hidden_link' href='#over.ics.ref-2.sentence-1'>.</a></div> <div id='over.ics.ref-2.sentence-2' class='sentence'>Conceptually, this conversion sequence corresponds to copy-initializing a
temporary of the referenced type with the argument expression<a class='hidden_link' href='#over.ics.ref-2.sentence-2'>.</a></div> <div id='over.ics.ref-2.sentence-3' class='sentence'>Any difference
in top-level cv-qualification is subsumed by the initialization itself and
does not constitute a conversion<a class='hidden_link' href='#over.ics.ref-2.sentence-3'>.</a></div></div><div class='para' id='over.ics.ref-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2545'>#</a></div><div id='over.ics.ref-3.sentence-1' class='sentence'>Except for an implicit object parameter, for which see <a href='over.match.funcs'>[over.match.funcs]</a>,
an implicit conversion sequence cannot be formed if it requires
binding an lvalue reference
other than a reference to a non-volatile <span class='texttt'><span class='keyword'>const</span></span> type
to an rvalue
or binding an rvalue reference to an lvalue other than a function lvalue<a class='hidden_link' href='#over.ics.ref-3.sentence-1'>.</a></div> <div id='over.ics.ref-3.note-1' class='note'>[&nbsp;<a class='note_link' href='#over.ics.ref-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='over.ics.ref-3.sentence-2' class='sentence'>This means, for example, that a candidate function cannot be a viable
function if it has a non-<span class='texttt'><span class='keyword'>const</span></span> lvalue reference parameter (other than
the implicit object parameter) and the corresponding argument
would require a temporary to be created to initialize the lvalue
reference (see <a href='dcl.init.ref'>[dcl.init.ref]</a>)<a class='hidden_link' href='#over.ics.ref-3.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.ref-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.ref-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2560'>#</a></div><div id='over.ics.ref-4.sentence-1' class='sentence'>Other restrictions on binding a reference to a particular argument
that are not based on the types of the reference and the argument
do not affect the formation of an implicit conversion
sequence, however<a class='hidden_link' href='#over.ics.ref-4.sentence-1'>.</a></div> <div id='over.ics.ref-4.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.ref-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='over.ics.ref-4.sentence-2' class='sentence'>A function with an “lvalue reference to <span class='texttt'><span class='keyword'>int</span></span>” parameter can
be a viable candidate even if the corresponding argument is an
<span class='texttt'><span class='keyword'>int</span></span>
bit-field<a class='hidden_link' href='#over.ics.ref-4.sentence-2'>.</a></div> <div id='over.ics.ref-4.sentence-3' class='sentence'>The formation of implicit conversion sequences
treats the
<span class='texttt'><span class='keyword'>int</span></span>
bit-field as an
<span class='texttt'><span class='keyword'>int</span></span>
lvalue and finds an exact
match with the parameter<a class='hidden_link' href='#over.ics.ref-4.sentence-3'>.</a></div> <div id='over.ics.ref-4.sentence-4' class='sentence'>If the function is selected by overload
resolution, the call will nonetheless be ill-formed because of
the prohibition on binding a non-<span class='texttt'><span class='keyword'>const</span></span> lvalue reference to a bit-field (<a href='dcl.init.ref'>[dcl.init.ref]</a>)<a class='hidden_link' href='#over.ics.ref-4.sentence-4'>.</a></div> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div></div><div id='over.ics.list' class='section'><h4 ><a class='secnum' href='#over.ics.list' style='min-width:133pt'>12.4.3.1.5</a> List-initialization sequence <a class='abbr_ref' href='over.ics.list'>[over.ics.list]</a></h4><div class='para' id='over.ics.list-1'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2584'>#</a></div><div id='over.ics.list-1.sentence-1' class='sentence'>When an argument is an initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), it is not an expression and special rules apply for converting it to a parameter type<a class='hidden_link' href='#over.ics.list-1.sentence-1'>.</a></div></div><div class='para' id='over.ics.list-2'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2588'>#</a></div><div id='over.ics.list-2.sentence-1' class='sentence'>If the initializer list is a <a class='grammarterm' href='dcl.init#nt:designated-initializer-list'>designated-initializer-list</a>,
a conversion is only possible if
the parameter has an aggregate type
that can be initialized from the initializer list
according to the rules for aggregate initialization (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>),
in which case the implicit conversion sequence is
a user-defined conversion sequence
whose second standard conversion sequence
is an identity conversion<a class='hidden_link' href='#over.ics.list-2.sentence-1'>.</a></div> <div id='over.ics.list-2.note-1' class='note'>[&nbsp;<a class='note_link' href='#over.ics.list-2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='over.ics.list-2.sentence-2' class='sentence'>Aggregate initialization does not require that
the members are declared in designation order<a class='hidden_link' href='#over.ics.list-2.sentence-2'>.</a></div> <div id='over.ics.list-2.sentence-3' class='sentence'>If, after overload resolution, the order does not match
for the selected overload,
the initialization of the parameter will be ill-formed (<a href='dcl.init.list'>[dcl.init.list]</a>)<a class='hidden_link' href='#over.ics.list-2.sentence-3'>.</a></div> <div id='over.ics.list-2.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='keyword'>int</span> x, y; <span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> B <span class='curlybracket'>{</span> <span class='keyword'>int</span> y, x; <span class='curlybracket'>}</span>;
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>A a, <span class='keyword'>int</span><span class='parenthesis'>)</span>;               <span class='comment'>// #1</span>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>B b, <span class='operator'>.</span><span class='operator'>.</span><span class='operator'>.</span><span class='parenthesis'>)</span>;               <span class='comment'>// #2</span>
<span class='keyword'>void</span> g<span class='parenthesis'>(</span>A a<span class='parenthesis'>)</span>;                    <span class='comment'>// #3</span>
<span class='keyword'>void</span> g<span class='parenthesis'>(</span>B b<span class='parenthesis'>)</span>;                    <span class='comment'>// #4</span>
<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  f<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='operator'>.</span>x <span class='operator'>=</span> <span class='literal'>1</span>, <span class='operator'>.</span>y <span class='operator'>=</span> <span class='literal'>2</span><span class='curlybracket'>}</span>, <span class='literal'>0</span><span class='parenthesis'>)</span>;       <span class='comment'>// OK; calls #1</span>
  f<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='operator'>.</span>y <span class='operator'>=</span> <span class='literal'>2</span>, <span class='operator'>.</span>x <span class='operator'>=</span> <span class='literal'>1</span><span class='curlybracket'>}</span>, <span class='literal'>0</span><span class='parenthesis'>)</span>;       <span class='comment'>// error: selects #1, initialization of <span class='tcode_in_codeblock'>a</span> fails</span>
                                <span class='comment'>// due to non-matching member order (<a href='dcl.init.list'>[dcl.init.list]</a>)</span>
  g<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='operator'>.</span>x <span class='operator'>=</span> <span class='literal'>1</span>, <span class='operator'>.</span>y <span class='operator'>=</span> <span class='literal'>2</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;          <span class='comment'>// error: ambiguous between #3 and #4</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div>  —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.list-3'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2622'>#</a></div><div id='over.ics.list-3.sentence-1' class='sentence'>Otherwise,
if the parameter type is an aggregate class <span class='texttt'>X</span> and the initializer list has a
single element of type <span class='mathit'>cv</span> <span class='texttt'>U</span>, where <span class='texttt'>U</span> is <span class='texttt'>X</span>
or a class derived from <span class='texttt'>X</span>, the implicit conversion sequence is the one
required to convert the element to the parameter type<a class='hidden_link' href='#over.ics.list-3.sentence-1'>.</a></div></div><div class='para' id='over.ics.list-4'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2629'>#</a></div><div id='over.ics.list-4.sentence-1' class='sentence'>Otherwise, if the parameter type is a character array<a class='footnotenum' href='#footnote-125' id='footnoteref-125'>125</a>
and the initializer list has a single element that is an appropriately-typed
<a class='grammarterm' href='lex.string#nt:string-literal'>string-literal</a> (<a href='dcl.init.string'>[dcl.init.string]</a>), the implicit conversion
sequence is the identity conversion<a class='hidden_link' href='#over.ics.list-4.sentence-1'>.</a></div></div><div class='para' id='over.ics.list-5'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2637'>#</a></div><div id='over.ics.list-5.sentence-1' class='sentence'>Otherwise, if the parameter type is <span class='texttt'>std<span class='operator'>&#x200b;::&#x200b;</span>initializer_&shy;list<span class='anglebracket'>&lt;</span>X<span class='anglebracket'>&gt;</span></span>
and all the elements
of the initializer list can be implicitly converted to <span class='texttt'>X</span>, the implicit
conversion sequence is the worst conversion necessary to convert an element of
the list to <span class='texttt'>X</span>, or if the initializer list has no elements, the identity
conversion<a class='hidden_link' href='#over.ics.list-5.sentence-1'>.</a></div> <div id='over.ics.list-5.sentence-2' class='sentence'>This conversion can be a user-defined conversion even in
the context of a call to an initializer-list constructor<a class='hidden_link' href='#over.ics.list-5.sentence-2'>.</a></div> <div id='over.ics.list-5.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;                        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> identity conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span>,<span class='literal'>3</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;                   <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> identity conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>,<span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;                 <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> integral promotion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;                     <span class='comment'>// error: narrowing</span>

<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  A<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span><span class='keyword'>double</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;             <span class='comment'>// #1</span>
  A<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span>complex<span class='anglebracket'>&lt;</span><span class='keyword'>double</span><span class='anglebracket'>&gt;</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;    <span class='comment'>// #2</span>
  A<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span>std<span class='operator'>::</span>string<span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;        <span class='comment'>// #3</span>
<span class='curlybracket'>}</span>;
A a<span class='curlybracket'>{</span> <span class='literal'>1.0</span>,<span class='literal'>2.0</span> <span class='curlybracket'>}</span>;                 <span class='comment'>// OK, uses #1</span>

<span class='keyword'>void</span> g<span class='parenthesis'>(</span>A<span class='parenthesis'>)</span>;
g<span class='parenthesis'>(</span><span class='curlybracket'>{</span> <span class='literal'>"foo"</span>, <span class='literal'>"bar"</span> <span class='curlybracket'>}</span><span class='parenthesis'>)</span>;            <span class='comment'>// OK, uses #3</span>

<span class='keyword'>typedef</span> <span class='keyword'>int</span> IA<span class='squarebracket'>[</span><span class='literal'>3</span><span class='squarebracket'>]</span>;
<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='keyword'>const</span> IA<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
h<span class='parenthesis'>(</span><span class='curlybracket'>{</span> <span class='literal'>1</span>, <span class='literal'>2</span>, <span class='literal'>3</span> <span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                 <span class='comment'>// OK: identity conversion</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.list-6'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2669'>#</a></div><div id='over.ics.list-6.sentence-1' class='sentence'>Otherwise, if the parameter type is “array of <span class='texttt'>N</span> <span class='texttt'>X</span>”
or “array of unknown bound of <span class='texttt'>X</span>”,
if there exists an implicit conversion sequence
from each element of the initializer list
(and from <span class='texttt'><span class='curlybracket'>{</span><span class='curlybracket'>}</span></span> in the former case
if <span class='texttt'>N</span> exceeds the number of elements in the initializer list)
to <span class='texttt'>X</span>, the implicit conversion sequence is
the worst such implicit conversion sequence<a class='hidden_link' href='#over.ics.list-6.sentence-1'>.</a></div></div><div class='para' id='over.ics.list-7'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2679'>#</a></div><div id='over.ics.list-7.sentence-1' class='sentence'>Otherwise, if the parameter is a non-aggregate class <span class='texttt'>X</span> and overload
resolution per <a href='over.match.list'>[over.match.list]</a> chooses a single best constructor <span class='texttt'>C</span> of
<span class='texttt'>X</span> to perform the initialization of an object of type <span class='texttt'>X</span> from the
argument initializer list:
<ul class='itemize'><li id='over.ics.list-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-7.1'>(7.1)</a></div>If <span class='texttt'>C</span> is not an initializer-list constructor
and the initializer list has a single element of type <span class='mathit'>cv</span> <span class='texttt'>U</span>,
where <span class='texttt'>U</span> is <span class='texttt'>X</span> or a class derived from <span class='texttt'>X</span>,
the implicit conversion sequence has Exact Match rank if <span class='texttt'>U</span> is <span class='texttt'>X</span>,
or Conversion rank if <span class='texttt'>U</span> is derived from <span class='texttt'>X</span>.</li><li id='over.ics.list-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-7.2'>(7.2)</a></div>Otherwise, the implicit conversion sequence is a user-defined
conversion sequence with the second standard conversion sequence an
identity conversion.</li></ul></div> <div id='over.ics.list-7.sentence-2' class='sentence'>
If multiple constructors are viable but none is better than
the others, the implicit conversion sequence is the ambiguous conversion
sequence<a class='hidden_link' href='#over.ics.list-7.sentence-2'>.</a></div> <div id='over.ics.list-7.sentence-3' class='sentence'>User-defined conversions are allowed for conversion of the initializer
list elements to the constructor parameter types except as noted
in <a href='#over.best.ics'>[over.best.ics]</a><a class='hidden_link' href='#over.ics.list-7.sentence-3'>.</a></div> <div id='over.ics.list-7.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  A<span class='parenthesis'>(</span>std<span class='operator'>::</span>initializer_list<span class='anglebracket'>&lt;</span><span class='keyword'>int</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>void</span> f<span class='parenthesis'>(</span>A<span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>, <span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(std&#x200b;::&#x200b;initializer_&shy;list&lt;int&gt;))</span> user-defined conversion</span>

<span class='keyword'>struct</span> B <span class='curlybracket'>{</span>
  B<span class='parenthesis'>(</span><span class='keyword'>int</span>, <span class='keyword'>double</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>void</span> g<span class='parenthesis'>(</span>B<span class='parenthesis'>)</span>;
g<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>, <span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// OK: <span class='tcode_in_codeblock'>g(B(int, double))</span> user-defined conversion</span>
g<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span>, <span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// error: narrowing</span>

<span class='keyword'>void</span> f<span class='parenthesis'>(</span>B<span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>, <span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// error: ambiguous <span class='tcode_in_codeblock'>f(A)</span> or <span class='tcode_in_codeblock'>f(B)</span></span>

<span class='keyword'>struct</span> C <span class='curlybracket'>{</span>
  C<span class='parenthesis'>(</span>std<span class='operator'>::</span>string<span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>void</span> h<span class='parenthesis'>(</span>C<span class='parenthesis'>)</span>;
h<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>"foo"</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;             <span class='comment'>// OK: <span class='tcode_in_codeblock'>h(C(std&#x200b;::&#x200b;string("foo")))</span></span>

<span class='keyword'>struct</span> D <span class='curlybracket'>{</span>
  D<span class='parenthesis'>(</span>A, C<span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
<span class='keyword'>void</span> i<span class='parenthesis'>(</span>D<span class='parenthesis'>)</span>;
i<span class='parenthesis'>(</span><span class='curlybracket'>{</span> <span class='curlybracket'>{</span><span class='literal'>1</span>,<span class='literal'>2</span><span class='curlybracket'>}</span>, <span class='curlybracket'>{</span><span class='literal'>"bar"</span><span class='curlybracket'>}</span> <span class='curlybracket'>}</span><span class='parenthesis'>)</span>;  <span class='comment'>// OK: <span class='tcode_in_codeblock'>i(D(A(std&#x200b;::&#x200b;initializer_&shy;list&lt;int&gt;{1,2}), C(std&#x200b;::&#x200b;string("bar"))))</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.list-8'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2733'>#</a></div><div id='over.ics.list-8.sentence-1' class='sentence'>Otherwise, if the parameter has an aggregate type which can be initialized from
the initializer list according to the rules for <a href='dcl.init.aggr'>aggregate
initialization</a>, the implicit conversion sequence is a
user-defined conversion sequence with the second standard conversion
sequence an identity conversion<a class='hidden_link' href='#over.ics.list-8.sentence-1'>.</a></div> <div id='over.ics.list-8.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>int</span> m1;
  <span class='keyword'>double</span> m2;
<span class='curlybracket'>}</span>;

<span class='keyword'>void</span> f<span class='parenthesis'>(</span>A<span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>, <span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(int,double))</span> user-defined conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;             <span class='comment'>// error: narrowing</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.list-9'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2752'>#</a></div><div id='over.ics.list-9.sentence-1' class='sentence'>Otherwise, if the parameter is a reference, see <a href='#over.ics.ref'>[over.ics.ref]</a><a class='hidden_link' href='#over.ics.list-9.sentence-1'>.</a></div> <div id='over.ics.list-9.note-1' class='note'>[&nbsp;<a class='note_link' href='#over.ics.list-9.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='over.ics.list-9.sentence-2' class='sentence'>The rules in this subclause will apply for initializing the underlying temporary
for the reference<a class='hidden_link' href='#over.ics.list-9.sentence-2'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='over.ics.list-9.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>int</span> m1;
  <span class='keyword'>double</span> m2;
<span class='curlybracket'>}</span>;

<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>const</span> A<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span>, <span class='literal'>'b'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(int,double))</span> user-defined conversion</span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;             <span class='comment'>// error: narrowing</span>

<span class='keyword'>void</span> g<span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>double</span> <span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
g<span class='parenthesis'>(</span><span class='curlybracket'>{</span><span class='literal'>1</span><span class='curlybracket'>}</span><span class='parenthesis'>)</span>;                 <span class='comment'>// same conversion as <span class='tcode_in_codeblock'>int</span> to <span class='tcode_in_codeblock'>double</span></span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='over.ics.list-10'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2774'>#</a></div><div id='over.ics.list-10.sentence-1' class='sentence'>Otherwise, if the parameter type is not a class:
<ul class='itemize'><li id='over.ics.list-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-10.1'>(10.1)</a></div>if the initializer list has one element that is not itself an initializer list,
the implicit conversion sequence is the one required to convert the element to
the parameter type;
<div id='over.ics.list-10.1.example-1' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-10.1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>'a'</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;             <span class='comment'>// OK: same conversion as <span class='tcode_in_codeblock'>char</span> to <span class='tcode_in_codeblock'>int</span></span>
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span><span class='literal'>1.0</span><span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;             <span class='comment'>// error: narrowing</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </li><li id='over.ics.list-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#over.ics.list-10.2'>(10.2)</a></div>if the initializer list has no elements, the implicit conversion sequence
is the identity conversion<a class='hidden_link' href='#over.ics.list-10.sentence-1'>.</a> <div id='over.ics.list-10.2.example-2' class='example'>[&nbsp;<a class='example_link' href='#over.ics.list-10.2.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='keyword'>int</span><span class='parenthesis'>)</span>;
f<span class='parenthesis'>(</span> <span class='curlybracket'>{</span> <span class='curlybracket'>}</span> <span class='parenthesis'>)</span>;               <span class='comment'>// OK: identity conversion</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </li></ul></div></div><div class='para' id='over.ics.list-11'><div class='marginalizedparent'><a class='marginalized' href='#over.ics.list-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ac3fceec6107d67ed69535583ad83e35da9de218/source/overloading.tex#L2798'>#</a></div><div id='over.ics.list-11.sentence-1' class='sentence'>In all cases other than those enumerated above, no conversion is possible<a class='hidden_link' href='#over.ics.list-11.sentence-1'>.</a></div></div><div class='footnote' id='footnote-125'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-125'>125)</a></div><div id='footnote-125.sentence-1' class='sentence'>Since there are no parameters of array type,
this will only occur as the referenced type of a reference parameter<a class='hidden_link' href='#footnote-125.sentence-1'>.</a></div> <a href='#footnoteref-125'>⮥</a></div></div></div></body></html>