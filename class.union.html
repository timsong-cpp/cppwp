<!DOCTYPE html><html lang='en'><head><title>[class.union]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><div id='class.union'><h2 ><a class='secnum' style='min-width:88pt'>9.3</a> Unions <a class='abbr_ref'>[class.union]</a></h2><p ><span class='indexparent'><a class='index' id='union'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >In a union,
a non-static data member is <a class='hidden_link' href='#def:active,union_member' id='def:active,union_member'><i>active</i></a>
if its name refers to an object
whose lifetime has begun and has not ended (<a href='basic.life'>[basic.life]</a>).
At most one of the non-static data members of an object of union type
can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. [&nbsp;<i>Note:</i><span class='space'></span> One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (<a href='class.mem'>[class.mem]</a>), and
if a non-static data member of an object of this standard-layout union type
is active and is one of the standard-layout structs,
it is permitted to inspect the common initial sequence
of any of the standard-layout struct members;
see <a href='class.mem'>[class.mem]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct.
[&nbsp;<i>Note:</i><span class='space'></span>
A union object and its non-static data members are
pointer-interconvertible (<a href='basic.compound'>[basic.compound]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>).
As a consequence, all non-static data members of a
union object have the same address.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='member_function,union'></a></span><span class='indexparent'><a class='index' id='constructor,union'></a></span><span class='indexparent'><a class='index' id='destructor,union'></a></span>A union can have member functions (including constructors and destructors),
<span class='indexparent'><a class='index' id='restriction,union'></a></span>but it shall not have virtual (<a href='class.virtual'>[class.virtual]</a>) functions. A union shall not have
base classes. A union shall not be used as a base class.
<span class='indexparent'><a class='index' id='restriction,union'></a></span>If a union contains a non-static data member of
reference type the program is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span> If any non-static data member of a union has a non-trivial
default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy constructor (<a href='class.copy'>[class.copy]</a>),
move constructor (<a href='class.copy'>[class.copy]</a>),
copy assignment operator (<a href='class.copy'>[class.copy]</a>),
move assignment operator (<a href='class.copy'>[class.copy]</a>),
or destructor (<a href='class.dtor'>[class.dtor]</a>), the corresponding member function
of the union must be user-provided or it will
be implicitly deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>) for the union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span> Consider the following union:</p><pre class='codeblock'>
union U {
  int i;
  float f;
  std::string s;
};
</pre><p >Since <span class='texttt'>std::string</span> (<a href='string.classes'>[string.classes]</a>) declares non-trivial versions of all of the special
member functions, <span class='texttt'>U</span> will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use <span class='texttt'>U</span>, some or all of these member functions
must be user-provided.<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >When the left operand of an assignment operator
involves a member access expression (<a href='expr.ref'>[expr.ref]</a>)
that nominates a union member,
it may begin the lifetime of that union member,
as described below.
For an expression <span class='texttt'>E</span>,
define the set <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span>
of subexpressions of <span class='texttt'>E</span>
as follows:
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If <span class='texttt'>E</span> is of the form <span class='texttt'>A.B</span>,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> contains the elements of <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>A</span>)</span>,
and also contains <span class='texttt'>A.B</span>
if <span class='texttt'>B</span> names a union member of a non-class, non-array type,
or of a class type with a trivial default constructor that is not deleted,
or an array of such types.
</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >If <span class='texttt'>E</span> is of the form <span class='texttt'>A[B]</span>
and is interpreted as a built-in array subscripting operator,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> is <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>A</span>)</span> if <span class='texttt'>A</span> is of array type,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>B</span>)</span> if <span class='texttt'>B</span> is of array type,
and empty otherwise.
</p></li><li id='5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.3'>(5.3)</a></div><p >Otherwise, <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> is empty.
</p></li></ul><p >In an assignment expression of the form <span class='texttt'>E1 = E2</span>
that uses either the built-in assignment operator (<a href='expr.ass'>[expr.ass]</a>)
or a trivial assignment operator (<a href='class.copy'>[class.copy]</a>),
for each element <span class='texttt'>X</span> of <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>E1</span><span class='math'>)</span>,
if modification of <span class='texttt'>X</span> would have undefined behavior under <a href='basic.life'>[basic.life]</a>,
an object of the type of <span class='texttt'>X</span> is implicitly created
in the nominated storage;
no initialization is performed and
the beginning of its lifetime is sequenced after
the value computation of the left and right operands
and before the assignment.
[&nbsp;<i>Note:</i><span class='space'></span>
This ends the lifetime of the previously-active
member of the union, if any (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
union A { int x; int y[4]; };
struct B { A a; };
union C { B b; int k; };
int f() {
  C c;               <span class='comment'>// does not start lifetime of any union member
</span>  c.b.a.y[3] = 4;    <span class='comment'>// OK: <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>c.b.a.y[3]</span><span class='math'>)</span> contains <span class='texttt'>c.b</span> and <span class='texttt'>c.b.a.y</span>;
</span>                     <span class='comment'>// creates objects to hold union members <span class='texttt'>c.b</span> and <span class='texttt'>c.b.a.y</span>
</span>  return c.b.a.y[3]; <span class='comment'>// OK: <span class='texttt'>c.b.a.y</span> refers to newly created object (see <a href='basic.life'>[basic.life]</a>)
</span>}

struct X { const int a; int b; };
union Y { X x; int k; };
void g() {
  Y y = { { 1, 2 } }; <span class='comment'>// OK, <span class='texttt'>y.x</span> is active union member (<a href='class.mem'>[class.mem]</a>)
</span>  int n = y.x.a;
  y.k = 4;   <span class='comment'>// OK: ends lifetime of <span class='texttt'>y.x</span>, <span class='texttt'>y.k</span> is active member of union
</span>  y.x.b = n; <span class='comment'>// undefined behavior: <span class='texttt'>y.x.b</span> modified outside its lifetime,
</span>             <span class='comment'>// <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>y.x.b</span><span class='math'>)</span> is empty because <span class='texttt'>X</span>'s default constructor is deleted,
</span>             <span class='comment'>// so union member <span class='texttt'>y.x</span>'s lifetime does not implicitly start
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> In general, one must use explicit destructor calls and placement
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> to change the active member of a union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
Consider an object <span class='texttt'>u</span> of a <span class='texttt'>union</span> type <span class='texttt'>U</span> having non-static data members
<span class='texttt'>m</span> of type <span class='texttt'>M</span> and <span class='texttt'>n</span> of type <span class='texttt'>N</span>. If <span class='texttt'>M</span> has a non-trivial
destructor and <span class='texttt'>N</span> has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of <span class='texttt'>u</span> can be safely switched from <span class='texttt'>m</span> to
<span class='texttt'>n</span> using the destructor and placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> as follows:</p><pre class='codeblock'>
u.m.~M();
new (&amp;u.n) N;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='anon'><h3 ><a class='secnum' href='#anon' style='min-width:103pt'>9.3.1</a> Anonymous unions <a class='abbr_ref' href='class.union.anon'>[class.union.anon]</a></h3><p ><span class='indexparent'><a class='index' id='union,anonymous'></a></span>
</p><div class='para' id='anon-1'><div class='marginalizedparent'><a class='marginalized' href='#anon-1'>1</a></div><p >A union of the form</p><pre class='bnf'><span class='terminal'>union</span> <span class='terminal'>{</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> <span class='terminal'>}</span> <span class='terminal'>;</span></pre><p >is called an <a class='hidden_link' href='#def:anonymous_union' id='def:anonymous_union'><i>anonymous union</i></a>; it defines an unnamed object of unnamed
type. Each <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> in the <i ><a href='class.mem#nt:member-specification'>member-specification</a></i>
of an anonymous union shall either define a non-static data member or be a
<i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
Nested types, anonymous unions, and functions cannot be declared within an anonymous
union.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
<span class='indexparent'><a class='index' id='initialization,union'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
</pre><p >Here <span class='texttt'>a</span> and <span class='texttt'>p</span> are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='anon-2'><div class='marginalizedparent'><a class='marginalized' href='#anon-2'>2</a></div><p ><span class='indexparent'><a class='index' id='union,global_anonymous'></a></span><span class='indexparent'><a class='index' id='scope,anonymous_union_at_namespace'></a></span>Anonymous unions declared in a named namespace or in the global
namespace shall be declared <span class='texttt'>static</span>. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
<span class='indexparent'><a class='index' id='access_control,anonymous_union'></a></span><span class='indexparent'><a class='index' id='restriction,anonymous_union'></a></span>An anonymous union shall not have <span class='texttt'>private</span> or <span class='texttt'>protected</span>
members (Clause <a href='class.access'>[class.access]</a>). An anonymous union shall not have
member functions.</p></div><div class='para' id='anon-3'><div class='marginalizedparent'><a class='marginalized' href='#anon-3'>3</a></div><p >A union for which objects, pointers, or references are declared is not an anonymous union.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f() {
  union { int aa; char* p; } obj, *ptr = &amp;obj;
  aa = 1;                         <span class='comment'>// error
</span>  ptr-&gt;aa = 1;                    <span class='comment'>// OK
</span>}
</pre><p >The assignment to plain <span class='texttt'>aa</span> is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Initialization of unions with no user-declared constructors is described
in (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='anon-4'><div class='marginalizedparent'><a class='marginalized' href='#anon-4'>4</a></div><p ><span class='indexparent'><a class='index' id='class,union-like'></a></span><span class='indexparent'><a class='index' id='class,variant_member_of'></a></span>A <a class='hidden_link' href='#def:union-like_class' id='def:union-like_class'><i>union-like class</i></a> is a union or a class that has an anonymous union as a direct
member. A union-like class <span class='texttt'>X</span> has a set of <a class='hidden_link' href='#def:variant_member' id='def:variant_member'><i>variant member</i></a>s.
If <span class='texttt'>X</span> is a union, a non-static data member of <span class='texttt'>X</span> that is not an anonymous
union is a variant member of <span class='texttt'>X</span>. In addition, a non-static data member of an
anonymous union that is a member of <span class='texttt'>X</span> is also a variant member of <span class='texttt'>X</span>.
At most one variant member of a union may have a default member initializer.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
union U {
  int x = 0;
  union {
    int k;
  };
  union {
    int z;
    int y = 1; <span class='comment'>// error: initialization for second variant member of <span class='texttt'>U</span>
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></body></html>