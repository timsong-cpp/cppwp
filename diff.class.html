<!DOCTYPE html><html lang='en'><head><title>[diff.class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.class'>[diff.iso]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>C.1.6</a> <a href='class'>[class]</a>: classes <a class='abbr_ref'>[diff.class]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/12935b8549c0412f528b33b7795a19cda7ae8dd6/source/compatibility.tex#L662'>#</a></div><div id='1.sentence-1' class='sentence'><b>Affected subclause:</b> <a href='class.name'>[class.name]</a> [see also <a href='dcl.typedef'>[dcl.typedef]</a>]
<br/><b>Change:</b> In C++, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope<a class='hidden_link' href='#1.sentence-2'>.</a></div><div style='height:0.6em;display:block'></div><div id='1.sentence-3' class='sentence'>Example:</div><pre class='codeblock'>
<span class='keyword'>int</span> x<span class='squarebracket'>[</span><span class='literal'>99</span><span class='squarebracket'>]</span>;
<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>struct</span> x <span class='curlybracket'>{</span> <span class='keyword'>int</span> a; <span class='curlybracket'>}</span>;
  <span class='keyword'>sizeof</span><span class='parenthesis'>(</span>x<span class='parenthesis'>)</span>;  <span class='comment' style='font-style:italic;font-family:serif;'>/* size of the array in C */</span>
  <span class='comment' style='font-style:italic;font-family:serif;'>/* size of the struct in <span class='tcode_in_codeblock'><span class='textit'><span class='textrm'>C++</span></span></span> */</span>
<span class='curlybracket'>}</span>
</pre> <div id='1.sentence-4' class='sentence'><br/><b>Rationale:</b> 
This is one of the few incompatibilities between C and C++ that
can be attributed to the new C++ name space definition where a
name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that
the keywords <span class='texttt'><span class='keyword'>class</span></span>, <span class='texttt'><span class='keyword'>struct</span></span>, <span class='texttt'><span class='keyword'>union</span></span> or <span class='texttt'><span class='keyword'>enum</span></span> be used to refer to the type name<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>This new name space definition provides important notational
conveniences to C++ programmers and helps making the use of the
user-defined types as similar as possible to the use of fundamental
types<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.sentence-6' class='sentence'>The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above<a class='hidden_link' href='#1.sentence-6'>.</a></div> <div id='1.sentence-7' class='sentence'><br/><b>Effect on original feature:</b> 
Change to semantics of well-defined feature<a class='hidden_link' href='#1.sentence-7'>.</a></div> <div id='1.sentence-8' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#1.sentence-8'>.</a></div> <div id='1.sentence-9' class='sentence'>If the hidden name that needs to be accessed is at global scope,
the <span class='texttt'><span class='operator'>:</span><span class='operator'>:</span></span> C++ operator can be used<a class='hidden_link' href='#1.sentence-9'>.</a></div> <div id='1.sentence-10' class='sentence'>If the hidden name is at block scope, either the type or the struct
tag has to be renamed<a class='hidden_link' href='#1.sentence-10'>.</a></div> <div id='1.sentence-11' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#1.sentence-11'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/12935b8549c0412f528b33b7795a19cda7ae8dd6/source/compatibility.tex#L701'>#</a></div><div id='2.sentence-1' class='sentence'><b>Affected subclause:</b> <a href='class.copy.ctor'>[class.copy.ctor]</a>
<br/><b>Change:</b> Copying volatile objects<a class='hidden_link' href='#2.sentence-1'>.</a></div><div style='height:0.6em;display:block'></div><div id='2.sentence-2' class='sentence'>The implicitly-declared copy constructor and
implicitly-declared copy assignment operator
cannot make a copy of a volatile lvalue<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>For example, the following is valid in ISO C:</div><pre class='codeblock'>
<span class='keyword'>struct</span> X <span class='curlybracket'>{</span> <span class='keyword'>int</span> i; <span class='curlybracket'>}</span>;
<span class='keyword'>volatile</span> <span class='keyword'>struct</span> X x1 <span class='operator'>=</span> <span class='curlybracket'>{</span><span class='literal'>0</span><span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> X x2 <span class='operator'>=</span> x1;               <span class='comment' style='font-style:italic;font-family:serif;'>// invalid C++
</span><span class='keyword'>struct</span> X x3;
x3 <span class='operator'>=</span> x1;                        <span class='comment' style='font-style:italic;font-family:serif;'>// also invalid C++
</span></pre><div id='2.sentence-4' class='sentence'><br/><b>Rationale:</b> 
Several alternatives were debated at length<a class='hidden_link' href='#2.sentence-4'>.</a></div> <div id='2.sentence-5' class='sentence'>Changing the parameter to
<span class='texttt'><span class='keyword'>volatile</span></span>
<span class='texttt'><span class='keyword'>const</span></span>
<span class='texttt'>X<span class='operator'>&amp;</span></span>
would greatly complicate the generation of
efficient code for class objects<a class='hidden_link' href='#2.sentence-5'>.</a></div> <div id='2.sentence-6' class='sentence'>Discussion of
providing two alternative signatures for these
implicitly-defined operations raised
unanswered concerns about creating
ambiguities and complicating
the rules that specify the formation of
these operators according to the bases and
members<a class='hidden_link' href='#2.sentence-6'>.</a></div> <div id='2.sentence-7' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#2.sentence-7'>.</a></div> <div id='2.sentence-8' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#2.sentence-8'>.</a></div> <div id='2.sentence-9' class='sentence'>If volatile semantics are required for the copy,
a user-declared constructor or assignment must
be provided<a class='hidden_link' href='#2.sentence-9'>.</a></div> <div id='2.sentence-10' class='sentence'>If non-volatile semantics are required,
an explicit
<span class='texttt'><span class='keyword'>const_&shy;cast</span></span>
can be used<a class='hidden_link' href='#2.sentence-10'>.</a></div> <div id='2.sentence-11' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#2.sentence-11'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/12935b8549c0412f528b33b7795a19cda7ae8dd6/source/compatibility.tex#L747'>#</a></div><div id='3.sentence-1' class='sentence'><b>Affected subclause:</b> <a href='class.bit'>[class.bit]</a>
<br/><b>Change:</b> 
<span class='indexparent'><a class='index' id=':bit-field,implementation-defined_sign_of'></a></span>Bit-fields of type plain <span class='texttt'><span class='keyword'>int</span></span> are signed<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'><br/><b>Rationale:</b> 
Leaving the choice of signedness to implementations could lead to
inconsistent definitions of template specializations<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.sentence-3' class='sentence'>For consistency,
the implementation freedom was eliminated for non-dependent types,
too<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'><br/><b>Effect on original feature:</b> 
The choice is implementation-defined in C, but not so in C++<a class='hidden_link' href='#3.sentence-4'>.</a></div> <div id='3.sentence-5' class='sentence'><br/><b>Difficulty of converting:</b> 
Syntactic transformation<a class='hidden_link' href='#3.sentence-5'>.</a></div> <div id='3.sentence-6' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#3.sentence-6'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/12935b8549c0412f528b33b7795a19cda7ae8dd6/source/compatibility.tex#L763'>#</a></div><div id='4.sentence-1' class='sentence'><b>Affected subclause:</b> <a href='class.nest'>[class.nest]</a>
<br/><b>Change:</b> In C++, the name of a nested class is local to its enclosing class<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class<a class='hidden_link' href='#4.sentence-2'>.</a></div><div style='height:0.6em;display:block'></div><div id='4.sentence-3' class='sentence'>Example:</div><pre class='codeblock'>
<span class='keyword'>struct</span> X <span class='curlybracket'>{</span>
  <span class='keyword'>struct</span> Y <span class='curlybracket'>{</span> <span class='comment'>/* ... */</span> <span class='curlybracket'>}</span> y;
<span class='curlybracket'>}</span>;
<span class='keyword'>struct</span> Y yy;                    <span class='comment' style='font-style:italic;font-family:serif;'>// valid C, invalid C++
</span></pre> <div id='4.sentence-4' class='sentence'><br/><b>Rationale:</b> 
C++ classes have member functions which require that classes
establish scopes<a class='hidden_link' href='#4.sentence-4'>.</a></div> <div id='4.sentence-5' class='sentence'>The C rule would leave classes as an incomplete scope mechanism
which would prevent C++ programmers from maintaining locality
within a class<a class='hidden_link' href='#4.sentence-5'>.</a></div> <div id='4.sentence-6' class='sentence'>A coherent set of scope rules for C++ based on the C rule would
be very complicated and C++ programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions<a class='hidden_link' href='#4.sentence-6'>.</a></div> <div id='4.sentence-7' class='sentence'><br/><b>Effect on original feature:</b> 
Change to semantics of well-defined feature<a class='hidden_link' href='#4.sentence-7'>.</a></div> <div id='4.sentence-8' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#4.sentence-8'>.</a></div> <div id='4.sentence-9' class='sentence'>To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined<a class='hidden_link' href='#4.sentence-9'>.</a></div> <div id='4.sentence-10' class='sentence'>Example:</div><pre class='codeblock'>
<span class='keyword'>struct</span> Y;                       <span class='comment' style='font-style:italic;font-family:serif;'>// <span class='tcode_in_codeblock'>struct Y</span> and <span class='tcode_in_codeblock'>struct X</span> are at the same scope
</span><span class='keyword'>struct</span> X <span class='curlybracket'>{</span>
  <span class='keyword'>struct</span> Y <span class='curlybracket'>{</span> <span class='comment'>/* ... */</span> <span class='curlybracket'>}</span> y;
<span class='curlybracket'>}</span>;
</pre><div id='4.sentence-11' class='sentence'>All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct<a class='hidden_link' href='#4.sentence-11'>.</a></div> <div id='4.sentence-12' class='sentence'>Note: this is a consequence of the difference in scope rules,
which is documented in <a href='basic.scope'>[basic.scope]</a><a class='hidden_link' href='#4.sentence-12'>.</a></div> <div id='4.sentence-13' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#4.sentence-13'>.</a></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/12935b8549c0412f528b33b7795a19cda7ae8dd6/source/compatibility.tex#L809'>#</a></div><div id='5.sentence-1' class='sentence'><b>Affected subclause:</b> <a href='class.nested.type'>[class.nested.type]</a>
<br/><b>Change:</b> In C++, a typedef name may not be redeclared in a class definition after being used in that definition<a class='hidden_link' href='#5.sentence-1'>.</a></div><div style='height:0.6em;display:block'></div><div id='5.sentence-2' class='sentence'>Example:</div><pre class='codeblock'>
<span class='keyword'>typedef</span> <span class='keyword'>int</span> I;
<span class='keyword'>struct</span> S <span class='curlybracket'>{</span>
  I i;
  <span class='keyword'>int</span> I;                  <span class='comment' style='font-style:italic;font-family:serif;'>// valid C, invalid C++
</span><span class='curlybracket'>}</span>;
</pre> <div id='5.sentence-3' class='sentence'><br/><b>Rationale:</b> 
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for C++
programmers as to what the meaning of <span class='texttt'>I</span> really is<a class='hidden_link' href='#5.sentence-3'>.</a></div> <div id='5.sentence-4' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#5.sentence-4'>.</a></div> <div id='5.sentence-5' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#5.sentence-5'>.</a></div> <div id='5.sentence-6' class='sentence'>Either the type or the struct member has to be renamed<a class='hidden_link' href='#5.sentence-6'>.</a></div> <div id='5.sentence-7' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#5.sentence-7'>.</a></div></div></div></body></html>