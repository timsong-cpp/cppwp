<!DOCTYPE html><html lang='en'><head><title>[temp.dep.expr]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref' href='temp.res#temp.dep.expr'>[temp.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref' href='temp.dep#expr'>[temp.dep]</a></h3><div id='temp.dep.expr'><h4 ><a class='secnum' style='min-width:118pt'>14.6.2.2</a> Type-dependent expressions <a class='abbr_ref'>[temp.dep.expr]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Except as described below, an expression is type-dependent if any
subexpression is type-dependent.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='texttt'>this</span>
is type-dependent if the class type of the enclosing member function is
dependent (<a href='temp.dep.type'>[temp.dep.type]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >An
<i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
is type-dependent if it contains</p><ul ><li ><p >an
<i ><a href='lex.name#identifier'>identifier</a></i>
associated by name lookup with one or more declarations
declared with a dependent type,</p></li><li ><p >an
<i ><a href='lex.name#identifier'>identifier</a></i>
associated by name lookup with
a non-type <i ><a href='temp.param#template-parameter'>template-parameter</a></i>
declared with a type
that contains a placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>),</p></li><li ><p >an <i ><a href='lex.name#identifier'>identifier</a></i> associated by name lookup with one or more
declarations of member functions of the current instantiation declared
with a return type that contains a placeholder type,</p></li><li ><p >an <i ><a href='lex.name#identifier'>identifier</a></i> associated by name lookup with a decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>) whose <i ><a href='dcl.init#brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
is type-dependent,</p></li><li ><p >the
<i ><a href='lex.name#identifier'>identifier</a></i>
<span class='texttt'>__func__</span> (<a href='dcl.fct.def.general'>[dcl.fct.def.general]</a>), where any enclosing function is a
template, a member of a class template, or a generic lambda,</p></li><li ><p >a
<i ><a href='temp.names#template-id'>template-id</a></i>
that is dependent,</p></li><li ><p >a
<i ><a href='class.conv.fct#conversion-function-id'>conversion-function-id</a></i>
that specifies a dependent type, or</p></li><li ><p >a
<i ><a href='expr.prim.id.qual#nested-name-specifier'>nested-name-specifier</a></i>
or a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
that names a member of an unknown specialization;
</p></li></ul><p >or if it names a dependent member of the current instantiation that is a static
data member of type
“array of unknown bound of <span class='texttt'>T</span>” for some <span class='texttt'>T</span> (<a href='temp.static'>[temp.static]</a>).
Expressions of the following forms are type-dependent only if the type
specified by the
<i ><a href='dcl.name#type-id'>type-id</a></i>,
<i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i>
or
<i ><a href='expr.new#new-type-id'>new-type-id</a></i>
is dependent, even if any subexpression is type-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.new#new-type-id'>new-type-id</a></i> <i ><a href='expr.new#new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.new#new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>dynamic_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i></pre></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Expressions of the following forms are never type-dependent (because the type
of the expression cannot be dependent):</p><pre class='bnf'><i ><a href='lex.literal.kinds#literal'>literal</a></i>
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.post#pseudo-destructor-name'>pseudo-destructor-name</a></i>
<i ><a href='expr.post#postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.post#pseudo-destructor-name'>pseudo-destructor-name</a></i>
<span class='terminal'>sizeof</span> <i ><a href='expr.unary#unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#identifier'>identifier</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete [ ]</span> <i ><a href='expr.cast#cast-expression'>cast-expression</a></i>
<span class='terminal'>throw</span> <i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A class member access expression (<a href='expr.ref'>[expr.ref]</a>) is
type-dependent if
the expression refers to a member of the current instantiation and
the type of the referenced member is dependent, or the class member access
expression refers to a member of an unknown specialization.
[&nbsp;<i>Note:</i><span class='space'></span>
In an expression of the form
<span class='texttt'>x.y</span>
or
<span class='texttt'>xp-&gt;y</span>
the type of the expression is usually the type of the member
<span class='texttt'>y</span>
of the class of
<span class='texttt'>x</span>
(or the class pointed to by
<span class='texttt'>xp</span>).
However, if
<span class='texttt'>x</span>
or
<span class='texttt'>xp</span>
refers to a dependent type that is not the current instantiation,
the type of
<span class='texttt'>y</span>
is always dependent. If
<span class='texttt'>x</span>
or <span class='texttt'>xp</span>
refers to a non-dependent type or refers to the current instantiation, the
type of
<span class='texttt'>y</span>
is the type of the class member access expression.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i> is type-dependent if any element is
type-dependent or is a pack expansion.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A <i ><a href='expr.prim.fold#fold-expression'>fold-expression</a></i> is type-dependent.</p></div></div></div></body></html>