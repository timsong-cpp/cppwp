<!DOCTYPE html><html lang='en'><head><title>[internet.socket.opt]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Internet protocol <a class='abbr_ref' href='./#internet'>[internet]</a></h1><div id='internet.socket.opt'><h2 ><a class='secnum' style='min-width:88pt'>21.21</a> Internet socket options <a class='abbr_ref'>[internet.socket.opt]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >In Table <a href='#tab:internet.socket.opt.requirements'>[tab:internet.socket.opt.requirements]</a>, let <i>C</i> denote a socket option class; let <i>L</i> identify the POSIX macro to be passed as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> and getsockopt; let <i>N</i> identify the POSIX macro to be passed as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>; let <i>T</i> identify the type of the value whose address will be passed as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>;
let <span class='texttt'>p</span> denote a (possibly const) value of a type meeting the protocol (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements,
as passed to the socket option's <span class='texttt'>level</span> and <span class='texttt'>name</span> member functions;
and let <span class='texttt'>F</span> be the value of <span class='texttt'>p.family()</span>.</p><div class='numberedTable' id='tab:internet.socket.opt.requirements'>Table <a href='#tab:internet.socket.opt.requirements'>40</a> — Internet socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements,</b></td></tr><tr ><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td colspan='1' class='center'><b>definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ip::tcp::</span><br/>
<span class='texttt'>no_delay</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td><td class='left'>
<span class='texttt'>TCP_NODELAY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a TCP socket will avoid coalescing of small segments. [&nbsp;<i>Note:</i> That is, setting this option disables the Nagle algorithm. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::v6_only</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span>  </td><td class='left'>
<span class='texttt'>IPV6_V6ONLY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket created for an IPv6 protocol is restricted to IPv6 communications only. Implementations are not required to support setting the <span class='texttt'>v6_only</span> option to <span class='texttt'>false</span>, and the initial value of the <span class='texttt'>v6_only</span> option for a socket is <span class='indexparent'><a class='index' id='initial_value_of_the_v6_only_option_for_a_socket'></a></span>implementation-defined. [&nbsp;<i>Note:</i> As not all operating systems support dual stack IP networking. Some operating systems that do provide dual stack support offer a configuration option to disable it or to set the initial value of the <span class='texttt'>v6_only</span> socket option. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::unicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_UNICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::unicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>join_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_JOIN_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_ADD_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket join the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>leave_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_LEAVE_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_DROP_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket leave the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>outbound_interface</span><br/> (<a href='internet.multicast.outbound'>[internet.multicast.outbound]</a>)  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>  </td><td class='left'>
<span class='texttt'>unsigned int</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>in_addr</span>  </td><td class='left'>
 Specifies the network interface to use for outgoing multicast datagrams.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::multicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>enable_loopback</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_LOOP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_LOOP</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether multicast datagrams are delivered back to the local application.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='outbound_interface'></a></span></p></div><div id='internet.multicast.outbound'><h3 ><a class='secnum' href='#internet.multicast.outbound' style='min-width:103pt'>21.21.1</a> Class <span class='texttt'>ip::multicast::outbound_interface</span> <a class='abbr_ref' href='internet.multicast.outbound'>[internet.multicast.outbound]</a></h3><div class='para' id='internet.multicast.outbound-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-1'>1</a></div><p >The <span class='texttt'>outbound_interface</span> class represents a socket option that specifies the network interface to use for outgoing multicast datagrams.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    <span class='comment'>// constructors:
</span>    explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
    explicit outbound_interface(unsigned int network_interface) noexcept;
  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.multicast.outbound-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-2'>2</a></div><p ><span class='texttt'>outbound_interface</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++ 2014 [destructible]), <span class='texttt'>CopyConstructible</span> (C++ 2014 [copyconstructible]), <span class='texttt'>CopyAssignable</span> (C++ 2014 [copyassignable]), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,outbound_interface'></a></span><span class='indexparent'><a class='index' id='outbound_interface,extensible_implementation'></a></span></p></div><div class='para' id='internet.multicast.outbound-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
    <span class='comment'>// <i>remainder unchanged</i>
</span>  private:
      in_addr v4_value_; <span class='comment'>// <i>exposition only</i>
</span>      unsigned int v6_value_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v4_value_</span> is initialized to correspond to the IPv4 address <span class='texttt'>network_interface</span>, and <span class='texttt'>v6_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
explicit outbound_interface(unsigned int network_interface) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v6_value_</span> is initialized to <span class='texttt'>network_interface</span>, and <span class='texttt'>v4_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>addressof(v4_value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(v4_value_)</span>.
</p></div></div></div></div></div></body></html>