<!DOCTYPE html><html lang='en'><head><title>[internet.resolver.results]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Internet protocol <a class='abbr_ref' href='./#internet'>[internet]</a></h1><div id='internet.resolver.results'><h2 ><a class='secnum' style='min-width:88pt'>21.15</a> Class template <span class='texttt'>ip::basic_resolver_results</span> <a class='abbr_ref'>[internet.resolver.results]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >An object of type <span class='texttt'>basic_resolver_results&lt;InternetProtocol&gt;</span>
represents a sequence of <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;</span> elements
resulting from a single name resolution operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver_results
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;
    using endpoint_type = typename protocol_type::endpoint;
    using value_type = basic_resolver_entry&lt;protocol_type&gt;;
    using const_reference = const value_type&amp;;
    using reference = value_type&amp;;
    using const_iterator = <span class='indexparent'><a class='index' id='type_of_basic_resolver_results::const_iterator'></a></span><i>implementation-defined</i>;
    using iterator = const_iterator;
    using difference_type = ptrdiff_t;
    using size_type = size_t;

    <span class='comment'>// <a href='internet.resolver.results.cons'>[internet.resolver.results.cons]</a>, construct / copy / destroy:
</span>    basic_resolver_results();
    basic_resolver_results(const basic_resolver_results&amp; rhs);
    basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
    basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
    basic_resolver_results&amp; operator=(basic_resolver_results&amp;&amp; rhs);
    ~basic_resolver_results();

    <span class='comment'>// <a href='internet.resolver.results.size'>[internet.resolver.results.size]</a>, size:
</span>    size_type size() const noexcept;
    size_type max_size() const noexcept;
    bool empty() const noexcept;

    <span class='comment'>// <a href='internet.resolver.results.access'>[internet.resolver.results.access]</a>, element access:
</span>    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    <span class='comment'>// <a href='internet.resolver.results.swap'>[internet.resolver.results.swap]</a>, swap:
</span>    void swap(basic_resolver_results&amp; that) noexcept;
  };

  <span class='comment'>// <a href='internet.resolver.results.comparisons'>[internet.resolver.results.comparisons]</a>, basic_resolver_results comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The class template <span class='texttt'>basic_resolver_results</span> satisfies the requirements of a sequence container (C++ 2014 [sequence.reqmts]), except that only the operations defined for const-qualified sequence containers are supported. The class template <span class='texttt'>basic_resolver_results</span> supports forward iterators.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A default-constructed <span class='texttt'>basic_resolver_results</span> object is empty. A non-empty results object is obtained only by calling a <span class='texttt'>basic_resolver</span> object's <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operations, or otherwise by copy construction, move construction, assignment, or swap from another non-empty results object.</p></div><div id='cons'><h3 ><a class='secnum' href='#cons' style='min-width:103pt'>21.15.1</a> <span class='texttt'>ip::basic_resolver_results</span> constructors <a class='abbr_ref' href='internet.resolver.results.cons'>[internet.resolver.results.cons]</a></h3><p ><code class='itemdecl'>
basic_resolver_results();
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>size() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cons-3'><div class='marginalizedparent'><a class='marginalized' href='#cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.
</p></div></div></div><div id='assign'><h3 ><a class='secnum' href='#assign' style='min-width:103pt'>21.15.2</a> <span class='texttt'>ip::basic_resolver_results</span> assignment <a class='abbr_ref' href='internet.resolver.results.assign'>[internet.resolver.results.assign]</a></h3><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='assign-1'><div class='marginalizedparent'><a class='marginalized' href='#assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.</p></div></div><div class='para' id='assign-2'><div class='marginalizedparent'><a class='marginalized' href='#assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(basic_resolver_results&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assign-3'><div class='marginalizedparent'><a class='marginalized' href='#assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='assign-4'><div class='marginalizedparent'><a class='marginalized' href='#assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='size'><h3 ><a class='secnum' href='#size' style='min-width:103pt'>21.15.3</a> <span class='texttt'>ip::basic_resolver_results</span> size <a class='abbr_ref' href='internet.resolver.results.size'>[internet.resolver.results.size]</a></h3><p ><code class='itemdecl'>
size_type size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='size-1'><div class='marginalizedparent'><a class='marginalized' href='#size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of <span class='texttt'>basic_resolver_entry</span> elements in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
size_type max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='size-2'><div class='marginalizedparent'><a class='marginalized' href='#size-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The maximum number of <span class='texttt'>basic_resolver_entry</span> elements that can be stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='size-3'><div class='marginalizedparent'><a class='marginalized' href='#size-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size() == 0</span>.
</p></div></div></div><div id='access'><h3 ><a class='secnum' href='#access' style='min-width:103pt'>21.15.4</a> <span class='texttt'>ip::basic_resolver_results</span> element access <a class='abbr_ref' href='internet.resolver.results.access'>[internet.resolver.results.access]</a></h3><p ><code class='itemdecl'>
const_iterator begin() const;
const_iterator cbegin() const;
</code></p><div class='itemdescr'></div><div class='para' id='access-1'><div class='marginalizedparent'><a class='marginalized' href='#access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A starting iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
const_iterator end() const;
const_iterator cend() const;
</code></p><div class='itemdescr'></div><div class='para' id='access-2'><div class='marginalizedparent'><a class='marginalized' href='#access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A terminating iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div></div><div id='swap'><h3 ><a class='secnum' href='#swap' style='min-width:103pt'>21.15.5</a> <span class='texttt'>ip::basic_resolver_results</span> swap <a class='abbr_ref' href='internet.resolver.results.swap'>[internet.resolver.results.swap]</a></h3><p ><code class='itemdecl'>
void swap(basic_resolver_results&amp; that) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='swap-1'><div class='marginalizedparent'><a class='marginalized' href='#swap-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>that</span>, and <span class='texttt'>that</span> is equal to the prior value of <span class='texttt'>*this</span>.
</p></div></div></div><div id='comparisons'><h3 ><a class='secnum' href='#comparisons' style='min-width:103pt'>21.15.6</a> <span class='texttt'>ip::basic_resolver_results</span> comparisons <a class='abbr_ref' href='internet.resolver.results.comparisons'>[internet.resolver.results.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.size() == b.size() &amp;&amp; equal(a.cbegin(), a.cend(), b.cbegin())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resolver_base'></a></span></p></div></div></div></body></html>