<!DOCTYPE html><html lang='en'><head><title>[buffer.stream]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='buffer.stream'><h1 ><a class='secnum' style='min-width:73pt'>17</a> Buffer-oriented streams <a class='abbr_ref' href='./#buffer.stream'>[buffer.stream]</a></h1><div id='reqmts'><h2 ><a class='secnum' href='#reqmts' style='min-width:88pt'>17.1</a> Requirements <a class='abbr_ref' href='buffer.stream.reqmts'>[buffer.stream.reqmts]</a></h2><div id='reqmts.syncreadstream'><h3 ><a class='secnum' href='#reqmts.syncreadstream' style='min-width:103pt'>17.1.1</a> Buffer-oriented synchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a></h3><p ><span class='indexparent'><a class='index' id='SyncReadStream'></a></span><span class='indexparent'><a class='index' id='requirements,SyncReadStream'></a></span></p><div class='para' id='reqmts.syncreadstream-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.syncreadstream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>SyncReadStream</span> requirements if it satisfies the requirements listed in Table <a href='#tab:buffer.stream.reqmts.syncreadstream.requirements'>[tab:buffer.stream.reqmts.syncreadstream.requirements]</a>.</p></div><div class='para' id='reqmts.syncreadstream-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.syncreadstream-2'>2</a></div><p >An <a class='hidden_link' href='#def:orderly_shutdown' id='def:orderly_shutdown'><i>orderly shutdown</i></a> is
the procedure for shutting down a stream after all work in progress has been completed, without loss of data.</p></div><div class='para' id='reqmts.syncreadstream-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.syncreadstream-3'>3</a></div><p >In Table <a href='#tab:buffer.stream.reqmts.syncreadstream.requirements'>[tab:buffer.stream.reqmts.syncreadstream.requirements]</a>,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>mb</span> denotes a (possibly const) value of a type satisfying the <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements,
and <span class='texttt'>ec</span> denotes an object of type <span class='texttt'>error_code</span>.</p><p ><span class='indexparent'><a class='index' id='read_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.syncreadstream.requirements'>Table <a href='#tab:buffer.stream.reqmts.syncreadstream.requirements'>16</a> — SyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.read_some(mb)</span>
<span class='texttt'>a.read_some(mb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, reads one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes read. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If all data has been read from the stream, and the stream performed an orderly shutdown, sets <span class='texttt'>ec</span> to <span class='texttt'>stream_errc::eof</span> and returns 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div></div></div><div id='reqmts.asyncreadstream'><h3 ><a class='secnum' href='#reqmts.asyncreadstream' style='min-width:103pt'>17.1.2</a> Buffer-oriented asynchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a></h3><p ><span class='indexparent'><a class='index' id='AsyncReadStream'></a></span><span class='indexparent'><a class='index' id='requirements,AsyncReadStream'></a></span></p><div class='para' id='reqmts.asyncreadstream-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.asyncreadstream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>AsyncReadStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='reqmts.asyncreadstream-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.asyncreadstream-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>mb</span> denotes a (possibly const) value of a type satisfying the <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements,
and <span class='texttt'>t</span> is a completion token.</p><p ><span class='indexparent'><a class='index' id='get_executor'></a></span><span class='indexparent'><a class='index' id='async_read_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.asyncreadstream.requirements'>Table <a href='#tab:buffer.stream.reqmts.asyncreadstream.requirements'>17</a> — AsyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_read_some(mb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, initiates an asynchronous operation to read one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes read. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If all data has been read from the stream, and the stream performed an orderly shutdown, <span class='texttt'>ec</span> is <span class='texttt'>stream_errc::eof</span> and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div></div></div><div id='reqmts.syncwritestream'><h3 ><a class='secnum' href='#reqmts.syncwritestream' style='min-width:103pt'>17.1.3</a> Buffer-oriented synchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a></h3><p ><span class='indexparent'><a class='index' id='SyncWriteStream'></a></span><span class='indexparent'><a class='index' id='requirements,SyncWriteStream'></a></span></p><div class='para' id='reqmts.syncwritestream-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.syncwritestream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>SyncWriteStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='reqmts.syncwritestream-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.syncwritestream-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>cb</span> denotes a (possibly const) value of a type satisfying the <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements,
and <span class='texttt'>ec</span> denotes an object of type <span class='texttt'>error_code</span>.</p><p ><span class='indexparent'><a class='index' id='write_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.syncwritestream.requirements'>Table <a href='#tab:buffer.stream.reqmts.syncwritestream.requirements'>18</a> — SyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.write_some(cb)</span>
<span class='texttt'>a.write_some(cb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, writes one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes written. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div></div></div><div id='reqmts.asyncwritestream'><h3 ><a class='secnum' href='#reqmts.asyncwritestream' style='min-width:103pt'>17.1.4</a> Buffer-oriented asynchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a></h3><p ><span class='indexparent'><a class='index' id='AsyncWriteStream'></a></span><span class='indexparent'><a class='index' id='requirements,AsyncWriteStream'></a></span></p><div class='para' id='reqmts.asyncwritestream-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.asyncwritestream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>AsyncWriteStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='reqmts.asyncwritestream-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.asyncwritestream-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>cb</span> denotes a (possibly const) value of a type satisfying the <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements,
and <span class='texttt'>t</span> is a completion token.</p><p ><span class='indexparent'><a class='index' id='get_executor'></a></span><span class='indexparent'><a class='index' id='async_write_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.asyncwritestream.requirements'>Table <a href='#tab:buffer.stream.reqmts.asyncwritestream.requirements'>19</a> — AsyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_write_some(cb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, initiates an asynchronous operation to write one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes written. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div></div></div><div id='reqmts.completioncondition'><h3 ><a class='secnum' href='#reqmts.completioncondition' style='min-width:103pt'>17.1.5</a> Completion condition requirements <a class='abbr_ref' href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a></h3><p ><span class='indexparent'><a class='index' id='CompletionCondition'></a></span><span class='indexparent'><a class='index' id='requirements,CompletionCondition'></a></span></p><div class='para' id='reqmts.completioncondition-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.completioncondition-1'>1</a></div><p >A completion condition is a function object that is used with the algorithms <span class='texttt'>read</span> (<a href='buffer.read'>[buffer.read]</a>), <span class='texttt'>async_read</span> (<a href='buffer.async.read'>[buffer.async.read]</a>), <span class='texttt'>write</span> (<a href='buffer.write'>[buffer.write]</a>), and <span class='texttt'>async_write</span> (<a href='buffer.async.write'>[buffer.async.write]</a>) to determine when the algorithm has completed transferring data.</p></div><div class='para' id='reqmts.completioncondition-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.completioncondition-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>CompletionCondition</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++ 2014 [destructible]) and <span class='texttt'>CopyConstructible</span> (C++ 2014 [copyconstructible]), as well as the additional requirements listed below.</p></div><div class='para' id='reqmts.completioncondition-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.completioncondition-3'>3</a></div><p >In the table below, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>ec</span> denotes a (possibly const) value of type <span class='texttt'>error_code</span>,
and <span class='texttt'>n</span> denotes a (possibly const) value of type <span class='texttt'>size_t</span>.</p><div class='numberedTable' id='tab:buffer.stream.reqmts.completioncondition.requirements'>Table <a href='#tab:buffer.stream.reqmts.completioncondition.requirements'>20</a> — CompletionCondition requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x(ec, n)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Let <span class='texttt'>n</span> be the total number of bytes transferred by the read or write algorithm so far.<br/>
Returns the maximum number of bytes to be transferred on the next <span class='texttt'>read_some</span>, <span class='texttt'>async_read_some</span>, <span class='texttt'>write_some</span>, or <span class='texttt'>async_write_some</span> operation performed by the algorithm. Returns <span class='texttt'>0</span> to indicate that the algorithm is complete.  </td></tr></table></div></div></div></div><div id='transfer.all'><h2 ><a class='secnum' href='#transfer.all' style='min-width:88pt'>17.2</a> Class <span class='texttt'>transfer_all</span> <a class='abbr_ref' href='buffer.stream.transfer.all'>[buffer.stream.transfer.all]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_all'></a></span></p><div class='para' id='transfer.all-1'><div class='marginalizedparent'><a class='marginalized' href='#transfer.all-1'>1</a></div><p >The class <span class='texttt'>transfer_all</span> is a completion condition that is used to specify that a read or write operation should continue until all of the data has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_all
  {
  public:
    size_t operator()(const error_code&amp; ec, size_t) const;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='transfer.all-2'><div class='marginalizedparent'><a class='marginalized' href='#transfer.all-2'>2</a></div><p >The class <span class='texttt'>transfer_all</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t) const;
</code></p></div><div class='itemdescr'></div><div class='para' id='transfer.all-3'><div class='marginalizedparent'><a class='marginalized' href='#transfer.all-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec</span>, an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='transfer.at.least'><h2 ><a class='secnum' href='#transfer.at.least' style='min-width:88pt'>17.3</a> Class <span class='texttt'>transfer_at_least</span> <a class='abbr_ref' href='buffer.stream.transfer.at.least'>[buffer.stream.transfer.at.least]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_at_least'></a></span></p><div class='para' id='transfer.at.least-1'><div class='marginalizedparent'><a class='marginalized' href='#transfer.at.least-1'>1</a></div><p >The class <span class='texttt'>transfer_at_least</span> is a completion condition that is used to specify that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_at_least
  {
  public:
    explicit transfer_at_least(size_t m);
    size_t operator()(const error_code&amp; ec, size_t n) const;
  private:
    size_t minimum_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='transfer.at.least-2'><div class='marginalizedparent'><a class='marginalized' href='#transfer.at.least-2'>2</a></div><p >The class <span class='texttt'>transfer_at_least</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
explicit transfer_at_least(size_t m);
</code></p></div><div class='itemdescr'></div><div class='para' id='transfer.at.least-3'><div class='marginalizedparent'><a class='marginalized' href='#transfer.at.least-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>minimum_ == m</span>.
</p></div></div><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t n) const;
</code></p><div class='itemdescr'></div><div class='para' id='transfer.at.least-4'><div class='marginalizedparent'><a class='marginalized' href='#transfer.at.least-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec &amp;&amp; n &lt; minimum_</span>, an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='transfer.exactly'><h2 ><a class='secnum' href='#transfer.exactly' style='min-width:88pt'>17.4</a> Class <span class='texttt'>transfer_exactly</span> <a class='abbr_ref' href='buffer.stream.transfer.exactly'>[buffer.stream.transfer.exactly]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_exactly'></a></span></p><div class='para' id='transfer.exactly-1'><div class='marginalizedparent'><a class='marginalized' href='#transfer.exactly-1'>1</a></div><p >The class <span class='texttt'>transfer_exactly</span> is a completion condition that is used to specify that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_exactly
  {
  public:
    explicit transfer_exactly(size_t e);
    size_t operator()(const error_code&amp; ec, size_t n) const;
  private:
    size_t exact_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='transfer.exactly-2'><div class='marginalizedparent'><a class='marginalized' href='#transfer.exactly-2'>2</a></div><p >The class <span class='texttt'>transfer_exactly</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
explicit transfer_exactly(size_t e);
</code></p></div><div class='itemdescr'></div><div class='para' id='transfer.exactly-3'><div class='marginalizedparent'><a class='marginalized' href='#transfer.exactly-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>exact_ == e</span>.
</p></div></div><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t n) const;
</code></p><div class='itemdescr'></div><div class='para' id='transfer.exactly-4'><div class='marginalizedparent'><a class='marginalized' href='#transfer.exactly-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec &amp;&amp; n &lt; exact_</span>, the result of <span class='texttt'>min(exact_ - n, N)</span>, where <span class='texttt'>N</span> is an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.read'><h2 ><a class='secnum' href='#buffer.read' style='min-width:88pt'>17.5</a> Synchronous read operations <a class='abbr_ref' href='buffer.read'>[buffer.read]</a></h2><p ><span class='indexparent'><a class='index' id='read'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class MutableBufferSequence&gt;
  size_t read(SyncReadStream&amp; stream,
              const MutableBufferSequence&amp; buffers);
template&lt;class SyncReadStream, class MutableBufferSequence&gt;
  size_t read(SyncReadStream&amp; stream,
              const MutableBufferSequence&amp; buffers, error_code&amp; ec);
template&lt;class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers,
                CompletionCondition completion_condition,
                error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-1'>1</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.read-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Clears <span class='texttt'>ec</span>, then reads data from the buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function.</p></div></div><div class='para' id='buffer.read-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-3'>3</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>read_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent <span class='texttt'>read_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.read-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-4'>4</a></div><div class='itemdescr'><p >The synchronous read operation continues until:</p><ul class='itemize'><li id='buffer.read-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-4.1'>(4.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.read-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-4.2'>(4.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.read-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-5'>5</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous read operation.</p></div></div><div class='para' id='buffer.read-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_mutable_buffer_sequence_v&lt;MutableBufferSequence&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='read'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition,
                error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Clears <span class='texttt'>ec</span>, then reads data from the synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function.</p></div></div><div class='para' id='buffer.read-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-9'>9</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value less than or equal to <span class='texttt'>b.max_size() - b.size()</span>. [&nbsp;<i>Note:</i> Implementations can use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of <span class='texttt'>read_some</span> calls performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After each <span class='texttt'>read_some</span> call, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the return value from <span class='texttt'>read_some</span>.</p></div></div><div class='para' id='buffer.read-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-10'>10</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>read_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent <span class='texttt'>read_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.read-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-11'>11</a></div><div class='itemdescr'><p >The synchronous read operation continues until:</p><ul class='itemize'><li id='buffer.read-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-11.1'>(11.1)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.read-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-11.2'>(11.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.read-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-12'>12</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous read operation.</p></div></div><div class='para' id='buffer.read-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.async.read'><h2 ><a class='secnum' href='#buffer.async.read' style='min-width:88pt'>17.6</a> Asynchronous read operations <a class='abbr_ref' href='buffer.async.read'>[buffer.async.read]</a></h2><p ><span class='indexparent'><a class='index' id='async_read'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class MutableBufferSequence, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       const MutableBufferSequence&amp; buffers,
                       CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class MutableBufferSequence, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       const MutableBufferSequence&amp; buffers,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous read operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>, <a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.async.read-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Reads data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by invoking the stream's <span class='texttt'>async_read_some</span> member function (henceforth referred to as asynchronous read_some operations) zero or more times.</p></div></div><div class='para' id='buffer.async.read-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-4'>4</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.read-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-5'>5</a></div><div class='itemdescr'><p >This asynchronous read operation is outstanding until:</p><ul class='itemize'><li id='buffer.async.read-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-5.1'>(5.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.async.read-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-5.2'>(5.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.read-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-6'>6</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-7'>7</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.read-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_mutable_buffer_sequence_v&lt;MutableBufferSequence&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='async_read'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;&amp; b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by performing one or more asynchronous read_some operations on the stream.</p></div></div><div class='para' id='buffer.async.read-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-11'>11</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>async_read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N</span> is less than or equal to <span class='texttt'>b.max_size() - b.size()</span>. [&nbsp;<i>Note:</i> Implementations can use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of asynchronous read_some operations performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After the completion of each asynchronous read_some operation, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the value passed to the asynchronous read_some operation's completion handler.</p></div></div><div class='para' id='buffer.async.read-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-12'>12</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.read-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-13'>13</a></div><div class='itemdescr'><p >The asynchronous read operation is outstanding until:</p><ul class='itemize'><li id='buffer.async.read-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-13.1'>(13.1)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.async.read-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-13.2'>(13.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.read-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-14'>14</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-15'>15</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.read-16'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.write'><h2 ><a class='secnum' href='#buffer.write' style='min-width:88pt'>17.7</a> Synchronous write operations <a class='abbr_ref' href='buffer.write'>[buffer.write]</a></h2><p ><span class='indexparent'><a class='index' id='write'></a></span><code class='itemdecl'>
template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
  size_t write(SyncWriteStream&amp; stream,
               const ConstBufferSequence&amp; buffers);
template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
  size_t write(SyncWriteStream&amp; stream,
               const ConstBufferSequence&amp; buffers, error_code&amp; ec);
template&lt;class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers,
                 CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers,
                 CompletionCondition completion_condition,
                 error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.write-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-1'>1</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.write-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Writes data to the buffer-oriented synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>write_some</span> member function.</p></div></div><div class='para' id='buffer.write-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-3'>3</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>write_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent <span class='texttt'>write_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.write-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-4'>4</a></div><div class='itemdescr'><p >The synchronous write operation continues until:</p><ul class='itemize'><li id='buffer.write-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-4.1'>(4.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.write-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-4.2'>(4.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.write-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-5'>5</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call.</p></div></div><div class='para' id='buffer.write-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous write operation.</p></div></div><div class='para' id='buffer.write-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='write'></a></span><code class='itemdecl'>
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
               CompletionCondition completion_condition,
               error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.write-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Writes data to the synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>write_some</span> member function.</p></div></div><div class='para' id='buffer.write-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-9'>9</a></div><div class='itemdescr'><p >Data is written from the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) is obtained using <span class='texttt'>b.data()</span>. After the data has been written to the stream, the implementation performs <span class='texttt'>b.consume(n)</span>, where <span class='texttt'>n</span> is the number of bytes successfully written.</p></div></div><div class='para' id='buffer.write-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-10'>10</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called after each call to the stream's <span class='texttt'>write_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent <span class='texttt'>write_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.write-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-11'>11</a></div><div class='itemdescr'><p >The synchronous write operation continues until:</p><ul class='itemize'><li id='buffer.write-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-11.1'>(11.1)</a></div><p ><span class='texttt'>b.size() == 0</span>; or
</p></li><li id='buffer.write-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-11.2'>(11.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.write-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-12'>12</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call.</p></div></div><div class='para' id='buffer.write-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous write operation.</p></div></div><div class='para' id='buffer.write-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.async.write'><h2 ><a class='secnum' href='#buffer.async.write' style='min-width:88pt'>17.8</a> Asynchronous write operations <a class='abbr_ref' href='buffer.async.write'>[buffer.async.write]</a></h2><p ><span class='indexparent'><a class='index' id='async_write'></a></span><code class='itemdecl'>
template&lt;class AsyncWriteStream, class ConstBufferSequence, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        const ConstBufferSequence&amp; buffers,
                        CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        const ConstBufferSequence&amp; buffers,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.write-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous write operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>, <a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.async.write-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.write-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous operations on the stream using the stream's <span class='texttt'>async_write_some</span> member function (henceforth referred to as asynchronous write_some operations).</p></div></div><div class='para' id='buffer.async.write-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-4'>4</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.write-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-5'>5</a></div><div class='itemdescr'><p >The asynchronous write operation continues until:</p><ul class='itemize'><li id='buffer.async.write-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-5.1'>(5.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.async.write-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-5.2'>(5.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.write-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-6'>6</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncWriteStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.write-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-7'>7</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.write-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='async_write'></a></span><code class='itemdecl'>
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;&amp; b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.write-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.write-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous write_some operations on the stream.</p></div></div><div class='para' id='buffer.async.write-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-11'>11</a></div><div class='itemdescr'><p >Data is written from the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) is obtained using <span class='texttt'>b.data()</span>. After the data has been written to the stream, the implementation performs <span class='texttt'>b.consume(n)</span>, where <span class='texttt'>n</span> is the number of bytes successfully written.</p></div></div><div class='para' id='buffer.async.write-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-12'>12</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.write-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-13'>13</a></div><div class='itemdescr'><p >The asynchronous write operation continues until:</p><ul class='itemize'><li id='buffer.async.write-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-13.1'>(13.1)</a></div><p ><span class='texttt'>b.size() == 0</span>; or
</p></li><li id='buffer.async.write-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-13.2'>(13.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.write-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-14'>14</a></div><div class='itemdescr'><p >The program shall ensure both the <span class='texttt'>AsyncWriteStream</span> object <span class='texttt'>stream</span> and the memory associated with the dynamic buffer <span class='texttt'>b</span> are valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.write-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-15'>15</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.write-16'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.read.until'><h2 ><a class='secnum' href='#buffer.read.until' style='min-width:88pt'>17.9</a> Synchronous delimited read operations <a class='abbr_ref' href='buffer.read.until'>[buffer.read.until]</a></h2><p ><span class='indexparent'><a class='index' id='read_until'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    string_view delim, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read.until-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Reads data from the buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function, until the input sequence of the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span> contains the specified delimiter <span class='texttt'>delim</span>.</p></div></div><div class='para' id='buffer.read.until-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-2'>2</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N &lt;= max_size() - size()</span>. [&nbsp;<i>Note:</i> Implementations can use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of <span class='texttt'>read_some</span> calls performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After each <span class='texttt'>read_some</span> call, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the return value from <span class='texttt'>read_some</span>.</p></div></div><div class='para' id='buffer.read.until-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-3'>3</a></div><div class='itemdescr'><p >The synchronous read_until operation continues until:</p><ul class='itemize'><li id='buffer.read.until-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.1'>(3.1)</a></div><p >the input sequence of <span class='texttt'>b</span> contains the delimiter <span class='texttt'>delim</span>; or
</p></li><li id='buffer.read.until-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.2'>(3.2)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.read.until-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.3'>(3.3)</a></div><p >an asynchronous read_some operation fails.
</p></li></ul></div></div><div class='para' id='buffer.read.until-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-4'>4</a></div><div class='itemdescr'><p >On exit, if the input sequence of <span class='texttt'>b</span> contains the delimiter, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>. Otherwise, if <span class='texttt'>b.size() == b.max_size()</span>, <span class='texttt'>ec</span> is set such that <span class='texttt'>ec == stream_errc::not_found</span>. If <span class='texttt'>b.size() &lt; b.max_size()</span>, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read.until-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of bytes in the input sequence of <span class='texttt'>b</span> up to and including the delimiter, if present. [&nbsp;<i>Note:</i> On completion, the buffer can contain additional bytes following the delimiter. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise returns <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.async.read.until'><h2 ><a class='secnum' href='#buffer.async.read.until' style='min-width:88pt'>17.10</a> Asynchronous delimited read operations <a class='abbr_ref' href='buffer.async.read.until'>[buffer.async.read.until]</a></h2><p ><span class='indexparent'><a class='index' id='async_read_until'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;&amp; b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;&amp; b, string_view delim,
                           CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read.until-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>).</p></div></div><div class='para' id='buffer.async.read.until-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read.until-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous read_some operations on the stream, until the readable bytes of the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span> contain the specified delimiter <span class='texttt'>delim</span>.</p></div></div><div class='para' id='buffer.async.read.until-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-4'>4</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>async_read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N &lt;= max_size() - size()</span>. [&nbsp;<i>Note:</i> Implementations can use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of asynchronous read_some operations performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After the completion of each asynchronous read_some operation, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the value passed to the asynchronous read_some operation's completion handler.</p></div></div><div class='para' id='buffer.async.read.until-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-5'>5</a></div><div class='itemdescr'><p >The asynchronous read_until operation continues until:</p><ul class='itemize'><li id='buffer.async.read.until-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.1'>(5.1)</a></div><p >the readable bytes of <span class='texttt'>b</span> contain the delimiter <span class='texttt'>delim</span>; or
</p></li><li id='buffer.async.read.until-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.2'>(5.2)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.async.read.until-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.3'>(5.3)</a></div><p >an asynchronous read_some operation fails.
</p></li></ul></div></div><div class='para' id='buffer.async.read.until-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-6'>6</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read.until-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-7'>7</a></div><div class='itemdescr'><p >If <span class='texttt'>delim</span> is of type <span class='texttt'>string_view</span>, the implementation copies the underlying sequence of characters prior to initiating an asynchronous read_some operation on the stream. [&nbsp;<i>Note:</i> This means that the caller is not required to guarantee the validity of the delimiter string after the call to <span class='texttt'>async_read_until</span> returns. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='buffer.async.read.until-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-8'>8</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, if the readable bytes of <span class='texttt'>b</span> contain the delimiter, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>. Otherwise, if <span class='texttt'>b.size() == b.max_size()</span>, <span class='texttt'>ec</span> is set such that <span class='texttt'>ec == stream_errc::not_found</span>. If <span class='texttt'>b.size() &lt; b.max_size()</span>, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> from the most recent asynchronous read_some operation. <span class='texttt'>n</span> is the number of readable bytes in <span class='texttt'>b</span> up to and including the delimiter, if present, otherwise <span class='texttt'>0</span>.
</p></div></div></div></div></div></body></html>