<!DOCTYPE html><html lang='en'><head><title>[async]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='async'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Asynchronous model <a class='abbr_ref' href='./#async'>[async]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/executor'></a></span></p><div id='synop'><h2 ><a class='secnum' href='#synop' style='min-width:88pt'>13.1</a> Header <span class='texttt'>&lt;experimental/executor&gt;</span> synopsis <a class='abbr_ref' href='async.synop'>[async.synop]</a></h2><p ><span class='indexparent'><a class='index' id='is_executor_v'></a></span><span class='indexparent'><a class='index' id='uses_executor_v'></a></span><span class='indexparent'><a class='index' id='associated_allocator_t'></a></span><span class='indexparent'><a class='index' id='associated_executor_t'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
    class async_result;

  template&lt;class CompletionToken, class Signature&gt;
    struct async_completion;

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
    struct associated_allocator;

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
    using associated_allocator_t = typename associated_allocator&lt;T, ProtoAllocator&gt;::type;

  <span class='comment'>// get_associated_allocator:
</span>
  template&lt;class T&gt;
    associated_allocator_t&lt;T&gt; get_associated_allocator(const T&amp; t) noexcept;
  template&lt;class T, class ProtoAllocator&gt;
    associated_allocator_t&lt;T, ProtoAllocator&gt;
      get_associated_allocator(const T&amp; t, const ProtoAllocator&amp; a) noexcept;

  enum class fork_event {
    prepare,
    parent,
    child
  };

  class execution_context;

  class service_already_exists;

  template&lt;class Service&gt; Service&amp; use_service(execution_context&amp; ctx);
  template&lt;class Service, class... Args&gt; Service&amp;
    make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
  template&lt;class Service&gt; bool has_service(execution_context&amp; ctx) noexcept;

  template&lt;class T&gt; struct is_executor;

  template&lt;class T&gt;
    constexpr bool is_executor_v = is_executor&lt;T&gt;::value;

  struct executor_arg_t { };
  constexpr executor_arg_t executor_arg = executor_arg_t();

  template&lt;class T, class Executor&gt; struct uses_executor;

  template&lt;class T, class Executor&gt;
    constexpr bool uses_executor_v = uses_executor&lt;T, Executor&gt;::value;

  template&lt;class T, class Executor = system_executor&gt;
    struct associated_executor;

  template&lt;class T, class Executor = system_executor&gt;
    using associated_executor_t = typename associated_executor&lt;T, Executor&gt;::type;

  <span class='comment'>// get_associated_executor:
</span>
  template&lt;class T&gt;
    associated_executor_t&lt;T&gt; get_associated_executor(const T&amp; t) noexcept;
  template&lt;class T, class Executor&gt;
    associated_executor_t&lt;T, Executor&gt;
      get_associated_executor(const T&amp; t, const Executor&amp; ex) noexcept;
  template&lt;class T, class ExecutionContext&gt;
    associated_executor_t&lt;T, typename ExecutionContext::executor_type&gt;
      get_associated_executor(const T&amp; t, ExecutionContext&amp; ctx) noexcept;

  template&lt;class T, class Executor&gt;
    class executor_binder;

  template&lt;class T, class Executor, class Signature&gt;
    class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;;

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;;

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;;

  <span class='comment'>// bind_executor:
</span>
  template&lt;class Executor, class T&gt;
    executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;
      bind_executor(const Executor&amp; ex, T&amp;&amp; t);
  template&lt;class ExecutionContext, class T&gt;
    executor_binder&lt;decay_t&lt;T&gt;, typename ExecutionContext::executor_type&gt;
      bind_executor(ExecutionContext&amp; ctx, T&amp;&amp; t);

  template&lt;class Executor&gt;
    class executor_work_guard;

  <span class='comment'>// make_work_guard:
</span>
  template&lt;class Executor&gt;
    executor_work_guard&lt;Executor&gt;
      make_work_guard(const Executor&amp; ex);
  template&lt;class ExecutionContext&gt;
    executor_work_guard&lt;typename ExecutionContext::executor_type&gt;
      make_work_guard(ExecutionContext&amp; ctx);
  template&lt;class T&gt;
    executor_work_guard&lt;associated_executor_t&lt;T&gt;&gt;
      make_work_guard(const T&amp; t);
  template&lt;class T, class U&gt;
    auto make_work_guard(const T&amp; t, U&amp;&amp; u)
      -&gt; decltype(make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u))));

  class system_executor;
  class system_context;

  bool operator==(const system_executor&amp;, const system_executor&amp;);
  bool operator!=(const system_executor&amp;, const system_executor&amp;);

  class bad_executor;

  class executor;

  bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator==(const executor&amp; e, nullptr_t) noexcept;
  bool operator==(nullptr_t, const executor&amp; e) noexcept;
  bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator!=(const executor&amp; e, nullptr_t) noexcept;
  bool operator!=(nullptr_t, const executor&amp; e) noexcept;

  <span class='comment'>// dispatch:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  <span class='comment'>// post:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  <span class='comment'>// defer:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  template&lt;class Executor&gt;
    class strand;

  template&lt;class Executor&gt;
    bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
  template&lt;class Executor&gt;
    bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);

  template&lt;class ProtoAllocator = allocator&lt;void&gt;&gt;
    class use_future_t;

  constexpr use_future_t&lt;&gt; use_future = use_future_t&lt;&gt;();

  template&lt;class ProtoAllocator, class Result, class... Args&gt;
    class async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;;

  template&lt;class R, class... Args, class Signature&gt;
    class async_result&lt;packaged_task&lt;Result(Args...)&gt;, Signature&gt;;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;class Allocator&gt;
    struct uses_allocator&lt;experimental::net::v1::executor, Allocator&gt;
      : true_type {};

} <span class='comment'>// namespace std
</span></pre></div><div id='reqmts'><h2 ><a class='secnum' href='#reqmts' style='min-width:88pt'>13.2</a> Requirements <a class='abbr_ref' href='async.reqmts'>[async.reqmts]</a></h2><div id='reqmts.proto.allocator'><h3 ><a class='secnum' href='#reqmts.proto.allocator' style='min-width:103pt'>13.2.1</a> Proto-allocator requirements <a class='abbr_ref' href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a></h3><div class='para' id='reqmts.proto.allocator-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.proto.allocator-1'>1</a></div><p >A type <span class='texttt'>A</span> meets the proto-allocator requirements if <span class='texttt'>A</span> is <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), and <span class='texttt'>allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</span> meets the allocator requirements (C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>), where <span class='texttt'>U</span> is an object type. [&nbsp;<i>Note:</i> For example, <span class='texttt'>std::allocator&lt;void&gt;</span> meets the proto-allocator requirements but not the allocator requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;] No constructor, comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.</p></div></div><div id='reqmts.executor'><h3 ><a class='secnum' href='#reqmts.executor' style='min-width:103pt'>13.2.2</a> Executor requirements <a class='abbr_ref' href='async.reqmts.executor'>[async.reqmts.executor]</a></h3><div class='para' id='reqmts.executor-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-1'>1</a></div><p >The library describes a standard set of requirements for executors. A type meeting the <span class='texttt'>Executor</span> requirements embodies a set of rules for determining how submitted function objects are to be executed.</p></div><div class='para' id='reqmts.executor-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>Executor</span> requirements if it satisfies the requirements of <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>) and <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='reqmts.executor-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-3'>3</a></div><p >No constructor, comparison operator, copy operation, move operation, swap operation, or member functions <span class='texttt'>context</span>, <span class='texttt'>on_work_started</span>, and <span class='texttt'>on_work_finished</span> on these types shall exit via an exception.</p></div><div class='para' id='reqmts.executor-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-4'>4</a></div><p >The executor copy constructor, comparison operators, and other member functions defined in these requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.</p></div><div class='para' id='reqmts.executor-5'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-5'>5</a></div><p >Let <span class='texttt'>ctx</span> be the execution context returned by the executor's <span class='texttt'>context()</span> member function. An executor becomes invalid when the first call to <span class='texttt'>ctx.shutdown()</span> returns. The effect of calling <span class='texttt'>on_work_started</span>, <span class='texttt'>on_work_finished</span>, <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, or <span class='texttt'>defer</span> on an invalid executor is undefined. [&nbsp;<i>Note:</i> The copy constructor, comparison operators, and <span class='texttt'>context()</span> member function continue to remain valid until <span class='texttt'>ctx</span> is destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='reqmts.executor-6'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executor-6'>6</a></div><p >In Table <a href='#tab:async.reqmts.executor.requirements'>[tab:async.reqmts.executor.requirements]</a>,
<span class='texttt'>x1</span> and <span class='texttt'>x2</span> denote values of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>mx1</span> denotes an xvalue of type <span class='texttt'>X</span>,
<span class='texttt'>f</span> denotes a <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) function object callable with zero arguments,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>A</span> or <span class='texttt'>const A</span>
where <span class='texttt'>A</span> is a type meeting the <span class='texttt'>Allocator</span> requirements (C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>),
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:async.reqmts.executor.requirements'>Table <a href='#tab:async.reqmts.executor.requirements'>4</a> — Executor requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(x1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u == x1</span> and <span class='texttt'>std::addressof(u.context()) == std::addressof(x1.context()).</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(mx1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u</span> equals the prior value of <span class='texttt'>mx1</span> and <span class='texttt'>std::addressof(u.context())</span> equals the prior value of <span class='texttt'>std::addressof(mx1.context())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 == x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> only if <span class='texttt'>x1</span> and <span class='texttt'>x2</span> can be interchanged with identical effects in any of the expressions defined in these type requirements. [&nbsp;<i>Note:</i> Returning <span class='texttt'>false</span> does not necessarily imply that the effects are not identical. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/><span class='texttt'>operator==</span> shall be reflexive, symmetric, and transitive, and shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 != x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Same as <span class='texttt'>!(x1 == x2)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.context()</span>  </td><td class='left'>
<span class='texttt'>execution_context&amp;</span>, or <span class='texttt'>E&amp;</span> where <span class='texttt'>E</span> is a type that satisfies the <span class='texttt'>ExecutionContext</span>  (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) requirements.  </td><td class='left'>
Shall not exit via an exception. The comparison operators and member functions defined in these requirements shall not alter the reference returned by this function.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_started()</span>  </td><td class='left'>
  </td><td class='left'>
 Shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_finished()</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception. <br/><i>Precondition:</i> A preceding call <span class='texttt'>x2.on_work_started()</span> where <span class='texttt'>x1 == x2</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.dispatch(<br/><span class='mbox'>  </span>std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>) in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor may block forward progress of the caller until <span class='texttt'>f1()</span> finishes execution. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;] <br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>dispatch</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.post(std::move(f), a)</span><br/>
<span class='texttt'>x1.defer(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>post</span> or <span class='texttt'>defer</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>. [&nbsp;<i>Note:</i> Although the requirements placed on <span class='texttt'>defer</span> are identical to <span class='texttt'>post</span>, the use of <span class='texttt'>post</span> conveys a preference that the caller does not block the first step of <span class='texttt'>f1</span>'s progress, whereas <span class='texttt'>defer</span> conveys a preference that the caller does block the first step of <span class='texttt'>f1</span>. One use of <span class='texttt'>defer</span> is to convey the intention of the caller that <span class='texttt'>f1</span> is a continuation of the current call context. The executor may use this information to optimize or otherwise adjust the way in which <span class='texttt'>f1</span> is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div></div></div><div id='reqmts.executioncontext'><h3 ><a class='secnum' href='#reqmts.executioncontext' style='min-width:103pt'>13.2.3</a> Execution context requirements <a class='abbr_ref' href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context'></a></span></p><div class='para' id='reqmts.executioncontext-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executioncontext-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ExecutionContext</span> requirements if it is publicly and unambiguously derived from <span class='texttt'>execution_context</span>, and satisfies the additional requirements listed below.</p></div><div class='para' id='reqmts.executioncontext-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.executioncontext-2'>2</a></div><p >In Table <a href='#tab:async.reqmts.executioncontext.requirements'>[tab:async.reqmts.executioncontext.requirements]</a>, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,ExecutionContext'></a></span><span class='indexparent'><a class='index' id='ExecutionContext'></a></span>
 
 
 </p><div class='numberedTable' id='tab:async.reqmts.executioncontext.requirements'>Table <a href='#tab:async.reqmts.executioncontext.requirements'>5</a> — ExecutionContext requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.~X()</span>  </td><td class='left'>
  </td><td class='left'>
 Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.get_executor()</span>  </td><td class='left'>
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
 Returns an executor object that is associated with the execution context.  </td></tr></table></div></div></div><div id='reqmts.service'><h3 ><a class='secnum' href='#reqmts.service' style='min-width:103pt'>13.2.4</a> Service requirements <a class='abbr_ref' href='async.reqmts.service'>[async.reqmts.service]</a></h3><p ><span class='indexparent'><a class='index' id='service'></a></span>
<span class='indexparent'><a class='index' id='execution_context::service'></a></span></p><div class='para' id='reqmts.service-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.service-1'>1</a></div><p >A class is a service if it is publicly and unambiguously derived from <span class='texttt'>execution_context::service</span>, or if it is publicly and unambiguously derived from another service. For a service <span class='texttt'>S</span>, <span class='texttt'>S::key_type</span> shall be valid and denote a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>is_base_of_v&lt;typename S::key_type, S&gt;</span> shall be <span class='texttt'>true</span>, and <span class='texttt'>S</span> shall satisfy the <span class='texttt'>Destructible</span> requirements (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>).</p></div><div class='para' id='reqmts.service-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.service-2'>2</a></div><p >The first parameter of all service constructors shall be an lvalue reference to <span class='texttt'>execution_context</span>. This parameter denotes the <span class='texttt'>execution_context</span> object that represents a set of services, of which the service object will be a member. [&nbsp;<i>Note:</i> These constructors may be called by the <span class='texttt'>make_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='reqmts.service-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.service-3'>3</a></div><p >A service shall provide an explicit constructor with a single parameter of lvalue reference to <span class='texttt'>execution_context</span>. [&nbsp;<i>Note:</i> This constructor may be called by the <span class='texttt'>use_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='reqmts.service-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.service-4'>4</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class my_service : public execution_context::service{
public:
  using key_type = my_service;
  explicit my_service(execution_context&amp; ctx);
  my_service(execution_context&amp; ctx, int some_value);
private:
  virtual void shutdown() noexcept override;
  ...
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='reqmts.service-5'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.service-5'>5</a></div><p >A service's <span class='texttt'>shutdown</span> member function shall destroy all copies of user-defined function objects that are held by the service.</p></div></div><div id='reqmts.signature'><h3 ><a class='secnum' href='#reqmts.signature' style='min-width:103pt'>13.2.5</a> Signature requirements <a class='abbr_ref' href='async.reqmts.signature'>[async.reqmts.signature]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,signature'></a></span><span class='indexparent'><a class='index' id='signature_requirements'></a></span></p><div class='para' id='reqmts.signature-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.signature-1'>1</a></div><p >A type satisfies the signature requirements if it is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p></div></div><div id='reqmts.associator'><h3 ><a class='secnum' href='#reqmts.associator' style='min-width:103pt'>13.2.6</a> Associator requirements <a class='abbr_ref' href='async.reqmts.associator'>[async.reqmts.associator]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,associator'></a></span><span class='indexparent'><a class='index' id='associator'></a></span></p><div class='para' id='reqmts.associator-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.associator-1'>1</a></div><p >An associator defines a relationship between different types and objects where, given:</p><ul class='itemize'><li id='reqmts.associator-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.associator-1.1'>(1.1)</a></div><p >a source object <span class='texttt'>s</span> of type <span class='texttt'>S</span>,</p></li><li id='reqmts.associator-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.associator-1.2'>(1.2)</a></div><p >type requirements <span class='texttt'>R</span>, and</p></li><li id='reqmts.associator-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.associator-1.3'>(1.3)</a></div><p >a candidate object <span class='texttt'>c</span> of type <span class='texttt'>C</span> meeting the type requirements <span class='texttt'>R</span>,
</p></li></ul><p >an associated type <span class='texttt'>A</span> meeting the type requirements <span class='texttt'>R</span> may be computed, and an associated object <span class='texttt'>a</span> of type <span class='texttt'>A</span> may be obtained.</p></div><div class='para' id='reqmts.associator-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.associator-2'>2</a></div><p >An associator shall be a class template that takes two template type arguments. The first template argument is the source type <span class='texttt'>S</span>. The second template argument is the candidate type <span class='texttt'>C</span>. The second template argument shall be defaulted to some default candidate type <span class='texttt'>D</span> that satisfies the type requirements <span class='texttt'>R</span>.</p></div><div class='para' id='reqmts.associator-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.associator-3'>3</a></div><p >An associator shall additionally satisfy the requirements in Table <a href='#tab:async.reqmts.associator.requirements'>[tab:async.reqmts.associator.requirements]</a>.
In this table, <span class='texttt'>X</span> is a class template that meets the associator requirements,
<span class='texttt'>S</span> is the source type,
<span class='texttt'>s</span> is a value of type <span class='texttt'>S</span> or <span class='texttt'>const S</span>,
<span class='texttt'>C</span> is the candidate type,
<span class='texttt'>c</span> is a value of type <span class='texttt'>C</span> or <span class='texttt'>const C</span>,
<span class='texttt'>D</span> is the default candidate type,
and <span class='texttt'>d</span> is a value of type <span class='texttt'>D</span> or <span class='texttt'>const D</span> that is the default candidate object.</p><div class='numberedTable' id='tab:async.reqmts.associator.requirements'>Table <a href='#tab:async.reqmts.associator.requirements'>6</a> — Associator requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, D&gt;::type</span>  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
  </td><td class='left'>
 The associated type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S&gt;::get(s)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
Returns <span class='texttt'>X&lt;S&gt;::get(S, d)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::get(s, c)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
 Returns the associated object.  </td></tr></table></div></div><div class='para' id='reqmts.associator-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.associator-4'>4</a></div><p >The associator's primary template shall be defined. A program may partially specialize the associator class template for some user-defined type <span class='texttt'>S</span>.</p></div><div class='para' id='reqmts.associator-5'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.associator-5'>5</a></div><p >Finally, the associator shall provide the following type alias and function template in the enclosing namespace:</p><pre class='codeblock'>
template&lt;class S, class C = D&gt; using <i>X</i>_t = typename <i>X</i>&lt;S, C&gt;::type;

template&lt;class S, class C = D&gt;
typename <i>X</i>&lt;S, C&gt;::type get_<i>X</i>(const S&amp; s, const C&amp; c = d){
  return <i>X</i>&lt;S, C&gt;::get(s, c);
}
</pre><p >where <span class='texttt'><i>X</i></span> is replaced with the name of the associator class template.
[&nbsp;<i>Note:</i> This function template is provided as a convenience, to automatically deduce the source and candidate types. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='reqmts.async'><h3 ><a class='secnum' href='#reqmts.async' style='min-width:103pt'>13.2.7</a> Requirements on asynchronous operations <a class='abbr_ref' href='async.reqmts.async'>[async.reqmts.async]</a></h3><div class='para' id='reqmts.async-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async-1'>1</a></div><p >This section uses the names <span class='texttt'>Alloc1</span>, <span class='texttt'>Alloc2</span>, <span class='texttt'>alloc1</span>, <span class='texttt'>alloc2</span>, <span class='texttt'>Args</span>, <span class='texttt'>CompletionHandler</span>, <span class='texttt'>completion_handler</span>, <span class='texttt'>Executor1</span>, <span class='texttt'>Executor2</span>, <span class='texttt'>ex1</span>, <span class='texttt'>ex2</span>, <span class='texttt'>f</span>, <i>i</i>, <i>N</i>, <span class='texttt'>Signature</span>, <span class='texttt'>token</span>, <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>work1</span>, and <span class='texttt'>work2</span> as placeholders for specifying the requirements below.</p></div><div id='reqmts.async.concepts'><h4 ><a class='secnum' href='#reqmts.async.concepts' style='min-width:118pt'>13.2.7.1</a> General asynchronous operation concepts <a class='abbr_ref' href='async.reqmts.async.concepts'>[async.reqmts.async.concepts]</a></h4><div class='para' id='reqmts.async.concepts-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.concepts-1'>1</a></div><p >An initiating function is a function which may be called to start an asynchronous operation. A completion handler is a function object that will be invoked, at most once, with the result of the asynchronous operation.</p></div><div class='para' id='reqmts.async.concepts-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.concepts-2'>2</a></div><p >The life cycle of an asynchronous operation is comprised of the following events and phases:</p><ul class='itemize'><li id='reqmts.async.concepts-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.concepts-2.1'>(2.1)</a></div><p >Event 1: The asynchronous operation is started by a call to the initiating function.</p></li><li id='reqmts.async.concepts-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.concepts-2.2'>(2.2)</a></div><p >Phase 1: The asynchronous operation is now outstanding.</p></li><li id='reqmts.async.concepts-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.concepts-2.3'>(2.3)</a></div><p >Event 2: The externally observable side effects of the asynchronous operation, if any, are fully established. The completion handler is submitted to an executor.</p></li><li id='reqmts.async.concepts-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.concepts-2.4'>(2.4)</a></div><p >Phase 2: The asynchronous operation is now completed.</p></li><li id='reqmts.async.concepts-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.concepts-2.5'>(2.5)</a></div><p >Event 3: The completion handler is called with the result of the asynchronous operation.
</p></li></ul></div><div class='para' id='reqmts.async.concepts-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.concepts-3'>3</a></div><p >In this Technical Specification, all functions with the prefix <span class='texttt'>async_</span> are initiating functions.</p></div></div><div id='reqmts.async.token'><h4 ><a class='secnum' href='#reqmts.async.token' style='min-width:118pt'>13.2.7.2</a> Completion tokens and handlers <a class='abbr_ref' href='async.reqmts.async.token'>[async.reqmts.async.token]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function'></a></span></p><div class='para' id='reqmts.async.token-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.token-1'>1</a></div><p >Initiating functions:</p><ul class='itemize'><li id='reqmts.async.token-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.token-1.1'>(1.1)</a></div><p >are function templates with template parameter <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_token'></a></span></p></li><li id='reqmts.async.token-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.token-1.2'>(1.2)</a></div><p >accept, as the final parameter, a completion token object <span class='texttt'>token</span> of type <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_signature'></a></span></p></li><li id='reqmts.async.token-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.token-1.3'>(1.3)</a></div><p >specify a completion signature, which is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>) <span class='texttt'>Signature</span> that determines the arguments to the completion handler.
</p></li></ul><p ><span class='indexparent'><a class='index' id='completion_handler'></a></span></p></div><div class='para' id='reqmts.async.token-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.token-2'>2</a></div><p >An initiating function determines the type <span class='texttt'>CompletionHandler</span> of its
completion handler function object by performing
<span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::completion_handler_type</span>.
The completion handler object <span class='texttt'>completion_handler</span> is initialized with
<span class='texttt'>std::forward&lt;CompletionToken&gt;(token)</span>.
[&nbsp;<i>Note:</i> No other requirements are placed on the type <span class='texttt'>CompletionToken</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='reqmts.async.token-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.token-3'>3</a></div><p >The type <span class='texttt'>CompletionHandler</span> must satisfy the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and be callable with the specified call signature.</p></div><div class='para' id='reqmts.async.token-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.token-4'>4</a></div><p >In this Technical Specification, all initiating functions specify a
<i>Completion signature:</i> element that defines the call signature <span class='texttt'>Signature</span>.
The <i>Completion signature:</i> elements in this Technical Specification have named
parameters, and the results of an asynchronous operation are specified in
terms of these names.</p></div></div><div id='reqmts.async.return.type'><h4 ><a class='secnum' href='#reqmts.async.return.type' style='min-width:118pt'>13.2.7.3</a> Deduction of initiating function return type <a class='abbr_ref' href='async.reqmts.async.return.type'>[async.reqmts.async.return.type]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,deduction_of_return_type'></a></span></p><div class='para' id='reqmts.async.return.type-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.return.type-1'>1</a></div><p >The return type of an initiating function is <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div><div class='para' id='reqmts.async.return.type-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.return.type-2'>2</a></div><p >For the sake of exposition, this Technical Specification sometimes annotates functions with a return type <i><span class='texttt'>DEDUCED</span></i>. For every function declaration that returns <i><span class='texttt'>DEDUCED</span></i>, the meaning is equivalent to specifying the return type as <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div></div><div id='reqmts.async.return.value'><h4 ><a class='secnum' href='#reqmts.async.return.value' style='min-width:118pt'>13.2.7.4</a> Production of initiating function return value <a class='abbr_ref' href='async.reqmts.async.return.value'>[async.reqmts.async.return.value]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,production_of_return_value'></a></span></p><div class='para' id='reqmts.async.return.value-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.return.value-1'>1</a></div><p >An initiating function produces its return type as follows:</p><ul class='itemize'><li id='reqmts.async.return.value-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.return.value-1.1'>(1.1)</a></div><p >constructing an object <span class='texttt'>result</span> of type <span class='texttt'>async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;</span>, initialized as <span class='texttt'>result(completion_handler)</span>; and</p></li><li id='reqmts.async.return.value-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.return.value-1.2'>(1.2)</a></div><p >using <span class='texttt'>result.get()</span> as the operand of the return statement.
</p></li></ul></div><div class='para' id='reqmts.async.return.value-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.return.value-2'>2</a></div><p >[&nbsp;<i>Example:</i> Given an asynchronous operation with Completion signature <span class='texttt'>void(R1 r1, R2 r2)</span>, an initiating function meeting these requirements may be implemented as follows:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  typename async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt;::completion_handler_type
    completion_handler(forward&lt;CompletionToken&gt;(token));

  async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt; result(completion_handler);

  <span class='comment'>// initiate the operation and cause completion_handler to be invoked with
</span>  <span class='comment'>// the result
</span>
  return result.get();
}
</pre></div><div class='para' id='reqmts.async.return.value-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.return.value-3'>3</a></div><p >For convenience, initiating functions may be implemented using the <span class='texttt'>async_completion</span> template:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  async_completion&lt;CompletionToken, void(R1, R2)&gt; init(token);

  <span class='comment'>// initiate the operation and cause init.completion_handler to be invoked
</span>  <span class='comment'>// with the result
</span>
  return init.result.get();
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='reqmts.async.lifetime'><h4 ><a class='secnum' href='#reqmts.async.lifetime' style='min-width:118pt'>13.2.7.5</a> Lifetime of initiating function arguments <a class='abbr_ref' href='async.reqmts.async.lifetime'>[async.reqmts.async.lifetime]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,lifetime_of_arguments'></a></span></p><div class='para' id='reqmts.async.lifetime-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.lifetime-1'>1</a></div><p >Unless otherwise specified, the lifetime of arguments to initiating functions shall be treated as follows:</p><ul class='itemize'><li id='reqmts.async.lifetime-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.lifetime-1.1'>(1.1)</a></div><p >If the parameter has a pointer type or has a type of lvalue reference to non-const, the implementation may assume the validity of the pointee or referent, respectively, until the completion handler is invoked. [&nbsp;<i>Note:</i> In other words, the program must guarantee the validity of the argument until the completion handler is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='reqmts.async.lifetime-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.lifetime-1.2'>(1.2)</a></div><p >Otherwise, the implementation must not assume the validity of the argument after the initiating function completes. [&nbsp;<i>Note:</i> In other words, the program is not required to guarantee the validity of the argument after the initiating function completes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The implementation may make copies of the argument, and all copies shall be destroyed no later than immediately after invocation of the completion handler.
</p></li></ul></div></div><div id='reqmts.async.non.blocking'><h4 ><a class='secnum' href='#reqmts.async.non.blocking' style='min-width:118pt'>13.2.7.6</a> Non-blocking requirements on initiating functions <a class='abbr_ref' href='async.reqmts.async.non.blocking'>[async.reqmts.async.non.blocking]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,non-blocking_requirements'></a></span></p><div class='para' id='reqmts.async.non.blocking-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.non.blocking-1'>1</a></div><p >An initiating function shall not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the outstanding operation.</p></div><div class='para' id='reqmts.async.non.blocking-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.non.blocking-2'>2</a></div><p >[&nbsp;<i>Note:</i> Initiating functions may still block the calling thread for other reasons. For example, an initiating function may lock a mutex in order to synchronize access to shared data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='reqmts.async.assoc.exec'><h4 ><a class='secnum' href='#reqmts.async.assoc.exec' style='min-width:118pt'>13.2.7.7</a> Associated executor <a class='abbr_ref' href='async.reqmts.async.assoc.exec'>[async.reqmts.async.assoc.exec]</a></h4><p ><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><div class='para' id='reqmts.async.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.assoc.exec-1'>1</a></div><p >Certain objects that participate in asynchronous operations have an associated executor. These are obtained as specified below.</p></div></div><div id='reqmts.async.io.exec'><h4 ><a class='secnum' href='#reqmts.async.io.exec' style='min-width:118pt'>13.2.7.8</a> I/O executor <a class='abbr_ref' href='async.reqmts.async.io.exec'>[async.reqmts.async.io.exec]</a></h4><p ><span class='indexparent'><a class='index' id='system_executor'></a></span></p><div class='para' id='reqmts.async.io.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.io.exec-1'>1</a></div><p >An asynchronous operation has an associated executor satisfying the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements. If not otherwise specified by the asynchronous operation, this associated executor is an object of type <span class='texttt'>system_executor</span>.</p></div><div class='para' id='reqmts.async.io.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.io.exec-2'>2</a></div><p >All asynchronous operations in this Technical Specification have an associated executor object that is determined as follows:</p><ul class='itemize'><li id='reqmts.async.io.exec-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.io.exec-2.1'>(2.1)</a></div><p >If the initiating function is a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function on the same object.</p></li><li id='reqmts.async.io.exec-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.io.exec-2.2'>(2.2)</a></div><p >If the initiating function is not a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function of the first argument to the initiating function.
</p></li></ul></div><div class='para' id='reqmts.async.io.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.io.exec-3'>3</a></div><p >Let <span class='texttt'>Executor1</span> be the type of the associated executor. Let <span class='texttt'>ex1</span> be a value of type <span class='texttt'>Executor1</span>, representing the associated executor object obtained as described above.</p></div></div><div id='reqmts.async.handler.exec'><h4 ><a class='secnum' href='#reqmts.async.handler.exec' style='min-width:118pt'>13.2.7.9</a> Completion handler executor <a class='abbr_ref' href='async.reqmts.async.handler.exec'>[async.reqmts.async.handler.exec]</a></h4><div class='para' id='reqmts.async.handler.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.handler.exec-1'>1</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span>
has an associated executor
satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).
The type of this associated executor is
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>Executor2</span> be the type
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>ex2</span> be a value of type <span class='texttt'>Executor2</span>
obtained by performing <span class='texttt'>get_associated_executor(completion_handler, ex1)</span>.</p></div></div><div id='reqmts.async.work'><h4 ><a class='secnum' href='#reqmts.async.work' style='min-width:118pt'>13.2.7.10</a> Outstanding work <a class='abbr_ref' href='async.reqmts.async.work'>[async.reqmts.async.work]</a></h4><p ><span class='indexparent'><a class='index' id='outstanding_work'></a></span></p><div class='para' id='reqmts.async.work-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.work-1'>1</a></div><p >Until the asynchronous operation has completed, the asynchronous operation shall maintain:</p><ul class='itemize'><li id='reqmts.async.work-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.work-1.1'>(1.1)</a></div><p >an object <span class='texttt'>work1</span> of type <span class='texttt'>executor_work_guard&lt;Executor1&gt;</span>, initialized as <span class='texttt'>work1(ex1)</span>, and where <span class='texttt'>work1.owns_work() == true</span>; and</p></li><li id='reqmts.async.work-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.work-1.2'>(1.2)</a></div><p >an object <span class='texttt'>work2</span> of type <span class='texttt'>executor_work_guard&lt;Executor2&gt;</span>, initialized as <span class='texttt'>work2(ex2)</span>, and where <span class='texttt'>work2.owns_work() == true</span>.
</p></li></ul></div></div><div id='reqmts.async.alloc'><h4 ><a class='secnum' href='#reqmts.async.alloc' style='min-width:118pt'>13.2.7.11</a> Allocation of intermediate storage <a class='abbr_ref' href='async.reqmts.async.alloc'>[async.reqmts.async.alloc]</a></h4><div class='para' id='reqmts.async.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.alloc-1'>1</a></div><p >Asynchronous operations may allocate memory. [&nbsp;<i>Note:</i> Such as a data structure to store copies of the <span class='texttt'>completion_handler</span> object and the initiating function's arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='reqmts.async.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.alloc-2'>2</a></div><p >Let <span class='texttt'>Alloc1</span> be a type, satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements, that represents the asynchronous operation's default allocation strategy. [&nbsp;<i>Note:</i> Typically <span class='texttt'>std::allocator&lt;void&gt;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Let <span class='texttt'>alloc1</span> be a value of type <span class='texttt'>Alloc1</span>.</p></div><div class='para' id='reqmts.async.alloc-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.alloc-3'>3</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span> has an associated allocator object <span class='texttt'>alloc2</span> of type <span class='texttt'>Alloc2</span> satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements. The type <span class='texttt'>Alloc2</span> is <span class='texttt'>associated_allocator_t&lt;CompletionHandler, Alloc1&gt;</span>. Let <span class='texttt'>alloc2</span> be a value of type <span class='texttt'>Alloc2</span> obtained by performing <span class='texttt'>get_associated_allocator(completion_handler, alloc1)</span>.</p></div><div class='para' id='reqmts.async.alloc-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.alloc-4'>4</a></div><p >The asynchronous operations defined in this Technical Specification:</p><ul class='itemize'><li id='reqmts.async.alloc-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.alloc-4.1'>(4.1)</a></div><p >If required, allocate memory using only the completion handler's associated allocator.</p></li><li id='reqmts.async.alloc-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.alloc-4.2'>(4.2)</a></div><p >Prior to completion handler execution, deallocate any memory allocated using the completion handler's associated allocator.
</p></li></ul></div><div class='para' id='reqmts.async.alloc-5'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.alloc-5'>5</a></div><p >[&nbsp;<i>Note:</i> The implementation may perform operating system or underlying API calls that perform memory allocations not using the associated allocator. Invocations of the allocator functions may not introduce data races (See C++Std &sect;<a href='../n4140/res.on.data.races'>[res.on.data.races]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='reqmts.async.completion'><h4 ><a class='secnum' href='#reqmts.async.completion' style='min-width:118pt'>13.2.7.12</a> Execution of completion handler on completion of asynchronous operation <a class='abbr_ref' href='async.reqmts.async.completion'>[async.reqmts.async.completion]</a></h4><div class='para' id='reqmts.async.completion-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.completion-1'>1</a></div><p >Let <span class='texttt'>Args...</span> be the argument types of the completion signature <span class='texttt'>Signature</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span>. Let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args...</span> and let <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> completion handler argument associated with <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>.</p></div><div class='para' id='reqmts.async.completion-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.completion-2'>2</a></div><p >Let <span class='texttt'>f</span> be a function object, callable as <span class='texttt'>f()</span>, that invokes <span class='texttt'>completion_handler</span> as if by <span class='texttt'>completion_handler(forward&lt;T<span class='math'><sub >0</sub></span>&gt;(t<span class='math'><sub >0</sub></span>), ..., forward&lt;T<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(t<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span>.</p></div><div class='para' id='reqmts.async.completion-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.completion-3'>3</a></div><p >If an asynchronous operation completes immediately (that is, within the thread of execution calling the initiating function, and before the initiating function returns), the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.post(std::move(f), alloc2)</span>. Otherwise, the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.dispatch(std::move(f), alloc2)</span>.</p></div></div><div id='reqmts.async.exceptions'><h4 ><a class='secnum' href='#reqmts.async.exceptions' style='min-width:118pt'>13.2.7.13</a> Completion handlers and exceptions <a class='abbr_ref' href='async.reqmts.async.exceptions'>[async.reqmts.async.exceptions]</a></h4><div class='para' id='reqmts.async.exceptions-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.exceptions-1'>1</a></div><p >Completion handlers are permitted to throw exceptions. The effect of any exception propagated from the execution of a completion handler is determined by the executor which is executing the completion handler.</p></div></div><div id='reqmts.async.composed'><h4 ><a class='secnum' href='#reqmts.async.composed' style='min-width:118pt'>13.2.7.14</a> Composed asynchronous operations <a class='abbr_ref' href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a></h4><div class='para' id='reqmts.async.composed-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.async.composed-1'>1</a></div><p >In this Technical Specification, a <a class='hidden_link' href='#def:composed_asynchronous_operation' id='def:composed_asynchronous_operation'><i>composed asynchronous operation</i></a> is an asynchronous operation that is implemented in terms of zero or more intermediate calls to other asynchronous operations. The intermediate asynchronous operations are performed sequentially. [&nbsp;<i>Note:</i> That is, the completion handler of an intermediate operation initiates the next operation in the sequence. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >An intermediate operation's completion handler shall have an associated executor that is either:</p><ul class='itemize'><li id='reqmts.async.composed-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.composed-1.1'>(1.1)</a></div><p >the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='reqmts.async.composed-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.composed-1.2'>(1.2)</a></div><p >an object of an unspecified type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), that delegates executor operations to the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span>.
</p></li></ul><p >An intermediate operation's completion handler shall have an associated allocator that is either:</p><ul class='itemize'><li id='reqmts.async.composed-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.composed-1.3'>(1.3)</a></div><p >the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='reqmts.async.composed-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#reqmts.async.composed-1.4'>(1.4)</a></div><p >an object of an unspecified type satisfying the ProtoAllocator requirements (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>), that delegates allocator operations to the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span>.
</p></li></ul></div></div></div></div><div id='async.result'><h2 ><a class='secnum' href='#async.result' style='min-width:88pt'>13.3</a> Class template <span class='texttt'>async_result</span> <a class='abbr_ref' href='async.async.result'>[async.async.result]</a></h2><p ><span class='indexparent'><a class='index' id='async_result'></a></span></p><div class='para' id='async.result-1'><div class='marginalizedparent'><a class='marginalized' href='#async.result-1'>1</a></div><p >The <span class='texttt'>async_result</span> class template is a customization point for asynchronous operations. Template parameter <span class='texttt'>CompletionToken</span> specifies the model used to obtain the result of the asynchronous operation. Template parameter <span class='texttt'>Signature</span> is the call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>) for the completion handler type invoked on completion of the asynchronous operation. The <span class='texttt'>async_result</span> template:</p><ul class='itemize'><li id='async.result-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.result-1.1'>(1.1)</a></div><p >transforms a <span class='texttt'>CompletionToken</span> into a completion handler type that is based on a <span class='texttt'>Signature</span>; and</p></li><li id='async.result-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.result-1.2'>(1.2)</a></div><p >determines the return type and return value of an asynchronous operation's initiating function.
</p></li></ul><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
  class async_result
  {
  public:
    using completion_handler_type = CompletionToken;
    using return_type = void;

    explicit async_result(completion_handler_type&amp;) {}
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get() {}
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.result-2'><div class='marginalizedparent'><a class='marginalized' href='#async.result-2'>2</a></div><p >The template parameter <span class='texttt'>CompletionToken</span> shall be an object type. The template parameter <span class='texttt'>Signature</span> shall be a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p></div><div class='para' id='async.result-3'><div class='marginalizedparent'><a class='marginalized' href='#async.result-3'>3</a></div><p >Specializations of <span class='texttt'>async_result</span> shall satisfy the <span class='texttt'>Destructible</span> requirements (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) in addition to the requirements in Table <a href='#tab:async.async.result.requirements'>[tab:async.async.result.requirements]</a>. In this table, <span class='texttt'>R</span> is a specialization of <span class='texttt'>async_result</span>; <span class='texttt'>r</span> is a modifiable lvalue of type <span class='texttt'>R</span>; and <span class='texttt'>h</span> is a modifiable lvalue of type <span class='texttt'>R::completion_handler_type</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,async_result'></a></span>
 
 
 </p><div class='numberedTable' id='tab:async.async.result.requirements'>Table <a href='#tab:async.async.result.requirements'>7</a> — <span class='texttt'>async_result</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Requirement</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>R::completion_handler_type</span>  </td><td class='left'>
  </td><td class='left'>
A type satisfying <span class='texttt'>MoveConstructible</span> requirements (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), An object of type <span class='texttt'>completion_handler_type</span> shall be a function object with call signature <span class='texttt'>Signature</span>, and <span class='texttt'>completion_handler_type</span> shall be constructible with an rvalue of type <span class='texttt'>CompletionToken</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R::return_type</span>  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>void</span>; or a type satisfying <span class='texttt'>MoveConstructible</span> requirements (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R r(h);</span>  </td><td class='left'>
  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>r.get()</span>  </td><td class='left'>
<span class='texttt'>R::return_type</span>  </td><td class='left'>
[&nbsp;<i>Note:</i> An asynchronous operation's initiating function uses the <span class='texttt'>get()</span> member function as the sole operand of a return statement. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div></div></div><div id='async.completion'><h2 ><a class='secnum' href='#async.completion' style='min-width:88pt'>13.4</a> Class template <span class='texttt'>async_completion</span> <a class='abbr_ref' href='async.async.completion'>[async.async.completion]</a></h2><p ><span class='indexparent'><a class='index' id='async_completion'></a></span></p><div class='para' id='async.completion-1'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-1'>1</a></div><p >Class template <span class='texttt'>async_completion</span> is provided as a convenience, to simplify the implementation of asynchronous operations that use <span class='texttt'>async_result</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
  struct async_completion
  {
    using completion_handler_type = async_result&lt;decay_t&lt;CompletionToken&gt;,
      Signature&gt;::completion_handler_type;

    explicit async_completion(CompletionToken&amp; t);
    async_completion(const async_completion&amp;) = delete;
    async_completion&amp; operator=(const async_completion&amp;) = delete;

    <i><span class='texttt'>see below</span></i> completion_handler;
    async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt; result;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.completion-2'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-2'>2</a></div><p >The template parameter <span class='texttt'>Signature</span> shall be a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p><p ><code class='itemdecl'>
explicit async_completion(CompletionToken&amp; t);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.completion-3'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>CompletionToken</span> and <span class='texttt'>completion_handler_type</span> are the same type,
binds <span class='texttt'>completion_handler</span> to <span class='texttt'>t</span>;
otherwise, initializes <span class='texttt'>completion_handler</span> with <span class='texttt'>forward&lt;CompletionToken&gt;(t)</span>.
Initializes <span class='texttt'>result</span> with <span class='texttt'>completion_handler</span>.
</p></div></div><p ><code class='itemdecl'>
<i><span class='texttt'>see below</span></i> completion_handler;
</code></p><div class='itemdescr'></div><div class='para' id='async.completion-4'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-4'>4</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>completion_handler_type&amp;</span> if <span class='texttt'>CompletionToken</span> and <span class='texttt'>completion_handler_type</span> are the same type; otherwise, <span class='texttt'>completion_handler_type</span>.
</p></div></div></div><div id='assoc.alloc'><h2 ><a class='secnum' href='#assoc.alloc' style='min-width:88pt'>13.5</a> Class template <span class='texttt'>associated_allocator</span> <a class='abbr_ref' href='async.assoc.alloc'>[async.assoc.alloc]</a></h2><p ><span class='indexparent'><a class='index' id='associated_allocator'></a></span></p><div class='para' id='assoc.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc-1'>1</a></div><p >Class template <span class='texttt'>associated_allocator</span> is an associator (<a href='async.reqmts.associator'>[async.reqmts.associator]</a>) for the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) type requirements, with default candidate type <span class='texttt'>allocator&lt;void&gt;</span> and default candidate object <span class='texttt'>allocator&lt;void&gt;()</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
  struct associated_allocator
  {
    using type = <i><span class='texttt'>see below</span></i>;

    static type get(const T&amp; t, const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='requirements,associated_allocator'></a></span></p></div><div class='para' id='assoc.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc-2'>2</a></div><p >Specializations of <span class='texttt'>associated_allocator</span> shall satisfy the requirements in Table <a href='#tab:async.assoc.alloc.requirements'>[tab:async.assoc.alloc.requirements]</a>.
In this table, <span class='texttt'>X</span> is a specialization of <span class='texttt'>associated_allocator</span>
for the template parameters <span class='texttt'>T</span> and <span class='texttt'>ProtoAllocator</span>;
<span class='texttt'>t</span> is a value of type <span class='texttt'>T</span> or <span class='texttt'>const T</span>;
and <span class='texttt'>a</span> is an object of type <span class='texttt'>ProtoAllocator</span>.</p><div class='numberedTable' id='tab:async.assoc.alloc.requirements'>Table <a href='#tab:async.assoc.alloc.requirements'>8</a> — <span class='texttt'>associated_allocator</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting the proto-allocator (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements.  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, ProtoAllocator())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, a)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div></div><div id='assoc.alloc.members'><h3 ><a class='secnum' href='#assoc.alloc.members' style='min-width:103pt'>13.5.1</a> <span class='texttt'>associated_allocator</span> members <a class='abbr_ref' href='async.assoc.alloc.members'>[async.assoc.alloc.members]</a></h3><p ><code class='itemdecl'>
using type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.alloc.members-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc.members-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::allocator_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>T::allocator_type</span>.
Otherwise <span class='texttt'>ProtoAllocator</span>.
</p></div></div><p ><code class='itemdecl'>
type get(const T&amp; t, const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.alloc.members-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::allocator_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>t.get_allocator()</span>.
Otherwise <span class='texttt'>a</span>.
</p></div></div></div></div><div id='assoc.alloc.get'><h2 ><a class='secnum' href='#assoc.alloc.get' style='min-width:88pt'>13.6</a> Function <span class='texttt'>get_associated_allocator</span> <a class='abbr_ref' href='async.assoc.alloc.get'>[async.assoc.alloc.get]</a></h2><p ><span class='indexparent'><a class='index' id='get_associated_allocator'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  associated_allocator_t&lt;T&gt; get_associated_allocator(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.alloc.get-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc.get-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T&gt;::get(t)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class ProtoAllocator&gt;
  associated_allocator_t&lt;T, ProtoAllocator&gt;
    get_associated_allocator(const T&amp; t, const ProtoAllocator&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.alloc.get-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.alloc.get-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T, ProtoAllocator&gt;::get(t, a)</span>.
</p></div></div></div><div id='exec.ctx'><h2 ><a class='secnum' href='#exec.ctx' style='min-width:88pt'>13.7</a> Class <span class='texttt'>execution_context</span> <a class='abbr_ref' href='async.exec.ctx'>[async.exec.ctx]</a></h2><p ><span class='indexparent'><a class='index' id='execution_context'></a></span></p><div class='para' id='exec.ctx-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx-1'>1</a></div><p >Class <span class='texttt'>execution_context</span> implements an extensible, type-safe, polymorphic set of services, indexed by service type.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context
  {
  public:
    class service;

    <span class='comment'>// construct / copy / destroy:
</span>
    execution_context();
    execution_context(const execution_context&amp;) = delete;
    execution_context&amp; operator=(const execution_context&amp;) = delete;
    virtual ~execution_context();

    <span class='comment'>// execution context operations:
</span>
    void notify_fork(fork_event e);

  protected:

    <span class='comment'>// execution context protected operations:
</span>
    void shutdown() noexcept;
    void destroy() noexcept;
  };

  <span class='comment'>// service access:
</span>  template&lt;class Service&gt; typename Service::key_type&amp;
    use_service(execution_context&amp; ctx);
  template&lt;class Service, class... Args&gt; Service&amp;
    make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
  template&lt;class Service&gt; bool has_service(const execution_context&amp; ctx) noexcept;
  class service_already_exists : public logic_error { };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='exec.ctx-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx-2'>2</a></div><p >Access to the services of an <span class='texttt'>execution_context</span> is via three function templates, <span class='texttt'>use_service&lt;&gt;</span>, <span class='texttt'>make_service&lt;&gt;</span> and <span class='texttt'>has_service&lt;&gt;</span>.</p></div><div class='para' id='exec.ctx-3'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx-3'>3</a></div><p >In a call to <span class='texttt'>use_service&lt;Service&gt;()</span>, the type argument chooses a service. If the service is not present in an <span class='texttt'>execution_context</span>, an object of type <span class='texttt'>Service</span> is created and added to the <span class='texttt'>execution_context</span>. A program can check if an <span class='texttt'>execution_context</span> implements a particular service with the function template <span class='texttt'>has_service&lt;Service&gt;()</span>.</p></div><div class='para' id='exec.ctx-4'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx-4'>4</a></div><p >Service objects may be explicitly added to an <span class='texttt'>execution_context</span> using the function template <span class='texttt'>make_service&lt;Service&gt;()</span>. If the service is already present, <span class='texttt'>make_service</span> exits via an exception of type <span class='texttt'>service_already_exists</span>.</p></div><div class='para' id='exec.ctx-5'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx-5'>5</a></div><p >Once a service reference is obtained from an <span class='texttt'>execution_context</span> object by calling <span class='texttt'>use_service&lt;&gt;</span>, that reference remains usable until a call to <span class='texttt'>destroy()</span>.</p></div><div id='exec.ctx.cons'><h3 ><a class='secnum' href='#exec.ctx.cons' style='min-width:103pt'>13.7.1</a> <span class='texttt'>execution_context</span> constructor <a class='abbr_ref' href='async.exec.ctx.cons'>[async.exec.ctx.cons]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context,constructor'></a></span><code class='itemdecl'>
execution_context();
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Creates an object of class <span class='texttt'>execution_context</span> which contains no services. [&nbsp;<i>Note:</i> An implementation might preload services of internal service types for its own use. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='exec.ctx.dtor'><h3 ><a class='secnum' href='#exec.ctx.dtor' style='min-width:103pt'>13.7.2</a> <span class='texttt'>execution_context</span> destructor <a class='abbr_ref' href='async.exec.ctx.dtor'>[async.exec.ctx.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context,destructor'></a></span><code class='itemdecl'>
~execution_context();
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys an object of class <span class='texttt'>execution_context</span>. Performs <span class='texttt'>shutdown()</span> followed by <span class='texttt'>destroy()</span>.
</p></div></div></div><div id='exec.ctx.ops'><h3 ><a class='secnum' href='#exec.ctx.ops' style='min-width:103pt'>13.7.3</a> <span class='texttt'>execution_context</span> operations <a class='abbr_ref' href='async.exec.ctx.ops'>[async.exec.ctx.ops]</a></h3><p ><span class='indexparent'><a class='index' id='notify_fork,execution_context'></a></span><span class='indexparent'><a class='index' id='execution_context,notify_fork'></a></span><code class='itemdecl'>
void notify_fork(fork_event e);
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> For each service object <span class='texttt'>svc</span> in the set:
</p><ul class='itemize'><li id='exec.ctx.ops-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#exec.ctx.ops-1.1'>(1.1)</a></div><p >If <span class='texttt'>e == fork_event::prepare</span>, performs <span class='texttt'>svc-&gt;notify_fork(e)</span> in reverse order of addition to the set.
</p></li><li id='exec.ctx.ops-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#exec.ctx.ops-1.2'>(1.2)</a></div><p >Otherwise, performs <span class='texttt'>svc-&gt;notify_fork(e)</span> in order of addition to the set.
</p></li></ul></div></div></div><div id='exec.ctx.protected'><h3 ><a class='secnum' href='#exec.ctx.protected' style='min-width:103pt'>13.7.4</a> <span class='texttt'>execution_context</span> protected operations <a class='abbr_ref' href='async.exec.ctx.protected'>[async.exec.ctx.protected]</a></h3><p ><span class='indexparent'><a class='index' id='shutdown,execution_context'></a></span><span class='indexparent'><a class='index' id='execution_context,shutdown'></a></span><code class='itemdecl'>
void shutdown() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.protected-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.protected-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> For each service object <span class='texttt'>svc</span> in the <span class='texttt'>execution_context</span> set, in reverse order of addition to the set, performs <span class='texttt'>svc-&gt;shutdown()</span>. For each service in the set, <span class='texttt'>svc-&gt;shutdown()</span> is called only once irrespective of the number of calls to <span class='texttt'>shutdown</span> on the <span class='texttt'>execution_context</span>.
</p></div></div><p ><code class='itemdecl'>
void destroy() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.protected-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.protected-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys each service object in the <span class='texttt'>execution_context</span> set, and removes it from the set, in reverse order of addition to the set.
</p></div></div></div><div id='exec.ctx.globals'><h3 ><a class='secnum' href='#exec.ctx.globals' style='min-width:103pt'>13.7.5</a> <span class='texttt'>execution_context</span> globals <a class='abbr_ref' href='async.exec.ctx.globals'>[async.exec.ctx.globals]</a></h3><div class='para' id='exec.ctx.globals-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-1'>1</a></div><p >The functions <span class='texttt'>use_service</span>, <span class='texttt'>make_service</span>, and <span class='texttt'>has_service</span> do not introduce data races as a result of concurrent calls to those functions from different threads.</p><p ><span class='indexparent'><a class='index' id='use_service'></a></span><code class='itemdecl'>
template&lt;class Service&gt; typename Service::key_type&amp;
  use_service(execution_context&amp; ctx);
</code></p></div><div class='itemdescr'></div><div class='para' id='exec.ctx.globals-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> If an object of type <span class='texttt'>Service::key_type</span> does not already exist in the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>, creates an object of type <span class='texttt'>Service</span>, initialized as <span class='texttt'>Service(ctx)</span>, and adds it to the set.</p></div></div><div class='para' id='exec.ctx.globals-3'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the corresponding service of <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='exec.ctx.globals-4'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-4'>4</a></div><div class='itemdescr'><p >Notes: The reference returned remains valid until a call to <span class='texttt'>destroy</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_service'></a></span><code class='itemdecl'>
template&lt;class Service, class... Args&gt; Service&amp;
  make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.globals-5'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> A service object of type <span class='texttt'>Service::key_type</span> does not already exist in the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='exec.ctx.globals-6'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Creates an object of type <span class='texttt'>Service</span>, initialized as <span class='texttt'>Service(ctx, forward&lt;Args&gt;(args)...)</span>, and adds it to the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='exec.ctx.globals-7'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>service_already_exists</span> if a corresponding service object of type <span class='texttt'>Key</span> is already present in the set.</p></div></div><div class='para' id='exec.ctx.globals-8'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-8'>8</a></div><div class='itemdescr'><p >Notes: The reference returned remains valid until a call to <span class='texttt'>destroy</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='has_service'></a></span><code class='itemdecl'>
template&lt;class Service&gt; bool has_service(const execution_context&amp; ctx) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.globals-9'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.globals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if an object of type <span class='texttt'>Service::key_type</span> is present in <span class='texttt'>ctx</span>, otherwise <span class='texttt'>false</span>.
</p></div></div></div></div><div id='exec.ctx.svc'><h2 ><a class='secnum' href='#exec.ctx.svc' style='min-width:88pt'>13.8</a> Class <span class='texttt'>execution_context::service</span> <a class='abbr_ref' href='async.exec.ctx.svc'>[async.exec.ctx.svc]</a></h2><p ><span class='indexparent'><a class='index' id='execution_context::service'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context::service
  {
  protected:
    <span class='comment'>// construct / copy / destroy:
</span>
    explicit service(execution_context&amp; owner);
    service(const service&amp;) = delete;
    service&amp; operator=(const service&amp;) = delete;
    virtual ~service();

    <span class='comment'>// service observers:
</span>
    execution_context&amp; context() noexcept;

  private:
    <span class='comment'>// service operations:
</span>
    virtual void shutdown() noexcept = 0;
    virtual void notify_fork(fork_event e) {}

    execution_context&amp; context_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='execution_context::service,constructor'></a></span><code class='itemdecl'>
explicit service(execution_context&amp; owner);
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.svc-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.svc-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>std::addressof(context_) == std::addressof(owner)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='context,execution_context::service'></a></span><span class='indexparent'><a class='index' id='execution_context::service,context'></a></span><code class='itemdecl'>
execution_context&amp; context() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.ctx.svc-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.ctx.svc-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>context_</span>.
</p></div></div></div><div id='is.exec'><h2 ><a class='secnum' href='#is.exec' style='min-width:88pt'>13.9</a> Class template <span class='texttt'>is_executor</span> <a class='abbr_ref' href='async.is.exec'>[async.is.exec]</a></h2><p ><span class='indexparent'><a class='index' id='is_executor'></a></span></p><div class='para' id='is.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#is.exec-1'>1</a></div><p >The class template <span class='texttt'>is_executor</span> can be used to detect executor types satisfying the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T&gt; struct is_executor;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='is.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#is.exec-2'>2</a></div><p ><span class='texttt'>T</span> shall be a complete type.</p></div><div class='para' id='is.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#is.exec-3'>3</a></div><p >Class template <span class='texttt'>is_executor</span> is a UnaryTypeTrait (C++Std &sect;<a href='../n4140/meta.rqmts'>[meta.rqmts]</a>) with a BaseCharacteristic of <span class='texttt'>true_type</span> if the type <span class='texttt'>T</span> meets the syntactic requirements for <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), otherwise <span class='texttt'>false_type</span>.</p></div></div><div id='executor.arg'><h2 ><a class='secnum' href='#executor.arg' style='min-width:88pt'>13.10</a> Executor argument tag <a class='abbr_ref' href='async.executor.arg'>[async.executor.arg]</a></h2><p ><span class='indexparent'><a class='index' id='executor_arg_t'></a></span><span class='indexparent'><a class='index' id='executor_arg'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  struct executor_arg_t { };
  constexpr executor_arg_t executor_arg = executor_arg_t();

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='executor.arg-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.arg-1'>1</a></div><p >The <span class='texttt'>executor_arg_t</span> struct is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, types may have constructors with <span class='texttt'>executor_arg_t</span> as the first argument, immediately followed by an argument of a type that satisfies the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p></div></div><div id='uses.executor'><h2 ><a class='secnum' href='#uses.executor' style='min-width:88pt'>13.11</a> <span class='texttt'>uses_executor</span> <a class='abbr_ref' href='async.uses.executor'>[async.uses.executor]</a></h2><div id='uses.executor.trait'><h3 ><a class='secnum' href='#uses.executor.trait' style='min-width:103pt'>13.11.1</a> <span class='texttt'>uses_executor</span> trait <a class='abbr_ref' href='async.uses.executor.trait'>[async.uses.executor.trait]</a></h3><p ><span class='indexparent'><a class='index' id='uses_executor'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor&gt; struct uses_executor;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='uses.executor.trait-1'><div class='marginalizedparent'><a class='marginalized' href='#uses.executor.trait-1'>1</a></div><p >Remark: Detects whether <span class='texttt'>T</span> has a nested <span class='texttt'>executor_type</span> that is convertible from <span class='texttt'>Executor</span>. Meets the <span class='texttt'>BinaryTypeTrait</span> requirements (C++Std &sect;<a href='../n4140/meta.rqmts'>[meta.rqmts]</a>). The implementation provides a definition that is derived from <span class='texttt'>true_type</span> if a type <span class='texttt'>T::executor_type</span> exists and <span class='texttt'>is_convertible&lt;Executor, T::executor_type&gt;::value != false</span>, otherwise it is derived from <span class='texttt'>false_type</span>. A program may specialize this template to derive from <span class='texttt'>true_type</span> for a user-defined type <span class='texttt'>T</span> that does not have a nested <span class='texttt'>executor_type</span> but nonetheless can be constructed with an executor if the first argument of a constructor has type <span class='texttt'>executor_arg_t</span> and the second argument has type <span class='texttt'>Executor</span>.</p></div></div><div id='uses.executor.cons'><h3 ><a class='secnum' href='#uses.executor.cons' style='min-width:103pt'>13.11.2</a> uses-executor construction <a class='abbr_ref' href='async.uses.executor.cons'>[async.uses.executor.cons]</a></h3><p ><span class='indexparent'><a class='index' id='uses-executor_construction'></a></span></p><div class='para' id='uses.executor.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#uses.executor.cons-1'>1</a></div><p >Uses-executor construction with executor <span class='texttt'>Executor</span> refers to the construction of an object <span class='texttt'>obj</span> of type <span class='texttt'>T</span>, using constructor arguments <span class='texttt'>v1, v2, ..., vN</span> of types <span class='texttt'>V1, V2, ..., VN</span>, respectively, and an executor <span class='texttt'>ex</span> of type <span class='texttt'>Executor</span>, according to the following rules:</p><ul class='itemize'><li id='uses.executor.cons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#uses.executor.cons-1.1'>(1.1)</a></div><p >if <span class='texttt'>uses_executor_v&lt;T, Executor&gt;</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;T, executor_arg_t, Executor, V1, V2, ..., VN&gt;::value</span> is <span class='texttt'>true</span>,
then <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(executor_arg, ex, v1, v2, ..., vN)</span>;</p></li><li id='uses.executor.cons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#uses.executor.cons-1.2'>(1.2)</a></div><p >otherwise, <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(v1, v2, ..., vN)</span>.
</p></li></ul></div></div></div><div id='assoc.exec'><h2 ><a class='secnum' href='#assoc.exec' style='min-width:88pt'>13.12</a> Class template <span class='texttt'>associated_executor</span> <a class='abbr_ref' href='async.assoc.exec'>[async.assoc.exec]</a></h2><p ><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><div class='para' id='assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec-1'>1</a></div><p >Class template <span class='texttt'>associated_executor</span> is an associator (<a href='async.reqmts.associator'>[async.reqmts.associator]</a>) for the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements, with default candidate type <span class='texttt'>system_executor</span> and default candidate object <span class='texttt'>system_executor()</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor = system_executor&gt;
  struct associated_executor
  {
    using type = <i><span class='texttt'>see below</span></i>;

    static type get(const T&amp; t, const Executor&amp; e = Executor()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='requirements,associated_executor'></a></span></p></div><div class='para' id='assoc.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec-2'>2</a></div><p >Specializations of <span class='texttt'>associated_executor</span> shall satisfy the requirements in Table <a href='#tab:async.assoc.exec.requirements'>[tab:async.assoc.exec.requirements]</a>.
In this table, <span class='texttt'>X</span> is a specialization of <span class='texttt'>associated_executor</span>
for the template parameters <span class='texttt'>T</span> and <span class='texttt'>Executor</span>;
<span class='texttt'>t</span> is a value of <span class='texttt'>T</span> or <span class='texttt'>const T</span>;
and <span class='texttt'>e</span> is an object of type <span class='texttt'>Executor</span>.</p><div class='numberedTable' id='tab:async.assoc.exec.requirements'>Table <a href='#tab:async.assoc.exec.requirements'>9</a> — <span class='texttt'>associated_executor</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, Executor())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, e)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div></div><div id='assoc.exec.members'><h3 ><a class='secnum' href='#assoc.exec.members' style='min-width:103pt'>13.12.1</a> <span class='texttt'>associated_executor</span> members <a class='abbr_ref' href='async.assoc.exec.members'>[async.assoc.exec.members]</a></h3><p ><code class='itemdecl'>
using type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.exec.members-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.members-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::executor_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>T::executor_type</span>.
Otherwise <span class='texttt'>Executor</span>.
</p></div></div><p ><code class='itemdecl'>
type get(const T&amp; t, const Executor&amp; e = Executor()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.exec.members-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::executor_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>t.get_executor()</span>.
Otherwise <span class='texttt'>e</span>.
</p></div></div></div></div><div id='assoc.exec.get'><h2 ><a class='secnum' href='#assoc.exec.get' style='min-width:88pt'>13.13</a> Function <span class='texttt'>get_associated_executor</span> <a class='abbr_ref' href='async.assoc.exec.get'>[async.assoc.exec.get]</a></h2><p ><span class='indexparent'><a class='index' id='get_associated_executor'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  associated_executor_t&lt;T&gt; get_associated_executor(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.exec.get-1'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.get-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_executor&lt;T&gt;::get(t)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class Executor&gt;
  associated_executor_t&lt;T, Executor&gt;
    get_associated_executor(const T&amp; t, const Executor&amp; ex) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.exec.get-2'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.get-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_executor&lt;T, Executor&gt;::get(t, ex)</span>.</p></div></div><div class='para' id='assoc.exec.get-3'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.get-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class ExecutionContext&gt;
  associated_executor_t&lt;T, typename ExecutionContext::executor_type&gt;
    get_associated_executor(const T&amp; t, ExecutionContext&amp; ctx) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='assoc.exec.get-4'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.get-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get_associated_executor(t, ctx.get_executor())</span>.</p></div></div><div class='para' id='assoc.exec.get-5'><div class='marginalizedparent'><a class='marginalized' href='#assoc.exec.get-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='exec.binder'><h2 ><a class='secnum' href='#exec.binder' style='min-width:88pt'>13.14</a> Class template <span class='texttt'>executor_binder</span> <a class='abbr_ref' href='async.exec.binder'>[async.exec.binder]</a></h2><p ><span class='indexparent'><a class='index' id='executor_binder'></a></span></p><div class='para' id='exec.binder-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder-1'>1</a></div><p >The class template <span class='texttt'>executor_binder</span> binds executors to objects.
A specialization <span class='texttt'>executor_binder&lt;T, Executor&gt;</span> binds
an executor of type <span class='texttt'>Executor</span> satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>)
to an object or function of type <span class='texttt'>T</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor&gt;
  class executor_binder
  {
  public:
    <span class='comment'>// types:
</span>
    using target_type = T;
    using executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    executor_binder(T t, const Executor&amp; ex);
    executor_binder(const executor_binder&amp; other) = default;
    executor_binder(executor_binder&amp;&amp; other) = default;
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_arg_t, const Executor&amp; ex,
        const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_arg_t, const Executor&amp; ex,
        executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);

    ~executor_binder();

    <span class='comment'>// executor binder access:
</span>
    T&amp; get() noexcept;
    const T&amp; get() const noexcept;
    executor_type get_executor() const noexcept;

    <span class='comment'>// executor binder invocation:
</span>
    template&lt;class... Args&gt;
      result_of_t&lt;T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      result_of_t&lt;const T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args) const;

  private:
    Executor ex_; <span class='comment'>// <i>exposition only</i>
</span>    T target_; <span class='comment'>// <i>exposition only</i>
</span>  };

  template&lt;class T, class Executor, class Signature&gt;
    class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;;

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;;

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='exec.binder.cons'><h3 ><a class='secnum' href='#exec.binder.cons' style='min-width:103pt'>13.14.1</a> <span class='texttt'>executor_binder</span> constructors <a class='abbr_ref' href='async.exec.binder.cons'>[async.exec.binder.cons]</a></h3><p ><span class='indexparent'><a class='index' id='executor_binder,constructor'></a></span><code class='itemdecl'>
executor_binder(T t, const Executor&amp; ex);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(t)</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span>, or if <span class='texttt'>OtherExecutor</span> is not convertible to <span class='texttt'>Executor</span>, the program is ill-formed.</p></div></div><div class='para' id='exec.binder.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.get_executor()</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>other.get()</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span>, or if <span class='texttt'>OtherExecutor</span> is not convertible to <span class='texttt'>Executor</span>, the program is ill-formed.</p></div></div><div class='para' id='exec.binder.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.get_executor()</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(other.get())</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_arg_t, const Executor&amp; ex,
    const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span> the program is ill-formed.</p></div></div><div class='para' id='exec.binder.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>other.get()</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_arg_t, const Executor&amp; ex,
    executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>U</span> is <span class='texttt'>T</span> or convertible to <span class='texttt'>T</span>.</p></div></div><div class='para' id='exec.binder.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(other.get())</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div></div><div id='exec.binder.access'><h3 ><a class='secnum' href='#exec.binder.access' style='min-width:103pt'>13.14.2</a> <span class='texttt'>executor_binder</span> access <a class='abbr_ref' href='async.exec.binder.access'>[async.exec.binder.access]</a></h3><p ><span class='indexparent'><a class='index' id='get,executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,get'></a></span><code class='itemdecl'>
T&amp; get() noexcept;
const T&amp; get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.access-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.access-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_</span>.
</p></div></div></div><div id='exec.binder.invocation'><h3 ><a class='secnum' href='#exec.binder.invocation' style='min-width:103pt'>13.14.3</a> <span class='texttt'>executor_binder</span> invocation <a class='abbr_ref' href='async.exec.binder.invocation'>[async.exec.binder.invocation]</a></h3><p ><span class='indexparent'><a class='index' id='operator(),executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,operator()'></a></span><code class='itemdecl'>
template&lt;class... Args&gt;
  result_of_t&lt;T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args);
template&lt;class... Args&gt;
  result_of_t&lt;const T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args) const;
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.invocation-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.invocation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'><i>INVOKE</i>(get(), forward&lt;Args&gt;(args)...)</span> (C++Std &sect;<a href='../n4140/func.require'>[func.require]</a>).
</p></div></div></div><div id='exec.binder.async.result'><h3 ><a class='secnum' href='#exec.binder.async.result' style='min-width:103pt'>13.14.4</a> Class template partial specialization <span class='texttt'>async_result</span> <a class='abbr_ref' href='async.exec.binder.async.result'>[async.exec.binder.async.result]</a></h3><p ><span class='indexparent'><a class='index' id='async_result,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='async_result'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class Signature&gt;
  class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;
  {
  public:
    using completion_handler_type = executor_binder&lt;
      typename async_result&lt;T, Signature&gt;::completion_handler_type,
        Executor&gt;;
    using return_type = typename async_result&lt;T, Signature&gt;::return_type;

    explicit async_result(completion_handler_type&amp; h);
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get();

  private:
    async_result&lt;T, Signature&gt; target_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
explicit async_result(completion_handler_type&amp; h);
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.async.result-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.async.result-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>target_</span> as <span class='texttt'>target_(h.get())</span>.
</p></div></div><p ><code class='itemdecl'>
return_type get();
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.async.result-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.async.result-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target_.get()</span>.
</p></div></div></div><div id='exec.binder.assoc.alloc'><h3 ><a class='secnum' href='#exec.binder.assoc.alloc' style='min-width:103pt'>13.14.5</a> Class template partial specialization <span class='texttt'>associated_allocator</span> <a class='abbr_ref' href='async.exec.binder.assoc.alloc'>[async.exec.binder.assoc.alloc]</a></h3><p ><span class='indexparent'><a class='index' id='associated_allocator,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='associated_allocator'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;
  {
    using type = associated_allocator_t&lt;T, ProtoAllocator&gt;;

    static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                    const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.assoc.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.assoc.alloc-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T, ProtoAllocator&gt;::get(b.get(), a)</span>.
</p></div></div></div><div id='exec.binder.assoc.exec'><h3 ><a class='secnum' href='#exec.binder.assoc.exec' style='min-width:103pt'>13.14.6</a> Class template partial specialization <span class='texttt'>associated_executor</span> <a class='abbr_ref' href='async.exec.binder.assoc.exec'>[async.exec.binder.assoc.exec]</a></h3><p ><span class='indexparent'><a class='index' id='associated_executor,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;
  {
    using type = Executor;

    static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                    const Executor1&amp; e = Executor1()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                const Executor1&amp; e = Executor1()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.binder.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.binder.assoc.exec-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b.get_executor()</span>.
</p></div></div></div></div><div id='bind.executor'><h2 ><a class='secnum' href='#bind.executor' style='min-width:88pt'>13.15</a> Function <span class='texttt'>bind_executor</span> <a class='abbr_ref' href='async.bind.executor'>[async.bind.executor]</a></h2><p ><span class='indexparent'><a class='index' id='bind_executor'></a></span><code class='itemdecl'>
template&lt;class Executor, class T&gt;
  executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;
    bind_executor(const Executor&amp; ex, T&amp;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='bind.executor-1'><div class='marginalizedparent'><a class='marginalized' href='#bind.executor-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;(forward&lt;T&gt;(t), ex)</span>.</p></div></div><div class='para' id='bind.executor-2'><div class='marginalizedparent'><a class='marginalized' href='#bind.executor-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bind_executor'></a></span><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  executor_binder&lt;decay_t&lt;T&gt;, typename ExecutionContext::executor_type&gt;
    bind_executor(ExecutionContext&amp; ctx, T&amp;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='bind.executor-3'><div class='marginalizedparent'><a class='marginalized' href='#bind.executor-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>bind_executor(ctx.get_executor(), forward&lt;T&gt;(t))</span>.</p></div></div><div class='para' id='bind.executor-4'><div class='marginalizedparent'><a class='marginalized' href='#bind.executor-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='exec.work.guard'><h2 ><a class='secnum' href='#exec.work.guard' style='min-width:88pt'>13.16</a> Class template <span class='texttt'>executor_work_guard</span> <a class='abbr_ref' href='async.exec.work.guard'>[async.exec.work.guard]</a></h2><p ><span class='indexparent'><a class='index' id='executor_work_guard'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Executor&gt;
  class executor_work_guard
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit executor_work_guard(const executor_type&amp; ex) noexcept;
    executor_work_guard(const executor_work_guard&amp; other) noexcept;
    executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;

    executor_work_guard&amp; operator=(const executor_work_guard&amp;) = delete;

    ~executor_work_guard();

    <span class='comment'>// executor work guard observers:
</span>
    executor_type get_executor() const noexcept;
    bool owns_work() const noexcept;

    <span class='comment'>// executor work guard modifiers:
</span>
    void reset() noexcept;

  private:
    Executor ex_; <span class='comment'>// <i>exposition only</i>
</span>    bool owns_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div id='exec.work.guard.members'><h3 ><a class='secnum' href='#exec.work.guard.members' style='min-width:103pt'>13.16.1</a> <span class='texttt'>executor_work_guard</span> members <a class='abbr_ref' href='async.exec.work.guard.members'>[async.exec.work.guard.members]</a></h3><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
explicit executor_work_guard(const executor_type&amp; ex) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-1'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>, and then performs <span class='texttt'>ex_.on_work_started()</span>.</p></div></div><div class='para' id='exec.work.guard.members-2'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ex_ == ex</span> and <span class='texttt'>owns_ == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
executor_work_guard(const executor_work_guard&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-3'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.ex_</span>. If <span class='texttt'>other.owns_ == true</span>, performs <span class='texttt'>ex_.on_work_started()</span>.</p></div></div><div class='para' id='exec.work.guard.members-4'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ex_ == other.ex_</span> and <span class='texttt'>owns_ == other.owns_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-5'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>std::move(other.ex_)</span>
and initializes <span class='texttt'>owns_</span> with <span class='texttt'>other.owns_</span>,
and sets <span class='texttt'>other.owns_</span> to <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,destructor'></a></span><code class='itemdecl'>
~executor_work_guard();
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-6'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns_</span> is <span class='texttt'>true</span>, performs <span class='texttt'>ex_.on_work_finished()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-7'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ex_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='owns_work,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,owns_work'></a></span><code class='itemdecl'>
bool owns_work() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-8'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,reset'></a></span><code class='itemdecl'>
void reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='exec.work.guard.members-9'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns_</span> is <span class='texttt'>true</span>, performs <span class='texttt'>ex_.on_work_finished()</span>.</p></div></div><div class='para' id='exec.work.guard.members-10'><div class='marginalizedparent'><a class='marginalized' href='#exec.work.guard.members-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns_ == false</span>.
</p></div></div></div></div><div id='make.work.guard'><h2 ><a class='secnum' href='#make.work.guard' style='min-width:88pt'>13.17</a> Function <span class='texttt'>make_work_guard</span> <a class='abbr_ref' href='async.make.work.guard'>[async.make.work.guard]</a></h2><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class Executor&gt;
  executor_work_guard&lt;Executor&gt;
    make_work_guard(const Executor&amp; ex);
</code></p><div class='itemdescr'></div><div class='para' id='make.work.guard-1'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_work_guard&lt;Executor&gt;(ex)</span>.</p></div></div><div class='para' id='make.work.guard-2'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class ExecutionContext&gt;
  executor_work_guard&lt;typename ExecutionContext::executor_type&gt;
    make_work_guard(ExecutionContext&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='make.work.guard-3'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(ctx.get_executor())</span>.</p></div></div><div class='para' id='make.work.guard-4'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  executor_work_guard&lt;associated_executor_t&lt;T&gt;&gt;
    make_work_guard(const T&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='make.work.guard-5'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(get_associated_executor(t))</span>.</p></div></div><div class='para' id='make.work.guard-6'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;T&gt;</span> is <span class='texttt'>false</span>
and <span class='texttt'>is_convertible&lt;T&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt;
  auto make_work_guard(const T&amp; t, U&amp;&amp; u)
    -&gt; decltype(make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u))));
</code></p><div class='itemdescr'></div><div class='para' id='make.work.guard-7'><div class='marginalizedparent'><a class='marginalized' href='#make.work.guard-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u)))</span>.
</p></div></div></div><div id='system.exec'><h2 ><a class='secnum' href='#system.exec' style='min-width:88pt'>13.18</a> Class <span class='texttt'>system_executor</span> <a class='abbr_ref' href='async.system.exec'>[async.system.exec]</a></h2><p ><span class='indexparent'><a class='index' id='system_executor'></a></span></p><div class='para' id='system.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#system.exec-1'>1</a></div><p >Class <span class='texttt'>system_executor</span> represents a set of rules where function objects are permitted to execute on any thread.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class system_executor
  {
  public:
    <span class='comment'>// constructors:
</span>
    system_executor() {}

    <span class='comment'>// executor operations:
</span>
    system_context&amp; context() const noexcept;

    void on_work_started() const noexcept {}
    void on_work_finished() const noexcept {}

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
  };

  bool operator==(const system_executor&amp;, const system_executor&amp;) noexcept;
  bool operator!=(const system_executor&amp;, const system_executor&amp;) noexcept;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='system.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#system.exec-2'>2</a></div><p >Class <span class='texttt'>system_executor</span> satisfies the <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements.</p></div><div class='para' id='system.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#system.exec-3'>3</a></div><p >To satisfy the <span class='texttt'>Executor</span> requirements for the <span class='texttt'>post</span> and <span class='texttt'>defer</span> member functions, the system executor may create <span class='texttt'>thread</span> objects to run the submitted function objects. These <span class='texttt'>thread</span> objects are collectively referred to as system threads.</p></div><div id='system.exec.ops'><h3 ><a class='secnum' href='#system.exec.ops' style='min-width:103pt'>13.18.1</a> <span class='texttt'>system_executor</span> operations <a class='abbr_ref' href='async.system.exec.ops'>[async.system.exec.ops]</a></h3><p ><span class='indexparent'><a class='index' id='context,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,context'></a></span><code class='itemdecl'>
system_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='system.exec.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#system.exec.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object with static storage duration. All calls to this function return references to the same object.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='system.exec.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#system.exec.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='post,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,post'></a></span><span class='indexparent'><a class='index' id='defer,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='system.exec.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#system.exec.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>context().stopped() == false</span>, creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span>, and calls <span class='texttt'>f1</span> as if in a thread of execution represented by a <span class='texttt'>thread</span> object. Any exception propagated from the execution of <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> results in a call to <span class='texttt'>std::terminate</span>.
</p></div></div></div><div id='system.exec.comparisons'><h3 ><a class='secnum' href='#system.exec.comparisons' style='min-width:103pt'>13.18.2</a> <span class='texttt'>system_executor</span> comparisons <a class='abbr_ref' href='async.system.exec.comparisons'>[async.system.exec.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const system_executor&amp;, const system_executor&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='system.exec.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#system.exec.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const system_executor&amp;, const system_executor&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='system.exec.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#system.exec.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>false</span>.
</p></div></div></div></div><div id='system.context'><h2 ><a class='secnum' href='#system.context' style='min-width:88pt'>13.19</a> Class <span class='texttt'>system_context</span> <a class='abbr_ref' href='async.system.context'>[async.system.context]</a></h2><p ><span class='indexparent'><a class='index' id='system_context'></a></span></p><div class='para' id='system.context-1'><div class='marginalizedparent'><a class='marginalized' href='#system.context-1'>1</a></div><p >Class <span class='texttt'>system_context</span> implements the execution context associated with <span class='texttt'>system_executor</span> objects.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class system_context : public execution_context
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = system_executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    system_context() = delete;
    system_context(const system_context&amp;) = delete;
    system_context&amp; operator=(const system_context&amp;) = delete;
    ~system_context();

    <span class='comment'>// system_context operations:
</span>
    executor_type get_executor() noexcept;

    void stop();
    bool stopped() const noexcept;
    void join();
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='system.context-2'><div class='marginalizedparent'><a class='marginalized' href='#system.context-2'>2</a></div><p >The class <span class='texttt'>system_context</span> satisfies the <span class='texttt'>ExecutionContext</span> (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) type requirements.</p></div><div class='para' id='system.context-3'><div class='marginalizedparent'><a class='marginalized' href='#system.context-3'>3</a></div><p >The <span class='texttt'>system_context</span> member functions <span class='texttt'>get_executor</span>, <span class='texttt'>stop</span>, and <span class='texttt'>stopped</span>, and the <span class='texttt'>system_executor</span> copy constructors, member functions and comparison operators, do not introduce data races as a result of concurrent calls to those functions from different threads of execution.</p><p ><span class='indexparent'><a class='index' id='system_context,destructor'></a></span><code class='itemdecl'>
~system_context();
</code></p></div><div class='itemdescr'></div><div class='para' id='system.context-4'><div class='marginalizedparent'><a class='marginalized' href='#system.context-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>stop()</span> followed by <span class='texttt'>join()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='system.context-5'><div class='marginalizedparent'><a class='marginalized' href='#system.context-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>system_executor()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='stop,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,stop'></a></span><code class='itemdecl'>
void stop();
</code></p><div class='itemdescr'></div><div class='para' id='system.context-6'><div class='marginalizedparent'><a class='marginalized' href='#system.context-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Signals all system threads to exit as soon as possible. If a system thread is currently executing a function object, the thread will exit only after completion of that function object. Returns without waiting for the system threads to complete.</p></div></div><div class='para' id='system.context-7'><div class='marginalizedparent'><a class='marginalized' href='#system.context-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>stopped() == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='stopped,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,stopped'></a></span><code class='itemdecl'>
bool stopped() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='system.context-8'><div class='marginalizedparent'><a class='marginalized' href='#system.context-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the <span class='texttt'>system_context</span> has been stopped by a prior call to <span class='texttt'>stop</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='join,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,join'></a></span><code class='itemdecl'>
void join();
</code></p><div class='itemdescr'></div><div class='para' id='system.context-9'><div class='marginalizedparent'><a class='marginalized' href='#system.context-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) until all system threads have completed.</p></div></div><div class='para' id='system.context-10'><div class='marginalizedparent'><a class='marginalized' href='#system.context-10'>10</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of each system thread synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the corresponding successful <span class='texttt'>join()</span> return.
</p></div></div></div><div id='bad.exec'><h2 ><a class='secnum' href='#bad.exec' style='min-width:88pt'>13.20</a> Class <span class='texttt'>bad_executor</span> <a class='abbr_ref' href='async.bad.exec'>[async.bad.exec]</a></h2><p ><span class='indexparent'><a class='index' id='bad_executor'></a></span></p><div class='para' id='bad.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#bad.exec-1'>1</a></div><p >An exception of type <span class='texttt'>bad_executor</span> is thrown by <span class='texttt'>executor</span> member functions <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, and <span class='texttt'>defer</span> when the executor object has no target.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class bad_executor : public exception
  {
  public:
    <span class='comment'>// constructor:
</span>    bad_executor() noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
bad_executor() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='bad.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#bad.exec-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_executor</span> object.</p></div></div><div class='para' id='bad.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#bad.exec-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>what()</span> returns an <span class='indexparent'><a class='index' id='result_of_bad_executor::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.
</p></div></div></div><div id='executor'><h2 ><a class='secnum' href='#executor' style='min-width:88pt'>13.21</a> Class <span class='texttt'>executor</span> <a class='abbr_ref' href='async.executor'>[async.executor]</a></h2><p ><span class='indexparent'><a class='index' id='executor'></a></span></p><div class='para' id='executor-1'><div class='marginalizedparent'><a class='marginalized' href='#executor-1'>1</a></div><p >The <span class='texttt'>executor</span> class provides a polymorphic wrapper for types that satisfy the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class executor
  {
  public:
    <span class='comment'>// construct / copy / destroy:
</span>
    executor() noexcept;
    executor(nullptr_t) noexcept;
    executor(const executor&amp; e) noexcept;
    executor(executor&amp;&amp; e) noexcept;
    template&lt;class Executor&gt; executor(Executor e);
    template&lt;class Executor, class ProtoAllocator&gt;
      executor(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);

    executor&amp; operator=(const executor&amp; e) noexcept;
    executor&amp; operator=(executor&amp;&amp; e) noexcept;
    executor&amp; operator=(nullptr_t) noexcept;
    template&lt;class Executor&gt; executor&amp; operator=(Executor e);

    ~executor();

    <span class='comment'>// executor modifiers:
</span>
    void swap(executor&amp; other) noexcept;
    template&lt;class Executor, class ProtoAllocator&gt;
      void assign(Executor e, const ProtoAllocator&amp; a);

    <span class='comment'>// executor operations:
</span>
    execution_context&amp; context() const noexcept;

    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;

    <span class='comment'>// executor capacity:
</span>
    explicit operator bool() const noexcept;

    <span class='comment'>// executor target access:
</span>
    const type_info&amp; target_type() const noexcept;
    template&lt;class Executor&gt; Executor* target() noexcept;
    template&lt;class Executor&gt; const Executor* target() const noexcept;
  };

  <span class='comment'>// executor comparisons:
</span>
  bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator==(const executor&amp; e, nullptr_t) noexcept;
  bool operator==(nullptr_t, const executor&amp; e) noexcept;
  bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator!=(const executor&amp; e, nullptr_t) noexcept;
  bool operator!=(nullptr_t, const executor&amp; e) noexcept;

  <span class='comment'>// executor specialized algorithms:
</span>
  void swap(executor&amp; a, executor&amp; b) noexcept;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;class Allocator&gt;
    struct uses_allocator&lt;experimental::net::v1::executor, Allocator&gt;
      : true_type {};

} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='executor-2'><div class='marginalizedparent'><a class='marginalized' href='#executor-2'>2</a></div><p >Class <span class='texttt'>executor</span> meets the requirements of <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div class='para' id='executor-3'><div class='marginalizedparent'><a class='marginalized' href='#executor-3'>3</a></div><p >[&nbsp;<i>Note:</i> To meet the <span class='texttt'>noexcept</span> requirements for executor copy constructors and move constructors, implementations may share a target between two or more <span class='texttt'>executor</span> objects. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='executor-4'><div class='marginalizedparent'><a class='marginalized' href='#executor-4'>4</a></div><p >The <a class='hidden_link' href='#def:target,executor' id='def:target,executor'><i>target</i></a> is the executor object that is held by the wrapper.</p></div><div id='executor.cons'><h3 ><a class='secnum' href='#executor.cons' style='min-width:103pt'>13.21.1</a> <span class='texttt'>executor</span> constructors <a class='abbr_ref' href='async.executor.cons'>[async.executor.cons]</a></h3><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if <span class='texttt'>!e</span>; otherwise, <span class='texttt'>*this</span> targets <span class='texttt'>e.target()</span> or a copy of <span class='texttt'>e.target()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(executor&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>!e</span>, <span class='texttt'>*this</span> has no target; otherwise, moves <span class='texttt'>e.target()</span> or move-constructs the target of <span class='texttt'>e</span> into the target of <span class='texttt'>*this</span>, leaving <span class='texttt'>e</span> in a valid state with an unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
template&lt;class Executor&gt; executor(Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> targets a copy of <span class='texttt'>e</span> initialized with <span class='texttt'>std::move(e)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
template&lt;class Executor, class ProtoAllocator&gt;
  executor(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='executor.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> targets a copy of <span class='texttt'>e</span> initialized with <span class='texttt'>std::move(e)</span>.</p></div></div><div class='para' id='executor.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#executor.cons-7'>7</a></div><div class='itemdescr'><p >A copy of the allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed <span class='texttt'>executor</span> object.
</p></div></div></div><div id='executor.assign'><h3 ><a class='secnum' href='#executor.assign' style='min-width:103pt'>13.21.2</a> <span class='texttt'>executor</span> assignment <a class='abbr_ref' href='async.executor.assign'>[async.executor.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(e).swap(*this)</span>.</p></div></div><div class='para' id='executor.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(executor&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Replaces the target of <span class='texttt'>*this</span> with the target of <span class='texttt'>e</span>, leaving <span class='texttt'>e</span> in a valid state with an unspecified value.</p></div></div><div class='para' id='executor.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(nullptr).swap(*this)</span>.</p></div></div><div class='para' id='executor.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
template&lt;class Executor&gt; executor&amp; operator=(Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='executor.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(std::move(e)).swap(*this)</span>.</p></div></div><div class='para' id='executor.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#executor.assign-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='executor.dtor'><h3 ><a class='secnum' href='#executor.dtor' style='min-width:103pt'>13.21.3</a> <span class='texttt'>executor</span> destructor <a class='abbr_ref' href='async.executor.dtor'>[async.executor.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='executor,destructor'></a></span><code class='itemdecl'>
~executor();
</code></p><div class='itemdescr'></div><div class='para' id='executor.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, releases shared ownership of, or destroys, the target of <span class='texttt'>*this</span>.
</p></div></div></div><div id='executor.modifiers'><h3 ><a class='secnum' href='#executor.modifiers' style='min-width:103pt'>13.21.4</a> <span class='texttt'>executor</span> modifiers <a class='abbr_ref' href='async.executor.modifiers'>[async.executor.modifiers]</a></h3><p ><span class='indexparent'><a class='index' id='swap,executor'></a></span><span class='indexparent'><a class='index' id='executor,swap'></a></span><code class='itemdecl'>
void swap(executor&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Interchanges the targets of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='assign,executor'></a></span><span class='indexparent'><a class='index' id='executor,assign'></a></span><code class='itemdecl'>
template&lt;class Executor, class ProtoAllocator&gt;
  void assign(Executor e, const ProtoAllocator&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='executor.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(allocator_arg, a, std::move(e)).swap(*this)</span>.
</p></div></div></div><div id='executor.ops'><h3 ><a class='secnum' href='#executor.ops' style='min-width:103pt'>13.21.5</a> <span class='texttt'>executor</span> operations <a class='abbr_ref' href='async.executor.ops'>[async.executor.ops]</a></h3><p ><span class='indexparent'><a class='index' id='context,executor'></a></span><span class='indexparent'><a class='index' id='executor,context'></a></span><code class='itemdecl'>
execution_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='executor.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>e.context()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_started,executor'></a></span><span class='indexparent'><a class='index' id='executor,on_work_started'></a></span><code class='itemdecl'>
void on_work_started() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='executor.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.on_work_started()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_finished,executor'></a></span><span class='indexparent'><a class='index' id='executor,on_work_finished'></a></span><code class='itemdecl'>
void on_work_finished() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='executor.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.on_work_finished()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,executor'></a></span><span class='indexparent'><a class='index' id='executor,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-7'>7</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>).</p></div></div><div class='para' id='executor.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.dispatch(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='post,executor'></a></span><span class='indexparent'><a class='index' id='executor,post'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-9'>9</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span>.</p></div></div><div class='para' id='executor.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.post(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='defer,executor'></a></span><span class='indexparent'><a class='index' id='executor,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='executor.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-11'>11</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span>.</p></div></div><div class='para' id='executor.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#executor.ops-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.defer(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div></div><div id='executor.capacity'><h3 ><a class='secnum' href='#executor.capacity' style='min-width:103pt'>13.21.6</a> <span class='texttt'>executor</span> capacity <a class='abbr_ref' href='async.executor.capacity'>[async.executor.capacity]</a></h3><p ><span class='indexparent'><a class='index' id='operator_bool,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.capacity-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> has a target, otherwise <span class='texttt'>false</span>.
</p></div></div></div><div id='executor.target'><h3 ><a class='secnum' href='#executor.target' style='min-width:103pt'>13.21.7</a> <span class='texttt'>executor</span> target access <a class='abbr_ref' href='async.executor.target'>[async.executor.target]</a></h3><p ><span class='indexparent'><a class='index' id='target_type,executor'></a></span><span class='indexparent'><a class='index' id='executor,target_type'></a></span><code class='itemdecl'>
const type_info&amp; target_type() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.target-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.target-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>*this</span> has a target of type <span class='texttt'>T</span>, <span class='texttt'>typeid(T)</span>; otherwise, <span class='texttt'>typeid(void)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='target,executor'></a></span><span class='indexparent'><a class='index' id='executor,target'></a></span><code class='itemdecl'>
template&lt;class Executor&gt; Executor* target() noexcept;
template&lt;class Executor&gt; const Executor* target() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.target-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.target-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>target_type() == typeid(Executor)</span> a pointer to the stored executor target; otherwise a null pointer value.
</p></div></div></div><div id='executor.comparisons'><h3 ><a class='secnum' href='#executor.comparisons' style='min-width:103pt'>13.21.8</a> <span class='texttt'>executor</span> comparisons <a class='abbr_ref' href='async.executor.comparisons'>[async.executor.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='executor.comparisons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#executor.comparisons-1.1'>(1.1)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>!a</span> and <span class='texttt'>!b</span>;
</p></li><li id='executor.comparisons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#executor.comparisons-1.2'>(1.2)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>a</span> and <span class='texttt'>b</span> share a target;
</p></li><li id='executor.comparisons-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#executor.comparisons-1.3'>(1.3)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>e</span> and <span class='texttt'>f</span> are the same type and <span class='texttt'>e == f</span>, where <span class='texttt'>e</span> is the target of <span class='texttt'>a</span> and <span class='texttt'>f</span> is the target of <span class='texttt'>b</span>;
</p></li><li id='executor.comparisons-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#executor.comparisons-1.4'>(1.4)</a></div><p >otherwise <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator==,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const executor&amp; e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#executor.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!e</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#executor.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const executor&amp; e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#executor.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(bool) e</span>.
</p></div></div></div><div id='executor.algo'><h3 ><a class='secnum' href='#executor.algo' style='min-width:103pt'>13.21.9</a> <span class='texttt'>executor</span> specialized algorithms <a class='abbr_ref' href='async.executor.algo'>[async.executor.algo]</a></h3><p ><span class='indexparent'><a class='index' id='swap,executor'></a></span><span class='indexparent'><a class='index' id='executor,swap'></a></span><code class='itemdecl'>
void swap(executor&amp; a, executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='executor.algo-1'><div class='marginalizedparent'><a class='marginalized' href='#executor.algo-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>a.swap(b)</span>.
</p></div></div></div></div><div id='dispatch'><h2 ><a class='secnum' href='#dispatch' style='min-width:88pt'>13.22</a> Function <span class='texttt'>dispatch</span> <a class='abbr_ref' href='async.dispatch'>[async.dispatch]</a></h2><p ><span class='indexparent'><a class='index' id='dispatch'></a></span></p><div class='para' id='dispatch-1'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>dispatch</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), except for the requirement that the operation uses <span class='texttt'>post</span> if it completes immediately. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='dispatch-2'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='dispatch-3'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='dispatch-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dispatch-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='dispatch-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dispatch-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.dispatch(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='dispatch-4'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='dispatch-5'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='dispatch-6'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='dispatch-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dispatch-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='dispatch-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dispatch-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='dispatch-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dispatch-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='dispatch-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dispatch-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='dispatch-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dispatch-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='dispatch-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dispatch-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='dispatch-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dispatch-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.dispatch(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='dispatch-7'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='dispatch-8'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='dispatch-9'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='dispatch-10'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::dispatch(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='dispatch-11'><div class='marginalizedparent'><a class='marginalized' href='#dispatch-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='post'><h2 ><a class='secnum' href='#post' style='min-width:88pt'>13.23</a> Function <span class='texttt'>post</span> <a class='abbr_ref' href='async.post'>[async.post]</a></h2><p ><span class='indexparent'><a class='index' id='post'></a></span></p><div class='para' id='post-1'><div class='marginalizedparent'><a class='marginalized' href='#post-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>post</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='post-2'><div class='marginalizedparent'><a class='marginalized' href='#post-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='post-3'><div class='marginalizedparent'><a class='marginalized' href='#post-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='post-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#post-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='post-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#post-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.post(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='post-4'><div class='marginalizedparent'><a class='marginalized' href='#post-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='post-5'><div class='marginalizedparent'><a class='marginalized' href='#post-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='post-6'><div class='marginalizedparent'><a class='marginalized' href='#post-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='post-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#post-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='post-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#post-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='post-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#post-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='post-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#post-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='post-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#post-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='post-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#post-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='post-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#post-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.post(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='post-7'><div class='marginalizedparent'><a class='marginalized' href='#post-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='post-8'><div class='marginalizedparent'><a class='marginalized' href='#post-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='post-9'><div class='marginalizedparent'><a class='marginalized' href='#post-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='post-10'><div class='marginalizedparent'><a class='marginalized' href='#post-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::post(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='post-11'><div class='marginalizedparent'><a class='marginalized' href='#post-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='defer'><h2 ><a class='secnum' href='#defer' style='min-width:88pt'>13.24</a> Function <span class='texttt'>defer</span> <a class='abbr_ref' href='async.defer'>[async.defer]</a></h2><p ><span class='indexparent'><a class='index' id='defer'></a></span></p><div class='para' id='defer-1'><div class='marginalizedparent'><a class='marginalized' href='#defer-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>defer</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), except for the requirement that the operation uses <span class='texttt'>post</span> if it completes immediately. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='defer-2'><div class='marginalizedparent'><a class='marginalized' href='#defer-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='defer-3'><div class='marginalizedparent'><a class='marginalized' href='#defer-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='defer-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defer-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='defer-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defer-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.defer(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='defer-4'><div class='marginalizedparent'><a class='marginalized' href='#defer-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='defer-5'><div class='marginalizedparent'><a class='marginalized' href='#defer-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='defer-6'><div class='marginalizedparent'><a class='marginalized' href='#defer-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='defer-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defer-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='defer-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defer-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='defer-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#defer-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='defer-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#defer-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='defer-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#defer-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='defer-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#defer-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='defer-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defer-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.defer(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='defer-7'><div class='marginalizedparent'><a class='marginalized' href='#defer-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='defer-8'><div class='marginalizedparent'><a class='marginalized' href='#defer-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='defer-9'><div class='marginalizedparent'><a class='marginalized' href='#defer-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='defer-10'><div class='marginalizedparent'><a class='marginalized' href='#defer-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::defer(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='defer-11'><div class='marginalizedparent'><a class='marginalized' href='#defer-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='strand'><h2 ><a class='secnum' href='#strand' style='min-width:88pt'>13.25</a> Class template <span class='texttt'>strand</span> <a class='abbr_ref' href='async.strand'>[async.strand]</a></h2><p ><span class='indexparent'><a class='index' id='strand'></a></span></p><div class='para' id='strand-1'><div class='marginalizedparent'><a class='marginalized' href='#strand-1'>1</a></div><p >The class template <span class='texttt'>strand</span> is a wrapper around an object of type <span class='texttt'>Executor</span> satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Executor&gt;
  class strand
  {
  public:
    <span class='comment'>// types:
</span>
    using inner_executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    strand();
    explicit strand(Executor ex);
    template&lt;class ProtoAllocator&gt;
      strand(allocator_arg_t, const ProtoAllocator&amp; alloc, Executor ex);
    strand(const strand&amp; other) noexcept;
    strand(strand&amp;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;

    strand&amp; operator=(const strand&amp; other) noexcept;
    strand&amp; operator=(strand&amp;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand&amp; operator=(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand&amp; operator=(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;

    ~strand();

    <span class='comment'>// strand operations:
</span>
    inner_executor_type get_inner_executor() const noexcept;

    bool running_in_this_thread() const noexcept;

    execution_context&amp; context() const noexcept;

    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;

  private:
    Executor inner_ex_; <span class='comment'>// <i>exposition only</i>
</span>  };

  bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
  bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='strand-2'><div class='marginalizedparent'><a class='marginalized' href='#strand-2'>2</a></div><p ><span class='texttt'>strand&lt;Executor&gt;</span> satisfies the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements.</p></div><div class='para' id='strand-3'><div class='marginalizedparent'><a class='marginalized' href='#strand-3'>3</a></div><p >A strand provides guarantees of ordering and non-concurrency. Given:</p><ul class='itemize'><li id='strand-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand-3.1'>(3.1)</a></div><p >strand objects <span class='texttt'>s1</span> and <span class='texttt'>s2</span> such that <span class='texttt'>s1 == s2</span></p></li><li id='strand-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand-3.2'>(3.2)</a></div><p >a function object <span class='texttt'>f1</span> added to the strand <span class='texttt'>s1</span> using <span class='texttt'>post</span> or <span class='texttt'>defer</span>, or using <span class='texttt'>dispatch</span> when <span class='texttt'>s1.running_in_this_thread() == false</span></p></li><li id='strand-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand-3.3'>(3.3)</a></div><p >a function object <span class='texttt'>f2</span> added to the strand <span class='texttt'>s2</span> using <span class='texttt'>post</span> or <span class='texttt'>defer</span>, or using <span class='texttt'>dispatch</span> when <span class='texttt'>s2.running_in_this_thread() == false</span>
</p></li></ul></div><div class='para' id='strand-4'><div class='marginalizedparent'><a class='marginalized' href='#strand-4'>4</a></div><p >then the implementation invokes <span class='texttt'>f1</span> and <span class='texttt'>f2</span> such that:</p><ul class='itemize'><li id='strand-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand-4.1'>(4.1)</a></div><p >the invocation of <span class='texttt'>f1</span> is not concurrent with the invocation of <span class='texttt'>f2</span></p></li><li id='strand-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand-4.2'>(4.2)</a></div><p >the invocation of <span class='texttt'>f1</span> synchronizes with the invocation of <span class='texttt'>f2</span>.
</p></li></ul></div><div class='para' id='strand-5'><div class='marginalizedparent'><a class='marginalized' href='#strand-5'>5</a></div><p >Furthermore, if the addition of <span class='texttt'>f1</span> happens before the addition of <span class='texttt'>f2</span>, then the invocation of <span class='texttt'>f1</span> happens before the invocation of <span class='texttt'>f2</span>.</p></div><div class='para' id='strand-6'><div class='marginalizedparent'><a class='marginalized' href='#strand-6'>6</a></div><p >All member functions, except for the assignment operators and the destructor, do not introduce data races on <span class='texttt'>*this</span>, including its ordered, non-concurrent state. Additionally, constructors and assignment operators do not introduce data races on lvalue arguments.</p></div><div class='para' id='strand-7'><div class='marginalizedparent'><a class='marginalized' href='#strand-7'>7</a></div><p >If any function <span class='texttt'>f</span> executed by the strand throws an exception, the subsequent strand state is as if <span class='texttt'>f</span> had exited without throwing an exception.</p></div><div id='strand.cons'><h3 ><a class='secnum' href='#strand.cons' style='min-width:103pt'>13.25.1</a> <span class='texttt'>strand</span> constructors <a class='abbr_ref' href='async.strand.cons'>[async.strand.cons]</a></h3><p ><span class='indexparent'><a class='index' id='strand,constructor'></a></span><code class='itemdecl'>
strand();
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_()</span>.</p></div></div><div class='para' id='strand.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This overload shall not participate in overload resolution unless <span class='texttt'>Executor</span> satisfies the <span class='texttt'>DefaultConstructible</span> requirements (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>).
</p></div></div><p ><code class='itemdecl'>
explicit strand(Executor ex);
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(ex)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ProtoAllocator&gt;
  strand(allocator_arg_t, const ProtoAllocator&amp; a, Executor ex);
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(ex)</span>. A copy of the allocator argument <span class='texttt'>a</span> is used to allocate memory, if necessary, for the internal data structures of the constructed strand object.
</p></div></div><p ><code class='itemdecl'>
strand(const strand&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(other.inner_ex_)</span>.</p></div></div><div class='para' id='strand.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='strand.cons-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.cons-6.1'>(6.1)</a></div><p ><span class='texttt'>*this == other</span>
</p></li><li id='strand.cons-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.cons-6.2'>(6.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><p ><code class='itemdecl'>
strand(strand&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(std::move(other.inner_ex_))</span>.</p></div></div><div class='para' id='strand.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='strand.cons-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.cons-8.1'>(8.1)</a></div><p ><span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>
</p></li><li id='strand.cons-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.cons-8.2'>(8.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>.</p></div></div><div class='para' id='strand.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(other.inner_ex_)</span>.</p></div></div><div class='para' id='strand.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>.</p></div></div><div class='para' id='strand.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(std::move(other.inner_ex_))</span>.</p></div></div><div class='para' id='strand.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#strand.cons-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.
</p></div></div></div><div id='strand.assign'><h3 ><a class='secnum' href='#strand.assign' style='min-width:103pt'>13.25.2</a> <span class='texttt'>strand</span> assignment <a class='abbr_ref' href='async.strand.assign'>[async.strand.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator='></a></span><code class='itemdecl'>
strand&amp; operator=(const strand&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Executor</span> is <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div></div><div class='para' id='strand.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='strand.assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.assign-2.1'>(2.1)</a></div><p ><span class='texttt'>*this == other</span>
</p></li><li id='strand.assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.assign-2.2'>(2.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><div class='para' id='strand.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
strand&amp; operator=(strand&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Executor</span> is <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='strand.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='strand.assign-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.assign-5.1'>(5.1)</a></div><p ><span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>
</p></li><li id='strand.assign-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#strand.assign-5.2'>(5.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><div class='para' id='strand.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand&amp; operator=(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>. <span class='texttt'>Executor</span> is <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div></div><div class='para' id='strand.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>other.inner_ex_</span> to <span class='texttt'>inner_ex_</span>.</p></div></div><div class='para' id='strand.assign-9'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.</p></div></div><div class='para' id='strand.assign-10'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand&amp; operator=(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.assign-11'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>. <span class='texttt'>Executor</span> is <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='strand.assign-12'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>std::move(other.inner_ex_)</span> to <span class='texttt'>inner_ex_</span>.</p></div></div><div class='para' id='strand.assign-13'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.</p></div></div><div class='para' id='strand.assign-14'><div class='marginalizedparent'><a class='marginalized' href='#strand.assign-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='strand.dtor'><h3 ><a class='secnum' href='#strand.dtor' style='min-width:103pt'>13.25.3</a> <span class='texttt'>strand</span> destructor <a class='abbr_ref' href='async.strand.dtor'>[async.strand.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='strand,destructor'></a></span><code class='itemdecl'>
~strand();
</code></p><div class='itemdescr'></div><div class='para' id='strand.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#strand.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys an object of class <span class='texttt'>strand&lt;Executor&gt;</span>. After this destructor completes, objects that were added to the strand but have not yet been executed will be executed in a way that meets the guarantees of ordering and non-concurrency.
</p></div></div></div><div id='strand.ops'><h3 ><a class='secnum' href='#strand.ops' style='min-width:103pt'>13.25.4</a> <span class='texttt'>strand</span> operations <a class='abbr_ref' href='async.strand.ops'>[async.strand.ops]</a></h3><p ><span class='indexparent'><a class='index' id='get_inner_executor,strand'></a></span><span class='indexparent'><a class='index' id='strand,get_inner_executor'></a></span><code class='itemdecl'>
inner_executor_type get_inner_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>inner_ex_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='running_in_this_thread,strand'></a></span><span class='indexparent'><a class='index' id='strand,running_in_this_thread'></a></span><code class='itemdecl'>
bool running_in_this_thread() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the current thread of execution is running a function that was submitted to the strand, or to any other strand object <span class='texttt'>s</span> such that <span class='texttt'>s == *this</span>, using <span class='texttt'>dispatch</span>, <span class='texttt'>post</span> or <span class='texttt'>defer</span>; otherwise <span class='texttt'>false</span>. [&nbsp;<i>Note:</i> That is, the current thread of execution's call chain includes a function that was submitted to the strand. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='context,strand'></a></span><span class='indexparent'><a class='index' id='strand,context'></a></span><code class='itemdecl'>
execution_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>inner_ex_.context()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_started,strand'></a></span><span class='indexparent'><a class='index' id='strand,on_work_started'></a></span><code class='itemdecl'>
void on_work_started() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>inner_ex_.on_work_started()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_finished,strand'></a></span><span class='indexparent'><a class='index' id='strand,on_work_finished'></a></span><code class='itemdecl'>
void on_work_finished() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>inner_ex_.on_work_finished()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,strand'></a></span><span class='indexparent'><a class='index' id='strand,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>running_in_this_thread() == true</span>, calls <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>). [&nbsp;<i>Note:</i> If <span class='texttt'>f</span> exits via an exception, the exception propagates to the caller of <span class='texttt'>dispatch()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise, requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div><p ><span class='indexparent'><a class='index' id='post,strand'></a></span><span class='indexparent'><a class='index' id='strand,post'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div><p ><span class='indexparent'><a class='index' id='defer,strand'></a></span><span class='indexparent'><a class='index' id='strand,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='strand.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#strand.ops-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div></div><div id='strand.comparisons'><h3 ><a class='secnum' href='#strand.comparisons' style='min-width:103pt'>13.25.5</a> <span class='texttt'>strand</span> comparisons <a class='abbr_ref' href='async.strand.comparisons'>[async.strand.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator=='></a></span><code class='itemdecl'>
bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='strand.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#strand.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span>, if the strand objects share the same ordered, non-concurrent state; otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator!='></a></span><code class='itemdecl'>
bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='strand.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#strand.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div><div id='use.future'><h2 ><a class='secnum' href='#use.future' style='min-width:88pt'>13.26</a> Class template <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future'>[async.use.future]</a></h2><p ><span class='indexparent'><a class='index' id='use_future_t'></a></span></p><div class='para' id='use.future-1'><div class='marginalizedparent'><a class='marginalized' href='#use.future-1'>1</a></div><p >The class template <span class='texttt'>use_future_t</span> defines a set of types that, when passed as a completion token (<a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>) to an asynchronous operation's initiating function, cause the result of the asynchronous operation to be delivered via a future (C++Std &sect;<a href='../n4140/futures.uniquefuture'>[futures.uniquefuture]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class ProtoAllocator = allocator&lt;void&gt;&gt;
  class use_future_t
  {
  public:
    <span class='comment'>// use_future_t types:
</span>    using allocator_type = ProtoAllocator;

    <span class='comment'>// use_future_t members:
</span>    constexpr use_future_t() noexcept(noexcept(allocator_type()));
    explicit use_future_t(const allocator_type&amp; a) noexcept;
    template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
      rebind(const OtherProtoAllocator&amp; a) const noexcept;
    allocator_type get_allocator() const noexcept;
    template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='use.future.cons'><h3 ><a class='secnum' href='#use.future.cons' style='min-width:103pt'>13.26.1</a> <span class='texttt'>use_future_t</span> constructors <a class='abbr_ref' href='async.use.future.cons'>[async.use.future.cons]</a></h3><p ><span class='indexparent'><a class='index' id='use_future_t,constructor'></a></span><code class='itemdecl'>
constexpr use_future_t() noexcept(noexcept(allocator_type()));
</code></p><div class='itemdescr'></div><div class='para' id='use.future.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#use.future.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>use_future_t</span> with a default-constructed allocator.
</p></div></div><p ><code class='itemdecl'>
explicit use_future_t(const allocator_type&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='use.future.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#use.future.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_allocator() == a</span>.
</p></div></div></div><div id='use.future.members'><h3 ><a class='secnum' href='#use.future.members' style='min-width:103pt'>13.26.2</a> <span class='texttt'>use_future_t</span> members <a class='abbr_ref' href='async.use.future.members'>[async.use.future.members]</a></h3><p ><span class='indexparent'><a class='index' id='rebind,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,rebind'></a></span><code class='itemdecl'>
template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
  rebind(const OtherProtoAllocator&amp; a) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='use.future.members-1'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>use_future_t</span> object where <span class='texttt'>get_allocator() == a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_allocator,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,get_allocator'></a></span><code class='itemdecl'>
allocator_type get_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='use.future.members-2'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated allocator object.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator(),use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,operator()'></a></span><code class='itemdecl'>
template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
</code></p><div class='itemdescr'></div><div class='para' id='use.future.members-3'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>T</span> be a completion token type. Let <span class='texttt'>H</span> be a completion handler type and let <span class='texttt'>h</span> be an object of type <span class='texttt'>H</span>. Let <span class='texttt'>FD</span> be the type <span class='texttt'>decay_t&lt;F&gt;</span> and let <span class='texttt'>fd</span> be an lvalue of type <span class='texttt'>FD</span> constructed with <span class='texttt'>forward&lt;F&gt;(f)</span>. Let <span class='texttt'>R(Args...)</span> be the completion signature of an asynchronous operation using <span class='texttt'>H</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>. Let <span class='texttt'>a<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the argument associated with <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span>.</p></div></div><div class='para' id='use.future.members-4'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A completion token <span class='texttt'>t</span> of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='use.future.members-5'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type <span class='texttt'>T</span> satisfies the <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) requirements.</p></div></div><div class='para' id='use.future.members-6'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-6'>6</a></div><div class='itemdescr'><p >The object <span class='texttt'>h</span> of type <span class='texttt'>H</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The effect of <span class='texttt'>h(a<span class='math'><sub >0</sub></span>, ..., a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>)</span> is to atomically store the result of <span class='texttt'><i>INVOKE</i>(fd, forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> (C++Std &sect;<a href='../n4140/func.require'>[func.require]</a>) in the shared state and make the shared state ready. If <span class='texttt'>fd</span> exits via an exception then that exception is atomically stored in the shared state and the shared state is made ready.</p></div></div><div class='para' id='use.future.members-7'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-7'>7</a></div><div class='itemdescr'><p >The implementation provides a partial specialization <span class='texttt'>template &lt;class Result, class... Args&gt; async_result&lt;T, Result(Args...)&gt;</span> such that:
</p><ul class='itemize'><li id='use.future.members-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#use.future.members-7.1'>(7.1)</a></div><p >the nested type <span class='texttt'>completion_handler_type</span> is a type <span class='texttt'>H</span>;
</p></li><li id='use.future.members-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#use.future.members-7.2'>(7.2)</a></div><p >the nested type <span class='texttt'>return_type</span> is <span class='texttt'>future&lt;result_of_t&lt;FD(decay_t&lt;Args&gt;...)&gt;&gt;</span>; and
</p></li><li id='use.future.members-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#use.future.members-7.3'>(7.3)</a></div><p >when an object <span class='texttt'>r1</span> of type <span class='texttt'>async_result&lt;T, Result(Args...)&gt;</span> is constructed from <span class='texttt'>h</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>h</span>.
</p></li></ul></div></div><div class='para' id='use.future.members-8'><div class='marginalizedparent'><a class='marginalized' href='#use.future.members-8'>8</a></div><div class='itemdescr'><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;H, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by a function object and stored in the associated shared state.
</p></div></div></div><div id='use.future.result'><h3 ><a class='secnum' href='#use.future.result' style='min-width:103pt'>13.26.3</a> Partial class template specialization <span class='texttt'>async_result</span>
        for <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future.result'>[async.use.future.result]</a></h3><p ><span class='indexparent'><a class='index' id='async_result'></a></span><span class='indexparent'><a class='index' id='async_result,specialization_for_use_future_t'></a></span></p><pre class='codeblock'>
template&lt;class ProtoAllocator, class Result, class... Args&gt;
class async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;{
  using completion_handler_type = <i><span class='texttt'>see below</span></i>;
  using return_type =  <i><span class='texttt'>see below</span></i>;

  explicit async_result(completion_handler_type&amp; h);
  async_result(const async_result&amp;) = delete;
  async_result&amp; operator=(const async_result&amp;) = delete;

  return_type get();
};
</pre><div class='para' id='use.future.result-1'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-1'>1</a></div><p >Let <span class='texttt'>R</span> be the type <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span>. Let <span class='texttt'>F</span> be the nested function object type <span class='texttt'>R::completion_handler_type</span>.</p></div><div class='para' id='use.future.result-2'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-2'>2</a></div><p >An object <span class='texttt'>t1</span> of type <span class='texttt'>F</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The type <span class='texttt'>F</span> provides <span class='texttt'>F::operator()</span> such that the expression <span class='texttt'>t1(declval&lt;Args&gt;()...)</span> is well formed.</p></div><div class='para' id='use.future.result-3'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-3'>3</a></div><p >The implementation specializes <span class='texttt'>associated_executor</span> for <span class='texttt'>F</span>. For function objects executed using the associated executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='use.future.result-4'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-4'>4</a></div><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;F, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown by a function object is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='use.future.result-5'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-5'>5</a></div><p >When an object <span class='texttt'>r1</span> of type <span class='texttt'>R</span> is constructed from <span class='texttt'>t1</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>t1</span>.</p></div><div class='para' id='use.future.result-6'><div class='marginalizedparent'><a class='marginalized' href='#use.future.result-6'>6</a></div><p >The type of <span class='texttt'>R::return_type</span> and the effects of <span class='texttt'>F::operator()</span> are defined in Table <a href='#tab:async.use.future.result.requirements'>[tab:async.use.future.result.requirements]</a>. After establishing these effects, <span class='texttt'>F::operator()</span> makes the shared state ready. In this table, <i>N</i> is the value of <span class='texttt'>sizeof...(Args)</span>; let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>; let <span class='texttt'>U</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be <span class='texttt'>decay_t&lt;T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span><span class='texttt'>&gt;</span> for each type <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>Args</span>; let <span class='texttt'>A</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the deduced type of the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>; and let <span class='texttt'>a</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>.</p><div class='numberedTable' id='tab:async.use.future.result.requirements'>Table <a href='#tab:async.use.future.result.requirements'>10</a> — <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span> semantics<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>N</b></td><td colspan='1' class='center'><b>U<span class='math'><sub >0</sub></span></b></td><td colspan='1' class='center'><b><span class='texttt'>R::return_type</span></b></td><td colspan='1' class='center'><b><span class='texttt'>F::operator()</span> effects</b></td></tr><tr class='capsep'><td class='center'> 
 0  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
 None.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer a<span class='math'><sub >0</sub></span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >0</sub></span>&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, U<span class='math'><sub >1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr></table></div></div></div></div><div id='packaged.task.spec'><h2 ><a class='secnum' href='#packaged.task.spec' style='min-width:88pt'>13.27</a> Partial specialization of <span class='texttt'>async_result</span> for <span class='texttt'>packaged_task</span> <a class='abbr_ref' href='async.packaged.task.spec'>[async.packaged.task.spec]</a></h2><p ><span class='indexparent'><a class='index' id='async_result'></a></span><span class='indexparent'><a class='index' id='async_result,specialization_for_packaged_task'></a></span><code class='itemdecl'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Result, class... Args, class Signature&gt;
  class async_result&lt;packaged_task&lt;Result(Args...)&gt;, Signature&gt;
  {
  public:
    using completion_handler_type = packaged_task&lt;Result(Args...)&gt;;
    using return_type = future&lt;Result&gt;;

    explicit async_result(completion_handler_type&amp; h);
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get();

  private:
    return_type future_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span>
explicit async_result(completion_handler_type&amp; h);
</code></p><div class='itemdescr'></div><div class='para' id='packaged.task.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#packaged.task.spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>future_</span> with <span class='texttt'>h.get_future()</span>.
</p></div></div><p ><code class='itemdecl'>
return_type get();
</code></p><div class='itemdescr'></div><div class='para' id='packaged.task.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#packaged.task.spec-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(future_)</span>.
</p></div></div></div></div></div></body></html>