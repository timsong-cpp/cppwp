<!DOCTYPE html><html lang='en'><head><title>[async.use.future]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Asynchronous model <a class='abbr_ref' href='./#async'>[async]</a></h1><div id='async.use.future'><h2 ><a class='secnum' style='min-width:88pt'>13.26</a> Class template <span class='texttt'>use_future_t</span> <a class='abbr_ref'>[async.use.future]</a></h2><p ><span class='indexparent'><a class='index' id='use_future_t'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The class template <span class='texttt'>use_future_t</span> defines a set of types that, when passed as a completion token (<a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>) to an asynchronous operation's initiating function, cause the result of the asynchronous operation to be delivered via a future (C++Std &sect;<a href='../n4140/futures.uniquefuture'>[futures.uniquefuture]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class ProtoAllocator = allocator&lt;void&gt;&gt;
  class use_future_t
  {
  public:
    <span class='comment'>// use_future_t types:
</span>    using allocator_type = ProtoAllocator;

    <span class='comment'>// use_future_t members:
</span>    constexpr use_future_t() noexcept(noexcept(allocator_type()));
    explicit use_future_t(const allocator_type&amp; a) noexcept;
    template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
      rebind(const OtherProtoAllocator&amp; a) const noexcept;
    allocator_type get_allocator() const noexcept;
    template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='cons'><h3 ><a class='secnum' href='#cons' style='min-width:103pt'>13.26.1</a> <span class='texttt'>use_future_t</span> constructors <a class='abbr_ref' href='async.use.future.cons'>[async.use.future.cons]</a></h3><p ><span class='indexparent'><a class='index' id='use_future_t,constructor'></a></span><code class='itemdecl'>
constexpr use_future_t() noexcept(noexcept(allocator_type()));
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>use_future_t</span> with a default-constructed allocator.
</p></div></div><p ><code class='itemdecl'>
explicit use_future_t(const allocator_type&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_allocator() == a</span>.
</p></div></div></div><div id='members'><h3 ><a class='secnum' href='#members' style='min-width:103pt'>13.26.2</a> <span class='texttt'>use_future_t</span> members <a class='abbr_ref' href='async.use.future.members'>[async.use.future.members]</a></h3><p ><span class='indexparent'><a class='index' id='rebind,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,rebind'></a></span><code class='itemdecl'>
template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
  rebind(const OtherProtoAllocator&amp; a) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-1'><div class='marginalizedparent'><a class='marginalized' href='#members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>use_future_t</span> object where <span class='texttt'>get_allocator() == a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_allocator,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,get_allocator'></a></span><code class='itemdecl'>
allocator_type get_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-2'><div class='marginalizedparent'><a class='marginalized' href='#members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated allocator object.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator(),use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,operator()'></a></span><code class='itemdecl'>
template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
</code></p><div class='itemdescr'></div><div class='para' id='members-3'><div class='marginalizedparent'><a class='marginalized' href='#members-3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>T</span> be a completion token type. Let <span class='texttt'>H</span> be a completion handler type and let <span class='texttt'>h</span> be an object of type <span class='texttt'>H</span>. Let <span class='texttt'>FD</span> be the type <span class='texttt'>decay_t&lt;F&gt;</span> and let <span class='texttt'>fd</span> be an lvalue of type <span class='texttt'>FD</span> constructed with <span class='texttt'>forward&lt;F&gt;(f)</span>. Let <span class='texttt'>R(Args...)</span> be the completion signature of an asynchronous operation using <span class='texttt'>H</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>. Let <span class='texttt'>a<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the argument associated with <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span>.</p></div></div><div class='para' id='members-4'><div class='marginalizedparent'><a class='marginalized' href='#members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A completion token <span class='texttt'>t</span> of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='members-5'><div class='marginalizedparent'><a class='marginalized' href='#members-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type <span class='texttt'>T</span> satisfies the <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) requirements.</p></div></div><div class='para' id='members-6'><div class='marginalizedparent'><a class='marginalized' href='#members-6'>6</a></div><div class='itemdescr'><p >The object <span class='texttt'>h</span> of type <span class='texttt'>H</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The effect of <span class='texttt'>h(a<span class='math'><sub >0</sub></span>, ..., a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>)</span> is to atomically store the result of <span class='texttt'><i>INVOKE</i>(fd, forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> (C++Std &sect;<a href='../n4140/func.require'>[func.require]</a>) in the shared state and make the shared state ready. If <span class='texttt'>fd</span> exits via an exception then that exception is atomically stored in the shared state and the shared state is made ready.</p></div></div><div class='para' id='members-7'><div class='marginalizedparent'><a class='marginalized' href='#members-7'>7</a></div><div class='itemdescr'><p >The implementation provides a partial specialization <span class='texttt'>template &lt;class Result, class... Args&gt; async_result&lt;T, Result(Args...)&gt;</span> such that:
</p><ul class='itemize'><li id='members-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-7.1'>(7.1)</a></div><p >the nested type <span class='texttt'>completion_handler_type</span> is a type <span class='texttt'>H</span>;
</p></li><li id='members-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-7.2'>(7.2)</a></div><p >the nested type <span class='texttt'>return_type</span> is <span class='texttt'>future&lt;result_of_t&lt;FD(decay_t&lt;Args&gt;...)&gt;&gt;</span>; and
</p></li><li id='members-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-7.3'>(7.3)</a></div><p >when an object <span class='texttt'>r1</span> of type <span class='texttt'>async_result&lt;T, Result(Args...)&gt;</span> is constructed from <span class='texttt'>h</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>h</span>.
</p></li></ul></div></div><div class='para' id='members-8'><div class='marginalizedparent'><a class='marginalized' href='#members-8'>8</a></div><div class='itemdescr'><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;H, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by a function object and stored in the associated shared state.
</p></div></div></div><div id='result'><h3 ><a class='secnum' href='#result' style='min-width:103pt'>13.26.3</a> Partial class template specialization <span class='texttt'>async_result</span>
        for <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future.result'>[async.use.future.result]</a></h3><p ><span class='indexparent'><a class='index' id='async_result'></a></span><span class='indexparent'><a class='index' id='async_result,specialization_for_use_future_t'></a></span></p><pre class='codeblock'>
template&lt;class ProtoAllocator, class Result, class... Args&gt;
class async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;{
  using completion_handler_type = <i><span class='texttt'>see below</span></i>;
  using return_type =  <i><span class='texttt'>see below</span></i>;

  explicit async_result(completion_handler_type&amp; h);
  async_result(const async_result&amp;) = delete;
  async_result&amp; operator=(const async_result&amp;) = delete;

  return_type get();
};
</pre><div class='para' id='result-1'><div class='marginalizedparent'><a class='marginalized' href='#result-1'>1</a></div><p >Let <span class='texttt'>R</span> be the type <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span>. Let <span class='texttt'>F</span> be the nested function object type <span class='texttt'>R::completion_handler_type</span>.</p></div><div class='para' id='result-2'><div class='marginalizedparent'><a class='marginalized' href='#result-2'>2</a></div><p >An object <span class='texttt'>t1</span> of type <span class='texttt'>F</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The type <span class='texttt'>F</span> provides <span class='texttt'>F::operator()</span> such that the expression <span class='texttt'>t1(declval&lt;Args&gt;()...)</span> is well formed.</p></div><div class='para' id='result-3'><div class='marginalizedparent'><a class='marginalized' href='#result-3'>3</a></div><p >The implementation specializes <span class='texttt'>associated_executor</span> for <span class='texttt'>F</span>. For function objects executed using the associated executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='result-4'><div class='marginalizedparent'><a class='marginalized' href='#result-4'>4</a></div><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;F, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown by a function object is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='result-5'><div class='marginalizedparent'><a class='marginalized' href='#result-5'>5</a></div><p >When an object <span class='texttt'>r1</span> of type <span class='texttt'>R</span> is constructed from <span class='texttt'>t1</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>t1</span>.</p></div><div class='para' id='result-6'><div class='marginalizedparent'><a class='marginalized' href='#result-6'>6</a></div><p >The type of <span class='texttt'>R::return_type</span> and the effects of <span class='texttt'>F::operator()</span> are defined in Table <a href='#tab:async.use.future.result.requirements'>[tab:async.use.future.result.requirements]</a>. After establishing these effects, <span class='texttt'>F::operator()</span> makes the shared state ready. In this table, <i>N</i> is the value of <span class='texttt'>sizeof...(Args)</span>; let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>; let <span class='texttt'>U</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be <span class='texttt'>decay_t&lt;T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span><span class='texttt'>&gt;</span> for each type <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>Args</span>; let <span class='texttt'>A</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the deduced type of the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>; and let <span class='texttt'>a</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>.</p><div class='numberedTable' id='tab:async.use.future.result.requirements'>Table <a href='#tab:async.use.future.result.requirements'>10</a> â€” <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span> semantics<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>N</b></td><td colspan='1' class='center'><b>U<span class='math'><sub >0</sub></span></b></td><td colspan='1' class='center'><b><span class='texttt'>R::return_type</span></b></td><td colspan='1' class='center'><b><span class='texttt'>F::operator()</span> effects</b></td></tr><tr class='capsep'><td class='center'> 
 0  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
 None.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer a<span class='math'><sub >0</sub></span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >0</sub></span>&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, U<span class='math'><sub >1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr></table></div></div></div></div></div></body></html>