<!DOCTYPE html><html lang='en'><head><title>[temp.fct]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.6</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.fct'>[temp.decls]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>12.6.6</a> Function templates <a class='abbr_ref'>[temp.fct]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3508'>#</a></div><div id='1.sentence-1' class='sentence'>A function template defines an unbounded set of related functions<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='1.sentence-2' class='sentence'>A family of sort functions might be declared like this:</div><pre class='codeblock'>
template&lt;class T&gt; class Array { };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp;);</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3519'>#</a></div><div id='2.sentence-1' class='sentence'>A function template can be overloaded with other function templates
and with non-template functions (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>A non-template function is not
related to a function template
(i.e., it is never considered to be a specialization),
even if it has the same name and type
as a potentially generated function template specialization<a class='hidden_link' href='#2.sentence-2'>.</a><a class='footnotenum' href='#footnote-139'>139</a></div></div><div class='footnote' id='footnote-139'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-139'>139)</a></div><div id='footnote-139.sentence-1' class='sentence'>That is,
declarations of non-template functions do not merely guide
overload resolution of
function template specializations
with the same name<a class='hidden_link' href='#footnote-139.sentence-1'>.</a></div> <div id='footnote-139.sentence-2' class='sentence'>If such a non-template function is <a href='basic.def.odr'>odr-used</a> in a program, it must be defined;
it will not be implicitly instantiated using the function template definition<a class='hidden_link' href='#footnote-139.sentence-2'>.</a></div></div><div id='temp.over.link' class='section'><h4 ><a class='secnum' href='#temp.over.link' style='min-width:118pt'>12.6.6.1</a> Function template overloading <a class='abbr_ref' href='temp.over.link'>[temp.over.link]</a></h4><div class='para' id='temp.over.link-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3536'>#</a></div><div id='temp.over.link-1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading'></a></span>It is possible to overload function templates so that two different
function template specializations have the same type<a class='hidden_link' href='#temp.over.link-1.sentence-1'>.</a></div> <div id='temp.over.link-1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.over.link-1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div class='minipage'><pre class='codeblock'>
<span class='comment'>// translation unit 1:
</span>template&lt;class T&gt;
  void f(T*);
void g(int* p) {
  f(p); <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int&gt;(int*)</span>
</span>}</pre></div>
<div class='minipage'><pre class='codeblock'>
<span class='comment'>// translation unit 2:
</span>template&lt;class T&gt;
  void f(T);
void h(int* p) {
  f(p); <span class='comment'>// calls <span class='tcode_in_codeblock'>f&lt;int*&gt;(int*)</span>
</span>}</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='temp.over.link-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3565'>#</a></div><div id='temp.over.link-2.sentence-1' class='sentence'>Such specializations are distinct functions and do not violate the
<a href='basic.def.odr'>one-definition rule</a><a class='hidden_link' href='#temp.over.link-2.sentence-1'>.</a></div></div><div class='para' id='temp.over.link-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3569'>#</a></div><div id='temp.over.link-3.sentence-1' class='sentence'>The signature of a function template
is defined in <a href='intro.defs'>[intro.defs]</a><a class='hidden_link' href='#temp.over.link-3.sentence-1'>.</a></div> <div id='temp.over.link-3.sentence-2' class='sentence'>The names of the template parameters are significant only for establishing
the relationship between the template parameters and the rest of the
signature<a class='hidden_link' href='#temp.over.link-3.sentence-2'>.</a></div> <div id='temp.over.link-3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.over.link-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.over.link-3.sentence-3' class='sentence'>Two distinct function templates may have identical function return types and
function parameter lists, even if overload resolution alone cannot distinguish
them<a class='hidden_link' href='#temp.over.link-3.sentence-3'>.</a></div><pre class='codeblock'>
template&lt;class T&gt; void f();
template&lt;int I&gt; void f();       <span class='comment'>// OK: overloads the first template
</span>                                <span class='comment'>// distinguishable with an explicit template argument list
</span></pre> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='temp.over.link-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3587'>#</a></div><div id='temp.over.link-4.sentence-1' class='sentence'>When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template<a class='hidden_link' href='#temp.over.link-4.sentence-1'>.</a></div> <div id='temp.over.link-4.sentence-2' class='sentence'>This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another<a class='hidden_link' href='#temp.over.link-4.sentence-2'>.</a></div> <div id='temp.over.link-4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.over.link-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template &lt;int I, int J&gt; A&lt;I+J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// #1
</span>template &lt;int K, int L&gt; A&lt;K+L&gt; f(A&lt;K&gt;, A&lt;L&gt;);   <span class='comment'>// same as #1
</span>template &lt;int I, int J&gt; A&lt;I-J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// different from #1
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.over.link-4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.over.link-4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.over.link-4.sentence-3' class='sentence'>Most expressions that use template parameters use non-type template
parameters, but it is possible for an expression to reference a type
parameter<a class='hidden_link' href='#temp.over.link-4.sentence-3'>.</a></div> <div id='temp.over.link-4.sentence-4' class='sentence'>For example, a template type parameter can be used in the
<span class='texttt'>sizeof</span> operator<a class='hidden_link' href='#temp.over.link-4.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='temp.over.link-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3614'>#</a></div><div id='temp.over.link-5.sentence-1' class='sentence'>Two expressions involving template parameters are considered
<a class='hidden_link' href='#def:equivalent,expressions' id='def:equivalent,expressions'><i >equivalent</i></a>
if two function definitions containing the expressions would satisfy
the <a href='basic.def.odr'>one-definition rule</a>, except that the tokens used
to name the template parameters may differ as long as a token used to
name a template parameter in one expression is replaced by another token
that names the same template parameter in the other expression<a class='hidden_link' href='#temp.over.link-5.sentence-1'>.</a></div> <div id='temp.over.link-5.sentence-2' class='sentence'>Two <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><span class='textit'>s</span> are never considered equivalent<a class='hidden_link' href='#temp.over.link-5.sentence-2'>.</a></div> <div id='temp.over.link-5.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.over.link-5.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.over.link-5.sentence-3' class='sentence'>The intent is to avoid <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><span class='textit'>s</span> appearing in the
signature of a function template with external linkage<a class='hidden_link' href='#temp.over.link-5.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.over.link-5.sentence-4' class='sentence'>
For determining whether two dependent names (<a href='temp.dep'>[temp.dep]</a>) are
equivalent, only the name itself is considered, not the result of name
lookup in the context of the template<a class='hidden_link' href='#temp.over.link-5.sentence-4'>.</a></div> <div id='temp.over.link-5.sentence-5' class='sentence'>If multiple declarations of the
same function template differ in the result of this name lookup, the
result for the first declaration is used<a class='hidden_link' href='#temp.over.link-5.sentence-5'>.</a></div> <div id='temp.over.link-5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.over.link-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template &lt;int I, int J&gt; void f(A&lt;I+J&gt;);         <span class='comment'>// #1
</span>template &lt;int K, int L&gt; void f(A&lt;K+L&gt;);         <span class='comment'>// same as #1
</span>
template &lt;class T&gt; decltype(g(T())) h();
int g(int);
template &lt;class T&gt; decltype(g(T())) h()         <span class='comment'>// redeclaration of <span class='tcode_in_codeblock'>h()</span> uses the earlier lookup&hellip;
</span>  { return g(T()); }                            <span class='comment'>// &hellip; although the lookup here does find <span class='tcode_in_codeblock'>g(int)</span>
</span>int i = h&lt;int&gt;();                               <span class='comment'>// template argument substitution fails; <span class='tcode_in_codeblock'>g(int)</span>
</span>                                                <span class='comment'>// was not in scope at the first declaration of <span class='tcode_in_codeblock'>h()</span>
</span>
<span class='comment'>// ill-formed, no diagnostic required: the two expressions are functionally equivalent but not equivalent
</span>template &lt;int N&gt; void foo(const char (*s)[([]{}, N)]);
template &lt;int N&gt; void foo(const char (*s)[([]{}, N)]);

<span class='comment'>// two different declarations because the non-dependent portions are not considered equivalent
</span>template &lt;class T&gt; void spam(decltype([]{}) (*s)[sizeof(T)]);
template &lt;class T&gt; void spam(decltype([]{}) (*s)[sizeof(T)]);</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.over.link-5.sentence-6' class='sentence'>Two expressions involving template parameters that are not equivalent are
<a class='hidden_link' href='#def:functionally_equivalent,expressions' id='def:functionally_equivalent,expressions'><i >functionally equivalent</i></a>
if, for any given set of template arguments, the evaluation of the
expression results in the same value<a class='hidden_link' href='#temp.over.link-5.sentence-6'>.</a></div></div><div class='para' id='temp.over.link-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3660'>#</a></div><div id='temp.over.link-6.sentence-1' class='sentence'>Two <i ><a href='temp#nt:template-head'>template-head</a></i><span class='textit'>s</span> are
<a class='hidden_link' href='#def:equivalent,template-heads' id='def:equivalent,template-heads'><i >equivalent</i></a> if
their <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i><span class='textit'>s</span> have the same length,
corresponding <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span> are equivalent,
and if either has a <i ><a href='temp#nt:requires-clause'>requires-clause</a></i>, they both have
<i ><a href='temp#nt:requires-clause'>requires-clause</a></i><span class='textit'>s</span> and the corresponding
<i ><a href='temp.constr.decl#nt:constraint-expression'>constraint-expression</a></i><span class='textit'>s</span> are equivalent<a class='hidden_link' href='#temp.over.link-6.sentence-1'>.</a></div> <div id='temp.over.link-6.sentence-2' class='sentence'>Two <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span> are
<a class='hidden_link' href='#def:equivalent,template-parameters' id='def:equivalent,template-parameters'><i >equivalent</i></a>
under the following conditions:
<ul class='itemize'><li id='temp.over.link-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.over.link-6.1'>(6.1)</a></div><div id='temp.over.link-6.1.sentence-1' class='sentence'>they declare template parameters of the same kind,</div></li><li id='temp.over.link-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.over.link-6.2'>(6.2)</a></div><div id='temp.over.link-6.2.sentence-1' class='sentence'>if either declares a template parameter pack, they both do,</div></li><li id='temp.over.link-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.over.link-6.3'>(6.3)</a></div><div id='temp.over.link-6.3.sentence-1' class='sentence'>if they declare non-type template parameters, they have
equivalent types,</div></li><li id='temp.over.link-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.over.link-6.4'>(6.4)</a></div><div id='temp.over.link-6.4.sentence-1' class='sentence'>if they declare template template parameters, their template
parameters are equivalent, and</div></li><li id='temp.over.link-6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.over.link-6.5'>(6.5)</a></div><div id='temp.over.link-6.5.sentence-1' class='sentence'>if either is declared with a <i ><a href='temp.param#nt:qualified-concept-name'>qualified-concept-name</a></i>,
they both are, and the <i ><a href='temp.param#nt:qualified-concept-name'>qualified-concept-name</a></i><span class='textit'>s</span> are
equivalent<a class='hidden_link' href='#temp.over.link-6.5.sentence-1'>.</a></div></li></ul></div> <div id='temp.over.link-6.sentence-3' class='sentence'>
When determining whether types or <i ><a href='temp.param#nt:qualified-concept-name'>qualified-concept-name</a></i><span class='textit'>s</span>
are equivalent, the rules above are used to compare expressions
involving template parameters<a class='hidden_link' href='#temp.over.link-6.sentence-3'>.</a></div> <div id='temp.over.link-6.sentence-4' class='sentence'>Two <i ><a href='temp#nt:template-head'>template-head</a></i><span class='textit'>s</span> are
<a class='hidden_link' href='#def:functionally_equivalent,template-heads' id='def:functionally_equivalent,template-heads'><i >functionally equivalent</i></a>
if they accept and are satisfied by (<a href='temp.constr.constr'>[temp.constr.constr]</a>)
the same set of template argument lists<a class='hidden_link' href='#temp.over.link-6.sentence-4'>.</a></div></div><div class='para' id='temp.over.link-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3690'>#</a></div><div id='temp.over.link-7.sentence-1' class='sentence'>Two function templates are
<a class='hidden_link' href='#def:equivalent,function_templates' id='def:equivalent,function_templates'><i >equivalent</i></a>
if they
are declared in the same scope,
have the same name,
have equivalent <i ><a href='temp#nt:template-head'>template-head</a></i><span class='textit'>s</span>,
and
have return types, parameter lists,
and trailing <i ><a href='temp#nt:requires-clause'>requires-clause</a></i><span class='textit'>s</span> (if any)
that are equivalent using the rules described above to compare
expressions involving
template parameters<a class='hidden_link' href='#temp.over.link-7.sentence-1'>.</a></div> <div id='temp.over.link-7.sentence-2' class='sentence'>Two function templates are
<a class='hidden_link' href='#def:functionally_equivalent,function_templates' id='def:functionally_equivalent,function_templates'><i >functionally equivalent</i></a>
if they
are declared in the same scope,
have the same name,
accept and are satisfied by the same set of template argument lists,
and
have return types and parameter lists that
are functionally equivalent using the rules described above to
compare expressions involving
template parameters<a class='hidden_link' href='#temp.over.link-7.sentence-2'>.</a></div> <div id='temp.over.link-7.sentence-3' class='sentence'>If the validity or meaning of the program depends on
whether two constructs are equivalent, and they are
functionally equivalent but not equivalent, the program is ill-formed,
no diagnostic required<a class='hidden_link' href='#temp.over.link-7.sentence-3'>.</a></div></div><div class='para' id='temp.over.link-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.over.link-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3722'>#</a></div><div id='temp.over.link-8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.over.link-8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.over.link-8.sentence-1' class='sentence'>This rule guarantees that equivalent declarations will be linked with
one another, while not requiring implementations to use heroic efforts
to guarantee that functionally equivalent declarations will be treated
as distinct<a class='hidden_link' href='#temp.over.link-8.sentence-1'>.</a></div> <div id='temp.over.link-8.sentence-2' class='sentence'>For example, the last two declarations are functionally
equivalent and would cause a program to be ill-formed:</div><pre class='codeblock'>
<span class='comment'>// guaranteed to be the same
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);

<span class='comment'>// guaranteed to be different
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+11&gt;);

<span class='comment'>// ill-formed, no diagnostic required
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);</pre> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div></div><div id='temp.func.order' class='section'><h4 ><a class='secnum' href='#temp.func.order' style='min-width:118pt'>12.6.6.2</a> Partial ordering of function templates <a class='abbr_ref' href='temp.func.order'>[temp.func.order]</a></h4><div class='para' id='temp.func.order-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3748'>#</a></div><div id='temp.func.order-1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,resolution,template'></a></span>If a function template is overloaded,
the use of a function template specialization might be ambiguous because
<a href='temp.deduct'>template argument deduction</a> may associate the function
template specialization with more than one function template declaration<a class='hidden_link' href='#temp.func.order-1.sentence-1'>.</a></div> <div id='temp.func.order-1.sentence-2' class='sentence'><a class='hidden_link' href='#def:template,function,partial_ordering' id='def:template,function,partial_ordering'><i >Partial ordering</i></a>
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:</div><div id='temp.func.order-1.sentence-3' class='sentence'><ul class='itemize'><li id='temp.func.order-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.1'>(1.1)</a></div><div id='temp.func.order-1.1.sentence-1' class='sentence'>during overload resolution for a call to a function template specialization (<a href='over.match.best'>[over.match.best]</a>);</div></li><li id='temp.func.order-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.2'>(1.2)</a></div><div id='temp.func.order-1.2.sentence-1' class='sentence'>when the address of a function template specialization is taken;</div></li><li id='temp.func.order-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.3'>(1.3)</a></div><div id='temp.func.order-1.3.sentence-1' class='sentence'>when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>);</div></li><li id='temp.func.order-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.func.order-1.4'>(1.4)</a></div><div id='temp.func.order-1.4.sentence-1' class='sentence'>when a <a href='temp.friend'>friend function declaration</a>, an
<a href='temp.explicit'>explicit instantiation</a> or an <a href='temp.expl.spec'>explicit specialization</a> refers to
a function template specialization<a class='hidden_link' href='#temp.func.order-1.4.sentence-1'>.</a></div></li></ul></div></div><div class='para' id='temp.func.order-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3776'>#</a></div><div id='temp.func.order-2.sentence-1' class='sentence'>Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type<a class='hidden_link' href='#temp.func.order-2.sentence-1'>.</a></div> <div id='temp.func.order-2.sentence-2' class='sentence'>The deduction process determines whether
one of the templates is more specialized than the other<a class='hidden_link' href='#temp.func.order-2.sentence-2'>.</a></div> <div id='temp.func.order-2.sentence-3' class='sentence'>If so, the
more specialized template is the one chosen by the partial ordering
process<a class='hidden_link' href='#temp.func.order-2.sentence-3'>.</a></div> <div id='temp.func.order-2.sentence-4' class='sentence'>If both deductions succeed, the partial ordering selects
the more constrained template as described by the rules in
<a href='temp.constr.order'>[temp.constr.order]</a><a class='hidden_link' href='#temp.func.order-2.sentence-4'>.</a></div></div><div class='para' id='temp.func.order-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3789'>#</a></div><div id='temp.func.order-3.sentence-1' class='sentence'>To produce the transformed template, for each type, non-type, or template
template parameter (including
<a href='temp.variadic#def:template_parameter_pack'>template parameter packs</a>
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template<a class='hidden_link' href='#temp.func.order-3.sentence-1'>.</a></div> <div id='temp.func.order-3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.func.order-3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.func.order-3.sentence-2' class='sentence'>The type replacing the placeholder
in the type of the value synthesized for a non-type template parameter
is also a unique synthesized type<a class='hidden_link' href='#temp.func.order-3.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.func.order-3.sentence-3' class='sentence'>
If only one of the function templates <span class='textit'>M</span> is a non-static
member of some class <span class='textit'>A</span>, <span class='textit'>M</span> is considered to have
a new first parameter inserted in its function
parameter list<a class='hidden_link' href='#temp.func.order-3.sentence-3'>.</a></div> <div id='temp.func.order-3.sentence-4' class='sentence'>Given <span class='mathit'>cv</span> as the cv-qualifiers of <span class='textit'>M</span>
(if any), the new parameter is of type “rvalue reference to
<span class='mathit'>cv</span> <span class='textit'>A</span>” if the optional <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> of
<span class='textit'>M</span> is <span class='texttt'>&amp;&amp;</span> or if <span class='textit'>M</span> has no
<i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> and the first parameter of the other
template has rvalue reference type<a class='hidden_link' href='#temp.func.order-3.sentence-4'>.</a></div> <div id='temp.func.order-3.sentence-5' class='sentence'>Otherwise, the new parameter is
of type “lvalue reference to <span class='mathit'>cv</span> <span class='textit'>A</span>”<a class='hidden_link' href='#temp.func.order-3.sentence-5'>.</a></div> <div id='temp.func.order-3.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.func.order-3.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.func.order-3.sentence-6' class='sentence'>This allows a non-static
member to be ordered with respect to a non-member function and for the results
to be equivalent to the ordering of two equivalent non-members<a class='hidden_link' href='#temp.func.order-3.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.func.order-3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.func.order-3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { };
template&lt;class T&gt; struct B {
  template&lt;class R&gt; int operator*(R&amp;);              <span class='comment'>// #1
</span>};

template&lt;class T, class R&gt; int operator*(T&amp;, R&amp;);   <span class='comment'>// #2
</span>
<span class='comment'>// The declaration of <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;operator*</span> is transformed into the equivalent of
</span><span class='comment'>// <span class='tcode_in_codeblock'>template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;// #1a
</span>
int main() {
  A a;
  B&lt;A&gt; b;
  b * a;                                            <span class='comment'>// calls #1a
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='temp.func.order-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3834'>#</a></div><div id='temp.func.order-4.sentence-1' class='sentence'>Using the transformed function template's function type,
perform type deduction against the other template as described in <a href='temp.deduct.partial'>[temp.deduct.partial]</a><a class='hidden_link' href='#temp.func.order-4.sentence-1'>.</a></div><div style='height:0.6em;display:block'></div><div id='temp.func.order-4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.func.order-4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T&gt; struct A { A(); };

template&lt;class T&gt; void f(T);
template&lt;class T&gt; void f(T*);
template&lt;class T&gt; void f(const T*);

template&lt;class T&gt; void g(T);
template&lt;class T&gt; void g(T&amp;);

template&lt;class T&gt; void h(const T&amp;);
template&lt;class T&gt; void h(A&lt;T&gt;&amp;);

void m() {
  const int* p;
  f(p);             <span class='comment'>// <span class='tcode_in_codeblock'>f(const T*)</span> is more specialized than <span class='tcode_in_codeblock'>f(T)</span> or <span class='tcode_in_codeblock'>f(T*)</span>
</span>  float x;
  g(x);             <span class='comment'>// ambiguous: <span class='tcode_in_codeblock'>g(T)</span> or <span class='tcode_in_codeblock'>g(T&amp;)</span>
</span>  A&lt;int&gt; z;
  h(z);             <span class='comment'>// overload resolution selects <span class='tcode_in_codeblock'>h(A&lt;T&gt;&amp;)</span>
</span>  const A&lt;int&gt; z2;
  h(z2);            <span class='comment'>// <span class='tcode_in_codeblock'>h(const T&amp;)</span> is called because <span class='tcode_in_codeblock'>h(A&lt;T&gt;&amp;)</span> is not callable
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='temp.func.order-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.func.order-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/templates.tex#L3866'>#</a></div><div id='temp.func.order-5.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#temp.func.order-5.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='temp.func.order-5.sentence-1' class='sentence'>Since partial ordering in a call context considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters)<a class='hidden_link' href='#temp.func.order-5.sentence-1'>.</a></div> <div id='temp.func.order-5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.func.order-5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T&gt; void f(T);                            <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T*, int=1);                    <span class='comment'>// #2
</span>template&lt;class T&gt; void g(T);                            <span class='comment'>// #3
</span>template&lt;class T&gt; void g(T*, ...);                      <span class='comment'>// #4
</span></pre> <pre class='codeblock'>
int main() {
  int* ip;
  f(ip);                                                <span class='comment'>// calls #2
</span>  g(ip);                                                <span class='comment'>// calls #4
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.func.order-5.example-2' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.func.order-5.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T, class U&gt; struct A { };

template&lt;class T, class U&gt; void f(U, A&lt;U, T&gt;* p = 0);   <span class='comment'>// #1
</span>template&lt;         class U&gt; void f(U, A&lt;U, U&gt;* p = 0);   <span class='comment'>// #2
</span>template&lt;class T         &gt; void g(T, T = T());          <span class='comment'>// #3
</span>template&lt;class T, class... U&gt; void g(T, U ...);         <span class='comment'>// #4
</span>
void h() {
  f&lt;int&gt;(42, (A&lt;int, int&gt;*)0);                          <span class='comment'>// calls #2
</span>  f&lt;int&gt;(42);                                           <span class='comment'>// error: ambiguous
</span>  g(42);                                                <span class='comment'>// error: ambiguous
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='temp.func.order-5.example-3' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#temp.func.order-5.example-3'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T, U...);          <span class='comment'>// #1
</span>template&lt;class T            &gt; void f(T);                <span class='comment'>// #2
</span>template&lt;class T, class... U&gt; void g(T*, U...);         <span class='comment'>// #3
</span>template&lt;class T            &gt; void g(T);                <span class='comment'>// #4
</span>
void h(int i) {
  f(&amp;i);                                                <span class='comment'>// error: ambiguous
</span>  g(&amp;i);                                                <span class='comment'>// OK: calls #3
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div></div></div></body></html>