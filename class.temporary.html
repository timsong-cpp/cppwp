<!DOCTYPE html><html lang='en'><head><title>[class.temporary]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.temporary'><h2 ><a class='secnum' style='min-width:88pt'>12.2</a> Temporary objects <a class='abbr_ref'>[class.temporary]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L372'>#</a></div><p ><span class='indexparent'><a class='index' id='object_temporary'></a></span><span class='indexparent'><a class='index' id='temporary'></a></span><span class='indexparent'><a class='index' id='optimization_of_temporary'></a></span><span class='indexparent'><a class='index' id='temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id='temporary,implementation-defined_generation_of'></a></span>Temporary objects are created
</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >when a prvalue is materialized so that it can be used as a glvalue (<a href='conv.rval'>[conv.rval]</a>),
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >when needed by the implementation to pass or return an object of trivially-copyable type (see below),
and
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >when throwing an exception (<a href='except.throw'>[except.throw]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The lifetime of exception objects is described in <a href='except.throw'>[except.throw]</a>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul><p >Even when the creation of the temporary object is
unevaluated (Clause <a href='expr'>[expr]</a>),
all the semantic restrictions shall be respected as if the temporary object
had been created and later destroyed.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This includes accessibility (<a href='class.access'>[class.access]</a>) and whether it is deleted,
for the constructor selected and for the destructor. However, in the special
case of the operand of a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> (<a href='expr.call'>[expr.call]</a>), no temporary is introduced,
so the foregoing does not apply to such a prvalue.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L403'>#</a></div><p >The materialization of a temporary object is generally
delayed as long as possible
in order to avoid creating unnecessary temporary objects.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Temporary objects are materialized:
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >when binding a reference to a prvalue (<a href='dcl.init.ref'>[dcl.init.ref]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>,
<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>, <a href='expr.const.cast'>[expr.const.cast]</a>, <a href='expr.cast'>[expr.cast]</a>),
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >when performing member access on a class prvalue (<a href='expr.ref'>[expr.ref]</a>, <a href='expr.mptr.oper'>[expr.mptr.oper]</a>),
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >when performing an array-to-pointer conversion or subscripting on an array prvalue (<a href='conv.array'>[conv.array]</a>, <a href='expr.sub'>[expr.sub]</a>),
</p></li><li id='2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.4'>(2.4)</a></div><p >when initializing an object of type <span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;T&gt;</span> from a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>),
</p></li><li id='2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.5'>(2.5)</a></div><p >for certain unevaluated operands (<a href='expr.typeid'>[expr.typeid]</a>, <a href='expr.sizeof'>[expr.sizeof]</a>), and
</p></li><li id='2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.6'>(2.6)</a></div><p >when a prvalue appears as a discarded-value expression (Clause <a href='expr'>[expr]</a>).
</p></li></ul><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i> Consider the following code:
</p><pre class='codeblock'>
class X {
public:
  X(int);
  X(const X&amp;);
  X&amp; operator=(const X&amp;);
  ~X();
};

class Y {
public:
  Y(int);
  Y(Y&amp;&amp;);
  ~Y();
};

X f(X);
Y g(Y);

void h() {
  X a(1);
  X b = f(X(2));
  Y c = g(Y(3));
  a = f(a);
}</pre><p ><span class='indexparent'><a class='index' id='class_object_copy'></a></span><span class='indexparent'><a class='index' id='constructor,copy'></a></span><span class='texttt'>X(2)</span> is constructed in the space used to hold <span class='texttt'>f()</span>'s argument and
<span class='texttt'>Y(3)</span> is constructed in the space used to hold <span class='texttt'>g()</span>'s argument.
Likewise,
<span class='texttt'>f()</span>'s result is constructed directly in <span class='texttt'>b</span> and
<span class='texttt'>g()</span>'s result is constructed directly in <span class='texttt'>c</span>.
On the other hand, the expression
<span class='texttt'>a = f(a)</span>
requires a temporary for
the result of <span class='texttt'>f(a)</span>,
which is materialized so that the reference parameter
of <span class='texttt'>A&#x200b;::&#x200b;operator=(const A&amp;)</span> can bind to it.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L468'>#</a></div><p >When an object of class type <span class='texttt'>X</span>
is passed to or returned from a function,
if each copy constructor, move constructor, and destructor of <span class='texttt'>X</span>
is either trivial or deleted,
and <span class='texttt'>X</span>
has at least one non-deleted copy or move constructor,
implementations are permitted
to create a temporary object
to hold the function parameter or result object.
The temporary object is constructed
from the function argument or return value, respectively,
and the function's parameter or return object
is initialized as if by
using the non-deleted trivial constructor to copy the temporary
(even if that constructor is inaccessible
or would not be selected by overload resolution
to perform a copy or move of the object).
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This latitude is granted to allow objects of class type to be passed to or returned from functions in registers.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L490'>#</a></div><p ><span class='indexparent'><a class='index' id='temporary,constructor_for'></a></span><span class='indexparent'><a class='index' id='temporary,destructor_for'></a></span><span class='indexparent'><a class='index' id='temporary,destruction_of'></a></span>When an implementation introduces a temporary object of a class that has a
non-trivial constructor (<a href='class.ctor'>[class.ctor]</a>, <a href='class.copy'>[class.copy]</a>), it shall ensure that
a constructor is called for the temporary object.
Similarly, the destructor shall be called for a temporary with a non-trivial
destructor (<a href='class.dtor'>[class.dtor]</a>).
Temporary objects are destroyed as the last step
in evaluating
the full-expression (<a href='intro.execution'>[intro.execution]</a>)
that (lexically) contains the point where
they were created.
This is true even if that evaluation ends in throwing an exception.
The
<span class='indexparent'><a class='index' id='value_computation'></a></span>value computations and
<span class='indexparent'><a class='index' id='side_effects'></a></span>side effects of destroying a temporary object
are associated only with the full-expression, not with any specific
subexpression.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L513'>#</a></div><p ><span class='indexparent'><a class='index' id='initializer,temporary_and_declarator'></a></span><span class='indexparent'><a class='index' id='temporary,order_of_destruction_of'></a></span>There are three contexts in which temporaries are destroyed at a different
point than the end of the full-expression.
The first context is when a default constructor is called to initialize
an element of an array with no corresponding initializer (<a href='dcl.init'>[dcl.init]</a>).
The second context is when a copy constructor is called to copy an element of
an array while the entire array is copied (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>, <a href='class.copy'>[class.copy]</a>).
In either case, if the constructor has one or more default arguments,
the destruction of every temporary created in a default argument is
sequenced before the construction of the next array element, if any.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L526'>#</a></div><p >The third context is when a reference is bound to a
temporary.<a class='footnotenum' href='#footnote-116'>116</a>
The temporary to which the reference is bound or the temporary
that is the complete object of a subobject to which the reference is bound
persists for the lifetime of the reference except:</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >A temporary object bound to a reference parameter in a function call (<a href='expr.call'>[expr.call]</a>)
persists until the completion of the full-expression containing the call.</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >The lifetime of a temporary bound to the returned value in a function return statement (<a href='stmt.return'>[stmt.return]</a>) is not extended; the temporary is destroyed at the end of the full-expression in the return statement.</p></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div><p >A temporary bound to a reference in a <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i> (<a href='expr.new'>[expr.new]</a>) persists until the completion of the full-expression containing the <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i>. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} };   <span class='comment'>// Creates dangling reference
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>] [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> This may introduce a dangling reference, and implementations are encouraged to issue a warning in such a case. <i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L550'>#</a></div><p >The destruction of a temporary whose lifetime is not extended by being
bound to a reference is sequenced before the destruction of every
temporary which is constructed earlier in the same full-expression.
If the lifetime of two or more temporaries to which references are bound ends
at the same point,
these temporaries are destroyed at that point in the reverse order of the
completion of their construction.
In addition, the destruction of temporaries bound to references shall
take into account the ordering of destruction of objects with static, thread, or
automatic storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>, <a href='basic.stc.thread'>[basic.stc.thread]</a>, <a href='basic.stc.auto'>[basic.stc.auto]</a>);
that is, if
<span class='texttt'>obj1</span>
is an object with the same storage duration as the temporary and
created before the temporary is created 
the temporary shall be destroyed before
<span class='texttt'>obj1</span>
is destroyed;
if
<span class='texttt'>obj2</span>
is an object with the same storage duration as the temporary and
created after the temporary is created
the temporary shall be destroyed after
<span class='texttt'>obj2</span>
is destroyed.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/08fda7e637d27fa331a8fcfc64db98d52ae3b6fd/source/special.tex#L576'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
struct S {
  S();
  S(int);
  friend S operator+(const S&amp;, const S&amp;);
  ~S();
};
S obj1;
const S&amp; cr = S(16)+S(23);
S obj2;</pre><p >the expression
<span class='texttt'>S(16) + S(23)</span>
creates three temporaries:
a first temporary
<span class='texttt'>T1</span>
to hold the result of the expression
<span class='texttt'>S(16)</span>,
a second temporary
<span class='texttt'>T2</span>
to hold the result of the expression
<span class='texttt'>S(23)</span>,
and a third temporary
<span class='texttt'>T3</span>
to hold the result of the addition of these two expressions.
The temporary
<span class='texttt'>T3</span>
is then bound to the reference
<span class='texttt'>cr</span>.
It is unspecified whether
<span class='texttt'>T1</span>
or
<span class='texttt'>T2</span>
is created first.
On an implementation where
<span class='texttt'>T1</span>
is created before
<span class='texttt'>T2</span>,
<span class='texttt'>T2</span>
shall be destroyed before
<span class='texttt'>T1</span>.
The temporaries
<span class='texttt'>T1</span>
and
<span class='texttt'>T2</span>
are bound to the reference parameters of
<span class='texttt'>operator+</span>;
these temporaries are destroyed at the end of the full-expression
containing the call to
<span class='texttt'>operator+</span>.
The temporary
<span class='texttt'>T3</span>
bound to the reference
<span class='texttt'>cr</span>
is destroyed at the end of
<span class='texttt'>cr</span>'s
lifetime, that is, at the end of the program.
In addition, the order in which
<span class='texttt'>T3</span>
is destroyed takes into account the destruction order of other objects with
static storage duration.
That is, because
<span class='texttt'>obj1</span>
is constructed before
<span class='texttt'>T3</span>,
and
<span class='texttt'>T3</span>
is constructed before
<span class='texttt'>obj2</span>,
<span class='texttt'>obj2</span>
shall be destroyed before
<span class='texttt'>T3</span>,
and
<span class='texttt'>T3</span>
shall be destroyed before
<span class='texttt'>obj1</span>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-116'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-116'>116)</a></div><p >The same rules apply to initialization of an
  <span class='texttt'>initializer_&shy;list</span> object (<a href='dcl.init.list'>[dcl.init.list]</a>) with its
  underlying temporary array.</p></div></div></div></body></html>