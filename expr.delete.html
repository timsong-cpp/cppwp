<!DOCTYPE html><html lang='en'><head><title>[expr.delete]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Compound expressions <a class='abbr_ref' href='expr.compound#expr.delete'>[expr.compound]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>8.5.2</a> Unary expressions <a class='abbr_ref' href='expr.unary#expr.delete'>[expr.unary]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>8.5.2.5</a> Delete <a class='abbr_ref'>[expr.delete]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4198'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':expression,delete'></a></span><span class='indexparent'><a class='index' id=':delete'></a></span>The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> operator destroys a
<a href='intro.object#def:most_derived_object'>most derived object</a> or array created by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i><a class='hidden_link' href='#1.sentence-1'>.</a></div><pre class='bnf'><a class='nontermdef' href='#nt:delete-expression' id='nt:delete-expression'>delete-expression:</a>
&#9;<span class='terminal'>::</span><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
&#9;<span class='terminal'>::</span><span class="mjx-chtml"><span class="mjx-math" aria-label="_\mathit{opt}"><span class="mjx-mrow" aria-hidden="true"><span class="mjx-msubsup"><span class="mjx-base"><span class="mjx-mi"><span class="mjx-char"></span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span class="mjx-texatom"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.298em;">o</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.225em; padding-bottom: 0.446em;">p</span></span><span class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.372em; padding-bottom: 0.298em;">t</span></span></span></span></span></span></span></span></span> <span class='terminal'>delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
</pre><div id='1.sentence-2' class='sentence'>The first alternative is a
<a class='hidden_link' href='#def:delete,single-object' id='def:delete,single-object'><i >single-object delete expression</i></a>, and the
second is an <a class='hidden_link' href='#def:delete,array' id='def:delete,array'><i >array delete expression</i></a><a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>Whenever the <span class='texttt'>delete</span> keyword is immediately followed by empty square
brackets, it shall be interpreted as the second alternative<a class='hidden_link' href='#1.sentence-3'>.</a><a class='footnotenum' href='#footnote-81'>81</a></div> <div id='1.sentence-4' class='sentence'>
The operand shall be of pointer to object type or of class type<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>If of
class type, the operand is <a href='conv#def:contextually_implicitly_converted'>contextually implicitly converted</a>
to a pointer to object
type<a class='hidden_link' href='#1.sentence-5'>.</a><a class='footnotenum' href='#footnote-82'>82</a></div> <div id='1.sentence-6' class='sentence'>
The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>'s result has type
<span class='texttt'>void</span><a class='hidden_link' href='#1.sentence-6'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4228'>#</a></div><div id='2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':delete,single-object'></a></span>If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this subclause<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>In a single-object delete expression, the value of the operand of
<span class='texttt'>delete</span> may be a null pointer value, a pointer to a non-array object
created by a previous <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a pointer to a
<a href='intro.object#def:subobject'>subobject</a> representing a
<a href='class.derived'>base class</a> of such an
object<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>If not, the behavior is undefined<a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.sentence-4' class='sentence'><span class='indexparent'><a class='index' id=':array,delete'></a></span>In an array delete expression, the value of the operand of <span class='texttt'>delete</span>
may be a null pointer value or a pointer value that resulted from
a previous array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i><a class='hidden_link' href='#2.sentence-4'>.</a><a class='footnotenum' href='#footnote-83'>83</a></div> <div id='2.sentence-5' class='sentence'>
If not, the behavior is undefined<a class='hidden_link' href='#2.sentence-5'>.</a></div> <div id='2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-6' class='sentence'>This means that the syntax of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> must
match the type of the object allocated by <span class='texttt'>new</span>, not the syntax of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i><a class='hidden_link' href='#2.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='2.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-7' class='sentence'>A pointer to a <span class='texttt'>const</span> type can be the operand of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>; it is not necessary to
<a href='expr.const.cast#def:casting_away_constness'>cast away the constness</a>
of the pointer expression before it is
used as the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i><a class='hidden_link' href='#2.sentence-7'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4262'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':delete,undefined'></a></span>In a single-object delete expression, if the static type of the object to be
deleted is different from its dynamic type, the static type shall be a base
class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>In an array delete
expression, if the dynamic type of the object to be deleted differs from its
static type, the behavior is undefined<a class='hidden_link' href='#3.sentence-2'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4271'>#</a></div><div id='4.sentence-1' class='sentence'>The <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall
be evaluated exactly once<a class='hidden_link' href='#4.sentence-1'>.</a></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4275'>#</a></div><div id='5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':type,incomplete'></a></span>If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined<a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4281'>#</a></div><div id='6.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':delete,destructor_and'></a></span>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will invoke the
destructor (if any) for the object or the elements of the array being
deleted<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see <a href='class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#6.sentence-2'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4290'>#</a></div><div id='7.sentence-1' class='sentence'>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, then:</div><div id='7.sentence-2' class='sentence'><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><div id='7.1.sentence-1' class='sentence'>If the allocation call for the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> for the object to
be deleted was not omitted and the allocation was not extended (<a href='expr.new'>[expr.new]</a>), the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a <a href='basic.stc.dynamic.deallocation'>deallocation
function</a><a class='hidden_link' href='#7.1.sentence-1'>.</a></div> <div id='7.1.sentence-2' class='sentence'>The value returned from the
allocation call of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> shall be passed as the
first argument to the deallocation function<a class='hidden_link' href='#7.1.sentence-2'>.</a></div></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><div id='7.2.sentence-1' class='sentence'>Otherwise, if the allocation was extended or was provided by extending the
allocation of another <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>, and the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> for every other pointer value produced by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that had storage provided by the extended
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> has been evaluated, the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a deallocation function<a class='hidden_link' href='#7.2.sentence-1'>.</a></div> <div id='7.2.sentence-2' class='sentence'>The value
returned from the allocation call of the extended <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
shall be passed as the first argument to the deallocation function<a class='hidden_link' href='#7.2.sentence-2'>.</a></div></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><div id='7.3.sentence-1' class='sentence'>Otherwise, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will not call a
deallocation function<a class='hidden_link' href='#7.3.sentence-1'>.</a></div></li></ul></div> <div id='7.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#7.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='7.sentence-4' class='sentence'>The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception<a class='hidden_link' href='#7.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='7.sentence-3' class='sentence'>
If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is a
null pointer value, it is unspecified whether a deallocation function will be
called as described above<a class='hidden_link' href='#7.sentence-3'>.</a></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4325'>#</a></div><div id='8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='8.sentence-1' class='sentence'>An implementation provides default definitions of the global
deallocation functions <span class='texttt'>operator delete</span> for
non-arrays (<a href='new.delete.single'>[new.delete.single]</a>) and
<span class='indexparent'><a class='index' id=':operator_delete'></a></span><span class='texttt'>operator delete[]</span> for arrays (<a href='new.delete.array'>[new.delete.array]</a>)<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.sentence-2' class='sentence'>A C++
program can provide alternative definitions of these
functions (<a href='replacement.functions'>[replacement.functions]</a>), and/or class-specific
versions (<a href='class.free'>[class.free]</a>)<a class='hidden_link' href='#8.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4337'>#</a></div><div id='9.sentence-1' class='sentence'>When the keyword <span class='texttt'>delete</span> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is
preceded by the unary <span class='texttt'>&#x200b;::&#x200b;</span> operator, the deallocation function's name is looked
up in global scope<a class='hidden_link' href='#9.sentence-1'>.</a></div> <div id='9.sentence-2' class='sentence'>Otherwise, the lookup considers class-specific deallocation
functions (<a href='class.free'>[class.free]</a>)<a class='hidden_link' href='#9.sentence-2'>.</a></div> <div id='9.sentence-3' class='sentence'>If no class-specific deallocation function is found,
the deallocation function's name is looked up in global scope<a class='hidden_link' href='#9.sentence-3'>.</a></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4344'>#</a></div><div id='10.sentence-1' class='sentence'>If deallocation function lookup finds more than one usual
deallocation function,
the function to be called is selected as follows:
<ul class='itemize'><li id='10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.1'>(10.1)</a></div><div id='10.1.sentence-1' class='sentence'>If the type has new-extended alignment,
a function with a parameter of type <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span> is preferred;
otherwise a function without such a parameter is preferred<a class='hidden_link' href='#10.1.sentence-1'>.</a></div> <div id='10.1.sentence-2' class='sentence'>If exactly one preferred function is found,
that function is selected and the selection process terminates<a class='hidden_link' href='#10.1.sentence-2'>.</a></div> <div id='10.1.sentence-3' class='sentence'>If more than one preferred function is found,
all non-preferred functions are eliminated from further consideration<a class='hidden_link' href='#10.1.sentence-3'>.</a></div></li><li id='10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.2'>(10.2)</a></div><div id='10.2.sentence-1' class='sentence'>If the deallocation functions have class scope,
the one without a parameter of type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> is selected<a class='hidden_link' href='#10.2.sentence-1'>.</a></div></li><li id='10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.3'>(10.3)</a></div><div id='10.3.sentence-1' class='sentence'>If the type is complete and if, for the second alternative (delete
array) only, the operand is a pointer to a class type with a
non-trivial destructor or a (possibly multi-dimensional) array thereof,
the function with a parameter of type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> is selected<a class='hidden_link' href='#10.3.sentence-1'>.</a></div></li><li id='10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.4'>(10.4)</a></div><div id='10.4.sentence-1' class='sentence'>Otherwise, it is unspecified
whether a deallocation function with a parameter of type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>
is selected<a class='hidden_link' href='#10.4.sentence-1'>.</a></div></li></ul></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4371'>#</a></div><div id='11.sentence-1' class='sentence'>When a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
is executed, the selected deallocation function shall be called with
the address of the most-derived object in a single-object delete expression, or
the address of the object suitably adjusted for the array allocation
overhead (<a href='expr.new'>[expr.new]</a>) in an array delete expression,
as its first argument<a class='hidden_link' href='#11.sentence-1'>.</a></div> <div id='11.sentence-2' class='sentence'>If a deallocation function
with a parameter of type <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>
is used,
the alignment of the type of the object to be deleted
is passed as the corresponding argument<a class='hidden_link' href='#11.sentence-2'>.</a></div> <div id='11.sentence-3' class='sentence'>If a deallocation function
with a parameter of type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> is used,
the size
of the most-derived type, or
of the array plus allocation overhead, respectively,
is passed as the corresponding argument<a class='hidden_link' href='#11.sentence-3'>.</a><a class='footnotenum' href='#footnote-84'>84</a></div> <div id='11.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#11.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='11.sentence-4' class='sentence'>If this results in a call to a usual deallocation function, and either
the first argument was not the result of
a prior call to a usual allocation function or
the second argument was not the corresponding argument in said call,
the behavior is undefined (<a href='new.delete.single'>[new.delete.single]</a>, <a href='new.delete.array'>[new.delete.array]</a>)<a class='hidden_link' href='#11.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/0c0e0c3a740c133e1d25bfdbe141a3128d77a381/source/expressions.tex#L4400'>#</a></div><div id='12.sentence-1' class='sentence'>Access and ambiguity control are done for both the deallocation function
and the destructor (<a href='class.dtor'>[class.dtor]</a>, <a href='class.free'>[class.free]</a>)<a class='hidden_link' href='#12.sentence-1'>.</a></div></div><div class='footnote' id='footnote-81'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-81'>81)</a></div><div id='footnote-81.sentence-1' class='sentence'>A lambda
expression with a <i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> that consists of empty square
brackets can follow the <span class='texttt'>delete</span> keyword if the lambda expression is
enclosed in parentheses<a class='hidden_link' href='#footnote-81.sentence-1'>.</a></div></div><div class='footnote' id='footnote-82'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-82'>82)</a></div><div id='footnote-82.sentence-1' class='sentence'>This implies that an object
cannot be deleted using a pointer of type
<span class='texttt'>void*</span> because <span class='texttt'>void</span> is not an object type<a class='hidden_link' href='#footnote-82.sentence-1'>.</a></div></div><div class='footnote' id='footnote-83'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-83'>83)</a></div><div id='footnote-83.sentence-1' class='sentence'>For nonzero-length
arrays, this is the same as a pointer to the first
element of the array created by that <i ><a href='expr.new#nt:new-expression'>new-expression</a></i><a class='hidden_link' href='#footnote-83.sentence-1'>.</a></div> <div id='footnote-83.sentence-2' class='sentence'>Zero-length arrays do not have a first element<a class='hidden_link' href='#footnote-83.sentence-2'>.</a></div></div><div class='footnote' id='footnote-84'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-84'>84)</a></div><div id='footnote-84.sentence-1' class='sentence'>If the static type of the object to be deleted is complete
and is different from the dynamic type, and the destructor is not virtual, the size might
be incorrect, but that case is already undefined, as stated above<a class='hidden_link' href='#footnote-84.sentence-1'>.</a></div></div></div></body></html>