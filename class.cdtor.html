<!DOCTYPE html><html lang='en'><head><title>[class.cdtor]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.cdtor'><h2 ><a class='secnum' style='min-width:88pt'>12.7</a> Construction and destruction <a class='abbr_ref'>[class.cdtor]</a></h2><p ><span class='indexparent'><a class='index' id='construction'></a></span><span class='indexparent'><a class='index' id='destruction'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/special.tex#L2176'>#</a></div><p ><span class='indexparent'><a class='index' id='construction,member_access'></a></span><span class='indexparent'><a class='index' id='destruction,member_access'></a></span>For an object with a non-trivial constructor, referring to any non-static member
or base class of the object before the constructor begins execution results in
undefined behavior. For an object with a non-trivial destructor, referring to
any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct X { int i; };
struct Y : X { Y(); };                  <span class='comment'>// non-trivial
</span>struct A { int a; };
struct B : public A { int j; Y y; };    <span class='comment'>// non-trivial
</span>
extern B bobj;
B* pb = &amp;bobj;                          <span class='comment'>// OK
</span>int* p1 = &amp;bobj.a;                      <span class='comment'>// undefined, refers to base class member
</span>int* p2 = &amp;bobj.y.i;                    <span class='comment'>// undefined, refers to member's member
</span>
A* pa = &amp;bobj;                          <span class='comment'>// undefined, upcast to a base class type
</span>B bobj;                                 <span class='comment'>// definition of <span class='tcode_in_codeblock'>bobj</span>
</span>
extern X xobj;
int* p3 = &amp;xobj.i;                      <span class='comment'>// OK, <span class='tcode_in_codeblock'>X</span> is a trivial class
</span>X xobj;</pre><p >For another example,
</p><pre class='codeblock'>
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() : p(&amp;x.j) {   <span class='comment'>// undefined, <span class='tcode_in_codeblock'>x</span> is not yet constructed
</span>    }
};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/special.tex#L2216'>#</a></div><p ><span class='indexparent'><a class='index' id='construction,pointer_to_member_or_base'></a></span><span class='indexparent'><a class='index' id='destruction,pointer_to_member_or_base'></a></span>To explicitly or implicitly convert a pointer (a glvalue) referring to
an object of class
<span class='texttt'>X</span>
to a pointer (reference) to a direct or indirect base class
<span class='texttt'>B</span>
of
<span class='texttt'>X</span>,
the construction of
<span class='texttt'>X</span>
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
<span class='texttt'>B</span>
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior.
To form a pointer to (or access the value of) a direct non-static member of
an object
<span class='texttt'>obj</span>,
the construction of
<span class='texttt'>obj</span>
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    <span class='comment'>// undefined: upcast from <span class='tcode_in_codeblock'>E*</span> to <span class='tcode_in_codeblock'>A*</span> might use path <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>D*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span>
</span>                    <span class='comment'>// but <span class='tcode_in_codeblock'>D</span> is not constructed
</span>
                    <span class='comment'>// “<span class='tcode_in_codeblock'>D((C*)this)</span>” would be defined: <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>C*</span> is defined because <span class='tcode_in_codeblock'>E()</span> has started,
</span>                    <span class='comment'>// and <span class='tcode_in_codeblock'>C*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span> is defined because <span class='tcode_in_codeblock'>C</span> is fully constructed
</span>
  X(this) {}        <span class='comment'>// defined: upon construction of <span class='tcode_in_codeblock'>X</span>, <span class='tcode_in_codeblock'>C/B/D/A</span> sublattice is fully constructed
</span>};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/special.tex#L2261'>#</a></div><p ><span class='indexparent'><a class='index' id='virtual_function_call,constructor_and'></a></span><span class='indexparent'><a class='index' id='virtual_function_call,destructor_and'></a></span><span class='indexparent'><a class='index' id='construction,virtual_function_call'></a></span><span class='indexparent'><a class='index' id='destruction,virtual_function_call'></a></span>Member functions, including <a href='class.virtual'>virtual functions</a>, can be called
during construction or destruction (<a href='class.base.init'>[class.base.init]</a>).
When a virtual function is called directly or indirectly from a constructor
or from a destructor,
including during the construction or destruction of the class's non-static data
members,
and the object to which the call applies is the object (call it <span class='texttt'>x</span>) under construction or
destruction,
the function called is the
final overrider in the constructor's or destructor's class and not one
overriding it in a more-derived class.
If the virtual function call uses an explicit <a href='expr.ref'>class member access</a>
and the object expression refers to
the complete object of <span class='texttt'>x</span> or one of that object's base class subobjects
but not <span class='texttt'>x</span> or one of its base class subobjects, the behavior
is undefined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V*, A*);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  f();              <span class='comment'>// calls <span class='tcode_in_codeblock'>V&#x200b;::&#x200b;f</span>, not <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span>
</span>  g();              <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>, not <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;g</span>
</span>  v-&gt;g();           <span class='comment'>// <span class='tcode_in_codeblock'>v</span> is base of <span class='tcode_in_codeblock'>B</span>, the call is well-defined, calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>
</span>  a-&gt;f();           <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span>'s type not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/special.tex#L2314'>#</a></div><p ><span class='indexparent'><a class='index' id='construction,typeid'></a></span><span class='indexparent'><a class='index' id='destruction,typeid'></a></span><span class='indexparent'><a class='index' id='typeid,construction_and'></a></span><span class='indexparent'><a class='index' id='typeid,destruction_and'></a></span>The
<a href='expr.typeid'><span class='texttt'>typeid</span>
operator</a> can be used during construction or destruction (<a href='class.base.init'>[class.base.init]</a>).
When
<span class='texttt'>typeid</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or <a href='class.mem#def:default_member_initializer'>default member initializer</a>
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction,
<span class='texttt'>typeid</span>
yields the
<span class='texttt'>std&#x200b;::&#x200b;type_&shy;info</span>
object representing the constructor or destructor's class.
If the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the behavior is undefined.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/special.tex#L2341'>#</a></div><p ><span class='indexparent'><a class='index' id='construction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id='destruction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id='cast,dynamic,construction_and'></a></span><span class='indexparent'><a class='index' id='cast,dynamic,destruction_and'></a></span><a href='expr.dynamic.cast'><span class='texttt'>dynamic_&shy;cast</span>s</a> can be used during construction
or destruction (<a href='class.base.init'>[class.base.init]</a>). When a
<span class='texttt'>dynamic_&shy;cast</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or default member initializer
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class.
If the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
<span class='texttt'>dynamic_&shy;cast</span>
results in undefined behavior.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);        <span class='comment'>// <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*v);           <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>*v</span> has type <span class='tcode_in_codeblock'>V</span>, a base of <span class='tcode_in_codeblock'>B</span> yields <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*a);           <span class='comment'>// undefined behavior: type <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>  dynamic_cast&lt;B*&gt;(v);  <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>v</span> of type <span class='tcode_in_codeblock'>V*</span>, <span class='tcode_in_codeblock'>V</span> base of <span class='tcode_in_codeblock'>B</span> results in <span class='tcode_in_codeblock'>B*</span>
</span>  dynamic_cast&lt;B*&gt;(a);  <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span> has type <span class='tcode_in_codeblock'>A*</span>, <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]

</p></div></div></div></body></html>