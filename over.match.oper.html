<!DOCTYPE html><html lang='en'><head><title>[over.match.oper]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.3</a> Overload resolution <a class='abbr_ref' href='over.match#oper'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>13.3.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs#over.match.oper'>[over.match.funcs]</a></h3><div id='over.match.oper'><h4 ><a class='secnum' style='min-width:118pt'>13.3.1.2</a> Operators in expressions <a class='abbr_ref'>[over.match.oper]</a></h4><p ><span class='indexparent'><a class='index' id='overloading,resolution,operators'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L907'>#</a></div><p >If no operand of an operator in an expression has a type that is a class
or an enumeration, the operator is assumed to be a built-in operator
and interpreted according to Clause <a href='expr'>[expr]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Because
<span class='texttt'>.</span>,
<span class='texttt'>.*</span>,
and
<span class='texttt'>&#x200b;::&#x200b;</span>
cannot be overloaded,
these operators are always built-in operators interpreted according to
Clause <a href='expr'>[expr]</a>.
<span class='texttt'>?:</span>
cannot be overloaded, but the rules in this subclause are used to determine
the conversions to be applied to the second and third operands when they
have class or enumeration type (<a href='expr.cond'>[expr.cond]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
struct String {
  String (const String&amp;);
  String (const char*);
  operator const char* ();
};
String operator + (const String&amp;, const String&amp;);

void f() {
 const char* p= "one" + "two";  <span class='comment'>// ill-formed because neither operand has class or enumeration type
</span> int I = 1 + 1;                 <span class='comment'>// always evaluates to <span class='tcode_in_codeblock'>2</span> even if class or enumeration types exist
</span>                                <span class='comment'>// that would perform the operation.
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L943'>#</a></div><p >If either operand has a type that is a class or an enumeration, a
user-defined operator function might be declared that implements
this operator or a user-defined conversion can be necessary to
convert the operand to a type that is appropriate for a built-in
operator.
In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the
operator.
Therefore, the operator notation is first transformed
to the equivalent function-call notation as summarized in
Table <a href='#tab:over.rel.op.func'>[tab:over.rel.op.func]</a>
(where <span class='texttt'>@</span> denotes one of the operators covered in the specified subclause).
However, the operands are sequenced in the order prescribed
for the built-in operator (Clause <a href='expr'>[expr]</a>).</p><div class='numberedTable' id='tab:over.rel.op.func'>Table <a href='#tab:over.rel.op.func'>12</a> — Relationship between operator and function call notation<br><table ><tr class='rowsep'><td class='left'>

<b>Subclause</b> </td><td class='border left'>   <b>Expression</b> </td><td class='border left'>   <b>As member function</b> </td><td class='border left'>   <b>As non-member function</b> </td></tr><tr class='capsep'><td class='left'> 
<a href='over.unary'>[over.unary]</a>    </td><td class='border left'>   <span class='texttt'>@a</span>   </td><td class='border left'>   <span class='texttt'>(a).operator@ (<span style='white-space:nowrap'>&thinsp;</span>)</span>  </td><td class='border left'>   <span class='texttt'>operator@(a)</span>    </td></tr><tr ><td class='left'>
<a href='over.binary'>[over.binary]</a>   </td><td class='border left'>   <span class='texttt'>a@b</span>  </td><td class='border left'>   <span class='texttt'>(a).operator@ (b)</span>   </td><td class='border left'>   <span class='texttt'>operator@(a, b)</span> </td></tr><tr ><td class='left'>
<a href='over.ass'>[over.ass]</a>      </td><td class='border left'>   <span class='texttt'>a=b</span>  </td><td class='border left'>   <span class='texttt'>(a).operator= (b)</span>   </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.sub'>[over.sub]</a>      </td><td class='border left'>   <span class='texttt'>a[b]</span> </td><td class='border left'>   <span class='texttt'>(a).operator[](b)</span>   </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.ref'>[over.ref]</a>      </td><td class='border left'>   <span class='texttt'>a-&gt;</span>  </td><td class='border left'>   <span class='texttt'>(a).operator-&gt;(<span style='white-space:nowrap'>&thinsp;</span>)</span>  </td><td class='border left'>                           </td></tr><tr ><td class='left'>
<a href='over.inc'>[over.inc]</a>      </td><td class='border left'>   <span class='texttt'>a@</span>   </td><td class='border left'>   <span class='texttt'>(a).operator@ (0)</span>   </td><td class='border left'>   <span class='texttt'>operator@(a, 0)</span> </td></tr></table></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L971'>#</a></div><p >For a unary operator
<span class='texttt'>@</span>
with an operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>,
and for a binary operator
<span class='texttt'>@</span>
with a left operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>
and a right operand of a type whose cv-unqualified version is
<span class='texttt'>T2</span>,
three sets of candidate functions, designated
<a class='hidden_link' href='#def:member_candidates' id='def:member_candidates'><i>member candidates</i></a>,
<a class='hidden_link' href='#def:non-member_candidates' id='def:non-member_candidates'><i>non-member candidates</i></a>
and
<a class='hidden_link' href='#def:built-in_candidates' id='def:built-in_candidates'><i>built-in candidates</i></a>,
are constructed as follows:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If
<span class='texttt'>T1</span>
is a complete class type or a class currently being defined, the set of member candidates is the
result of the qualified lookup of
<span class='texttt'>T1&#x200b;::&#x200b;operator@</span> (<a href='over.call.func'>[over.call.func]</a>); otherwise, the set of member
candidates is empty.
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >The set of non-member candidates is the result of the unqualified lookup of
<span class='texttt'>operator@</span>
in the context of
the expression according to the usual rules for name
lookup in unqualified function calls (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except
that all member functions are ignored.
However, if no operand has a class type, only those non-member
functions in the lookup set that have a first parameter of type
<span class='texttt'>T1</span>
or “reference to <span class='textit'>cv</span> <span class='texttt'>T1</span>”,
when
<span class='texttt'>T1</span>
is an enumeration type,
or (if there is a right operand) a second parameter of type
<span class='texttt'>T2</span>
or “reference to <span class='textit'>cv</span> <span class='texttt'>T2</span>”,
when
<span class='texttt'>T2</span>
is an enumeration type,
are candidate functions.
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >For the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
the built-in candidates set is empty.
For all other operators, the built-in candidates include all
of the candidate operator functions defined in <a href='over.built'>[over.built]</a> that,
compared to the given operator,</p><ul class='itemize'><li id='3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.1'>(3.3.1)</a></div><p >have the same operator name, and
</p></li><li id='3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.2'>(3.3.2)</a></div><p >accept the same number of operands, and
</p></li><li id='3.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.3'>(3.3.3)</a></div><p >accept operand types to which the given operand or
operands can be converted according to <a href='over.best.ics'>[over.best.ics]</a>, and
</p></li><li id='3.3.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.4'>(3.3.4)</a></div><p >do not have the same parameter-type-list as any non-member candidate
that is not a function template specialization.
</p></li></ul></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1043'>#</a></div><p >For the built-in assignment operators, conversions of the left
operand are restricted as follows:</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >no temporaries are introduced to hold the left operand, and
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >no user-defined conversions are applied to the left operand to achieve
a type match with the left-most parameter of a built-in candidate.
</p></li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1055'>#</a></div><p >For all other operators, no such restrictions apply.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1058'>#</a></div><p >The set of candidate functions for overload resolution is the
union of the member candidates, the non-member candidates, and
the built-in candidates.
The argument list contains all of the
operands of the operator.
The best function from the set of candidate functions is selected
according to <a href='over.match.viable'>[over.match.viable]</a>
and <a href='over.match.best'>[over.match.best]</a>.<a class='footnotenum' href='#footnote-128'>128</a>
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
struct A {
  operator int();
};
A operator+(const A&amp;, const A&amp;);
void m() {
  A a, b;
  a + b;                        <span class='comment'>// <span class='tcode_in_codeblock'>operator+(a, b)</span> chosen over <span class='tcode_in_codeblock'>int(a) + int(b)</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1083'>#</a></div><p >If a built-in candidate is selected by overload resolution, the
operands of class type are converted to the types of the corresponding parameters
of the selected operation function, except that the second standard conversion
sequence of a user-defined conversion sequence (<a href='over.ics.user'>[over.ics.user]</a>) is not applied.
Then the operator is treated as the corresponding
built-in operator and interpreted according to Clause <a href='expr'>[expr]</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0;           <span class='comment'>// error: pointer arithmetic requires integral operand
</span>int *b = Y() + X();             <span class='comment'>// error: pointer arithmetic requires integral operand
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1105'>#</a></div><p >The second operand of operator
<span class='texttt'>-&gt;</span>
is ignored in selecting an
<span class='texttt'>operator-&gt;</span>
function, and is not an argument when the
<span class='texttt'>operator-&gt;</span>
function is called.
When
<span class='texttt'>operator-&gt;</span>
returns, the operator
<span class='texttt'>-&gt;</span>
is applied to the value returned, with the original second
operand.<a class='footnotenum' href='#footnote-129'>129</a></p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1127'>#</a></div><p >If the operator is the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
and there are no viable functions, then the operator is
assumed to be the built-in operator and interpreted according to
Clause <a href='expr'>[expr]</a>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/overloading.tex#L1138'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The lookup rules for operators in expressions are different than
the lookup
rules for operator function names in a function call, as shown in the following
example:</p><pre class='codeblock'>
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);              <span class='comment'>// error: global operator hidden by member
</span>  a + a;                        <span class='comment'>// OK: calls global <span class='tcode_in_codeblock'>operator+</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-128'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-128'>128)</a></div><p >If the set of candidate functions is empty,
overload resolution is unsuccessful.</p></div><div class='footnote' id='footnote-129'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-129'>129)</a></div><p >If the value returned by the
<span class='texttt'>operator-&gt;</span>
function has class type, this may result in selecting and calling another
<span class='texttt'>operator-&gt;</span>
function.
The process repeats until an
<span class='texttt'>operator-&gt;</span>
function returns a value of non-class type.</p></div></div></div></body></html>