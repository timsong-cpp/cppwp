<!DOCTYPE html><html lang='en'><head><title>[over.match.oper]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.4</a> Overload resolution <a class='abbr_ref' href='over.match#oper'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>12.4.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs#over.match.oper'>[over.match.funcs]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>12.4.1.2</a> Operators in expressions <a class='abbr_ref'>[over.match.oper]</a></h4><span class='indexparent'><a class='index' id=':overloading,resolution,operators'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L958'>#</a></div><div id='1.sentence-1' class='sentence'>If no operand of an operator in an expression has a type that is a class
or an enumeration, the operator is assumed to be a built-in operator
and interpreted according to <a href='expr.compound'>[expr.compound]</a><a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.note-1' class='note'>[&nbsp;<a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-2' class='sentence'>Because
<span class='texttt'><span class='operator'>.</span></span>,
<span class='texttt'><span class='operator'>.</span><span class='operator'>*</span></span>,
and
<span class='texttt'><span class='operator'>&#x200b;::&#x200b;</span></span>
cannot be overloaded,
these operators are always built-in operators interpreted according to
<a href='expr.compound'>[expr.compound]</a><a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'><span class='texttt'><span class='operator'>?</span><span class='operator'>:</span></span>
cannot be overloaded, but the rules in this subclause are used to determine
the conversions to be applied to the second and third operands when they
have class or enumeration type (<a href='expr.cond'>[expr.cond]</a>)<a class='hidden_link' href='#1.sentence-3'>.</a></div> —&nbsp;<i>end note</i></div>&nbsp;]</div>  <div id='1.example-1' class='example'>[&nbsp;<a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> String <span class='curlybracket'>{</span>
  String <span class='parenthesis'>(</span><span class='keyword'>const</span> String<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
  String <span class='parenthesis'>(</span><span class='keyword'>const</span> <span class='keyword'>char</span><span class='operator'>*</span><span class='parenthesis'>)</span>;
  <span class='keyword'>operator</span> <span class='keyword'>const</span> <span class='keyword'>char</span><span class='operator'>*</span> <span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
String <span class='keyword'>operator</span> <span class='operator'>+</span> <span class='parenthesis'>(</span><span class='keyword'>const</span> String<span class='operator'>&amp;</span>, <span class='keyword'>const</span> String<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;

<span class='keyword'>void</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>const</span> <span class='keyword'>char</span><span class='operator'>*</span> p<span class='operator'>=</span> <span class='literal'>"one"</span> <span class='operator'>+</span> <span class='literal'>"two"</span>; <span class='comment'>// error: cannot add two pointers; overloaded <span class='tcode_in_codeblock'>operator+</span> not considered</span>
                                <span class='comment'>// because neither operand has class or enumeration type</span>
  <span class='keyword'>int</span> I <span class='operator'>=</span> <span class='literal'>1</span> <span class='operator'>+</span> <span class='literal'>1</span>;                <span class='comment'>// always evaluates to <span class='tcode_in_codeblock'>2</span> even if class or enumeration types exist</span>
                                <span class='comment'>// that would perform the operation.</span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L994'>#</a></div><div id='2.sentence-1' class='sentence'>If either operand has a type that is a class or an enumeration, a
user-defined operator function might be declared that implements
this operator or a user-defined conversion can be necessary to
convert the operand to a type that is appropriate for a built-in
operator<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the
operator<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>Therefore, the operator notation is first transformed
to the equivalent function-call notation as summarized in
Table <a href='#tab:over.match.oper'>13</a>
(where <span class='texttt'>@</span> denotes one of the operators covered in the specified subclause)<a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.sentence-4' class='sentence'>However, the operands are sequenced in the order prescribed
for the built-in operator (<a href='expr.compound'>[expr.compound]</a>)<a class='hidden_link' href='#2.sentence-4'>.</a></div><div class='numberedTable' id='tab:over.match.oper'>Table <a href='#tab:over.match.oper'>13</a>: Relationship between operator and function call notation &emsp;&ensp;[tab:over.match.oper]<br><table ><tr class='rowsep'><td class='left'><div id='2.sentence-5' class='sentence'><b>Subclause</b></div></td><td class='border left'><div id='2.sentence-6' class='sentence'><b>Expression</b></div></td><td class='border left'><div id='2.sentence-7' class='sentence'><b>As member function</b></div></td><td class='border left'><div id='2.sentence-8' class='sentence'><b>As non-member function</b></div></td></tr><tr class='capsep'><td class='left'><div id='2.sentence-9' class='sentence'><a href='over.unary'>[over.unary]</a></div></td><td class='border left'><div id='2.sentence-10' class='sentence'><span class='texttt'>@a</span></div></td><td class='border left'><div id='2.sentence-11' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span>@ <span class='parenthesis'>(</span><span style='white-space:nowrap'>&thinsp;</span><span class='parenthesis'>)</span></span></div></td><td class='border left'><div id='2.sentence-12' class='sentence'><span class='texttt'><span class='keyword'>operator</span>@<span class='parenthesis'>(</span>a<span class='parenthesis'>)</span></span></div></td></tr><tr ><td class='left'><div id='2.sentence-13' class='sentence'><a href='over.binary'>[over.binary]</a></div></td><td class='border left'><div id='2.sentence-14' class='sentence'><span class='texttt'>a@b</span></div></td><td class='border left'><div id='2.sentence-15' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span>@ <span class='parenthesis'>(</span>b<span class='parenthesis'>)</span></span></div></td><td class='border left'><div id='2.sentence-16' class='sentence'><span class='texttt'><span class='keyword'>operator</span>@<span class='parenthesis'>(</span>a, b<span class='parenthesis'>)</span></span></div></td></tr><tr ><td class='left'><div id='2.sentence-17' class='sentence'><a href='over.ass'>[over.ass]</a></div></td><td class='border left'><div id='2.sentence-18' class='sentence'><span class='texttt'>a<span class='operator'>=</span>b</span></div></td><td class='border left'><div id='2.sentence-19' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span><span class='operator'>=</span> <span class='parenthesis'>(</span>b<span class='parenthesis'>)</span></span></div></td><td class='empty border left'></td></tr><tr ><td class='left'><div id='2.sentence-20' class='sentence'><a href='over.sub'>[over.sub]</a></div></td><td class='border left'><div id='2.sentence-21' class='sentence'><span class='texttt'>a<span class='squarebracket'>[</span>b<span class='squarebracket'>]</span></span></div></td><td class='border left'><div id='2.sentence-22' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span><span class='squarebracket'>[</span><span class='squarebracket'>]</span><span class='parenthesis'>(</span>b<span class='parenthesis'>)</span></span></div></td><td class='empty border left'></td></tr><tr ><td class='left'><div id='2.sentence-23' class='sentence'><a href='over.ref'>[over.ref]</a></div></td><td class='border left'><div id='2.sentence-24' class='sentence'><span class='texttt'>a<span class='operator'>-</span><span class='anglebracket'>&gt;</span></span></div></td><td class='border left'><div id='2.sentence-25' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span><span class='parenthesis'>(</span><span style='white-space:nowrap'>&thinsp;</span><span class='parenthesis'>)</span></span></div></td><td class='empty border left'></td></tr><tr ><td class='left'><div id='2.sentence-26' class='sentence'><a href='over.inc'>[over.inc]</a></div></td><td class='border left'><div id='2.sentence-27' class='sentence'><span class='texttt'>a@</span></div></td><td class='border left'><div id='2.sentence-28' class='sentence'><span class='texttt'><span class='parenthesis'>(</span>a<span class='parenthesis'>)</span><span class='operator'>.</span><span class='keyword'>operator</span>@ <span class='parenthesis'>(</span><span class='literal'>0</span><span class='parenthesis'>)</span></span></div></td><td class='border left'><div id='2.sentence-29' class='sentence'><span class='texttt'><span class='keyword'>operator</span>@<span class='parenthesis'>(</span>a, <span class='literal'>0</span><span class='parenthesis'>)</span></span></div></td></tr></table></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1022'>#</a></div><div id='3.sentence-1' class='sentence'>For a unary operator
<span class='texttt'>@</span>
with an operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>,
and for a binary operator
<span class='texttt'>@</span>
with a left operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>
and a right operand of a type whose cv-unqualified version is
<span class='texttt'>T2</span>,
four sets of candidate functions, designated
<a class='hidden_link' href='#def:member_candidate' id='def:member_candidate'><i >member candidates</i></a>,
<a class='hidden_link' href='#def:non-member_candidate' id='def:non-member_candidate'><i >non-member candidates</i></a>,
<a class='hidden_link' href='#def:built-in_candidate' id='def:built-in_candidate'><i >built-in candidates</i></a>,
and
<a class='hidden_link' href='#def:rewritten_candidate' id='def:rewritten_candidate'><i >rewritten candidates</i></a>,
are constructed as follows:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div>If
<span class='texttt'>T1</span>
is a complete class type or a class currently being defined, the set of member candidates is the
result of the qualified lookup of
<span class='texttt'>T1<span class='operator'>&#x200b;::&#x200b;</span><span class='keyword'>operator</span>@</span> (<a href='over.call.func'>[over.call.func]</a>); otherwise, the set of member
candidates is empty.</li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div>The set of non-member candidates is the result of the unqualified lookup of
<span class='texttt'><span class='keyword'>operator</span>@</span>
in the context of
the expression according to the usual rules for name
lookup in unqualified function calls (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except
that all member functions are ignored. However, if no operand has a class type, only those non-member
functions in the lookup set that have a first parameter of type
<span class='texttt'>T1</span>
or “reference to <span class='mathit'>cv</span> <span class='texttt'>T1</span>”,
when
<span class='texttt'>T1</span>
is an enumeration type,
or (if there is a right operand) a second parameter of type
<span class='texttt'>T2</span>
or “reference to <span class='mathit'>cv</span> <span class='texttt'>T2</span>”,
when
<span class='texttt'>T2</span>
is an enumeration type,
are candidate functions.</li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div>For the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'><span class='operator'>&amp;</span></span>,
or the operator
<span class='texttt'><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>,
the built-in candidates set is empty. For all other operators, the built-in candidates include all
of the candidate operator functions defined in <a href='over.built'>[over.built]</a> that,
compared to the given operator,
<ul class='itemize'><li id='3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.1'>(3.3.1)</a></div>have the same operator name, and</li><li id='3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.2'>(3.3.2)</a></div>accept the same number of operands, and</li><li id='3.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.3'>(3.3.3)</a></div>accept operand types to which the given operand or
operands can be converted according to <a href='over.best.ics'>[over.best.ics]</a>, and</li><li id='3.3.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.4'>(3.3.4)</a></div>do not have the same parameter-type-list as any non-member candidate
that is not a function template specialization.</li></ul></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div>The rewritten candidate set is determined as follows:
<ul class='itemize'><li id='3.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.4.1'>(3.4.1)</a></div>For the relational (<a href='expr.rel'>[expr.rel]</a>) operators,
the rewritten candidates include
all non-rewritten candidates
for the expression <span class='texttt'>x <span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span> y</span>.</li><li id='3.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.4.2'>(3.4.2)</a></div>For the
relational (<a href='expr.rel'>[expr.rel]</a>) and
three-way comparison (<a href='expr.spaceship'>[expr.spaceship]</a>)
operators,
the rewritten candidates also include
a synthesized candidate,
with the order of the two parameters reversed,
for each non-rewritten candidate
for the expression
<span class='texttt'>y <span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span> x</span>.</li><li id='3.4.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.4.3'>(3.4.3)</a></div>For the <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span> operator (<a href='expr.eq'>[expr.eq]</a>),
the rewritten candidates
include all non-rewritten candidates
for the expression <span class='texttt'>x <span class='operator'>=</span><span class='operator'>=</span> y</span>.</li><li id='3.4.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.4.4'>(3.4.4)</a></div>For the equality operators,
the rewritten candidates also include a synthesized candidate,
with the order of the two parameters reversed,
for each non-rewritten candidate
for the expression <span class='texttt'>y <span class='operator'>=</span><span class='operator'>=</span> x</span>.</li><li id='3.4.5'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.4.5'>(3.4.5)</a></div>For all other operators, the rewritten candidate set is empty.</li></ul> <div id='3.4.note-1' class='note'>[&nbsp;<a class='note_link' href='#3.4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> A candidate synthesized from a member candidate has its implicit
object parameter as the second parameter, thus implicit conversions
are considered for the first, but not for the second, parameter. —&nbsp;<i>end note</i></div>&nbsp;]</div> </li></ul></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1133'>#</a></div><div id='4.sentence-1' class='sentence'>For the built-in assignment operators, conversions of the left
operand are restricted as follows:
<ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div>no temporaries are introduced to hold the left operand, and</li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div>no user-defined conversions are applied to the left operand to achieve
a type match with the left-most parameter of a built-in candidate<a class='hidden_link' href='#4.sentence-1'>.</a></li></ul></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1144'>#</a></div><div id='5.sentence-1' class='sentence'>For all other operators, no such restrictions apply<a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1147'>#</a></div><div id='6.sentence-1' class='sentence'>The set of candidate functions for overload resolution
for some operator <span class='texttt'>@</span>
is the
union of
the member candidates,
the non-member candidates,
the built-in candidates,
and the rewritten candidates
for that operator <span class='texttt'>@</span><a class='hidden_link' href='#6.sentence-1'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1158'>#</a></div><div id='7.sentence-1' class='sentence'>The argument list contains all of the
operands of the operator<a class='hidden_link' href='#7.sentence-1'>.</a></div> <div id='7.sentence-2' class='sentence'>The best function from the set of candidate functions is selected
according to <a href='over.match.viable'>[over.match.viable]</a>
and <a href='over.match.best'>[over.match.best]</a><a class='hidden_link' href='#7.sentence-2'>.</a><a class='footnotenum' href='#footnote-122' id='footnoteref-122'>122</a></div> <div id='7.example-1' class='example'>[&nbsp;<a class='example_link' href='#7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> <span class='keyword'>int</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;
A <span class='keyword'>operator</span><span class='operator'>+</span><span class='parenthesis'>(</span><span class='keyword'>const</span> A<span class='operator'>&amp;</span>, <span class='keyword'>const</span> A<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>void</span> m<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  A a, b;
  a <span class='operator'>+</span> b;                        <span class='comment'>// <span class='tcode_in_codeblock'>operator+(a, b)</span> chosen over <span class='tcode_in_codeblock'>int(a) + int(b)</span></span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1178'>#</a></div><div id='8.sentence-1' class='sentence'>If a rewritten <span class='texttt'><span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span></span> candidate
is selected by overload resolution
for an operator <span class='texttt'>@</span>,
<span class='texttt'>x @ y</span>
is interpreted as
<span class='texttt'><span class='literal'>0</span> @ <span class='parenthesis'>(</span>y <span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span> x<span class='parenthesis'>)</span></span>
if the selected candidate is a synthesized candidate
with reversed order of parameters,
or <span class='texttt'><span class='parenthesis'>(</span>x <span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span> y<span class='parenthesis'>)</span> @ <span class='literal'>0</span></span> otherwise,
using the selected rewritten <span class='texttt'><span class='keyword'>operator</span><span class='anglebracket'>&lt;</span><span class='operator'>=</span><span class='anglebracket'>&gt;</span></span> candidate<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.sentence-2' class='sentence'>Rewritten candidates for the operator <span class='texttt'>@</span>
are not considered in the context of the resulting expression<a class='hidden_link' href='#8.sentence-2'>.</a></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1192'>#</a></div><div id='9.sentence-1' class='sentence'>If a rewritten <span class='texttt'><span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span></span> candidate
is selected by overload resolution
for an operator <span class='texttt'>@</span>,
its return type shall be <span class='mathit'>cv</span> <span class='texttt'><span class='keyword'>bool</span></span>, and
<span class='texttt'>x @ y</span> is interpreted as:
<ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div>if <span class='texttt'>@</span> is <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span>
and the selected candidate is a synthesized candidate
with reversed order of parameters,
<span class='texttt'><span class='operator'>!</span><span class='parenthesis'>(</span>y <span class='operator'>=</span><span class='operator'>=</span> x<span class='parenthesis'>)</span></span>,</li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div>otherwise, if <span class='texttt'>@</span> is <span class='texttt'><span class='operator'>!</span><span class='operator'>=</span></span>,
<span class='texttt'><span class='operator'>!</span><span class='parenthesis'>(</span>x <span class='operator'>=</span><span class='operator'>=</span> y<span class='parenthesis'>)</span></span>,</li><li id='9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.3'>(9.3)</a></div>otherwise (when <span class='texttt'>@</span> is <span class='texttt'><span class='operator'>=</span><span class='operator'>=</span></span>),
<span class='texttt'>y <span class='operator'>=</span><span class='operator'>=</span> x</span>,</li></ul>
in each case using the selected rewritten <span class='texttt'><span class='keyword'>operator</span><span class='operator'>=</span><span class='operator'>=</span></span> candidate<a class='hidden_link' href='#9.sentence-1'>.</a></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1213'>#</a></div><div id='10.sentence-1' class='sentence'>If a built-in candidate is selected by overload resolution, the
operands of class type are converted to the types of the corresponding parameters
of the selected operation function, except that the second standard conversion
sequence of a <a href='over.ics.user'>user-defined conversion sequence</a> is not applied<a class='hidden_link' href='#10.sentence-1'>.</a></div> <div id='10.sentence-2' class='sentence'>Then the operator is treated as the corresponding
built-in operator and interpreted according to <a href='expr.compound'>[expr.compound]</a><a class='hidden_link' href='#10.sentence-2'>.</a></div> <div id='10.example-1' class='example'>[&nbsp;<a class='example_link' href='#10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>struct</span> X <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> <span class='keyword'>double</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

<span class='keyword'>struct</span> Y <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span> <span class='keyword'>int</span><span class='operator'>*</span><span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

<span class='keyword'>int</span> <span class='operator'>*</span>a <span class='operator'>=</span> Y<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>+</span> <span class='literal'>100.0</span>;           <span class='comment'>// error: pointer arithmetic requires integral operand</span>
<span class='keyword'>int</span> <span class='operator'>*</span>b <span class='operator'>=</span> Y<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='operator'>+</span> X<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;             <span class='comment'>// error: pointer arithmetic requires integral operand</span>
</pre> —&nbsp;<i>end example</i></div>&nbsp;]</div> </div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1235'>#</a></div><div id='11.sentence-1' class='sentence'>The second operand of operator
<span class='texttt'><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
is ignored in selecting an
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
function, and is not an argument when the
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
function is called<a class='hidden_link' href='#11.sentence-1'>.</a></div> <div id='11.sentence-2' class='sentence'>When
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
returns, the operator
<span class='texttt'><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
is applied to the value returned, with the original second
operand<a class='hidden_link' href='#11.sentence-2'>.</a><a class='footnotenum' href='#footnote-123' id='footnoteref-123'>123</a></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1257'>#</a></div><div id='12.sentence-1' class='sentence'>If the operator is the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'><span class='operator'>&amp;</span></span>,
or the operator
<span class='texttt'><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>,
and there are no viable functions, then the operator is
assumed to be the built-in operator and interpreted according to
<a href='expr.compound'>[expr.compound]</a><a class='hidden_link' href='#12.sentence-1'>.</a></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/492f4fbc42cd74b34d0793c78f4210af55922fbc/source/overloading.tex#L1268'>#</a></div><div id='13.note-1' class='note'>[&nbsp;<a class='note_link' href='#13.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='13.sentence-1' class='sentence'>The lookup rules for operators in expressions are different than
the lookup
rules for operator function names in a function call, as shown in the following
example:</div><pre class='codeblock'>
<span class='keyword'>struct</span> A <span class='curlybracket'>{</span> <span class='curlybracket'>}</span>;
<span class='keyword'>void</span> <span class='keyword'>operator</span> <span class='operator'>+</span> <span class='parenthesis'>(</span>A, A<span class='parenthesis'>)</span>;

<span class='keyword'>struct</span> B <span class='curlybracket'>{</span>
  <span class='keyword'>void</span> <span class='keyword'>operator</span> <span class='operator'>+</span> <span class='parenthesis'>(</span>B<span class='parenthesis'>)</span>;
  <span class='keyword'>void</span> f <span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

A a;

<span class='keyword'>void</span> B<span class='operator'>::</span>f<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  <span class='keyword'>operator</span><span class='operator'>+</span> <span class='parenthesis'>(</span>a,a<span class='parenthesis'>)</span>;              <span class='comment'>// error: global operator hidden by member</span>
  a <span class='operator'>+</span> a;                        <span class='comment'>// OK: calls global <span class='tcode_in_codeblock'>operator+</span></span>
<span class='curlybracket'>}</span>
</pre> —&nbsp;<i>end note</i></div>&nbsp;]</div> </div><div class='footnote' id='footnote-122'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-122'>122)</a></div><div id='footnote-122.sentence-1' class='sentence'>If the set of candidate functions is empty,
overload resolution is unsuccessful<a class='hidden_link' href='#footnote-122.sentence-1'>.</a></div> <a href='#footnoteref-122'>⮥</a></div><div class='footnote' id='footnote-123'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-123'>123)</a></div><div id='footnote-123.sentence-1' class='sentence'>If the value returned by the
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
function has class type, this may result in selecting and calling another
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
function<a class='hidden_link' href='#footnote-123.sentence-1'>.</a></div> <div id='footnote-123.sentence-2' class='sentence'>The process repeats until an
<span class='texttt'><span class='keyword'>operator</span><span class='operator'>-</span><span class='anglebracket'>&gt;</span></span>
function returns a value of non-class type<a class='hidden_link' href='#footnote-123.sentence-2'>.</a></div> <a href='#footnoteref-123'>⮥</a></div></div></body></html>