<!DOCTYPE html><html lang='en'><head><title>[container.requirements.general]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.2</a> Container requirements <a class='abbr_ref' href='container.requirements#general'>[container.requirements]</a></h2><div id='container.requirements.general'><h3 ><a class='secnum' style='min-width:103pt'>23.2.1</a> General container requirements <a class='abbr_ref'>[container.requirements.general]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Containers are objects that store other objects.
They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >All of the complexity requirements in this Clause are stated solely
in terms of the number of operations on the contained objects.
[&nbsp;<i>Example:</i><span class='space'></span>
The copy constructor of type
<span class='texttt'>vector&lt;vector&lt;int&gt;&gt;</span>
has linear complexity,
even though the complexity of copying each contained
<span class='texttt'>vector&lt;int&gt;</span>
is itself linear.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >For the components affected by this subclause that declare an <span class='texttt'>allocator_type</span>,
objects stored in these components shall be constructed using the
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::rebind_traits&lt;U&gt;::construct</span> function
and destroyed using the
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::rebind_traits&lt;U&gt;::destroy</span>
function (<a href='allocator.traits.members'>[allocator.traits.members]</a>),
where <span class='texttt'>U</span> is either <span class='texttt'>allocator_type::value_type</span> or
an internal type used by the container.
These functions are called only for the
container's element type, not for internal types used by the container. [&nbsp;<i>Note:</i><span class='space'></span> This
means, for example, that a node-based container might need to construct nodes containing
aligned buffers and call <span class='texttt'>construct</span> to place the element into the buffer.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >In Tables <a href='#tab:containers.container.requirements'>[tab:containers.container.requirements]</a>,
<a href='#tab:containers.reversible.requirements'>[tab:containers.reversible.requirements]</a>, and
<a href='#tab:containers.optional.operations'>[tab:containers.optional.operations]</a>
<span class='texttt'>X</span> denotes a container class containing objects of type
<span class='texttt'>T</span>, <span class='texttt'>a</span> and <span class='texttt'>b</span>
denote values of type <span class='texttt'>X</span>, <span class='texttt'>u</span>
denotes an identifier, <span class='texttt'>r</span> denotes
a non-const value of type <span class='texttt'>X</span>, and <span class='texttt'>rv</span>
denotes a non-const rvalue of type <span class='texttt'>X</span>.</p><div class='numberedTable' id='tab:containers.container.requirements'>Table <a href='#tab:containers.container.requirements'>78</a> — Container requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Operational</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
    </td><td class='left'>   </td><td colspan='1' class='center'><b>semantics</b></td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>      </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>X::value_type</span>       </td><td class='left'>
 <span class='texttt'>T</span>                  </td><td class='left'>
                            </td><td class='left'>
 <i>Requires:</i> <span class='texttt'>T</span> is <span class='texttt'>Erasable</span> from <span class='texttt'>X</span> (see <a href='container.requirements.general'>[container.requirements.general]</a>, below) </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::reference</span>        </td><td class='left'>
 <span class='texttt'>T&amp;</span>                </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::const_reference</span> </td><td class='left'>
 <span class='texttt'>const T&amp;</span>          </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::iterator</span>         </td><td class='left'>
 iterator type whose value type is <span class='texttt'>T</span> </td><td class='left'>
                            </td><td class='left'>
 any iterator category
 that meets the forward iterator requirements.
 convertible to <span class='texttt'>X::const_iterator</span>. </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::const_iterator</span>  </td><td class='left'>
 constant iterator type whose value type is <span class='texttt'>T</span> </td><td class='left'>
                            </td><td class='left'>
 any iterator category
 that meets the forward iterator requirements. </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::difference_type</span>    </td><td class='left'>
 signed integer type           </td><td class='left'>
                                </td><td class='left'>
 is identical to the difference type of <span class='texttt'>X::iterator</span> and <span class='texttt'>X::const_iterator</span> </td><td class='left'>
 compile time               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::size_type</span>        </td><td class='left'>
 unsigned integer type     </td><td class='left'>
                            </td><td class='left'>
 <span class='texttt'>size_type</span> can represent any non-negative value of <span class='texttt'>difference_type</span> </td><td class='left'>
 compile time                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u;</span>                </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 post: <span class='texttt'>u.empty()</span>    </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X()</span>                 </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 post: <span class='texttt'>X().empty()</span>  </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(a)</span>                </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 <i>Requires:</i> <span class='texttt'>T</span> is <span class='texttt'>CopyInsertable</span>
 into <span class='texttt'>X</span> (see below).<span class='hfill'></span><br/> post: <span class='texttt'>a == X(a)</span>.         </td><td class='left'>
 linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(a);</span><span class='hfill'></span><br/>
<span class='texttt'>X u = a;</span>            </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 <i>Requires:</i> <span class='texttt'>T</span> is <span class='texttt'>CopyInsertable</span>
 into <span class='texttt'>X</span> (see below).<span class='hfill'></span><br/>
 post: <span class='texttt'>u == a</span>       </td><td class='left'>
 linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(rv);</span><span class='hfill'></span><br/>
<span class='texttt'>X u = rv;</span>            </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
  post: <span class='texttt'>u</span> shall be equal to the value that <span class='texttt'>rv</span> had before this construction
                            </td><td class='left'>
  (Note B)                  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a = rv</span>              </td><td class='left'>
  <span class='texttt'>X&amp;</span>               </td><td class='left'>
  All existing elements of <span class='texttt'>a</span> are either move assigned to or destroyed   </td><td class='left'>
  <span class='texttt'>a</span> shall be equal to the value that <span class='texttt'>rv</span>
  had before this assignment   </td><td class='left'>
   linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>(&amp;a)-&gt;~X()</span>    </td><td class='left'>
 <span class='texttt'>void</span>               </td><td class='left'>
                            </td><td class='left'>
 the destructor is applied to every element of <span class='texttt'>a</span>; any memory obtained is deallocated. </td><td class='left'>
 linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.begin()</span>           </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>a</span> </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.end()</span>             </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>a</span> </td><td class='left'>
                            </td><td class='left'>
                            </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.cbegin()</span>          </td><td class='left'>
 <span class='texttt'>const_iterator</span>     </td><td class='left'>
 <span class='texttt'>const_cast&lt;X const&amp;&gt;(a).begin();</span> </td><td class='left'>
                            </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.cend()</span>            </td><td class='left'>
 <span class='texttt'>const_iterator</span>     </td><td class='left'>
 <span class='texttt'>const_cast&lt;X const&amp;&gt;(a).end();</span> </td><td class='left'>
                            </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a == b</span>                  </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>==</span> is an equivalence relation. <span class='texttt'>equal(a.begin(),</span>
 <span class='texttt'>a.end(), b.begin(),</span>
 <span class='texttt'>b.end())</span>                                   </td><td class='left'>
 <i>Requires:</i> <span class='texttt'>T</span> is <span class='texttt'>EqualityComparable</span> </td><td class='left'>
 Constant if <span class='texttt'>a.size() != b.size()</span>,
 linear otherwise                                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a != b</span>                      </td><td class='left'>
 convertible to <span class='texttt'>bool</span>        </td><td class='left'>
 Equivalent to <span class='texttt'>!(a == b)</span>   </td><td class='left'>
                                    </td><td class='left'>
 linear                             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.swap(b)</span>          </td><td class='left'>
 <span class='texttt'>void</span>               </td><td class='left'>
                            </td><td class='left'>
 exchanges the contents of <span class='texttt'>a</span> and <span class='texttt'>b</span>          </td><td class='left'>
 (Note A)                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>swap(a, b)</span>          </td><td class='left'>
  <span class='texttt'>void</span>              </td><td class='left'>
  <span class='texttt'>a.swap(b)</span>         </td><td class='left'>
                            </td><td class='left'>
  (Note A)                  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>r = a</span>               </td><td class='left'>
 <span class='texttt'>X&amp;</span>                </td><td class='left'>
                            </td><td class='left'>
 post: <span class='texttt'>r == a</span>.      </td><td class='left'>
 linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size()</span>                </td><td class='left'>
 <span class='texttt'>size_type</span>             </td><td class='left'>
 <span class='texttt'>distance(a.begin(),</span>
 <span class='texttt'>a.end())</span>  </td><td class='left'>
                                </td><td class='left'>
 constant                       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.max_size()</span>        </td><td class='left'>
 <span class='texttt'>size_type</span>         </td><td class='left'>
 <span class='texttt'>distance(begin(),</span>
 <span class='texttt'>end())</span>
 for the largest possible container </td><td class='left'>
                            </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.empty()</span>               </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>a.begin() ==</span>
 <span class='texttt'>a.end()</span>          </td><td class='left'>
                                </td><td class='left'>
constant                        </td></tr></table></div><p >Notes: the algorithm
<span class='texttt'>equal()</span>
is defined in Clause <a href='algorithms'>[algorithms]</a>.
Those entries marked “(Note A)” or “(Note B)”
have linear complexity for <span class='texttt'>array</span> and have constant complexity
for all other standard containers.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The member function <span class='texttt'>size()</span> returns the number of elements in the container.
The number of elements is defined by the rules of
constructors, inserts, and erases.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='texttt'>begin()</span>
returns an iterator referring to the first element in the container.
<span class='texttt'>end()</span>
returns an iterator which is the past-the-end value for the container.
If the container is empty, then
<span class='texttt'>begin() == end()</span>.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >In the expressions
</p><pre class='codeblock'>
i == j
i != j
i &lt; j
i &lt;= j
i &gt;= j
i &gt; j
i - j
</pre><p >where <span class='texttt'>i</span> and <span class='texttt'>j</span> denote objects of a container's <span class='texttt'>iterator</span>
type, either or both may be replaced by an object of the container's
<span class='texttt'>const_iterator</span> type referring to the same element with no change in semantics.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Unless otherwise specified, all containers defined in this clause obtain memory
using an allocator (see <a href='allocator.requirements'>[allocator.requirements]</a>).
Copy constructors for these container types obtain an allocator by calling
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</span>
on the allocator belonging to the container being copied.
Move constructors obtain an allocator by move construction from the allocator belonging to
the container being moved. Such move construction of the allocator shall not exit via an
exception.
All other constructors for these container types take a
<span class='texttt'>const allocator_type&amp;</span> argument.
[&nbsp;<i>Note:</i><span class='space'></span> If an invocation of a constructor uses the default value of an optional
allocator argument, then the <span class='texttt'>Allocator</span> type must support value initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
A copy of this allocator is used for any memory allocation and element construction
performed, by these constructors and by all member functions,
during the lifetime of each container object
or until the allocator is replaced. The allocator may be replaced only via assignment or
<span class='texttt'>swap()</span>. Allocator replacement is performed by
copy assignment, move assignment, or swapping of the allocator only if
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</span>,
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</span>,
or <span class='texttt'>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</span> is <span class='texttt'>true</span>
within the implementation of the corresponding container operation.
In all container types defined in this Clause, the member <span class='texttt'>get_allocator()</span>
returns a copy of the allocator used to construct the container or, if that allocator
has been replaced, a copy of the most recent replacement.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The expression <span class='texttt'>a.swap(b)</span>, for containers <span class='texttt'>a</span> and <span class='texttt'>b</span> of a standard
container type other than <span class='texttt'>array</span>, shall exchange the values of <span class='texttt'>a</span> and
<span class='texttt'>b</span> without invoking any move, copy, or swap operations on the individual
container elements.
Lvalues of any <span class='texttt'>Compare</span>, <span class='texttt'>Pred</span>, or <span class='texttt'>Hash</span> types
belonging to <span class='texttt'>a</span> and <span class='texttt'>b</span> shall be swappable
and shall be exchanged by calling <span class='texttt'>swap</span>
as described in <a href='swappable.requirements'>[swappable.requirements]</a>. If
<span class='texttt'>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</span> is
<span class='texttt'>true</span>, then
lvalues of type <span class='texttt'>allocator_type</span> shall be swappable and
the allocators of <span class='texttt'>a</span> and <span class='texttt'>b</span> shall also be exchanged
by calling <span class='texttt'>swap</span> as described in <a href='swappable.requirements'>[swappable.requirements]</a>.
Otherwise, the allocators shall not be swapped, and the behavior is
undefined unless <span class='texttt'>a.get_allocator() == b.get_allocator()</span>. Every iterator
referring to an element in one container before the swap shall refer to the same
element in the other container after the swap. It is unspecified whether an iterator
with value <span class='texttt'>a.end()</span> before the swap will have value <span class='texttt'>b.end()</span> after the
swap.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If the iterator type of a container belongs to the bidirectional or
random access iterator categories (<a href='iterator.requirements'>[iterator.requirements]</a>),
the container is called
<a class='hidden_link' href='#def:reversible' id='def:reversible'><i>reversible</i></a>
and satisfies the additional requirements
in Table <a href='#tab:containers.reversible.requirements'>[tab:containers.reversible.requirements]</a>.</p><div class='numberedTable' id='tab:containers.reversible.requirements'>Table <a href='#tab:containers.reversible.requirements'>79</a> — Reversible container requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
    </td><td class='left'>   </td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>      </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>X::reverse_iterator</span>            </td><td class='left'>
iterator type whose value type is <span class='texttt'>T</span>    </td><td class='left'>
 <span class='texttt'>reverse_iterator&lt;iterator&gt;</span>   </td><td class='left'>
 compile time                           </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::const_reverse_iterator</span>         </td><td class='left'>
 constant iterator type whose value type is <span class='texttt'>T</span>  </td><td class='left'>
 <span class='texttt'>reverse_iterator&lt;const_iterator&gt;</span>    </td><td class='left'>
 compile time                               </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a.rbegin()</span>                  </td><td class='left'>
 <span class='texttt'>reverse_iterator; const_reverse_iterator</span> for constant <span class='texttt'>a</span> </td><td class='left'>
 <span class='texttt'>reverse_iterator(end())</span>   </td><td class='left'>
 constant                           </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a.rend()</span>                     </td><td class='left'>
 <span class='texttt'>reverse_iterator; const_reverse_iterator</span> for constant <span class='texttt'>a</span> </td><td class='left'>
 <span class='texttt'>reverse_iterator(begin())</span>    </td><td class='left'>
 constant                           </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a.crbegin()</span>         </td><td class='left'>
 <span class='texttt'>const_reverse_iterator</span>     </td><td class='left'>
 <span class='texttt'>const_cast&lt;X const&amp;&gt;(a).rbegin()</span> </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a.crend()</span>         </td><td class='left'>
 <span class='texttt'>const_reverse_iterator</span>     </td><td class='left'>
 <span class='texttt'>const_cast&lt;X const&amp;&gt;(a).rend()</span> </td><td class='left'>
 constant                   </td></tr></table></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >Unless otherwise specified (see <a href='associative.reqmts.except'>[associative.reqmts.except]</a>, <a href='unord.req.except'>[unord.req.except]</a>, <a href='deque.modifiers'>[deque.modifiers]</a>, and
<a href='vector.modifiers'>[vector.modifiers]</a>)
all container types defined in this Clause meet
the following additional requirements:</p><ul ><li ><p >if an exception is thrown by an
<span class='texttt'>insert()</span> or <span class='texttt'>emplace()</span>
function while inserting a single element, that
function has no effects.
</p></li><li ><p >if an exception is thrown by a
<span class='texttt'>push_back()</span>,
<span class='texttt'>push_front()</span>,
<span class='texttt'>emplace_back()</span>, or <span class='texttt'>emplace_front()</span>
function, that function has no effects.
</p></li><li ><p >no
<span class='texttt'>erase()</span>,
<span class='texttt'>clear()</span>,
<span class='texttt'>pop_back()</span>
or
<span class='texttt'>pop_front()</span>
function throws an exception.
</p></li><li ><p >no copy constructor or assignment operator of a returned iterator
throws an exception.
</p></li><li ><p >no
<span class='texttt'>swap()</span>
function throws an exception.
</p></li><li ><p >no
<span class='texttt'>swap()</span>
function invalidates any references,
pointers, or iterators referring to the elements
of the containers being swapped. [&nbsp;<i>Note:</i><span class='space'></span> The <span class='texttt'>end()</span> iterator does not refer to any element, so it may be invalidated. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Unless otherwise specified (either explicitly or by defining a
function in terms of other functions), invoking a container member
function or passing a container as an argument to a library function
shall not invalidate iterators to, or change the values of, objects
within that container.</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='container,contiguous'></a></span>A <a class='hidden_link' href='#def:contiguous_container' id='def:contiguous_container'><i>contiguous container</i></a>
is a container that supports random access iterators (<a href='random.access.iterators'>[random.access.iterators]</a>)
and whose member types <span class='texttt'>iterator</span> and <span class='texttt'>const_iterator</span>
are contiguous iterators (<a href='iterator.requirements.general'>[iterator.requirements.general]</a>).</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >Table <a href='#tab:containers.optional.operations'>[tab:containers.optional.operations]</a> lists operations that are provided
for some types of containers but not others. Those containers for which the
listed operations are provided shall implement the semantics described in
Table <a href='#tab:containers.optional.operations'>[tab:containers.optional.operations]</a> unless otherwise stated.</p><div class='numberedTable' id='tab:containers.optional.operations'>Table <a href='#tab:containers.optional.operations'>80</a> — Optional container operations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Operational</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
    </td><td class='left'>   </td><td colspan='1' class='center'><b>semantics</b></td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>      </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>a &lt; b</span>                   </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>lexicographical_compare( a.begin(), a.end(), b.begin(), b.end())</span> </td><td class='left'>
 pre: <span class='texttt'>&lt;</span> is defined for values of <span class='texttt'>T</span>. <span class='texttt'>&lt;</span> is a total ordering relationship.    </td><td class='left'>
 linear                     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a &gt; b</span>                   </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>b &lt; a</span>                  </td><td class='left'>
                                </td><td class='left'>
 linear                         </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a &lt;= b</span>                  </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>!(a &gt; b)</span>               </td><td class='left'>
                                </td><td class='left'>
 linear                         </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a &gt;= b</span>                  </td><td class='left'>
 convertible to <span class='texttt'>bool</span>    </td><td class='left'>
 <span class='texttt'>!(a &lt; b)</span>               </td><td class='left'>
                                </td><td class='left'>
 linear                         </td></tr></table></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The algorithm <span class='texttt'>lexicographical_compare()</span> is defined in Clause <a href='algorithms'>[algorithms]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >All of the containers defined in this Clause and in (<a href='basic.string'>[basic.string]</a>) except <span class='texttt'>array</span>
meet the additional requirements of an allocator-aware container, as described in
Table <a href='#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>.</p><p >Given an allocator type <span class='texttt'>A</span>
and given a container type <span class='texttt'>X</span> having a <span class='texttt'>value_type</span> identical to <span class='texttt'>T</span>
and an <span class='texttt'>allocator_type</span> identical to <span class='texttt'>allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;</span>
and given an lvalue <span class='texttt'>m</span> of type <span class='texttt'>A</span>,
a pointer <span class='texttt'>p</span> of type <span class='texttt'>T*</span>,
an expression <span class='texttt'>v</span> of type (possibly <span class='texttt'>const</span>) <span class='texttt'>T</span>,
and an rvalue <span class='texttt'>rv</span> of type <span class='texttt'>T</span>,
the following terms are defined. If <span class='texttt'>X</span>
is not allocator-aware, the terms below are defined as if <span class='texttt'>A</span> were
<span class='texttt'>std::allocator&lt;T&gt;</span> — no allocator object needs to be created
and user specializations of <span class='texttt'>std::allocator&lt;T&gt;</span> are not instantiated:</p><ul ><li ><p ><span class='texttt'>T</span> is <a class='hidden_link' href='#def:DefaultInsertable_into_X' id='def:DefaultInsertable_into_X'><i><span class='texttt'>DefaultInsertable</span> into <span class='texttt'>X</span></i></a>
means that the following expression is well-formed:
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::construct(m, p)
</pre></li><li ><p >An element of <span class='texttt'>X</span> is <a class='hidden_link' href='#def:default-inserted' id='def:default-inserted'><i>default-inserted</i></a> if it is initialized
by evaluation of the expression
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::construct(m, p)
</pre><p >where <span class='texttt'>p</span> is the address of the uninitialized storage for the element
allocated within <span class='texttt'>X</span>.
	
</p></li><li ><p ><span class='texttt'>T</span> is <a class='hidden_link' href='#def:MoveInsertable_into_X' id='def:MoveInsertable_into_X'><i><span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span></i></a>
means that the following expression
is well-formed:
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::construct(m, p, rv)
</pre><p >and its evaluation causes the following postcondition to hold: The value
of <span class='texttt'>*p</span> is equivalent to the value of <span class='texttt'>rv</span> before the evaluation.
[&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>rv</span> remains a valid object. Its state is unspecified <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p ><span class='texttt'>T</span> is <a class='hidden_link' href='#def:CopyInsertable_into_X' id='def:CopyInsertable_into_X'><i><span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span></i></a>
means that, in addition to <span class='texttt'>T</span> being <span class='texttt'>MoveInsertable</span> into
<span class='texttt'>X</span>, the following expression is well-formed:
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::construct(m, p, v)
</pre><p >and its evaluation causes the following postcondition to hold:
The value of <span class='texttt'>v</span> is unchanged and is equivalent to <span class='texttt'>*p</span>.</p></li><li ><p ><span class='texttt'>T</span> is
<a class='hidden_link' href='#def:EmplaceConstructible_into_X_from_args' id='def:EmplaceConstructible_into_X_from_args'><i><span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>args</span></i></a>,
for zero
or more arguments <span class='texttt'>args</span>, means that the following expression is well-formed:
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::construct(m, p, args)
</pre></li><li ><p ><span class='texttt'>T</span> is
<a class='hidden_link' href='#def:Erasable_from_X' id='def:Erasable_from_X'><i><span class='texttt'>Erasable</span> from <span class='texttt'>X</span></i></a>
means that the following expression is well-formed:
</p><pre class='codeblock'>
allocator_traits&lt;A&gt;::destroy(m, p)
</pre></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
A container calls <span class='texttt'>allocator_traits&lt;A&gt;::construct(m, p, args)</span>
to construct an element at <span class='texttt'>p</span> using <span class='texttt'>args</span>,
with <span class='texttt'>m == get_allocator()</span>.
The default <span class='texttt'>construct</span> in <span class='texttt'>std::allocator</span> will
call <span class='texttt'>::new((void*)p) T(args)</span>,
but specialized allocators may choose a different definition.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >In Table <a href='#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>, <span class='texttt'>X</span> denotes an allocator-aware container class
with a <span class='texttt'>value_type</span> of <span class='texttt'>T</span> using allocator of type <span class='texttt'>A</span>, <span class='texttt'>u</span> denotes a
variable,
<span class='texttt'>a</span> and <span class='texttt'>b</span> denote non-const lvalues of type <span class='texttt'>X</span>,
<span class='texttt'>t</span> denotes an lvalue or a const rvalue of type <span class='texttt'>X</span>, <span class='texttt'>rv</span> denotes a
non-const rvalue of type <span class='texttt'>X</span>, and <span class='texttt'>m</span> is a value of type <span class='texttt'>A</span>.</p><div class='numberedTable' id='tab:containers.allocatoraware'>Table <a href='#tab:containers.allocatoraware'>81</a> — Allocator-aware container requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
    </td><td class='left'>   </td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>      </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>allocator_type</span>		</td><td class='left'>
  <span class='texttt'>A</span>								</td><td class='left'>
  <i>Requires:</i> <span class='texttt'>allocator_type::value_type</span> is the same as <span class='texttt'>X::value_type</span>.					</td><td class='left'>
  compile time										</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>get_-</span> <span class='texttt'>allocator()</span>	</td><td class='left'>
  <span class='texttt'>A</span>								</td><td class='left'>
																				</td><td class='left'>
  constant												</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X()</span><span class='hfill'></span><br/>
<span class='texttt'>X u;</span>							</td><td class='left'>
													</td><td class='left'>
  <i>Requires:</i> <span class='texttt'>A</span> is <span class='texttt'>DefaultConstructible</span>.<span class='hfill'></span><br/>
  post: <span class='texttt'>u.empty()</span> returns <span class='texttt'>true</span>,
  <span class='texttt'>u.get_allocator() == A()</span> </td><td class='left'>
  constant												</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(m)</span>							</td><td class='left'>
																				</td><td class='left'>
post: <span class='texttt'>u.empty()</span> returns <span class='texttt'>true</span>, </td><td class='left'>
constant												</td></tr><tr ><td class='left'>
<span class='texttt'>X u(m);</span>					</td><td class='left'>
																				</td><td class='left'>
<span class='texttt'>u.get_allocator() == m</span> </td><td class='left'>
																				</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(t, m)</span><span class='hfill'></span><br/>
<span class='texttt'>X u(t, m);</span>				</td><td class='left'>
                          </td><td class='left'>
<i>Requires:</i> <span class='texttt'>T</span> is <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>.<span class='hfill'></span><br/>
post: <span class='texttt'>u == t</span>, <span class='texttt'>u.get_allocator() == m</span> </td><td class='left'>
linear													</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(rv)</span><span class='hfill'></span><br/>
<span class='texttt'>X u(rv);</span>
           </td><td class='left'>
           </td><td class='left'>
  post: <span class='texttt'>u</span> shall have the same elements as <span class='texttt'>rv</span> had before this
  construction; the value of <span class='texttt'>u.get_allocator()</span> shall be the same as the
  value of <span class='texttt'>rv.get_allocator()</span> before this construction. </td><td class='left'>
  constant                            </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(rv, m)</span><span class='hfill'></span><br/>
<span class='texttt'>X u(rv, m);</span>			</td><td class='left'>
												</td><td class='left'>
  <i>Requires:</i> <span class='texttt'>T</span> is
  <span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span>.<span class='hfill'></span><br/>
  post: <span class='texttt'>u</span> shall have the same elements,
  or copies of the elements, that <span class='texttt'>rv</span> had before
  this construction, <span class='texttt'>u.get_allocator() == m</span>												</td><td class='left'>
  constant if <span class='texttt'>m ==</span> <span class='texttt'>rv.get_allocator()</span>, otherwise linear	</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a = t</span>             </td><td class='left'>
  <span class='texttt'>X&amp;</span>             </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>T</span> is
  <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>
  and <span class='texttt'>CopyAssignable</span>.<span class='hfill'></span><br/>
  post: <span class='texttt'>a == t</span>    </td><td class='left'>
  linear                  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a = rv</span>          </td><td class='left'>
  <span class='texttt'>X&amp;</span>           </td><td class='left'>
  <i>Requires:</i> If <span class='texttt'>allocator_-</span><span class='hfill'></span><br/>
  <span class='texttt'>traits&lt;allocator_type&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>::propagate_on_container_-</span><span class='hfill'></span><br/>
  <span class='texttt'>move_assignment::value</span> is<span class='hfill'></span><br/>
  <span class='texttt'>false</span>, <span class='texttt'>T</span> is
  <span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span> and
  <span class='texttt'>MoveAssignable</span>. All existing elements of <span class='texttt'>a</span>
  are either move assigned to or destroyed.<span class='hfill'></span><br/>
  post: <span class='texttt'>a</span> shall be equal to the value that <span class='texttt'>rv</span> had before
  this assignment.      </td><td class='left'>
  linear                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.swap(b)</span>       </td><td class='left'>
  <span class='texttt'>void</span>          </td><td class='left'>
  exchanges the contents of <span class='texttt'>a</span> and <span class='texttt'>b</span> </td><td class='left'>
  constant      </td></tr></table></div></div></div></div></body></html>