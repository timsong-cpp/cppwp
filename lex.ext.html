<!DOCTYPE html><html lang='en'><head><title>[lex.ext]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>2</a> Lexical conventions <a class='abbr_ref' href='./#lex'>[lex]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>2.13</a> Literals <a class='abbr_ref' href='lex.literal#lex.ext'>[lex.literal]</a></h2><div id='lex.ext'><h3 ><a class='secnum' style='min-width:103pt'>2.13.8</a> User-defined literals <a class='abbr_ref'>[lex.ext]</a></h3><p ><span class='indexparent'><a class='index' id='literal,user-defined'></a></span></p><pre class='bnf'><a id='nt:user-defined-literal'>user-defined-literal:</a>
    <i ><a href='lex.ext#nt:user-defined-integer-literal'>user-defined-integer-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-floating-literal'>user-defined-floating-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i></pre><pre class='bnf'><a id='nt:user-defined-integer-literal'>user-defined-integer-literal:</a>
    <i ><a href='lex.icon#nt:decimal-literal'>decimal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:octal-literal'>octal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:hexadecimal-literal'>hexadecimal-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:binary-literal'>binary-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-floating-literal'>user-defined-floating-literal:</a>
    <i ><a href='lex.fcon#nt:fractional-constant'>fractional-constant</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.fcon#nt:digit-sequence'>digit-sequence</a></i> <i ><a href='lex.fcon#nt:exponent-part'>exponent-part</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:hexadecimal-prefix'>hexadecimal-prefix</a></i> <i ><a href='lex.fcon#nt:hexadecimal-fractional-constant'>hexadecimal-fractional-constant</a></i> <i ><a href='lex.fcon#nt:binary-exponent-part'>binary-exponent-part</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
    <i ><a href='lex.icon#nt:hexadecimal-prefix'>hexadecimal-prefix</a></i> <i ><a href='lex.icon#nt:hexadecimal-digit-sequence'>hexadecimal-digit-sequence</a></i> <i ><a href='lex.fcon#nt:binary-exponent-part'>binary-exponent-part</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-string-literal'>user-defined-string-literal:</a>
    <i ><a href='lex.string#nt:string-literal'>string-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:user-defined-character-literal'>user-defined-character-literal:</a>
    <i ><a href='lex.ccon#nt:character-literal'>character-literal</a></i> <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i></pre><pre class='bnf'><a id='nt:ud-suffix'>ud-suffix:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >If a token matches both <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> and another literal kind, it
is treated as the latter. [&nbsp;<i>Example:</i><span class='space'></span> <span class='texttt'>123_km</span>
is a <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i>, but <span class='texttt'>12LL</span> is an
<i ><a href='lex.icon#nt:integer-literal'>integer-literal</a></i>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]
The syntactic non-terminal preceding the <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> in a
<i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> is taken to be the longest sequence of
characters that could match that non-terminal.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> is treated as a call to a literal operator or
literal operator template (<a href='over.literal'>[over.literal]</a>). To determine the form of this call for a
given <i ><a href='lex.ext#nt:user-defined-literal'>user-defined-literal</a></i> <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> with <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>,
the <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> whose literal suffix identifier is <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a> is
looked up in the context of <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> using the rules for unqualified name
lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>). Let <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> be the set of declarations found by
this lookup. <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall not be empty.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-integer-literal'>user-defined-integer-literal</a></i>, let <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> be the literal
without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator with
parameter type <span class='texttt'>unsigned long long</span>, the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of
the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a>ULL)
</pre><p >Otherwise, <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a raw literal operator or a literal operator
template (<a href='over.literal'>[over.literal]</a>) but not both. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a raw literal operator,
the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>("<span class='term'>n"</span>)
</pre><p >Otherwise (<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator template), <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>&lt;'<span class='math'><span class='mathalpha'>c</span><sub >1</sub></span>', '<span class='math'><span class='mathalpha'>c</span><sub >2</sub></span>', ... '<span class='math'><span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>'&gt;()
</pre><p >where <a class='hidden_link' href='#def:n' id='def:n'><i>n</i></a> is the source character sequence <span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>. [&nbsp;<i>Note:</i><span class='space'></span> The sequence
<span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span> can only contain characters from the basic source character set.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-floating-literal'>user-defined-floating-literal</a></i>, let <a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator
with parameter type <span class='texttt'>long double</span>, the literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of
the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a>L)
</pre><p >Otherwise, <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a raw literal operator or a literal operator
template (<a href='over.literal'>[over.literal]</a>) but not both. If <a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a raw literal operator,
the <a class='hidden_link' href='#def:literal' id='def:literal'><i>literal</i></a> <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>("<span class='term'>f"</span>)
</pre><p >Otherwise (<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> contains a literal operator template), <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>&lt;'<span class='math'><span class='mathalpha'>c</span><sub >1</sub></span>', '<span class='math'><span class='mathalpha'>c</span><sub >2</sub></span>', ... '<span class='math'><span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>'&gt;()
</pre><p >where <a class='hidden_link' href='#def:f' id='def:f'><i>f</i></a> is the source character sequence <span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span>. [&nbsp;<i>Note:</i><span class='space'></span> The sequence
<span class='math'><span class='mathalpha'>c</span><sub >1</sub><span class='mathalpha'>c</span><sub >2</sub>...<span class='mathalpha'>c</span><sub ><span class='mathalpha'>k</span></sub></span> can only contain characters from the basic source character set.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>, let <a class='hidden_link' href='#def:str' id='def:str'><i>str</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i> and let <a class='hidden_link' href='#def:len' id='def:len'><i>len</i></a> be
the number of
code units in <a class='hidden_link' href='#def:str' id='def:str'><i>str</i></a> (i.e., its length excluding the terminating
null character).
 The literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<span class='term'>str</span>, <span class='term'>len</span>)
</pre></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is a <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i>, let <a class='hidden_link' href='#def:ch' id='def:ch'><i>ch</i></a> be the
literal without its <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>.
<a class='hidden_link' href='#def:S' id='def:S'><i>S</i></a> shall contain a literal operator (<a href='over.literal'>[over.literal]</a>) whose only parameter has
the type of <a class='hidden_link' href='#def:ch' id='def:ch'><i>ch</i></a> and the
literal <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a> is treated as a call
of the form</p><pre class='codeblock'>
operator "" <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a>(<span class='term'>ch</span>)
</pre></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
long double operator "" _w(long double);
std::string operator "" _w(const char16_t*, std::size_t);
unsigned operator "" _w(const char*);
int main() {
  1.2_w;      <span class='comment'>// calls <span class='texttt'>operator "" _w(1.2L)</span>
</span>  u"one"_w;   <span class='comment'>// calls <span class='texttt'>operator "" _w(u"one", 3)</span>
</span>  12_w;       <span class='comment'>// calls <span class='texttt'>operator "" _w("12")</span>
</span>  "two"_w;    <span class='comment'>// error: no applicable literal operator
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >In translation phase 6 (<a href='lex.phases'>[lex.phases]</a>), adjacent string literals are concatenated and
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literals</a></i> are considered string literals for that
purpose. During concatenation, <i ><a href='lex.ext#nt:ud-suffix'>ud-suffixes</a></i> are removed and ignored and
the concatenation process occurs as described in <a href='lex.string'>[lex.string]</a>. At the end of phase
6, if a string literal is the result of a concatenation involving at least one
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>, all the participating
<i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literals</a></i> shall have the same <i ><a href='lex.ext#nt:ud-suffix'>ud-suffix</a></i>
and that suffix is applied to the result of the concatenation.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int main() {
  L"A" "B" "C"_x; <span class='comment'>// OK: same as <span class='texttt'>L"ABC"_x</span>
</span>  "P"_x "Q" "R"_y;<span class='comment'>// error: two different <span class='grammarterm'>ud-suffixes</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='literal'></a></span><span class='indexparent'><a class='index' id='conventions,lexical'></a></span>
</p></div></div></div></body></html>