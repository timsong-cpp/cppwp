<!DOCTYPE html><html lang='en'><head><title>[temp.dep.type]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref' href='temp.res#temp.dep.type'>[temp.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref' href='temp.dep#type'>[temp.dep]</a></h3><div id='temp.dep.type'><h4 ><a class='secnum' style='min-width:118pt'>14.6.2.1</a> Dependent types <a class='abbr_ref'>[temp.dep.type]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A name refers to the
<a class='hidden_link' href='#def:current_instantiation' id='def:current_instantiation'><i>current instantiation</i></a>
if it is</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause <a href='class'>[class]</a>) of the class template or nested class,
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization),
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization).
If the <i>n</i>th template parameter is
a parameter pack, the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the parameter pack.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The template argument list of a primary template is a
template argument list in which the
<i>n</i>th
template argument has the value of the
<i>n</i>th
template parameter of the class template.
If the <i>n</i>th template parameter is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the template parameter pack.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  A* p1;                        <span class='comment'>// <span class='texttt'>A</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is the current instantiation
</span>  A&lt;T*&gt; p3;                     <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is not the current instantiation
</span>  ::A&lt;T&gt;* p4;                   <span class='comment'>// <span class='texttt'>::A&lt;T&gt;</span> is the current instantiation
</span>  class B {
    B* p1;                      <span class='comment'>// <span class='texttt'>B</span> is the current instantiation
</span>    A&lt;T&gt;::B* p2;                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::B</span> is the current instantiation
</span>    typename A&lt;T*&gt;::B* p3;      <span class='comment'>// <span class='texttt'>A&lt;T*&gt;::B</span> is not the
</span>                                <span class='comment'>// current instantiation
</span>  };
};

template &lt;class T&gt; class A&lt;T*&gt; {
  A&lt;T*&gt;* p1;                    <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is not the current instantiation
</span>};

template &lt;class T1, class T2, int I&gt; struct B {
  B&lt;T1, T2, I&gt;* b1;             <span class='comment'>// refers to the current instantiation
</span>  B&lt;T2, T1, I&gt;* b2;             <span class='comment'>// not the current instantiation
</span>  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B&lt;my_T1, T2, my_I&gt;* b3;       <span class='comment'>// refers to the current instantiation
</span>  B&lt;my_T1, T2, my_I2&gt;* b4;      <span class='comment'>// not the current instantiation
</span>  B&lt;my_T1, T2, my_I3&gt;* b5;      <span class='comment'>// refers to the current instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='base_class,dependent'></a></span>A <a class='hidden_link' href='#def:dependent_base_class' id='def:dependent_base_class'><i>dependent base class</i></a> is a base class that is a dependent type and is
not the current instantiation.
[&nbsp;<i>Note:</i>
a base class can be the current instantiation in the case of a nested class
naming an enclosing class as a base.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  typedef int M;
  struct B {
    typedef void M;
    struct C;
  };
};

template&lt;class T&gt; struct A&lt;T&gt;::B::C : A&lt;T&gt; {
  M m; <span class='comment'>// OK, <span class='texttt'>A&lt;T&gt;::M</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='instantiation,member_of_the_current'></a></span>A name is a
<a class='hidden_link' href='#def:member_of_the_current_instantiation' id='def:member_of_the_current_instantiation'><i>member of the current instantiation</i></a>
if it is</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >An unqualified name that, when looked up, refers to
at least one member of a class that is
the current instantiation or a non-dependent base class thereof.
[&nbsp;<i>Note:</i>
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >A
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation
and that, when looked up, refers to at least one member of a class that is
the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.3'>(5.3)</a></div><p >An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) for which the type of the object expression is the
current instantiation, and the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>, when looked
up (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), refers to at least one member of a class
that is the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  static const int i = 5;
  int n1[i];        <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>  int n2[A::i];     <span class='comment'>// <span class='texttt'>A::i</span> refers to a member of the current instantiation
</span>  int n3[A&lt;T&gt;::i];  <span class='comment'>// <span class='texttt'>A&lt;T&gt;::i</span> refers to a member of the current instantiation
</span>  int f();
};

template &lt;class T&gt; int A&lt;T&gt;::f() {
  return i;         <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='instantiation,dependent_member_of_the_current'></a></span>A name is a <a class='hidden_link' href='#def:dependent_member_of_the_current_instantiation' id='def:dependent_member_of_the_current_instantiation'><i>dependent member of the current instantiation</i></a> if it is a
member of the current instantiation that, when looked up, refers to at least
one member of a class that is the current instantiation.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A name is a
<a class='hidden_link' href='#def:member_of_an_unknown_specialization' id='def:member_of_an_unknown_specialization'><i>member of an unknown specialization</i></a>
if it is</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >A
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
names a dependent type that is not the current instantiation.</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >A <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> does not
find any member of a class that is the current instantiation or a non-dependent
base class thereof.</p></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div><p >An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) in which either
</p><ul class='itemize'><li id='6.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#6.3.1'>(6.3.1)</a></div><p >the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> does not find a member of a class that is
the current instantiation or a non-dependent base class thereof; or</p></li><li id='6.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#6.3.2'>(6.3.2)</a></div><p >the type of the object expression is dependent and is not the current
instantiation.
</p></li></ul></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> is not instantiated; no
diagnostic required. Similarly, if the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; class A {
  typedef int type;
  void f() {
    A&lt;T&gt;::type i;           <span class='comment'>// OK: refers to a member of the current instantiation
</span>    typename A&lt;T&gt;::other j; <span class='comment'>// error: neither a member of the current instantiation nor
</span>                            <span class='comment'>// a member of an unknown specialization
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> or class member access expression, the name in the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  int m;
};

struct B {
  int m;
};

template&lt;typename T&gt;
struct C : A, T {
  int f() { return this-&gt;m; }  <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>  int g() { return m; }        <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>};

template int C&lt;B&gt;::f();        <span class='comment'>// error: finds both <span class='texttt'>A::m</span> and <span class='texttt'>B::m</span>
</span>template int C&lt;B&gt;::g();        <span class='comment'>// OK: transformation to class member access syntax
</span>                               <span class='comment'>// does not occur in the template definition context; see <a href='class.mfct.non-static'>[class.mfct.non-static]</a>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A type is dependent if it is
</p><ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p >a template parameter,
</p></li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div><p >a member of an unknown specialization,
</p></li><li id='9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.3'>(9.3)</a></div><p >a nested class or enumeration that is a dependent member of the current
instantiation,
</p></li><li id='9.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.4'>(9.4)</a></div><p >a cv-qualified type where the cv-unqualified type is dependent,
</p></li><li id='9.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.5'>(9.5)</a></div><p >a compound type constructed from any dependent type,
</p></li><li id='9.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.6'>(9.6)</a></div><p >an array type whose element type is dependent or whose
bound (if any) is value-dependent,
</p></li><li id='9.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.7'>(9.7)</a></div><p >a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent or is a pack expansion, or
</p></li><li id='9.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.8'>(9.8)</a></div><p >denoted by <span class='texttt'>decltype(</span><i ><a href='expr.comma#nt:expression'>expression</a></i><span class='texttt'>)</span>,
where <i ><a href='expr.comma#nt:expression'>expression</a></i> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
</p></li></ul></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i>
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>