<!DOCTYPE html><html lang='en'><head><title>[dcl.spec]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><div id='dcl.spec'><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref'>[dcl.spec]</a></h2><p ><span class='indexparent'><a class='index' id='specifier'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='specifier,declaration'></a></span>The specifiers that can be used in a declaration are</p><pre class='bnf'><a id='nt:decl-specifier'>decl-specifier:</a>
    <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
    <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>
    <i ><a href='dcl.fct.spec#nt:function-specifier'>function-specifier</a></i>
    <span class='terminal'>friend</span>
    <span class='terminal'>typedef</span>
    <span class='terminal'>constexpr</span>
    <span class='terminal'>inline</span></pre><pre class='bnf'><a id='nt:decl-specifier-seq'>decl-specifier-seq:</a>
    <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
appertains to the type determined by the preceding
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> (<a href='dcl.meaning'>[dcl.meaning]</a>). The <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>
affects the type only for the declaration it appears in, not other declarations involving the
same type.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> shall appear at most once in a complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, except that
<span class='texttt'>long</span> may appear twice.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='ambiguity,declaration_type'></a></span>If a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is encountered while parsing a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>,
it is interpreted as part of the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> if and only if there is no
previous <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> other than a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.
The sequence shall be self-consistent as
described below.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
typedef char* Pc;
static Pc;                      <span class='comment'>// error: name missing
</span></pre><p >Here, the declaration <span class='texttt'>static</span> <span class='texttt'>Pc</span> is ill-formed because no
name was specified for the static variable of type <span class='texttt'>Pc</span>. To get a
variable called <span class='texttt'>Pc</span>, a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> (other than
<span class='texttt'>const</span> or <span class='texttt'>volatile</span>) has to be present to indicate that
the <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> <span class='texttt'>Pc</span> is the name being (re)declared,
rather than being part of the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> sequence. For
another example,
</p><pre class='codeblock'>
void f(const Pc);               <span class='comment'>// <span class='texttt'>void f(char* const)</span> (not <span class='texttt'>const char*</span>)
</span>void g(const int Pc);           <span class='comment'>// <span class='texttt'>void g(const int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='signed,typedef'></a></span><span class='indexparent'><a class='index' id='unsigned,typedef'></a></span><span class='indexparent'><a class='index' id='long,typedef'></a></span><span class='indexparent'><a class='index' id='short,typedef'></a></span>[&nbsp;<i>Note:</i>
Since <span class='texttt'>signed</span>, <span class='texttt'>unsigned</span>, <span class='texttt'>long</span>, and <span class='texttt'>short</span>
by default imply <span class='texttt'>int</span>, a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> appearing after one
of those specifiers is treated as the name being (re)declared.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
void h(unsigned Pc);            <span class='comment'>// <span class='texttt'>void h(unsigned int)</span>
</span>void k(unsigned int Pc);        <span class='comment'>// <span class='texttt'>void k(unsigned int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='dcl.stc'><h3 ><a class='secnum' href='#dcl.stc' style='min-width:103pt'>7.1.1</a> Storage class specifiers <a class='abbr_ref' href='dcl.stc'>[dcl.stc]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,storage_class'></a></span><span class='indexparent'><a class='index' id='declaration,storage_class'></a></span><span class='indexparent'><a class='index' id='static'></a></span><span class='indexparent'><a class='index' id='thread_local'></a></span><span class='indexparent'><a class='index' id='extern'></a></span><span class='indexparent'><a class='index' id='mutable'></a></span></p><div class='para' id='dcl.stc-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-1'>1</a></div><p >The storage class specifiers are</p><pre class='bnf'><a id='nt:storage-class-specifier'>storage-class-specifier:</a>
    <span class='terminal'>static</span>
    <span class='terminal'>thread_local</span>
    <span class='terminal'>extern</span>
    <span class='terminal'>mutable</span></pre><p >At most one <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> shall appear in a given
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, except that <span class='texttt'>thread_local</span> may appear with <span class='texttt'>static</span> or 
<span class='texttt'>extern</span>. If <span class='texttt'>thread_local</span> appears in any declaration of
a variable it shall be present in all declarations of that entity. If a 
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
appears in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, there can be no
<span class='texttt'>typedef</span> specifier in the same <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and
the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> or <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i>
of the declaration shall not be
empty (except for an anonymous union declared in a named namespace or in the
global namespace, which shall be declared
<span class='indexparent'><a class='index' id='specifier,static'></a></span><span class='texttt'>static</span> (<a href='class.union.anon'>[class.union.anon]</a>)). The
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> applies to the name declared by each
<i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i> in the list and not to any names declared by
other specifiers. A <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
other than <span class='texttt'>thread_local</span>
shall not be
specified in an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) or an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) directive.</p></div><div class='para' id='dcl.stc-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-2'>2</a></div><p >[&nbsp;<i>Note:</i>
A variable declared without a <i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i>
at block scope or declared as a function parameter
has automatic storage duration by default (<a href='basic.stc.auto'>[basic.stc.auto]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.stc-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-3'>3</a></div><p >The <span class='texttt'>thread_local</span> specifier
indicates that the named entity has thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). It
shall be applied only
to the names of variables of namespace
or block scope and to the names of static data members.
When <span class='texttt'>thread_local</span> is applied to a variable of block scope the
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> <span class='texttt'>static</span> is implied if no other
<i ><a href='dcl.stc#nt:storage-class-specifier'>storage-class-specifier</a></i> appears in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.</p></div><div class='para' id='dcl.stc-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-4'>4</a></div><p ><span class='indexparent'><a class='index' id='restriction,static'></a></span>The <span class='texttt'>static</span> specifier can be applied only to names of variables and
functions and to anonymous unions (<a href='class.union.anon'>[class.union.anon]</a>). There can be no
<span class='texttt'>static</span> function declarations within a block, nor any
<span class='texttt'>static</span> function parameters. A <span class='texttt'>static</span> specifier used in
the declaration of a variable declares the variable to have static storage
duration (<a href='basic.stc.static'>[basic.stc.static]</a>), unless accompanied by the
<span class='texttt'>thread_local</span> specifier, which declares the variable to have thread
storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). A <span class='texttt'>static</span> specifier can be
used in declarations of class members; <a href='class.static'>[class.static]</a> describes its
effect.
<span class='indexparent'><a class='index' id='static,linkage_of'></a></span>For the linkage of a name declared with a <span class='texttt'>static</span> specifier,
see <a href='basic.link'>[basic.link]</a>.</p></div><div class='para' id='dcl.stc-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-5'>5</a></div><p ><span class='indexparent'><a class='index' id='restriction,extern'></a></span>The <span class='texttt'>extern</span> specifier can be applied only to the names of variables
and functions. The <span class='texttt'>extern</span> specifier cannot be used in the
declaration of class members or function parameters.
<span class='indexparent'><a class='index' id='extern,linkage_of'></a></span><span class='indexparent'><a class='index' id='consistency,linkage'></a></span>For the linkage of a name declared with an <span class='texttt'>extern</span> specifier,
see <a href='basic.link'>[basic.link]</a>.
[&nbsp;<i>Note:</i>
The <span class='texttt'>extern</span> keyword can also be used in
<span class='rmfamily'></span><i> explicit-instantiation</i>s and
<span class='rmfamily'></span><i> linkage-specification</i>s, but it is not a
<span class='rmfamily'></span><i> storage-class-specifier</i> in such contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.stc-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-6'>6</a></div><p >The linkages implied by successive declarations for a given entity shall
agree. That is, within a given scope, each declaration declaring the
same variable name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions
can have a different linkage, however.
[&nbsp;<i>Example:</i>
<span class='indexparent'><a class='index' id='example,linkage_consistency'></a></span></p><pre class='codeblock'>
static char* f();               <span class='comment'>// <span class='texttt'>f()</span> has internal linkage
</span>char* f()                       <span class='comment'>// <span class='texttt'>f()</span> still has internal linkage
</span>  { <span class='comment'>/* ... */</span> }

char* g();                      <span class='comment'>// <span class='texttt'>g()</span> has external linkage
</span>static char* g()                <span class='comment'>// error: inconsistent linkage
</span>  { <span class='comment'>/* ... */</span> }

void h();
inline void h();                <span class='comment'>// external linkage
</span>
inline void l();
void l();                       <span class='comment'>// external linkage
</span>
inline void m();
extern void m();                <span class='comment'>// external linkage
</span>
static void n();
inline void n();                <span class='comment'>// internal linkage
</span>
static int a;                   <span class='comment'>// <span class='texttt'>a</span> has internal linkage
</span>int a;                          <span class='comment'>// error: two definitions
</span>
static int b;                   <span class='comment'>// <span class='texttt'>b</span> has internal linkage
</span>extern int b;                   <span class='comment'>// <span class='texttt'>b</span> still has internal linkage
</span>
int c;                          <span class='comment'>// <span class='texttt'>c</span> has external linkage
</span>static int c;                   <span class='comment'>// error: inconsistent linkage
</span>
extern int d;                   <span class='comment'>// <span class='texttt'>d</span> has external linkage
</span>static int d;                   <span class='comment'>// error: inconsistent linkage
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-7'>7</a></div><p ><span class='indexparent'><a class='index' id='declaration,forward'></a></span>The name of a declared but undefined class can be used in an
<span class='texttt'>extern</span> declaration. Such a declaration can only be used in ways
that do not require a complete class type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S;
extern S a;
extern S f();
extern void g(S);

void h() {
  g(a);                         <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>  f();                          <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-8'>8</a></div><p >The <span class='texttt'>mutable</span> specifier shall appear only in the declaration of
a non-static data member (<a href='class.mem'>[class.mem]</a>)
whose type is neither const-qualified nor a reference type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class X {
  mutable const int* p;         <span class='comment'>// OK
</span>  mutable int* const q;         <span class='comment'>// ill-formed
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.stc-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.stc-9'>9</a></div><p >The <span class='texttt'>mutable</span> specifier on a class data member nullifies a
<span class='texttt'>const</span> specifier applied to the containing class object and
permits modification of the mutable class member even though the rest of
the object is <span class='texttt'>const</span> (<a href='dcl.type.cv'>[dcl.type.cv]</a>).</p></div></div><div id='dcl.fct.spec'><h3 ><a class='secnum' href='#dcl.fct.spec' style='min-width:103pt'>7.1.2</a> Function specifiers <a class='abbr_ref' href='dcl.fct.spec'>[dcl.fct.spec]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,function'></a></span><span class='indexparent'><a class='index' id='function'></a></span></p><div class='para' id='dcl.fct.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-1'>1</a></div><p ><span class='grammarterm'>Function-specifiers</span>
can be used only in function declarations.</p><pre class='bnf'><a id='nt:function-specifier'>function-specifier:</a>
    <span class='terminal'>virtual</span>
    <span class='terminal'>explicit</span></pre></div><div class='para' id='dcl.fct.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-2'>2</a></div><p ><span class='indexparent'><a class='index' id='specifier,virtual'></a></span>The <span class='texttt'>virtual</span> specifier shall be used only in the initial
declaration of a non-static class member function;
see <a href='class.virtual'>[class.virtual]</a>.</p></div><div class='para' id='dcl.fct.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.fct.spec-3'>3</a></div><p ><span class='indexparent'><a class='index' id='specifier,explicit'></a></span>The <span class='texttt'>explicit</span> specifier shall be used only in the declaration of
a constructor or conversion function within its class definition;
see <a href='class.conv.ctor'>[class.conv.ctor]</a> and <a href='class.conv.fct'>[class.conv.fct]</a>.</p></div></div><div id='dcl.typedef'><h3 ><a class='secnum' href='#dcl.typedef' style='min-width:103pt'>7.1.3</a> The <span class='texttt'>typedef</span> specifier <a class='abbr_ref' href='dcl.typedef'>[dcl.typedef]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,typedef'></a></span></p><div class='para' id='dcl.typedef-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-1'>1</a></div><p >Declarations containing the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> <span class='texttt'>typedef</span>
declare identifiers that can be used later for naming
fundamental (<a href='basic.fundamental'>[basic.fundamental]</a>) or compound (<a href='basic.compound'>[basic.compound]</a>)
types. The <span class='texttt'>typedef</span> specifier shall not be
combined in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> with any other kind of
specifier except a <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>, and it shall not be used in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> (<a href='dcl.fct'>[dcl.fct]</a>) nor in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
If a <span class='texttt'>typedef</span> specifier appears in a declaration without a <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>,
the program is ill-formed.</p><pre class='bnf'><a id='nt:typedef-name'>typedef-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><p >A name declared with the <span class='texttt'>typedef</span> specifier becomes a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>. Within the scope of its declaration, a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is syntactically equivalent to a keyword and
names the type associated with the identifier in the way described in
Clause <a href='dcl.decl'>[dcl.decl]</a>.
<span class='indexparent'><a class='index' id='declaration,typedef'></a></span><span class='indexparent'><a class='index' id='equivalence,type'></a></span><span class='indexparent'><a class='index' id='synonym,type_name_as'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is thus a synonym for another type. A
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> does not introduce a new type the way a class
declaration (<a href='class.name'>[class.name]</a>) or enum declaration does.
[&nbsp;<i>Example:</i>
<span class='indexparent'><a class='index' id='example,typedef'></a></span>after</p><pre class='codeblock'>
typedef int MILES, *KLICKSP;
</pre><p >the constructions</p><pre class='codeblock'>
MILES distance;
extern KLICKSP metricp;
</pre><p >are all correct declarations; the type of <span class='texttt'>distance</span> is
<span class='texttt'>int</span> and that of <span class='texttt'>metricp</span> is “pointer to <span class='texttt'>int</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-2'>2</a></div><p >A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> can also be introduced by an
<i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>. The <i ><a href='lex.name#nt:identifier'>identifier</a></i> following the
<span class='texttt'>using</span> keyword becomes a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
and the optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> following the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> appertains to that <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>.
Such a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> has the same
semantics as if it were introduced by the <span class='texttt'>typedef</span> specifier. In
particular, it does not define a new type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int);         <span class='comment'>// redeclare <span class='texttt'>ignore</span>
</span>using cell = pair&lt;void*, cell*&gt;;    <span class='comment'>// ill-formed
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>
of the <i ><a href='dcl.name#nt:defining-type-id'>defining-type-id</a></i> shall not define
a class or enumeration if the <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
is the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> of a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>.</p></div><div class='para' id='dcl.typedef-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-3'>3</a></div><p ><span class='indexparent'><a class='index' id='redefinition,typedef'></a></span>In a given non-class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine the name of any type declared in that scope to refer to the
type to which it already refers.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef struct s { <span class='comment'>/* ... */</span> } s;
typedef int I;
typedef int I;
typedef I I;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-4'>4</a></div><p >In a given class scope, a <span class='texttt'>typedef</span> specifier can be used to
redefine any <i ><a href='class#nt:class-name'>class-name</a></i> declared in that scope that is not
also a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> to refer to the type to which it already
refers.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S {
  typedef struct A { } A;       <span class='comment'>// OK
</span>  typedef struct B B;           <span class='comment'>// OK
</span>  typedef A A;                  <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-5'>5</a></div><p >If a <span class='texttt'>typedef</span> specifier is used to redefine in a given scope an
entity that can be referenced using an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>,
the entity can continue to be referenced by an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> or as an enumeration or class name
in an enumeration or class definition respectively. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S;
typedef struct S S;
int main() {
  struct S* p;                  <span class='comment'>// OK
</span>}
struct S { };                   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-6'>6</a></div><p >In a given scope, a <span class='texttt'>typedef</span> specifier shall not be used to
redefine the name of any type declared in that scope to refer to a
different type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class complex { <span class='texttt'>/* ... */</span> };
typedef int complex;            <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-7'>7</a></div><p >Similarly, in a given scope, a class or enumeration shall not be
declared with the same name as a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that is
declared in that scope and refers to a type other than the class or
enumeration itself.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
typedef int complex;
class complex { <span class='texttt'>/* ... */</span> };    <span class='comment'>// error: redefinition
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-8'>8</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a class type, or a cv-qualified
version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>). If
a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> is used to identify the subject of an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>), a class
definition (Clause <a href='class'>[class]</a>), a constructor
declaration (<a href='class.ctor'>[class.ctor]</a>), or a destructor
declaration (<a href='class.dtor'>[class.dtor]</a>), the program is ill-formed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S {
  S();
  ~S();
};

typedef struct S T;

S a = T();                      <span class='comment'>// OK
</span>struct T * p;                   <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.typedef-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.typedef-9'>9</a></div><p ><span class='indexparent'><a class='index' id='class_name,typedef'></a></span><span class='indexparent'><a class='index' id='enum_name,typedef'></a></span><span class='indexparent'><a class='index' id='class,unnamed'></a></span>If the typedef declaration defines an unnamed class (or enum), the first
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> declared by the declaration to be that class
type (or enum type) is used to denote the class type (or enum type) for
linkage purposes only (<a href='basic.link'>[basic.link]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef struct { } *ps, S;      <span class='comment'>// <span class='texttt'>S</span> is the class name for linkage purposes
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.friend'><h3 ><a class='secnum' href='#dcl.friend' style='min-width:103pt'>7.1.4</a> The <span class='texttt'>friend</span> specifier <a class='abbr_ref' href='dcl.friend'>[dcl.friend]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,friend'></a></span></p><div class='para' id='dcl.friend-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.friend-1'>1</a></div><p >The <span class='texttt'>friend</span> specifier is used to specify access to class members;
see <a href='class.friend'>[class.friend]</a>.</p></div></div><div id='dcl.constexpr'><h3 ><a class='secnum' href='#dcl.constexpr' style='min-width:103pt'>7.1.5</a> The <span class='texttt'>constexpr</span> specifier <a class='abbr_ref' href='dcl.constexpr'>[dcl.constexpr]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,constexpr'></a></span></p><div class='para' id='dcl.constexpr-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-1'>1</a></div><p >The <span class='texttt'>constexpr</span> specifier shall be applied only to the definition of
a variable or variable template or
the declaration of a
function or function template.
A function or static data member declared with the <span class='texttt'>constexpr</span>
specifier is implicitly an inline function or variable (<a href='dcl.inline'>[dcl.inline]</a>).
If any declaration of a function or function template has
a <span class='texttt'>constexpr</span> specifier,
then all its declarations shall contain the <span class='texttt'>constexpr</span> specifier. [&nbsp;<i>Note:</i> An
explicit specialization can differ from the template declaration with respect to the
<span class='texttt'>constexpr</span> specifier. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i>
Function parameters cannot be declared <span class='texttt'>constexpr</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
constexpr void square(int &amp;x);  <span class='comment'>// OK: declaration
</span>constexpr int bufsz = 1024;     <span class='comment'>// OK: definition
</span>constexpr struct pixel {        <span class='comment'>// error: <span class='texttt'>pixel</span> is a type
</span>  int x;
  int y;
  constexpr pixel(int);         <span class='comment'>// OK: declaration
</span>}; 
constexpr pixel::pixel(int a)
  : x(a), y(x)                  <span class='comment'>// OK: definition
</span>  { square(x); }
constexpr pixel small(2);       <span class='comment'>// error: <span class='texttt'>square</span> not defined, so <span class='texttt'>small(2)</span>
</span>                                <span class='comment'>// not constant (<a href='expr.const'>[expr.const]</a>) so <span class='texttt'>constexpr</span> not satisfied
</span>
constexpr void square(int &amp;x) { <span class='comment'>// OK: definition
</span>  x *= x;
}
constexpr pixel large(4);       <span class='comment'>// OK: <span class='texttt'>square</span> defined
</span>int next(constexpr int x) {     <span class='comment'>// error: not for parameters
</span>     return x + 1;
} 
extern constexpr int memsz;     <span class='comment'>// error: not a definition 
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-2'>2</a></div><p >A <span class='texttt'>constexpr</span> specifier used in the declaration of a function that is not a
constructor declares that
function to be a <a class='hidden_link' href='#def:specifier,constexpr,function' id='def:specifier,constexpr,function'><i>constexpr function</i></a>. Similarly, a
<span class='texttt'>constexpr</span> specifier used in 
a constructor declaration declares that constructor to be a
<a class='hidden_link' href='#def:specifier,constexpr,constructor' id='def:specifier,constexpr,constructor'><i>constexpr constructor</i></a>.</p></div><div class='para' id='dcl.constexpr-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-3'>3</a></div><p ><span class='indexparent'><a class='index' id='specifier,constexpr,function'></a></span>
<span class='indexparent'><a class='index' id='constexpr_function'></a></span>
The definition of a constexpr function shall satisfy the following
requirements:</p><ul class='itemize'><li id='dcl.constexpr-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-3.1'>(3.1)</a></div><p >it shall not be virtual (<a href='class.virtual'>[class.virtual]</a>);</p></li><li id='dcl.constexpr-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-3.2'>(3.2)</a></div><p >for a defaulted copy/move assignment, the class of which it is a member
shall not have a mutable subobject that is a variant member;</p></li><li id='dcl.constexpr-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-3.3'>(3.3)</a></div><p >its return type shall be a literal type;</p></li><li id='dcl.constexpr-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-3.4'>(3.4)</a></div><p >each of its parameter types shall be a literal type;</p></li><li id='dcl.constexpr-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-3.5'>(3.5)</a></div><p >its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be
<span class='texttt'>= delete</span>, <span class='texttt'>= default</span>, or
a <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
that does not contain</p><ul class='itemize'><li id='dcl.constexpr-3.5.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dcl.constexpr-3.5.1'>(3.5.1)</a></div><p >an <i ><a href='dcl.asm#nt:asm-definition'>asm-definition</a></i>,
</p></li><li id='dcl.constexpr-3.5.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dcl.constexpr-3.5.2'>(3.5.2)</a></div><p >a <span class='texttt'>goto</span> statement,
</p></li><li id='dcl.constexpr-3.5.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dcl.constexpr-3.5.3'>(3.5.3)</a></div><p >an identifier label (<a href='stmt.label'>[stmt.label]</a>),
</p></li><li id='dcl.constexpr-3.5.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dcl.constexpr-3.5.4'>(3.5.4)</a></div><p >a <i ><a href='except#nt:try-block'>try-block</a></i>, or
</p></li><li id='dcl.constexpr-3.5.5'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#dcl.constexpr-3.5.5'>(3.5.5)</a></div><p >a definition of a variable
of non-literal type or
of static or thread storage duration or
for which no initialization is performed.
</p></li></ul></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
constexpr int square(int x) 
  { return x * x; }             <span class='comment'>// OK
</span>constexpr long long_max() 
  { return 2147483647; }        <span class='comment'>// OK
</span>constexpr int abs(int x) {
  if (x &lt; 0)
    x = -x;
  return x;                     <span class='comment'>// OK
</span>}
constexpr int first(int n) {
  static int value = n;         <span class='comment'>// error: variable has static storage duration
</span>  return value;
}
constexpr int uninit() {
  int a;                        <span class='comment'>// error: variable is uninitialized
</span>  return a;
}
constexpr int prev(int x)
  { return --x; }               <span class='comment'>// OK
</span>constexpr int g(int x, int n) { <span class='comment'>// OK
</span>  int r = 1;
  while (--n &gt; 0) r *= x;
  return r;
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-4'>4</a></div><p ><span class='indexparent'><a class='index' id='specifier,constexpr,constructor'></a></span>The definition of a constexpr constructor shall satisfy the
following requirements:
</p><ul class='itemize'><li id='dcl.constexpr-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.1'>(4.1)</a></div><p >the class shall not have any virtual base classes;</p></li><li id='dcl.constexpr-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.2'>(4.2)</a></div><p >for a defaulted copy/move constructor, the class shall not have a
mutable subobject that is a variant member;</p></li><li id='dcl.constexpr-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.3'>(4.3)</a></div><p >each of the parameter types shall be a literal type;</p></li><li id='dcl.constexpr-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.4'>(4.4)</a></div><p >its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall not be a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>.
</p></li></ul><p >In addition, either its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be
<span class='texttt'>= delete</span>, or it shall satisfy the following requirements:
</p><ul class='itemize'><li id='dcl.constexpr-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.5'>(4.5)</a></div><p >either its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> shall be <span class='texttt'>= default</span>, or the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of its <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i>
shall satisfy the requirements for a <i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> of a
constexpr function;</p></li><li id='dcl.constexpr-4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.6'>(4.6)</a></div><p >every non-variant non-static data member and base class subobject
shall be initialized (<a href='class.base.init'>[class.base.init]</a>);</p></li><li id='dcl.constexpr-4.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.7'>(4.7)</a></div><p >if the class is a union having variant members (<a href='class.union'>[class.union]</a>), exactly one of them
shall be initialized;</p></li><li id='dcl.constexpr-4.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.8'>(4.8)</a></div><p >if the class is a union-like class, but is not a union, for each of its anonymous union
members having variant members, exactly one of them shall be initialized;</p></li><li id='dcl.constexpr-4.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.9'>(4.9)</a></div><p >for a non-delegating constructor, every constructor selected to initialize non-static
data members and base class subobjects shall be a constexpr constructor;</p></li><li id='dcl.constexpr-4.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-4.10'>(4.10)</a></div><p >for a delegating constructor, the target constructor shall be a <span class='texttt'>constexpr</span>
constructor.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct Length { 
  constexpr explicit Length(int i = 0) : val(i) { }
private: 
  int val; 
}; 
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-5'>5</a></div><p >For a constexpr function or constexpr constructor
that is neither defaulted nor a template,
if no argument values exist such that
an invocation of the function or constructor could be an evaluated subexpression of a core
constant expression (<a href='expr.const'>[expr.const]</a>), or,
for a constructor, a constant initializer for some object (<a href='basic.start.static'>[basic.start.static]</a>),
the program is ill-formed; no diagnostic required.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
constexpr int f(bool b)
  { return b ? throw 0 : 0; }           <span class='comment'>// OK
</span>constexpr int f() { return f(true); }   <span class='comment'>// ill-formed, no diagnostic required
</span>
struct B {
  constexpr B(int x) : i(0) { }         <span class='comment'>// <span class='texttt'>x</span> is unused
</span>  int i;
};

int global;

struct D : B {
  constexpr D() : B(global) { }         <span class='comment'>// ill-formed, no diagnostic required
</span>                                        <span class='comment'>// lvalue-to-rvalue conversion on non-constant <span class='texttt'>global</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-6'>6</a></div><p >If the instantiated template specialization of a constexpr function
template
or member function of a class template
would fail to satisfy the requirements for a <span class='texttt'>constexpr</span>
function or constexpr constructor,
that specialization is still a constexpr function or <span class='texttt'>constexpr</span>
constructor, even though a call to such a function cannot appear in a constant
expression. If no specialization of the template would satisfy the
requirements for a constexpr function or constexpr constructor
when considered as a non-template function or constructor, the template is
ill-formed; no diagnostic
required.</p></div><div class='para' id='dcl.constexpr-7'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-7'>7</a></div><p >A call to a constexpr function produces the same result as a call to an equivalent
non-constexpr function in all respects except that
</p><ul class='itemize'><li id='dcl.constexpr-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-7.1'>(7.1)</a></div><p >a call to a <span class='texttt'>constexpr</span>
function can appear in a constant expression (<a href='expr.const'>[expr.const]</a>) and
</p></li><li id='dcl.constexpr-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.constexpr-7.2'>(7.2)</a></div><p >copy elision is mandatory in a constant expression (<a href='class.copy'>[class.copy]</a>).
</p></li></ul></div><div class='para' id='dcl.constexpr-8'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-8'>8</a></div><p >The <span class='texttt'>constexpr</span> specifier has no
effect on the type of a constexpr function or a constexpr constructor.  [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
constexpr int bar(int x, int y)         <span class='comment'>// OK
</span>    { return x + y + x*y; } 
<span class='comment'>// ... 
</span>int bar(int x, int y)                   <span class='comment'>// error: redefinition of <span class='texttt'>bar</span>
</span>    { return x * 2 + 3 * y; } 
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.constexpr-9'><div class='marginalizedparent'><a class='marginalized' href='#dcl.constexpr-9'>9</a></div><p >A <span class='texttt'>constexpr</span> specifier used in an object declaration
declares the object as <span class='texttt'>const</span>.
Such an object
shall have literal type and
shall be initialized.
In any <span class='texttt'>constexpr</span> variable declaration,
the full-expression of the initialization
shall be a constant expression (<a href='expr.const'>[expr.const]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct pixel { 
  int x, y; 
}; 
constexpr pixel ur = { 1294, 1024 };    <span class='comment'>// OK
</span>constexpr pixel origin;                 <span class='comment'>// error: initializer missing
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.inline'><h3 ><a class='secnum' href='#dcl.inline' style='min-width:103pt'>7.1.6</a> The <span class='texttt'>inline</span> specifier <a class='abbr_ref' href='dcl.inline'>[dcl.inline]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,inline'></a></span></p><div class='para' id='dcl.inline-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-1'>1</a></div><p >The <span class='texttt'>inline</span> specifier can be applied only to the declaration
or definition of a variable or function.</p></div><div class='para' id='dcl.inline-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-2'>2</a></div><p ><span class='indexparent'><a class='index' id='specifier,inline'></a></span><span class='indexparent'><a class='index' id='inline_function'></a></span>A function declaration (<a href='dcl.fct'>[dcl.fct]</a>, <a href='class.mfct'>[class.mfct]</a>,
<a href='class.friend'>[class.friend]</a>) with an <span class='texttt'>inline</span> specifier declares an
<a class='hidden_link' href='#def:inline_function' id='def:inline_function'><i>inline function</i></a>. The inline specifier indicates to
the implementation that inline substitution of the function body at the
point of call is to be preferred to the usual function call mechanism.
An implementation is not required to perform this inline substitution at
the point of call; however, even if this inline substitution is omitted,
the other rules for inline functions defined by <a href='dcl.fct.spec'>[dcl.fct.spec]</a> shall
still be respected.</p></div><div class='para' id='dcl.inline-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-3'>3</a></div><p >A variable declaration with an <span class='texttt'>inline</span> specifier declares an
<a class='hidden_link' href='#def:inline_variable' id='def:inline_variable'><i>inline variable</i></a>.</p></div><div class='para' id='dcl.inline-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-4'>4</a></div><p >A function defined within a class definition is an inline function.</p></div><div class='para' id='dcl.inline-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-5'>5</a></div><p >The <span class='texttt'>inline</span> specifier shall not appear on a block scope
declaration.<a class='footnotenum' href='#footnote-94'>94</a>
If the <span class='texttt'>inline</span> specifier is used in a friend function declaration, that
declaration shall be a definition or the function shall have previously
been declared inline.</p></div><div class='para' id='dcl.inline-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.inline-6'>6</a></div><p >An inline function or variable shall be defined in every translation unit in which
it is odr-used and shall have exactly the same definition in every
case (<a href='basic.def.odr'>[basic.def.odr]</a>).
[&nbsp;<i>Note:</i>
A call to the inline function or a use of the inline variable may be encountered before its definition
appears in the translation unit.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the definition of a function or variable appears in a translation unit before its
first declaration as inline, the program is ill-formed. If a function or variable
with external linkage is declared inline in one translation unit, it
shall be declared inline in all translation units in which it appears;
no diagnostic is required. An inline function or variable with external
linkage shall have the same address in all translation units.
[&nbsp;<i>Note:</i>
A <span class='texttt'>static</span> local variable in an inline
function with external linkage always refers to the same object.
A type defined within the body of an inline
function with external linkage is the
same type in every translation unit.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-94'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-94'>94)</a></div><p >The <span class='texttt'>inline</span> keyword has no effect on the linkage of a function.</p></div></div><div id='dcl.type'><h3 ><a class='secnum' href='#dcl.type' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type'>[dcl.type]</a></h3><p ><span class='indexparent'><a class='index' id='specifier,type'></a></span></p><div class='para' id='dcl.type-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-1'>1</a></div><p >The type-specifiers are</p><p ><span class='indexparent'><a class='index' id='type,const'></a></span><span class='indexparent'><a class='index' id='type,volatile'></a></span></p><pre class='bnf'><a id='nt:type-specifier'>type-specifier:</a>
  <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
  <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
  <i ><a href='temp.res#nt:typename-specifier'>typename-specifier</a></i>
  <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i></pre><pre class='bnf'><a id='nt:type-specifier-seq'>type-specifier-seq:</a>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i></pre><pre class='bnf'><a id='nt:defining-type-specifier'>defining-type-specifier:</a>
    <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
    <i ><a href='class#nt:class-specifier'>class-specifier</a></i>
    <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i></pre><pre class='bnf'><a id='nt:defining-type-specifier-seq'>defining-type-specifier-seq:</a>
  <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i></pre><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>
or a <i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>
appertains
to the type denoted by the preceding <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i>
or <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifiers</a></i> (<a href='dcl.meaning'>[dcl.meaning]</a>). The
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> affects the type only for the declaration it appears in,
not other declarations involving the same type.</p></div><div class='para' id='dcl.type-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-2'>2</a></div><p >As a general rule, at most one
<i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i>
is allowed in the complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> or in a
<i ><a href='dcl.type#nt:defining-type-specifier-seq'>defining-type-specifier-seq</a></i>,
and at most one
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>
is allowed in a
<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>.
The only exceptions to this rule are the following:</p><ul class='itemize'><li id='dcl.type-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.1'>(2.1)</a></div><p ><span class='texttt'>const</span> can be combined with any type specifier except itself.</p></li><li id='dcl.type-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.2'>(2.2)</a></div><p ><span class='texttt'>volatile</span> can be combined with any type specifier except itself.</p></li><li id='dcl.type-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.3'>(2.3)</a></div><p ><span class='texttt'>signed</span> or <span class='texttt'>unsigned</span> can be combined with
<span class='texttt'>char</span>, <span class='texttt'>long</span>, <span class='texttt'>short</span>, or <span class='texttt'>int</span>.</p></li><li id='dcl.type-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.4'>(2.4)</a></div><p ><span class='texttt'>short</span> or <span class='texttt'>long</span> can be combined with <span class='texttt'>int</span>.</p></li><li id='dcl.type-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.5'>(2.5)</a></div><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>double</span>.</p></li><li id='dcl.type-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type-2.6'>(2.6)</a></div><p ><span class='texttt'>long</span> can be combined with <span class='texttt'>long</span>.
</p></li></ul></div><div class='para' id='dcl.type-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-3'>3</a></div><p >Except in a declaration of a constructor, destructor, or conversion
function, at least one <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> that is not a
<i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> shall appear in a complete
<i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> or a complete
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>.<a class='footnotenum' href='#footnote-95'>95</a></p></div><div class='para' id='dcl.type-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type-4'>4</a></div><p >[&nbsp;<i>Note:</i>
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifiers</a></i>,
<i ><a href='class#nt:class-specifier'>class-specifiers</a></i>,
and
<i ><a href='temp.res#nt:typename-specifier'>typename-specifiers</a></i>
are discussed
in
<a href='dcl.enum'>[dcl.enum]</a>,
Clause <a href='class'>[class]</a>,
and
<a href='temp.res'>[temp.res]</a>, respectively. The remaining
<i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i> are discussed in the rest of this section.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-95'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-95'>95)</a></div><p >There is no special
provision for a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> that
lacks a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> or that has a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that only specifies <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i>.
The “implicit int” rule of C is no longer supported.</p></div><div id='dcl.type.cv'><h4 ><a class='secnum' href='#dcl.type.cv' style='min-width:118pt'>7.1.7.1</a> The <span class='grammarterm'>cv-qualifiers</span> <a class='abbr_ref' href='dcl.type.cv'>[dcl.type.cv]</a></h4><p ><span class='indexparent'><a class='index' id='specifier,cv-qualifier'></a></span><span class='indexparent'><a class='index' id='initialization,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span></p><div class='para' id='dcl.type.cv-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-1'>1</a></div><p >There are two <span class='grammarterm'>cv-qualifiers</span>, <span class='texttt'>const</span> and
<span class='texttt'>volatile</span>. Each <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> shall appear at most once in
a <i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i>. If a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> appears in a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
or <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> of
the declaration shall not be empty.
[&nbsp;<i>Note:</i>
<a href='basic.type.qualifier'>[basic.type.qualifier]</a> and <a href='dcl.fct'>[dcl.fct]</a> describe how cv-qualifiers affect object and
function types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Redundant cv-qualifications are ignored. [&nbsp;<i>Note:</i> For example,
these could be introduced by typedefs.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-2'>2</a></div><p >[&nbsp;<i>Note:</i>
Declaring a variable <span class='texttt'>const</span> can affect its linkage (<a href='dcl.stc'>[dcl.stc]</a>)
and its usability in constant expressions (<a href='expr.const'>[expr.const]</a>). As
described in <a href='dcl.init'>[dcl.init]</a>, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-3'>3</a></div><p >A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
[&nbsp;<i>Note:</i>
Cv-qualifiers are supported by the type system so that they cannot be
subverted without casting (<a href='expr.const.cast'>[expr.const.cast]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-4'>4</a></div><p ><span class='indexparent'><a class='index' id='const_object,undefined_change_to'></a></span>Except that any class member declared <span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>)
can be modified, any attempt to modify a <span class='texttt'>const</span> object during its
lifetime (<a href='basic.life'>[basic.life]</a>) results in undefined behavior.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const int ci = 3;                       <span class='comment'>// cv-qualified (initialized as required)
</span>ci = 4;                                 <span class='comment'>// ill-formed: attempt to modify <span class='texttt'>const</span>
</span>
int i = 2;                              <span class='comment'>// not cv-qualified
</span>const int* cip;                         <span class='comment'>// pointer to <span class='texttt'>const int</span>
</span>cip = &amp;i;                               <span class='comment'>// OK: cv-qualified access path to unqualified
</span>*cip = 4;                               <span class='comment'>// ill-formed: attempt to modify through ptr to <span class='texttt'>const</span>
</span>
int* ip;
ip = const_cast&lt;int*&gt;(cip);             <span class='comment'>// cast needed to convert <span class='texttt'>const int*</span> to <span class='texttt'>int*</span>
</span>*ip = 4;                                <span class='comment'>// defined: <span class='texttt'>*ip</span> points to <span class='texttt'>i</span>, a non-<span class='texttt'>const</span> object
</span>
const int* ciq = new const int (3);     <span class='comment'>// initialized as required
</span>int* iq = const_cast&lt;int*&gt;(ciq);        <span class='comment'>// cast required
</span>*iq = 4;                                <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> object
</span></pre><p >For another example,
</p><pre class='codeblock'>
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                                <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>y.x.j++;                                <span class='comment'>// ill-formed: const-qualified member modified
</span>Y* p = const_cast&lt;Y*&gt;(&amp;y);              <span class='comment'>// cast away const-ness of <span class='texttt'>y</span>
</span>p-&gt;x.i = 99;                            <span class='comment'>// well-formed: <span class='texttt'>mutable</span> member can be modified
</span>p-&gt;x.j = 99;                            <span class='comment'>// undefined: modifies a <span class='texttt'>const</span> member
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.type.cv-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-5'>5</a></div><p >What constitutes an access to an object that has volatile-qualified type is
<span class='indexparent'><a class='index' id='what_constitutes_an_access_to_an_object_that_has_volatile-qualified_type'></a></span>implementation-defined.
If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of a glvalue with a
non-volatile-qualified type, the behavior is undefined.</p></div><div class='para' id='dcl.type.cv-6'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.cv-6'>6</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span><span class='indexparent'><a class='index' id='volatile,implementation-defined'></a></span>[&nbsp;<i>Note:</i>
<span class='texttt'>volatile</span> is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
Furthermore, for some implementations, <span class='texttt'>volatile</span> might indicate that
special hardware instructions are required to access the object.
See <a href='intro.execution'>[intro.execution]</a> for detailed semantics. In general, the
semantics of <span class='texttt'>volatile</span> are intended to be the same in C++ as
they are in C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='dcl.type.simple'><h4 ><a class='secnum' href='#dcl.type.simple' style='min-width:118pt'>7.1.7.2</a> Simple type specifiers <a class='abbr_ref' href='dcl.type.simple'>[dcl.type.simple]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,simple'></a></span></p><div class='para' id='dcl.type.simple-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-1'>1</a></div><p >The simple type specifiers are</p><pre class='bnf'><a id='nt:simple-type-specifier'>simple-type-specifier:</a>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
    <span class='terminal'>char</span>
    <span class='terminal'>char16_t</span>
    <span class='terminal'>char32_t</span>
    <span class='terminal'>wchar_t</span>
    <span class='terminal'>bool</span>
    <span class='terminal'>short</span>
    <span class='terminal'>int</span>
    <span class='terminal'>long</span>
    <span class='terminal'>signed</span>
    <span class='terminal'>unsigned</span>
    <span class='terminal'>float</span>
    <span class='terminal'>double</span>
    <span class='terminal'>void</span>
    <span class='terminal'>auto</span>
    <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i></pre><pre class='bnf'><a id='nt:type-name'>type-name:</a>
    <i ><a href='class#nt:class-name'>class-name</a></i>
    <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>
    <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><pre class='bnf'><a id='nt:decltype-specifier'>decltype-specifier:</a>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <span class='terminal'>auto</span> <span class='terminal'>)</span></pre></div><div class='para' id='dcl.type.simple-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-2'>2</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,char'></a></span><span class='indexparent'><a class='index' id='type_specifier,char16_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,char32_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,wchar_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,bool'></a></span><span class='indexparent'><a class='index' id='type_specifier,short'></a></span><span class='indexparent'><a class='index' id='type_specifier,int'></a></span><span class='indexparent'><a class='index' id='type_specifier,long'></a></span><span class='indexparent'><a class='index' id='type_specifier,signed'></a></span><span class='indexparent'><a class='index' id='type_specifier,unsigned'></a></span><span class='indexparent'><a class='index' id='type_specifier,float'></a></span><span class='indexparent'><a class='index' id='type_specifier,double'></a></span><span class='indexparent'><a class='index' id='type_specifier,void'></a></span><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span><span class='indexparent'><a class='index' id='type-name'></a></span><span class='indexparent'><a class='index' id='lambda-introducer'></a></span>The <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='texttt'>auto</span> is a placeholder for a type to be
deduced (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
<span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>A <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> of the form
<span class='texttt'>typename</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
is a placeholder for a deduced class type
and shall appear only as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i> (<a href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a>)
or as the <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
in an explicit type conversion (functional notation) (<a href='expr.type.conv'>[expr.type.conv]</a>).
The <i ><a href='temp.names#nt:template-name'>template-name</a></i> shall name a class template
that is not an injected-class-name.
The other
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
specify either a previously-declared type, a type determined from an
expression, or one of the
fundamental types (<a href='basic.fundamental'>[basic.fundamental]</a>).
Table <a href='#tab:simple.type.specifiers'>[tab:simple.type.specifiers]</a>
 summarizes the valid combinations of
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
and the types they specify.</p><div class='numberedTable' id='tab:simple.type.specifiers'>Table <a href='#tab:simple.type.specifiers'>11</a> — <span class='grammarterm'>simple-type-specifiers</span> and the types they specify<br><table ><tr class='rowsep'><td class='left'>


Specifier(s)                    </td><td class='left'>   Type                 </td></tr><tr class='capsep'><td class='left'> 
<span class='grammarterm'>type-name</span>         </td><td class='left'>   the type named          </td></tr><tr ><td class='left'>
<span class='grammarterm'>simple-template-id</span>    </td><td class='left'>   the type as defined in <a href='temp.names'>[temp.names]</a>   </td></tr><tr ><td class='left'>
<span class='grammarterm'>template-name</span>     </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
char                            </td><td class='left'>   “char”                </td></tr><tr ><td class='left'>
unsigned char                   </td><td class='left'>   “unsigned char”       </td></tr><tr ><td class='left'>
signed char                     </td><td class='left'>   “signed char”         </td></tr><tr ><td class='left'>
char16_t                        </td><td class='left'>   “char16_t”            </td></tr><tr ><td class='left'>
char32_t                        </td><td class='left'>   “char32_t”            </td></tr><tr ><td class='left'>
bool                            </td><td class='left'>   “bool”                </td></tr><tr ><td class='left'>
unsigned                        </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
unsigned int                    </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
signed                          </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
signed int                      </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
int                             </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
unsigned short int              </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned short                  </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned long int               </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long                   </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long long int          </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
unsigned long long              </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
signed long int                 </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long                     </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long long int            </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
signed long long                </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long int                   </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long                       </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long int                        </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
long                            </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed short int                </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
signed short                    </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short int                       </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short                           </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
wchar_t                         </td><td class='left'>   “wchar_t”             </td></tr><tr ><td class='left'>
float                           </td><td class='left'>   “float”               </td></tr><tr ><td class='left'>
double                          </td><td class='left'>   “double”              </td></tr><tr ><td class='left'>
long double                     </td><td class='left'>   “long double”         </td></tr><tr ><td class='left'>
void                            </td><td class='left'>   “void”                </td></tr><tr ><td class='left'>
auto                            </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(auto)                  </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(<span class='grammarterm'>expression</span>) </td><td class='left'>   the type as defined below</td></tr></table></div></div><div class='para' id='dcl.type.simple-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-3'>3</a></div><p >When multiple <span class='grammarterm'>simple-type-specifiers</span> are allowed, they can be
freely intermixed with other <span class='grammarterm'>decl-specifiers</span> in any order.
[&nbsp;<i>Note:</i>
It is <span class='indexparent'><a class='index' id='signedness_of_char'></a></span>implementation-defined whether objects of <span class='texttt'>char</span> type are
represented as signed or unsigned quantities. The <span class='texttt'>signed</span> specifier
forces <span class='texttt'>char</span> objects to be signed; it is redundant in other contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.simple-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-4'>4</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span>For an expression <span class='texttt'>e</span>, the type denoted by <span class='texttt'>decltype(e)</span> is defined as follows:</p><ul class='itemize'><li id='dcl.type.simple-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.simple-4.1'>(4.1)</a></div><p >if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> naming an lvalue or
reference introduced from the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> of a decomposition declaration,
<span class='texttt'>decltype(e)</span> is the referenced type as given in the specification of the decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>);</p></li><li id='dcl.type.simple-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.simple-4.2'>(4.2)</a></div><p >otherwise, if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> or
an unparenthesized
class
member access (<a href='expr.ref'>[expr.ref]</a>), <span class='texttt'>decltype(e)</span> is the
type of the entity named by <span class='texttt'>e</span>. If there is no such entity, or
if <span class='texttt'>e</span> names a set of overloaded functions, the program is
ill-formed;</p></li><li id='dcl.type.simple-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.simple-4.3'>(4.3)</a></div><p >otherwise, if <span class='texttt'>e</span> is
an xvalue, <span class='texttt'>decltype(e)</span> is <span class='texttt'>T&amp;&amp;</span>, where <span class='texttt'>T</span> is the type
of <span class='texttt'>e</span>;</p></li><li id='dcl.type.simple-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.simple-4.4'>(4.4)</a></div><p >otherwise, if <span class='texttt'>e</span> is an lvalue, <span class='texttt'>decltype(e)</span>
is <span class='texttt'>T&amp;</span>, where <span class='texttt'>T</span> is the type of <span class='texttt'>e</span>;</p></li><li id='dcl.type.simple-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.simple-4.5'>(4.5)</a></div><p >otherwise, <span class='texttt'>decltype(e)</span> is the type of <span class='texttt'>e</span>.
</p></li></ul><p >The operand of the <span class='texttt'>decltype</span> specifier is an unevaluated
operand (Clause <a href='expr'>[expr]</a>).</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const int&amp;&amp; foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = 17;        <span class='comment'>// type is <span class='texttt'>const int&amp;&amp;</span>
</span>decltype(i) x2;                 <span class='comment'>// type is <span class='texttt'>int</span>
</span>decltype(a-&gt;x) x3;              <span class='comment'>// type is <span class='texttt'>double</span>
</span>decltype((a-&gt;x)) x4 = x3;       <span class='comment'>// type is <span class='texttt'>const double&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
The rules for determining types involving <span class='texttt'>decltype(auto)</span> are specified
in <a href='dcl.spec.auto'>[dcl.spec.auto]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.simple-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.simple-5'>5</a></div><p >If the operand of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is a prvalue,
the temporary materialization conversion is not applied (<a href='conv.rval'>[conv.rval]</a>)
and no result object is provided for the prvalue.
The type of the prvalue may be incomplete.
[&nbsp;<i>Note:</i>
As a result, storage is not allocated for the prvalue and it is not destroyed.
Thus, a class type is not instantiated
as a result of being the type of a function call in this context. 
In this context, the common purpose of
writing the expression is merely to refer to its type. In that sense, a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is analogous to a use of a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>,
so the usual reasons for requiring a complete type do not apply. In particular,
it is not necessary to allocate storage for a temporary object or to enforce the
semantic constraints associated with invoking the type's destructor.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i>
Unlike the preceding rule, parentheses have no special meaning in this context.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A { ~A() = delete; };
template&lt;class T&gt; auto h()
  -&gt; A&lt;T&gt;;
template&lt;class T&gt; auto i(T)     <span class='comment'>// identity
</span>  -&gt; T;
template&lt;class T&gt; auto f(T)     <span class='comment'>// #1
</span>  -&gt; decltype(i(h&lt;T&gt;()));       <span class='comment'>// forces completion of <span class='texttt'>A&lt;T&gt;</span> and implicitly uses <span class='texttt'>A&lt;T&gt;::~A()</span>
</span>                                <span class='comment'>// for the temporary introduced by the use of <span class='texttt'>h()</span>.
</span>                                <span class='comment'>// (A temporary is not introduced as a result of the use of <span class='texttt'>i()</span>.)
</span>template&lt;class T&gt; auto f(T)     <span class='comment'>// #2
</span>  -&gt; void;
auto g() -&gt; void {
  f(42);                        <span class='comment'>// OK: calls #2. (#1 is not a viable candidate: type deduction
</span>                                <span class='comment'>// fails (<a href='temp.deduct'>[temp.deduct]</a>) because <span class='texttt'>A&lt;int&gt;::~A()</span> is implicitly used in its
</span>                                <span class='comment'>// <span class='grammarterm'>decltype-specifier</span>)
</span>}
template&lt;class T&gt; auto q(T)
  -&gt; decltype((h&lt;T&gt;()));        <span class='comment'>// does not force completion of <span class='texttt'>A&lt;T&gt;</span>; <span class='texttt'>A&lt;T&gt;::~A()</span> is not implicitly
</span>                                <span class='comment'>// used within the context of this <span class='grammarterm'>decltype-specifier</span>
</span>void r() {
  q(42);                        <span class='comment'>// Error: deduction against <span class='texttt'>q</span> succeeds, so overload resolution selects
</span>                                <span class='comment'>// the specialization “<span class='texttt'>q(T) -&gt; decltype((h&lt;T&gt;())) [with T=int]</span>”.
</span>                                <span class='comment'>// The return type is <span class='texttt'>A&lt;int&gt;</span>, so a temporary is introduced and its
</span>                                <span class='comment'>// destructor is used, so the program is ill-formed.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='dcl.type.elab'><h4 ><a class='secnum' href='#dcl.type.elab' style='min-width:118pt'>7.1.7.3</a> Elaborated type specifiers <a class='abbr_ref' href='dcl.type.elab'>[dcl.type.elab]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,elaborated'></a></span><span class='indexparent'><a class='index' id='typename'></a></span><span class='indexparent'><a class='index' id='type_specifier,enum'></a></span></p><pre class='bnf'><a id='nt:elaborated-type-specifier'>elaborated-type-specifier:</a>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <span class='terminal'>enum</span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><div class='para' id='dcl.type.elab-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-1'>1</a></div><p ><span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='name,elaborated,enum'></a></span>An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> shall not appear in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
unless the latter is the sole constituent of a declaration.
If an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is the sole constituent of a
declaration, the declaration is ill-formed unless it is an explicit
specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>), an explicit
instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or it has one of the following
forms:</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span>
<span class='terminal'>friend</span> <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> <span class='terminal'>;</span></pre><p >In the first case, the <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i>, if any, appertains
to the class being declared; the attributes in the
<i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of
the class whenever it is named.</p></div><div class='para' id='dcl.type.elab-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-2'>2</a></div><p ><a href='basic.lookup.elab'>[basic.lookup.elab]</a> describes how name lookup proceeds for the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. If the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a <i ><a href='class#nt:class-name'>class-name</a></i> or
<i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>, the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
introduces it into the declaration the same way a
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> introduces its <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>. If
the <i ><a href='lex.name#nt:identifier'>identifier</a></i> resolves to a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> or the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> resolves to
an alias template specialization,
the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is ill-formed.
[&nbsp;<i>Note:</i>
This implies that, within a class template with a template
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> <span class='texttt'>T</span>, the declaration</p><pre class='codeblock'>
friend class T;
</pre><p >is ill-formed. However, the similar declaration <span class='texttt'>friend T;</span> is allowed (<a href='class.friend'>[class.friend]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='dcl.type.elab-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.elab-3'>3</a></div><p >The <i ><a href='class#nt:class-key'>class-key</a></i> or <span class='texttt'>enum</span> keyword
present in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> shall agree in kind with the
declaration to which the name in the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> refers. This rule also applies to
the form of <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> that declares a
<i ><a href='class#nt:class-name'>class-name</a></i> or <span class='texttt'>friend</span> class since it can be construed
as referring to the definition of the class. Thus, in any
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, the <span class='texttt'>enum</span> keyword
shall be
used to refer to an enumeration (<a href='dcl.enum'>[dcl.enum]</a>), the <span class='texttt'>union</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a union
(Clause <a href='class'>[class]</a>), and either the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i> shall be used to refer to a class
(Clause <a href='class'>[class]</a>) declared using the <span class='texttt'>class</span> or <span class='texttt'>struct</span>
<i ><a href='class#nt:class-key'>class-key</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
enum class E { a, b };
enum E x = E::a;                <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='auto'><h4 ><a class='secnum' href='#auto' style='min-width:118pt'>7.1.7.4</a> The <span class='texttt'>auto</span> specifier <a class='abbr_ref' href='dcl.spec.auto'>[dcl.spec.auto]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span></p><div class='para' id='auto-1'><div class='marginalizedparent'><a class='marginalized' href='#auto-1'>1</a></div><p >The <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i>
are used to
designate a placeholder type that will be replaced later by deduction
from an initializer. The <span class='texttt'>auto</span>
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is also used to
introduce a function type having a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> or to
signify that a lambda is a generic lambda (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>).
The <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is also used to introduce a
decomposition declaration (<a href='dcl.decomp'>[dcl.decomp]</a>).</p></div><div class='para' id='auto-2'><div class='marginalizedparent'><a class='marginalized' href='#auto-2'>2</a></div><p >The placeholder type can appear with a function declarator in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>,
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>, or <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>,
in any context where such a declarator is valid. If the function declarator
includes a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> (<a href='dcl.fct'>[dcl.fct]</a>), that
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> specifies
the declared return type of the function. Otherwise, the function declarator
shall declare a function. If the declared return type of the
function contains a placeholder type, the return type of the function is
deduced from non-discarded <span class='texttt'>return</span> statements, if any, in the body
of the function (<a href='stmt.if'>[stmt.if]</a>).</p></div><div class='para' id='auto-3'><div class='marginalizedparent'><a class='marginalized' href='#auto-3'>3</a></div><p >If the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> appears as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, the
<span class='indexparent'><a class='index' id='generic_lambda,definition_of'></a></span>lambda is a <a class='hidden_link' href='#def:generic_lambda' id='def:generic_lambda'><i>generic lambda</i></a> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>). [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto glambda = [](int i, auto a) { return i; };     <span class='comment'>// OK: a generic lambda
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-4'><div class='marginalizedparent'><a class='marginalized' href='#auto-4'>4</a></div><p >The type of a variable declared using <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> is
deduced from its initializer. This use is allowed when declaring variables in a
block (<a href='stmt.block'>[stmt.block]</a>), in
namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>), and in an
<span class='rmfamily'></span><i> init-statement</i> (Clause <a href='stmt.stmt'>[stmt.stmt]</a>).
<span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> shall appear as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall be followed by one or more <i ><a href='dcl.decl#nt:init-declarator'>init-declarators</a></i>, each of which shall
have a non-empty <i ><a href='dcl.init#nt:initializer'>initializer</a></i>. In an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> of the form</p><pre class='codeblock'>
( <span class='grammarterm'>expression-list</span> )
</pre><p >the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> shall be a single
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x = 5;                     <span class='comment'>// OK: <span class='texttt'>x</span> has type <span class='texttt'>int</span>
</span>const auto *v = &amp;x, u = 6;      <span class='comment'>// OK: <span class='texttt'>v</span> has type <span class='texttt'>const int*</span>, <span class='texttt'>u</span> has type <span class='texttt'>const int</span>
</span>static auto y = 0.0;            <span class='comment'>// OK: <span class='texttt'>y</span> has type <span class='texttt'>double</span>
</span>auto int r;                     <span class='comment'>// error: <span class='texttt'>auto</span> is not a <span class='grammarterm'>storage-class-specifier</span>
</span>auto f() -&gt; int;                <span class='comment'>// OK: <span class='texttt'>f</span> returns <span class='texttt'>int</span>
</span>auto g() { return 0.0; }        <span class='comment'>// OK: <span class='texttt'>g</span> returns <span class='texttt'>double</span>
</span>auto h();                       <span class='comment'>// OK: <span class='texttt'>h</span>'s return type will be deduced when it is defined
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-5'><div class='marginalizedparent'><a class='marginalized' href='#auto-5'>5</a></div><p >A placeholder type can also be used in declaring a variable in
the <span class='rmfamily'></span><i> condition</i> of a selection statement (<a href='stmt.select'>[stmt.select]</a>) or an iteration
statement (<a href='stmt.iter'>[stmt.iter]</a>), in the <span class='rmfamily'></span><i> type-specifier-seq</i> in 
the <span class='rmfamily'></span><i> new-type-id</i> or <span class='rmfamily'></span><i> type-id</i> of a
<span class='rmfamily'></span><i> new-expression</i> (<a href='expr.new'>[expr.new]</a>), in a
<i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>,
in declaring a static data member with a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> that appears within the
<span class='rmfamily'></span><i> member-specification</i> of a class definition (<a href='class.static.data'>[class.static.data]</a>),
and as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
of the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration's</a></i>
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
in a <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> (<a href='temp.param'>[temp.param]</a>).</p></div><div class='para' id='auto-6'><div class='marginalizedparent'><a class='marginalized' href='#auto-6'>6</a></div><p >A program that uses <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> in a context not
explicitly allowed in this section is ill-formed.</p></div><div class='para' id='auto-7'><div class='marginalizedparent'><a class='marginalized' href='#auto-7'>7</a></div><p >If the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> contains more than one
<i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>, they shall all form declarations of
variables. The type of each declared variable is determined
by placeholder type deduction (<a href='dcl.type.auto.deduct'>[dcl.type.auto.deduct]</a>),
and if the type that replaces the placeholder type is not the
same in each deduction, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x = 5, *y = &amp;x;            <span class='comment'>// OK: <span class='texttt'>auto</span> is <span class='texttt'>int</span>
</span>auto a = 5, b = { 1, 2 };       <span class='comment'>// error: different types for <span class='texttt'>auto</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='specifier'></a></span></p></div><div class='para' id='auto-8'><div class='marginalizedparent'><a class='marginalized' href='#auto-8'>8</a></div><p >If a function with a declared return type that contains a placeholder type has
multiple non-discarded <span class='texttt'>return</span> statements, the return type is deduced for each
such <span class='texttt'>return</span> statement. If the type deduced is not the same in each
deduction, the program is ill-formed.</p></div><div class='para' id='auto-9'><div class='marginalizedparent'><a class='marginalized' href='#auto-9'>9</a></div><p >If a function with a declared return type that uses a placeholder type has no
non-discarded <span class='texttt'>return</span> statements, the return type is deduced as though from a
<span class='texttt'>return</span> statement with no operand at the closing brace of the function
body.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto  f() { }                   <span class='comment'>// OK, return type is <span class='texttt'>void</span>
</span>auto* g() { }                   <span class='comment'>// error, cannot deduce <span class='texttt'>auto*</span> from <span class='texttt'>void()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-10'><div class='marginalizedparent'><a class='marginalized' href='#auto-10'>10</a></div><p >If the type of an entity with an undeduced placeholder type is needed to
determine the type of an expression, the program is ill-formed. Once a
non-discarded <span class='texttt'>return</span> statement has been seen in a function, however, the return type deduced
from that statement can be used in the rest of the function, including in other
<span class='texttt'>return</span> statements.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto n = n;                     <span class='comment'>// error, <span class='texttt'>n</span>'s type is unknown
</span>auto f();
void g() { &amp;f; }                <span class='comment'>// error, <span class='texttt'>f</span>'s return type is unknown
</span>auto sum(int i) {
  if (i == 1)
    return i;                   <span class='comment'>// <span class='texttt'>sum</span>'s return type is <span class='texttt'>int</span>
</span>  else
    return sum(i-1)+i;          <span class='comment'>// OK, <span class='texttt'>sum</span>'s return type has been deduced
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-11'><div class='marginalizedparent'><a class='marginalized' href='#auto-11'>11</a></div><p >Return type deduction for a function template with a placeholder in its
declared type occurs when the definition is instantiated even if the function
body contains a <span class='texttt'>return</span> statement with a non-type-dependent operand.
[&nbsp;<i>Note:</i> Therefore, any use of a specialization of the function template will
cause an implicit instantiation. Any errors that arise from this instantiation
are not in the immediate context of the function type and can result in the
program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; auto f(T t) { return t; }    <span class='comment'>// return type deduced at instantiation time
</span>typedef decltype(f(1)) fint_t;                  <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to deduce return type
</span>template&lt;class T&gt; auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &amp;f; }               <span class='comment'>// instantiates both <span class='texttt'>f</span>s to determine return types,
</span>                                                <span class='comment'>// chooses second
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-12'><div class='marginalizedparent'><a class='marginalized' href='#auto-12'>12</a></div><p >Redeclarations or specializations of a function or function template with a
declared return type that uses a placeholder type shall also use that
placeholder, not a deduced type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto f();
auto f() { return 42; }                         <span class='comment'>// return type is <span class='texttt'>int</span>
</span>auto f();                                       <span class='comment'>// OK
</span>int f();                                        <span class='comment'>// error, cannot be overloaded with <span class='texttt'>auto f()</span>
</span>decltype(auto) f();                             <span class='comment'>// error, <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> don't match
</span>
template &lt;typename T&gt; auto g(T t) { return t; } <span class='comment'>// #1
</span>template auto g(int);                           <span class='comment'>// OK, return type is <span class='texttt'>int</span>
</span>template char g(char);                          <span class='comment'>// error, no matching template
</span>template&lt;&gt; auto g(double);                      <span class='comment'>// OK, forward declaration with unknown return type
</span>
template &lt;class T&gt; T g(T t) { return t; }       <span class='comment'>// OK, not functionally equivalent to #1
</span>template char g(char);                          <span class='comment'>// OK, now there is a matching template
</span>template auto g(float);                         <span class='comment'>// still matches #1
</span>
void h() { return g(42); }                      <span class='comment'>// error, ambiguous
</span>
template &lt;typename T&gt; struct A {
  friend T frf(T);
};
auto frf(int i) { return i; }                   <span class='comment'>// not a friend of <span class='texttt'>A&lt;int&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='auto-13'><div class='marginalizedparent'><a class='marginalized' href='#auto-13'>13</a></div><p >A function declared with a return type that uses a placeholder type shall not
be <span class='texttt'>virtual</span> (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='auto-14'><div class='marginalizedparent'><a class='marginalized' href='#auto-14'>14</a></div><p >An explicit instantiation declaration (<a href='temp.explicit'>[temp.explicit]</a>) does not cause the
instantiation of an entity declared using a placeholder type, but it also does
not prevent that entity from being instantiated as needed to determine its
type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;typename T&gt; auto f(T t) { return t; }
extern template auto f(int);    <span class='comment'>// does not instantiate <span class='texttt'>f&lt;int&gt;</span>
</span>int (*p)(int) = f;              <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to determine its return type, but an explicit
</span>                                <span class='comment'>// instantiation definition is still required somewhere in the program
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='dcl.type.auto.deduct'><h4 ><a class='secnum' href='#dcl.type.auto.deduct' style='min-width:133pt'>7.1.7.4.1</a> Placeholder type deduction <a class='abbr_ref' href='dcl.type.auto.deduct'>[dcl.type.auto.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,placeholder_type'></a></span>
</p><div class='para' id='dcl.type.auto.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-1'>1</a></div><p ><a class='hidden_link' href='#def:placeholder_type_deduction' id='def:placeholder_type_deduction'><i>Placeholder type deduction</i></a>
is the process by which
a type containing a placeholder type
is replaced by a deduced type.</p></div><div class='para' id='dcl.type.auto.deduct-2'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-2'>2</a></div><p >A type <span class='texttt'>T</span> containing a placeholder type,
and a corresponding initializer <span class='texttt'>e</span>,
are determined as follows:</p><ul class='itemize'><li id='dcl.type.auto.deduct-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.auto.deduct-2.1'>(2.1)</a></div><p >for a non-discarded <span class='texttt'>return</span> statement that occurs
in a function declared with a return type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared return type
and <span class='texttt'>e</span> is the operand of the <span class='texttt'>return</span> statement.
If the <span class='texttt'>return</span> statement
has no operand,
then <span class='texttt'>e</span> is <span class='texttt'>void()</span>;
</p></li><li id='dcl.type.auto.deduct-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.auto.deduct-2.2'>(2.2)</a></div><p >for a variable declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the variable
and <span class='texttt'>e</span> is the initializer.
If the initialization is direct-list-initialization,
the initializer shall be a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
containing only a single <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
and <span class='texttt'>e</span> is the <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>;
</p></li><li id='dcl.type.auto.deduct-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dcl.type.auto.deduct-2.3'>(2.3)</a></div><p >for a non-type template parameter declared with a type
that contains a placeholder type,
<span class='texttt'>T</span> is the declared type of the non-type template parameter
and <span class='texttt'>e</span> is the corresponding template argument.
</p></li></ul><p >In the case of a <span class='texttt'>return</span> statement with no operand
or with an operand of type <span class='texttt'>void</span>,
<span class='texttt'>T</span> shall be either
<span class='texttt'>decltype(auto)</span> or <i>cv</i> <span class='texttt'>auto</span>.</p></div><div class='para' id='dcl.type.auto.deduct-3'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-3'>3</a></div><p >If the deduction is for a <span class='texttt'>return</span> statement
and <span class='texttt'>e</span> is a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>),
the program is ill-formed.</p></div><div class='para' id='dcl.type.auto.deduct-4'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-4'>4</a></div><p >If the placeholder is the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, the
deduced type
<span class='math'><span class='mathtt'>T</span>'</span> replacing <span class='texttt'>T</span>
is determined using the rules for template argument deduction.
Obtain <span class='texttt'>P</span> from
<span class='texttt'>T</span> by replacing the occurrences of <span class='texttt'>auto</span> with either a new
invented type template parameter <span class='texttt'>U</span> or,
if the initialization is copy-list-initialization, with
<span class='texttt'>std::initializer_list&lt;U&gt;</span>. Deduce a value for <span class='texttt'>U</span> using the rules
of template argument deduction from a function call (<a href='temp.deduct.call'>[temp.deduct.call]</a>),
where <span class='texttt'>P</span> is a
function template parameter type and
the corresponding argument is <span class='texttt'>e</span>.
If the deduction fails, the declaration is ill-formed.
Otherwise, <span class='math'><span class='mathtt'>T</span>'</span> is obtained by
substituting the deduced <span class='texttt'>U</span> into <span class='texttt'>P</span>.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x1 = { 1, 2 };             <span class='comment'>// <span class='texttt'>decltype(x1)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x2 = { 1, 2.0 };           <span class='comment'>// error: cannot deduce element type
</span>auto x3{ 1, 2 };                <span class='comment'>// error: not a single element
</span>auto x4 = { 3 };                <span class='comment'>// <span class='texttt'>decltype(x4)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x5{ 3 };                   <span class='comment'>// <span class='texttt'>decltype(x5)</span> is <span class='texttt'>int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const auto &amp;i = expr;
</pre><p >The type of <span class='texttt'>i</span> is the deduced type of the parameter <span class='texttt'>u</span> in
the call <span class='texttt'>f(expr)</span> of the following invented function template:
</p><pre class='codeblock'>
template &lt;class U&gt; void f(const U&amp; u);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='dcl.type.auto.deduct-5'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.auto.deduct-5'>5</a></div><p >If the placeholder is the <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>,
<span class='texttt'>T</span> shall be the
placeholder alone. The type deduced for <span class='texttt'>T</span> is
determined as described in <a href='dcl.type.simple'>[dcl.type.simple]</a>, as though
<span class='texttt'>e</span> had
been the operand of the <span class='texttt'>decltype</span>. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int i;
int&amp;&amp; f();
auto           x2a(i);          <span class='comment'>// <span class='texttt'>decltype(x2a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x2d(i);          <span class='comment'>// <span class='texttt'>decltype(x2d)</span> is <span class='texttt'>int</span>
</span>auto           x3a = i;         <span class='comment'>// <span class='texttt'>decltype(x3a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x3d = i;         <span class='comment'>// <span class='texttt'>decltype(x3d)</span> is <span class='texttt'>int</span>
</span>auto           x4a = (i);       <span class='comment'>// <span class='texttt'>decltype(x4a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x4d = (i);       <span class='comment'>// <span class='texttt'>decltype(x4d)</span> is <span class='texttt'>int&amp;</span>
</span>auto           x5a = f();       <span class='comment'>// <span class='texttt'>decltype(x5a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x5d = f();       <span class='comment'>// <span class='texttt'>decltype(x5d)</span> is <span class='texttt'>int&amp;&amp;</span>
</span>auto           x6a = { 1, 2 };  <span class='comment'>// <span class='texttt'>decltype(x6a)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>decltype(auto) x6d = { 1, 2 };  <span class='comment'>// error, <span class='texttt'>{ 1, 2 }</span> is not an expression
</span>auto          *x7a = &amp;i;        <span class='comment'>// <span class='texttt'>decltype(x7a)</span> is <span class='texttt'>int*</span>
</span>decltype(auto)*x7d = &amp;i;        <span class='comment'>// error, declared type is not plain <span class='texttt'>decltype(auto)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='dcl.type.class.deduct'><h4 ><a class='secnum' href='#dcl.type.class.deduct' style='min-width:118pt'>7.1.7.5</a> Deduced class template specialization types <a class='abbr_ref' href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>
</p><div class='para' id='dcl.type.class.deduct-1'><div class='marginalizedparent'><a class='marginalized' href='#dcl.type.class.deduct-1'>1</a></div><p >If a placeholder for a deduced class type
appears as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i>,
the <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>
of that declaration
shall be of the form</p><pre class='bnf'><i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.init#nt:initializer'>initializer</a></i></pre><p >The placeholder is replaced by the return type
of the function selected by overload resolution
for class template deduction (<a href='over.match.class.deduct'>[over.match.class.deduct]</a>).
If the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
contains more than one <i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>,
the type that replaces the placeholder shall be the same in each deduction.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct container {
    container(T t) {}
    template&lt;class Iter&gt; container(Iter beg, Iter end);
};
template&lt;class Iter&gt;
container(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;
std::vector&lt;double&gt; v = { <span class='comment'>/* ... */</span>};

container c(7);                         <span class='comment'>// OK, deduces <span class='texttt'>int</span> for <span class='texttt'>T</span>
</span>auto d = container(v.begin(), v.end()); <span class='comment'>// OK, deduces <span class='texttt'>double</span> for <span class='texttt'>T</span>
</span>container e{5, 6};                      <span class='comment'>// error, <span class='texttt'>int</span> is not an iterator
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></div></body></html>