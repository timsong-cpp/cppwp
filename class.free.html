<!DOCTYPE html><html lang='en'><head><title>[class.free]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>15.5</a> Free store <a class='abbr_ref'>[class.free]</a></h2><span class='indexparent'><a class='index' id=':free_store'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1310'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':new,type_of'></a></span>
Any allocation function for a class
<span class='texttt'>T</span>
is a static member (even if not explicitly declared
<span class='texttt'>static</span>)<a class='hidden_link' href='#1.sentence-1'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1317'>#</a></div><div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Arena;
struct B {
  void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};

Arena*  ap;
void foo(int i) {
  new (ap) D1;      <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;operator new(std&#x200b;::&#x200b;size_&shy;t, Arena*)</span>
</span>  new D1[i];        <span class='comment'>// calls <span class='tcode_in_codeblock'>&#x200b;::&#x200b;operator new[](std&#x200b;::&#x200b;size_&shy;t)</span>
</span>  new D1;           <span class='comment'>// ill-formed: <span class='tcode_in_codeblock'>&#x200b;::&#x200b;operator new(std&#x200b;::&#x200b;size_&shy;t)</span> hidden
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1336'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':delete'></a></span>When an object is deleted with a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>,
a deallocation function
<span class='indexparent'><a class='index' id=':function,deallocation'></a></span>(<span class='texttt'>operator delete()</span>
<span class='indexparent'><a class='index' id=':operator_delete'></a></span>for non-array objects or
<span class='texttt'>operator delete[]()</span>
<span class='indexparent'><a class='index' id=':operator_delete_'></a></span>for arrays) is (implicitly) called to reclaim the storage occupied by
the object (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)<a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1350'>#</a></div><div id='4.sentence-1' class='sentence'>Class-specific deallocation function lookup is a part of general deallocation
function lookup (<a href='expr.delete'>[expr.delete]</a>) and occurs as follows<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>If the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
is used to deallocate a class object whose static type has a virtual
destructor, the deallocation function is the one selected at the point
of definition of the dynamic type's virtual
destructor (<a href='class.dtor'>[class.dtor]</a>)<a class='hidden_link' href='#4.sentence-2'>.</a><a class='footnotenum' href='#footnote-117'>117</a></div> <div id='4.sentence-3' class='sentence'>
Otherwise, if the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
is used to deallocate an object of class
<span class='texttt'>T</span>
or array thereof,
the deallocation function's name is looked up in the scope of
<span class='texttt'>T</span><a class='hidden_link' href='#4.sentence-3'>.</a></div> <div id='4.sentence-4' class='sentence'>If this lookup fails to find the name, general deallocation function
lookup (<a href='expr.delete'>[expr.delete]</a>) continues<a class='hidden_link' href='#4.sentence-4'>.</a></div> <div id='4.sentence-5' class='sentence'>If the result of the lookup is ambiguous or inaccessible, or if the lookup
selects a placement deallocation function, the program is ill-formed<a class='hidden_link' href='#4.sentence-5'>.</a></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1374'>#</a></div><div id='5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':delete,type_of'></a></span>Any deallocation function for a class
<span class='texttt'>X</span>
is a static member (even if not explicitly declared
<span class='texttt'>static</span>)<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class X {
  void operator delete(void*);
  void operator delete[](void*, std::size_t);
};

class Y {
  void operator delete(void*, std::size_t);
  void operator delete[](void*);
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1394'>#</a></div><div id='6.sentence-1' class='sentence'>Since member allocation and deallocation functions are
<span class='texttt'>static</span>
they cannot be virtual<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#6.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='6.sentence-2' class='sentence'>However, when the
<i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
refers to an object of class type,
because the deallocation function actually called is looked up in the scope of
the class that is the dynamic type of the object
if the destructor is virtual, the effect is the same in that case<a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>For example,
<pre class='codeblock'>
struct B {
  virtual ~B();
  void operator delete(void*, std::size_t);
};

struct D : B {
  void operator delete(void*);
};

struct E : B {
  void log_deletion();
  void operator delete(E *p, std::destroying_delete_t) {
    p-&gt;log_deletion();
    p-&gt;~E();
    ::operator delete(p);
  }
};

void f() {
  B* bp = new D;
  delete bp;        <span class='comment'>// 1: uses <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;operator delete(void*)</span>
</span>  bp = new E;
  delete bp;        <span class='comment'>// 2: uses <span class='tcode_in_codeblock'>E&#x200b;::&#x200b;operator delete(E*, std&#x200b;::&#x200b;destroying_&shy;delete_&shy;t)</span>
</span>}</pre>
Here, storage for the object of class
<span class='texttt'>D</span>
is deallocated by
<span class='texttt'>D&#x200b;::&#x200b;operator delete()</span>,
and
the object of class <span class='texttt'>E</span> is destroyed
and its storage is deallocated
by <span class='texttt'>E&#x200b;::&#x200b;operator delete()</span>,
due to the virtual destructor<a class='hidden_link' href='#6.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='6.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#6.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='6.sentence-4' class='sentence'>Virtual destructors have no effect on the deallocation function actually
called when the
<i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
refers to an array of objects of class type<a class='hidden_link' href='#6.sentence-4'>.</a></div> <div id='6.sentence-5' class='sentence'>For example,
<pre class='codeblock'>
struct B {
  virtual ~B();
  void operator delete[](void*, std::size_t);
};

struct D : B {
  void operator delete[](void*, std::size_t);
};

void f(int i) {
  D* dp = new D[i];
  delete [] dp;     <span class='comment'>// uses <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;operator delete[](void*, std&#x200b;::&#x200b;size_&shy;t)</span>
</span>  B* bp = new D[i];
  delete[] bp;      <span class='comment'>// undefined behavior
</span>}</pre></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1471'>#</a></div><div id='7.sentence-1' class='sentence'>Access to the deallocation function is checked statically<a class='hidden_link' href='#7.sentence-1'>.</a></div> <div id='7.sentence-2' class='sentence'>Hence, even though a different one might actually be executed,
the statically visible deallocation function is required to be accessible<a class='hidden_link' href='#7.sentence-2'>.</a></div> <div id='7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='7.sentence-3' class='sentence'>For the call on line “// 1” above,
if
<span class='texttt'>B&#x200b;::&#x200b;operator delete()</span>
had been private, the delete expression would have been ill-formed<a class='hidden_link' href='#7.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/7231f47876a82200e7eeb000a1e90f0af19cdab1/source/special.tex#L1482'>#</a></div><div id='8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='8.sentence-1' class='sentence'>If a deallocation function has no explicit <i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i>, it
has a non-throwing <a href='except.spec'>exception specification</a><a class='hidden_link' href='#8.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-117'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-117'>117)</a></div><div id='footnote-117.sentence-1' class='sentence'>A similar provision is not needed for
the array version of <span class='texttt'>operator</span> <span class='texttt'>delete</span> because <a href='expr.delete'>[expr.delete]</a>
requires that in this situation, the static type of the object to be deleted be
the same as its dynamic type<a class='hidden_link' href='#footnote-117.sentence-1'>.</a></div></div></div></body></html>