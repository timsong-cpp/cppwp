<!DOCTYPE html><html lang='en'><head><title>[temp.arg.template]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>17</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>17.3</a> Template arguments <a class='abbr_ref' href='temp.arg#template'>[temp.arg]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>17.3.3</a> Template template arguments <a class='abbr_ref'>[temp.arg.template]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/templates.tex#L1105'>#</a></div><p >A
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
for a template
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
shall be the name of a class template or an alias template, expressed as
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>.
When the <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> names a class
template, only primary class templates are considered when matching the template template
argument with the corresponding parameter; partial specializations are not
considered even if their parameter lists match that of the template template
parameter.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/templates.tex#L1118'>#</a></div><p >Any <a href='temp.class.spec'>partial specializations</a> associated with the
primary class template or primary variable template are considered when a
specialization based on the template
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is instantiated.
If a specialization is not visible at the point of instantiation,
and it would have been selected had it been visible, the program is ill-formed,
no diagnostic required.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
template&lt;class T&gt; class A {     <span class='comment'>// primary template
</span>  int x;
};
template&lt;class T&gt; class A&lt;T*&gt; { <span class='comment'>// partial specialization
</span>  long x;
};
template&lt;template&lt;class U&gt; class V&gt; class C {
  V&lt;int&gt;  y;
  V&lt;int*&gt; z;
};
C&lt;A&gt; c;             <span class='comment'>// <span class='tcode_in_codeblock'>V&lt;int&gt;</span> within <span class='tcode_in_codeblock'>C&lt;A&gt;</span> uses the primary template, so <span class='tcode_in_codeblock'>c.y.x</span> has type <span class='tcode_in_codeblock'>int</span>
</span>                    <span class='comment'>// <span class='tcode_in_codeblock'>V&lt;int*&gt;</span> within <span class='tcode_in_codeblock'>C&lt;A&gt;</span> uses the partial specialization, so <span class='tcode_in_codeblock'>c.z.x</span> has type <span class='tcode_in_codeblock'>long</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/templates.tex#L1145'>#</a></div><p >A <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> matches a template
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> <span class='texttt'>P</span> when
<span class='texttt'>P</span> is at least as specialized as the <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> <span class='texttt'>A</span>.
If <span class='texttt'>P</span> contains a parameter pack, then <span class='texttt'>A</span> also matches <span class='texttt'>P</span>
if each of <span class='texttt'>A</span>'s template parameters
matches the corresponding template parameter in the
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> of <span class='texttt'>P</span>.
Two template parameters match if they are of the same kind (type, non-type, template),
for non-type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span>, their types are
equivalent (<a href='temp.over.link'>[temp.over.link]</a>), and for template <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span>,
each of their corresponding <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><span class='textit'>s</span> matches, recursively.
When <span class='texttt'>P</span>'s <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> contains a
<a href='temp.variadic#def:template_parameter_pack'>template parameter pack</a>,
the template parameter pack will match zero or more template
parameters or template parameter packs in the <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> of
<span class='texttt'>A</span> with the same type and form as the template parameter pack in <span class='texttt'>P</span>
(ignoring whether those template parameters are template parameter packs).</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
template&lt;class T&gt; class A { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class T, class U = T&gt; class B { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;class ... Types&gt; class C { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;auto n&gt; class D { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;template&lt;class&gt; class P&gt; class X { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;template&lt;class ...&gt; class Q&gt; class Y { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
template&lt;template&lt;int&gt; class R&gt; class Z { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };

X&lt;A&gt; xa;            <span class='comment'>// OK
</span>X&lt;B&gt; xb;            <span class='comment'>// OK
</span>X&lt;C&gt; xc;            <span class='comment'>// OK
</span>Y&lt;A&gt; ya;            <span class='comment'>// OK
</span>Y&lt;B&gt; yb;            <span class='comment'>// OK
</span>Y&lt;C&gt; yc;            <span class='comment'>// OK
</span>Z&lt;D&gt; zd;            <span class='comment'>// OK
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
template &lt;class T&gt; struct eval;

template &lt;template &lt;class, class...&gt; class TT, class T1, class... Rest&gt;
struct eval&lt;TT&lt;T1, Rest...&gt;&gt; { };

template &lt;class T1&gt; struct A;
template &lt;class T1, class T2&gt; struct B;
template &lt;int N&gt; struct C;
template &lt;class T1, int N&gt; struct D;
template &lt;class T1, class T2, int N = 17&gt; struct E;

eval&lt;A&lt;int&gt;&gt; eA;            <span class='comment'>// OK: matches partial specialization of <span class='tcode_in_codeblock'>eval</span>
</span>eval&lt;B&lt;int, float&gt;&gt; eB;     <span class='comment'>// OK: matches partial specialization of <span class='tcode_in_codeblock'>eval</span>
</span>eval&lt;C&lt;17&gt;&gt; eC;             <span class='comment'>// error: <span class='tcode_in_codeblock'>C</span> does not match <span class='tcode_in_codeblock'>TT</span> in partial specialization
</span>eval&lt;D&lt;int, 17&gt;&gt; eD;        <span class='comment'>// error: <span class='tcode_in_codeblock'>D</span> does not match <span class='tcode_in_codeblock'>TT</span> in partial specialization
</span>eval&lt;E&lt;int, float&gt;&gt; eE;     <span class='comment'>// error: <span class='tcode_in_codeblock'>E</span> does not match <span class='tcode_in_codeblock'>TT</span> in partial specialization
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/templates.tex#L1204'>#</a></div><p >A template <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> <span class='texttt'>P</span> is
at least as specialized as a template <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> <span class='texttt'>A</span>
if, given the following rewrite to two function templates,
the function template corresponding to <span class='texttt'>P</span>
is at least as specialized as
the function template corresponding to <span class='texttt'>A</span>
according to the <a href='temp.func.order'>partial ordering rules
for function templates</a>.
Given an invented class template <span class='texttt'>X</span>
with the template parameter list of <span class='texttt'>A</span> (including default arguments):</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >Each of the two function templates has the same template parameters,
respectively, as <span class='texttt'>P</span> or <span class='texttt'>A</span>.
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >Each function template has a single function parameter
whose type is a specialization of <span class='texttt'>X</span>
with template arguments corresponding to the template parameters
from the respective function template where,
for each template parameter <span class='texttt'>PP</span>
in the template parameter list of the function template,
a corresponding template argument <span class='texttt'>AA</span> is formed.
If <span class='texttt'>PP</span> declares a parameter pack,
then <span class='texttt'>AA</span> is the pack expansion <span class='texttt'>PP...</span> (<a href='temp.variadic'>[temp.variadic]</a>);
otherwise, <span class='texttt'>AA</span> is the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> <span class='texttt'>PP</span>.
</p></li></ul><p >If the rewrite produces an invalid type,
then <span class='texttt'>P</span> is not at least as specialized as <span class='texttt'>A</span>.</p></div></div></body></html>