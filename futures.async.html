<!DOCTYPE html><html lang='en'><head><title>[futures.async]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>33</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>33.6</a> Futures <a class='abbr_ref' href='futures#async'>[futures]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>33.6.9</a> Function template <span class='texttt'>async</span> <a class='abbr_ref'>[futures.async]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4795'>#</a></div><div id='1.sentence-1' class='sentence'>The function template <span class='texttt'>async</span> provides a mechanism to launch a function potentially
in a new thread and provides the result of the function in a <span class='texttt'>future</span> object with which
it shares a shared state<a class='hidden_link' href='#1.sentence-1'>.</a></div> <span class='indexparent'><a class='index' id='lib:async'></a></span></div><code class='itemdecl'>template &lt;class F, class... Args&gt;
  future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</code><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4811'>#</a></div><div id='2.sentence-1' class='sentence'><span class='textit'>Requires:</span> <span class='texttt'>F</span> and each <span class='texttt'>Ti</span> in <span class='texttt'>Args</span> shall
satisfy the
<span class='texttt'>MoveConstructible</span> requirements, and
<pre class='codeblock'>
<span class='textit'>INVOKE</span>(<span class='textit'>DECAY_COPY</span>(std::forward&lt;F&gt;(f)),
       <span class='textit'>DECAY_COPY</span>(std::forward&lt;Args&gt;(args))...)     <span class='comment'>// see <a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>
</span></pre>
shall be a valid expression<a class='hidden_link' href='#2.sentence-1'>.</a></div></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4821'>#</a></div><div id='3.sentence-1' class='sentence'><span class='textit'>Effects:</span>
The first function
behaves the same as a call to the second function with a <span class='texttt'>policy</span> argument of
<span class='texttt'>launch&#x200b;::&#x200b;async | launch&#x200b;::&#x200b;deferred</span>
and the same arguments for <span class='texttt'>F</span> and <span class='texttt'>Args</span><a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>The second function creates a shared state that is associated with
the returned <span class='texttt'>future</span> object<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.sentence-3' class='sentence'>The further behavior
of the second function depends on the <span class='texttt'>policy</span> argument as follows (if
more than one of these conditions applies, the implementation may choose any of
the corresponding policies):</div><div id='3.sentence-4' class='sentence'><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'>If <span class='texttt'>launch&#x200b;::&#x200b;async</span> is set in <span class='texttt'>policy</span>, calls
<span class='texttt'><span class='textit'>INVOKE</span>(<span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;F&gt;(f)),</span>
<span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;Args&gt;(args))...)</span>
(<a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>)
as if in a new thread of execution represented by a <span class='texttt'>thread</span> object
with the calls to <span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>()</span> being evaluated in the thread that called <span class='texttt'>async</span><a class='hidden_link' href='#3.1.sentence-1'>.</a></div> <div id='3.1.sentence-2' class='sentence'>Any return value
is stored as the result in the
shared state<a class='hidden_link' href='#3.1.sentence-2'>.</a></div> <div id='3.1.sentence-3' class='sentence'>Any exception propagated from
the execution of
<span class='texttt'><span class='textit'>INVOKE</span>(<span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;F&gt;(f)),
<span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;Args&gt;(args))...)</span>
is stored as the exceptional result in the shared state<a class='hidden_link' href='#3.1.sentence-3'>.</a></div> <div id='3.1.sentence-4' class='sentence'>The <span class='texttt'>thread</span> object is
stored in the shared state
and affects the behavior of any asynchronous return objects that
reference that state<a class='hidden_link' href='#3.1.sentence-4'>.</a></div></li><li id='3.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'>If <span class='texttt'>launch&#x200b;::&#x200b;deferred</span> is set in <span class='texttt'>policy</span>,
stores <span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;F&gt;(f))</span> and
<span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;Args&gt;(args))...</span>
in the shared state<a class='hidden_link' href='#3.2.sentence-1'>.</a></div> <div id='3.2.sentence-2' class='sentence'>These copies of <span class='texttt'>f</span> and <span class='texttt'>args</span> constitute
a <a class='hidden_link' href='#def:deferred_function' id='def:deferred_function'><i >deferred function</i></a><a class='hidden_link' href='#3.2.sentence-2'>.</a></div> <div id='3.2.sentence-3' class='sentence'>Invocation of the deferred function evaluates
<span class='texttt'><span class='textit'>INVOKE</span>(std&#x200b;::&#x200b;move(g), std&#x200b;::&#x200b;move(xyz))</span> where <span class='texttt'>g</span> is the stored value of
<span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;F&gt;(f))</span> and <span class='texttt'>xyz</span> is the stored copy of
<span class='texttt'><span class='textit'>DECAY_&shy;COPY</span>(std&#x200b;::&#x200b;forward&lt;Args&gt;(args))...</span><a class='hidden_link' href='#3.2.sentence-3'>.</a></div> <div id='3.2.sentence-4' class='sentence'>Any return value is stored
as the result in the shared state<a class='hidden_link' href='#3.2.sentence-4'>.</a></div> <div id='3.2.sentence-5' class='sentence'>Any exception propagated
from the execution
of the deferred function
is stored as the exceptional result
in the shared state<a class='hidden_link' href='#3.2.sentence-5'>.</a></div> <div id='3.2.sentence-6' class='sentence'>The shared state is not
made ready until the function has completed<a class='hidden_link' href='#3.2.sentence-6'>.</a></div> <div id='3.2.sentence-7' class='sentence'>The first call to a
non-timed waiting function (<a href='futures.state'>[futures.state]</a>)
on an asynchronous return object referring to
this shared state shall invoke the
deferred function in the thread that called the waiting function<a class='hidden_link' href='#3.2.sentence-7'>.</a></div> <div id='3.2.sentence-8' class='sentence'>Once evaluation of <span class='texttt'><span class='textit'>INVOKE</span>(std&#x200b;::&#x200b;move(g), std&#x200b;::&#x200b;move(xyz))</span> begins, the function is no longer
considered deferred<a class='hidden_link' href='#3.2.sentence-8'>.</a></div> <div id='3.2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.2.sentence-9' class='sentence'>If this policy is specified together with other policies, such as when using a
<span class='texttt'>policy</span> value of <span class='texttt'>launch&#x200b;::&#x200b;async | launch&#x200b;::&#x200b;deferred</span>, implementations should defer
invocation or the selection of the policy when no more concurrency can be effectively
exploited<a class='hidden_link' href='#3.2.sentence-9'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='3.3'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#3.3'>(3.3)</a></div><div id='3.3.sentence-1' class='sentence'>If no value is set in the launch policy, or a value is set that is neither specified
in this International Standard nor by the implementation, the behavior is undefined<a class='hidden_link' href='#3.3.sentence-1'>.</a></div></li></ul></div></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4888'>#</a></div><div id='4.sentence-1' class='sentence'><span class='textit'>Returns:</span> An object of type
<span class='texttt'>future&lt;invoke_&shy;result_&shy;t&lt;decay_&shy;t&lt;F&gt;, decay_&shy;t&lt;Args&gt;...&gt;&gt;</span> that refers
to the shared state created by this call to <span class='texttt'>async</span><a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='4.sentence-2' class='sentence'>If a future obtained from <span class='texttt'>async</span> is moved outside the local scope,
other code that uses the future must be aware that the future's destructor may
block for the shared state to become ready<a class='hidden_link' href='#4.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4896'>#</a></div><div id='5.sentence-1' class='sentence'><span class='textit'>Synchronization:</span>
Regardless of the provided <span class='texttt'>policy</span> argument,
<ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#5.1'>(5.1)</a></div><div id='5.1.sentence-1' class='sentence'>the invocation of <span class='texttt'>async</span>
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f</span><a class='hidden_link' href='#5.1.sentence-1'>.</a></div> <div id='5.1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#5.1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='5.1.sentence-3' class='sentence'>This statement applies even when the corresponding <span class='texttt'>future</span> object is moved to
another thread<a class='hidden_link' href='#5.1.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='5.1.sentence-2' class='sentence'>; and</div></li><li id='5.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#5.2'>(5.2)</a></div><div id='5.2.sentence-1' class='sentence'>the completion of the function <span class='texttt'>f</span> is sequenced before (<a href='intro.multithread'>[intro.multithread]</a>) the
shared state is made ready<a class='hidden_link' href='#5.2.sentence-1'>.</a></div> <div id='5.2.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#5.2.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='5.2.sentence-2' class='sentence'><span class='texttt'>f</span> might not be called at all,
so its completion might never happen<a class='hidden_link' href='#5.2.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul></div><div id='5.sentence-2' class='sentence'>If the implementation chooses the <span class='texttt'>launch&#x200b;::&#x200b;async</span> policy,</div><div id='5.sentence-3' class='sentence'><ul class='itemize'><li id='5.3'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#5.3'>(5.3)</a></div><div id='5.3.sentence-1' class='sentence'>a call to a waiting function on an asynchronous return
object that shares the shared state created by this <span class='texttt'>async</span> call shall
block until the associated thread has completed, as if joined, or else time
out (<a href='thread.thread.member'>[thread.thread.member]</a>);</div></li><li id='5.4'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#5.4'>(5.4)</a></div><div id='5.4.sentence-1' class='sentence'>the associated thread completion
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the return from
the first function
that successfully detects the ready status of the shared state or
with the return from the last
function that releases the shared state, whichever
happens first<a class='hidden_link' href='#5.4.sentence-1'>.</a></div></li></ul></div></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4933'>#</a></div><div id='6.sentence-1' class='sentence'><span class='textit'>Throws:</span> <span class='texttt'>system_&shy;error</span> if <span class='texttt'>policy == launch&#x200b;::&#x200b;async</span> and the
implementation is unable to start a new thread, or
<span class='texttt'>std&#x200b;::&#x200b;bad_&shy;alloc</span> if memory for the internal data structures
could not be allocated<a class='hidden_link' href='#6.sentence-1'>.</a></div></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4939'>#</a></div><div id='7.sentence-1' class='sentence'><span class='textit'>Error conditions:</span>
<ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#7.1'>(7.1)</a></div><div id='7.1.sentence-1' class='sentence'><span class='texttt'>resource_&shy;unavailable_&shy;try_&shy;again</span> — if
<span class='texttt'>policy == launch&#x200b;::&#x200b;async</span> and the system is unable to start a new thread<a class='hidden_link' href='#7.1.sentence-1'>.</a></div></li></ul></div></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/48da313836eb57fd8282649c6c17b50a9cb97c3a/source/threads.tex#L4947'>#</a></div><div id='8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
int work1(int value);
int work2(int value);
int work(int value) {
  auto handle = std::async([=]{ return work2(value); });
  int tmp = work1(value);
  return tmp + handle.get();    <span class='comment'>// #1
</span>}</pre><div id='8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='8.sentence-1' class='sentence'>Line #1 might not result in concurrency because
the <span class='texttt'>async</span> call uses the default policy, which may use
<span class='texttt'>launch&#x200b;::&#x200b;deferred</span>, in which case the lambda might not be invoked until the
<span class='texttt'>get()</span> call; in that case, <span class='texttt'>work1</span> and <span class='texttt'>work2</span> are called on the
same thread and there is no concurrency<a class='hidden_link' href='#8.sentence-1'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div></div></body></html>