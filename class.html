<!DOCTYPE html><html lang='en'><head><title>[class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='class'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><p ><span class='indexparent'><a class='index' id='class'></a></span></p><p ><span class='indexparent'><a class='index' id='class,member_function'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='{},class_declaration'></a></span><span class='indexparent'><a class='index' id='{},class_definition'></a></span><span class='indexparent'><a class='index' id='type,class_and'></a></span><span class='indexparent'><a class='index' id='object_class'></a></span>A class is a type.
<span class='indexparent'><a class='index' id='name_class'></a></span>Its name becomes a <i ><a href='class#nt:class-name'>class-name</a></i> (<a href='class.name'>[class.name]</a>) within its
scope.</p><pre class='bnf'><a id='nt:class-name'>class-name:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><p ><i ><a href='class#nt:class-specifier'>Class-specifiers</a></i> and
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifiers</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) are used to
make <i ><a href='class#nt:class-name'>class-names</a></i>. An object of a class consists of a
(possibly empty) sequence of members and base class objects.</p><pre class='bnf'><a id='nt:class-specifier'>class-specifier:</a>
    <i ><a href='class#nt:class-head'>class-head</a></i> <span class='terminal'>{</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:class-head'>class-head:</a>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-head-name'>class-head-name</a></i> <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.derived#nt:base-clause'>base-clause</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.derived#nt:base-clause'>base-clause</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:class-head-name'>class-head-name:</a>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-name'>class-name</a></i></pre><pre class='bnf'><a id='nt:class-virt-specifier'>class-virt-specifier:</a>
    <span class='terminal'>final</span></pre><pre class='bnf'><a id='nt:class-key'>class-key:</a>
    <span class='terminal'>class</span>
    <span class='terminal'>struct</span>
    <span class='terminal'>union</span></pre><p >A <i ><a href='class#nt:class-specifier'>class-specifier</a></i> whose
<i ><a href='class#nt:class-head'>class-head</a></i> omits the
<i ><a href='class#nt:class-head-name'>class-head-name</a></i> defines an unnamed class. [&nbsp;<i>Note:</i><span class='space'></span> An unnamed class thus can't
be <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='class#nt:class-name'>class-name</a></i> is inserted into the scope in which it is
declared immediately after the <i ><a href='class#nt:class-name'>class-name</a></i> is seen. The
<i ><a href='class#nt:class-name'>class-name</a></i> is also inserted into the scope of the class
itself; this is known as the <span class='grammarterm'>injected-class-name</span>.
<span class='indexparent'><a class='index' id='injected-class-name'></a></span>For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
<span class='indexparent'><a class='index' id='definition,class'></a></span>A <i ><a href='class#nt:class-specifier'>class-specifier</a></i> is commonly referred to as a class
definition.
<span class='indexparent'><a class='index' id='definition,class'></a></span>A class is considered defined after the closing brace of its
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> has been seen even though its member
functions are in general not yet defined.
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the class; the attributes in
the <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> are thereafter considered attributes of the class
whenever it is named.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If a class is marked with the <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i> <span class='texttt'>final</span> and it appears
as a <i ><a href='class.derived#nt:base-type-specifier'>base-type-specifier</a></i> in a <i ><a href='class.derived#nt:base-clause'>base-clause</a></i>
(Clause <a href='class.derived'>[class.derived]</a>), the program is ill-formed. Whenever a
<i ><a href='class#nt:class-key'>class-key</a></i> is followed by a <i ><a href='class#nt:class-head-name'>class-head-name</a></i>, the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='texttt'>final</span>, and a colon or left brace, <span class='texttt'>final</span> is
interpreted as a <i ><a href='class#nt:class-virt-specifier'>class-virt-specifier</a></i>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A;
struct A final {};      <span class='comment'>// OK: definition of <span class='texttt'>struct A</span>,
</span>                        <span class='comment'>// not value-initialization of variable <span class='texttt'>final</span>
</span>
struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B final : C{};  <span class='comment'>// OK: definition of nested class <span class='texttt'>B</span>,
</span>                        <span class='comment'>// not declaration of a bit-field member <span class='texttt'>final</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Complete objects and member subobjects of class type shall have nonzero
size.<a class='footnotenum' href='#footnote-107'>107</a>
[&nbsp;<i>Note:</i><span class='space'></span>
Class objects can be assigned, passed as arguments to functions, and
returned by functions (except objects of classes for which copying or moving has
been restricted; see <a href='class.copy'>[class.copy]</a>). Other plausible operators, such
as equality comparison, can be defined by the user; see <a href='over.oper'>[over.oper]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='struct,class_versus'></a></span><span class='indexparent'><a class='index' id='structure'></a></span><span class='indexparent'><a class='index' id='union,class_versus'></a></span>A <a class='hidden_link' href='#def:union' id='def:union'><i>union</i></a> is a class defined with the <i ><a href='class#nt:class-key'>class-key</a></i>
<span class='texttt'>union</span>;
<span class='indexparent'><a class='index' id='access_control,union'></a></span>it holds at most one data member at a time (<a href='class.union'>[class.union]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
Aggregates of class type are described in <a href='dcl.init.aggr'>[dcl.init.aggr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='class,trivial'></a></span><span class='indexparent'><a class='index' id='trivial_class'></a></span><span class='indexparent'><a class='index' id='class,trivially_copyable'></a></span></p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A <a class='hidden_link' href='#def:trivially_copyable_class' id='def:trivially_copyable_class'><i>trivially copyable class</i></a> is a class:</p><ul ><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >where each copy constructor, move constructor, copy assignment operator,
and move assignment operator (<a href='class.copy'>[class.copy]</a>, <a href='over.ass'>[over.ass]</a>)
is either deleted or trivial,
</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >that has at least one non-deleted copy constructor, move constructor,
copy assignment operator, or move assignment operator, and
</p></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div><p >that has a trivial, non-deleted destructor (<a href='class.dtor'>[class.dtor]</a>).
</p></li></ul><p >A <a class='hidden_link' href='#def:trivial_class' id='def:trivial_class'><i>trivial class</i></a> is a class that is trivially copyable and
has one or more default constructors (<a href='class.ctor'>[class.ctor]</a>),
all of which are either trivial or deleted and
at least one of which is not deleted.
[&nbsp;<i>Note:</i><span class='space'></span> In particular, a trivially copyable or trivial class does not have
virtual functions or virtual base classes.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='class,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_class'></a></span></p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A class <span class='texttt'>S</span> is a <span class='grammarterm'>standard-layout class</span> if it:
</p><ul ><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >has no non-static data members of type non-standard-layout class
(or array of such types) or reference,</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >has no virtual functions (<a href='class.virtual'>[class.virtual]</a>) and no
virtual base classes (<a href='class.mi'>[class.mi]</a>),</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >has the same access control (Clause <a href='class.access'>[class.access]</a>)
for all non-static data members,</p></li><li id='7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.4'>(7.4)</a></div><p >has no non-standard-layout base classes,</p></li><li id='7.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.5'>(7.5)</a></div><p >has at most one base class subobject of any given type,</p></li><li id='7.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.6'>(7.6)</a></div><p >has all non-static data members and bit-fields in the class and
its base classes first declared in the same class, and</p></li><li id='7.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.7'>(7.7)</a></div><p >has no element of the set <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>S</span>)</span> of types (defined below)
as a base class.<a class='footnotenum' href='#footnote-108'>108</a>
</p></li></ul><p ><span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> is defined as follows:
</p><ul ><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >If <span class='texttt'>X</span> is a non-union class type, the set <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> is
empty if <span class='texttt'>X</span> has no (possibly inherited (Clause <a href='class.derived'>[class.derived]</a>))
non-static data members;
otherwise, it consists of the type of the first non-static data member
of <span class='texttt'>X</span> (where said member may be an anonymous union), <span class='math'><span class='mathtt'>X</span><sub >0</sub></span>,
and the elements of <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span><sub >0</sub>)</span>.</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >If <span class='texttt'>X</span> is a union type, the set <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> is
the union of all <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>U</span><sub ><span class='mathalpha'>i</span></sub>)</span> and the set containing all <span class='math'><span class='mathtt'>U</span><sub ><span class='mathalpha'>i</span></sub></span>,
where each <span class='math'><span class='mathtt'>U</span><sub ><span class='mathalpha'>i</span></sub></span> is the type of the <span class='math'><span class='mathalpha'>i</span></span>th non-static data member
of <span class='texttt'>X</span>.</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >If <span class='texttt'>X</span> is an array type with element type <span class='math'><span class='mathtt'>X</span><sub ><span class='mathalpha'>e</span></sub></span>,
the set <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> consists of <span class='math'><span class='mathtt'>X</span><sub ><span class='mathalpha'>e</span></sub></span>
and the elements of <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span><sub ><span class='mathalpha'>e</span></sub>)</span>.</p></li><li id='7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.4'>(7.4)</a></div><p >If <span class='texttt'>X</span> is a non-class, non-array type, the set <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> is empty.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span> <span class='math'><span class='mathalpha'>M</span>(<span class='mathtt'>X</span>)</span> is the set of the types of all non-base-class subobjects
that are guaranteed in a standard-layout class to be at a zero offset
in <span class='texttt'>X</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
   struct B { int i; };         <span class='comment'>// standard-layout class
</span>   struct C : B { };            <span class='comment'>// standard-layout class
</span>   struct D : C { };            <span class='comment'>// standard-layout class
</span>   struct E : D { char : 4; };  <span class='comment'>// not a standard-layout class
</span>
   struct Q {};
   struct S : Q { };
   struct T : Q { };
   struct U : S, T { };         <span class='comment'>// not a standard-layout class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='struct,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_struct'></a></span><span class='indexparent'><a class='index' id='union,standard-layout'></a></span><span class='indexparent'><a class='index' id='standard-layout_union'></a></span></p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A <span class='grammarterm'>standard-layout struct</span> is a standard-layout class
defined with the <i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>struct</span> or the
<i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>class</span>.
A <span class='grammarterm'>standard-layout union</span> is a standard-layout class
defined with the
<i ><a href='class#nt:class-key'>class-key</a></i> <span class='texttt'>union</span>.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Standard-layout classes are useful for communicating with
code written in other programming languages. Their layout is specified
in <a href='class.mem'>[class.mem]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='POD_struct'></a></span><span class='indexparent'><a class='index' id='POD_class'></a></span><span class='indexparent'><a class='index' id='POD_union'></a></span>A <a class='hidden_link' href='#def:POD_struct' id='def:POD_struct'><i>POD struct</i></a><a class='footnotenum' href='#footnote-109'>109</a>
is a non-union class that is both a trivial class and a
standard-layout class, and has no non-static data members of type non-POD struct,
non-POD union (or array of such types). Similarly, a
<a class='hidden_link' href='#def:POD_union' id='def:POD_union'><i>POD union</i></a> is a union that is both a trivial class and a standard-layout
class, and has no non-static data members of type non-POD struct, non-POD
union (or array of such types). A <a class='hidden_link' href='#def:POD_class' id='def:POD_class'><i>POD class</i></a> is a
class that is either a POD struct or a POD union.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct N {          <span class='comment'>// neither trivial nor standard-layout
</span>  int i;
  int j;
  virtual ~N();
};

struct T {          <span class='comment'>// trivial but not standard-layout
</span>  int i;
private: 
  int j;
};

struct SL {         <span class='comment'>// standard-layout but not trivial
</span>  int i;
  int j;
  ~SL();
};

struct POD {        <span class='comment'>// both trivial and standard-layout
</span>  int i;
  int j;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >If a <i ><a href='class#nt:class-head-name'>class-head-name</a></i> contains a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
the <i ><a href='class#nt:class-specifier'>class-specifier</a></i> shall refer to a class that was
previously declared directly in the class or namespace to which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> refers,
or in an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>) of that namespace
(i.e., not merely inherited or
introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>), and the
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> shall appear in a namespace enclosing the
previous declaration.
In such cases, the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of the
<i ><a href='class#nt:class-head-name'>class-head-name</a></i> of the
definition shall not begin with a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>.</p></div><div class='footnote' id='footnote-107'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-107'>107)</a></div><p >Base class subobjects are not so constrained.</p></div><div class='footnote' id='footnote-108'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-108'>108)</a></div><p >This ensures that two subobjects that have the
same class type and that
belong to the same most derived object are not allocated at the same
address (<a href='expr.eq'>[expr.eq]</a>).</p></div><div class='footnote' id='footnote-109'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-109'>109)</a></div><p >The acronym POD stands for “plain old data”.</p></div><div id='name'><h2 ><a class='secnum' href='#name' style='min-width:88pt'>9.1</a> Class names <a class='abbr_ref' href='class.name'>[class.name]</a></h2><p ><span class='indexparent'><a class='index' id='definition,class_name_as_type'></a></span><span class='indexparent'><a class='index' id='structure_tag'></a></span><span class='indexparent'><a class='index' id='equivalence,type'></a></span>
</p><div class='para' id='name-1'><div class='marginalizedparent'><a class='marginalized' href='#name-1'>1</a></div><p >A class definition introduces a new type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
</pre><p >declares three variables of three different types. This implies that</p><pre class='codeblock'>
a1 = a2;                        <span class='comment'>// error: <span class='texttt'>Y</span> assigned to <span class='texttt'>X</span>
</span>a1 = a3;                        <span class='comment'>// error: <span class='texttt'>int</span> assigned to <span class='texttt'>X</span>
</span></pre><p >are type mismatches, and that</p><pre class='codeblock'>
int f(X);
int f(Y);
</pre><p ><span class='indexparent'><a class='index' id='overloading'></a></span>declare an overloaded (Clause <a href='over'>[over]</a>) function <span class='texttt'>f()</span> and not
simply a single function <span class='texttt'>f()</span> twice. For the same reason,</p><pre class='codeblock'>
struct S { int a; };
struct S { int a; };            <span class='comment'>// error, double definition
</span></pre><p >is ill-formed because it defines <span class='texttt'>S</span> twice.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='name-2'><div class='marginalizedparent'><a class='marginalized' href='#name-2'>2</a></div><p ><span class='indexparent'><a class='index' id='definition,scope_of_class'></a></span><span class='indexparent'><a class='index' id='class_name,scope_of'></a></span>A class declaration introduces the class name into the scope where
<span class='indexparent'><a class='index' id='name_hiding,class_definition'></a></span>it is declared and hides any
class, variable, function, or other declaration of that name in an
enclosing scope (<a href='basic.scope'>[basic.scope]</a>). If a class name is declared in a
scope where a variable, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='basic.lookup.elab'>[basic.lookup.elab]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct stat {
  <span class='comment'>// ...
</span>};

stat gstat;                     <span class='comment'>// use plain <span class='texttt'>stat</span> to
</span>                                <span class='comment'>// define variable
</span>
int stat(struct stat*);         <span class='comment'>// redeclare <span class='texttt'>stat</span> as function
</span>
void f() {
  struct stat* ps;              <span class='comment'>// <span class='texttt'>struct</span> prefix needed
</span>                                <span class='comment'>// to name <span class='texttt'>struct stat</span>
</span>  stat(ps);                     <span class='comment'>// call <span class='texttt'>stat()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='declaration,forward_class'></a></span>A <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> consisting solely of <span class='grammarterm'>class-key
identifier;</span> is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct s { int a; };

void g() {
  struct s;                     <span class='comment'>// hide global <span class='texttt'>struct s</span>
</span>                                <span class='comment'>// with a block-scope declaration
</span>  s* p;                         <span class='comment'>// refer to local <span class='texttt'>struct s</span>
</span>  struct s { char* p; };        <span class='comment'>// define local <span class='texttt'>struct s</span>
</span>  struct s;                     <span class='comment'>// redeclaration, has no effect
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Such declarations allow definition of classes that refer to each other.
<span class='indexparent'><a class='index' id='example,friend'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class Vector;

class Matrix {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};

class Vector {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};
</pre><p >Declaration of <span class='texttt'>friend</span>s is described in <a href='class.friend'>[class.friend]</a>,
operator functions in <a href='over.oper'>[over.oper]</a>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='name-3'><div class='marginalizedparent'><a class='marginalized' href='#name-3'>3</a></div><p ><span class='indexparent'><a class='index' id='class_name,elaborated'></a></span><span class='indexparent'><a class='index' id='elaborated_type_specifier'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
An <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) can also
be used as a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   <span class='comment'>// global <span class='texttt'>s</span>
</span>  p-&gt;a = s;                     <span class='comment'>// parameter <span class='texttt'>s</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='name-4'><div class='marginalizedparent'><a class='marginalized' href='#name-4'>4</a></div><p ><span class='indexparent'><a class='index' id='class_name,point_of_declaration'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
The declaration of a class name takes effect immediately after the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is seen in the class definition or
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. For example,</p><pre class='codeblock'>
class A * A;
</pre><p >first specifies <span class='texttt'>A</span> to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form <span class='texttt'>class</span> <span class='texttt'>A</span> must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='name-5'><div class='marginalizedparent'><a class='marginalized' href='#name-5'>5</a></div><p ><span class='indexparent'><a class='index' id='class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>) that names a class type,
or a cv-qualified version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i>. If a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a cv-qualified class type is used
where a <i ><a href='class#nt:class-name'>class-name</a></i> is required, the cv-qualifiers are
ignored. A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> shall not be used as the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='class#nt:class-head'>class-head</a></i>.</p></div></div><div id='mem'><h2 ><a class='secnum' href='#mem' style='min-width:88pt'>9.2</a> Class members <a class='abbr_ref' href='class.mem'>[class.mem]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,member'></a></span><span class='indexparent'><a class='index' id='data_member'></a></span></p><pre class='bnf'><a id='nt:member-specification'>member-specification:</a>
    <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class.derived#nt:access-specifier'>access-specifier</a></i> <span class='terminal'>:</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:member-declaration'>member-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
    <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
    <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>
    <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>
    <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>
    <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
    <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i></pre><pre class='bnf'><a id='nt:member-declarator-list'>member-declarator-list:</a>
    <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>
    <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> <span class='terminal'>,</span> <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i></pre><pre class='bnf'><a id='nt:member-declarator'>member-declarator:</a>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><pre class='bnf'><a id='nt:virt-specifier-seq'>virt-specifier-seq:</a>
    <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>
    <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i></pre><pre class='bnf'><a id='nt:virt-specifier'>virt-specifier:</a>
    <span class='terminal'>override</span>
    <span class='terminal'>final</span></pre><pre class='bnf'><a id='nt:pure-specifier'>pure-specifier:</a>
    <span class='terminal'>= 0</span></pre><div class='para' id='mem-1'><div class='marginalizedparent'><a class='marginalized' href='#mem-1'>1</a></div><p ><span class='indexparent'><a class='index' id='definition,class'></a></span>The <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> in a class definition declares the
full set of members of the class; no member can be added elsewhere.
Members of a class are data members, member
functions (<a href='class.mfct'>[class.mfct]</a>), nested types, enumerators,
and member templates (<a href='temp.mem'>[temp.mem]</a>) and specializations thereof.
[&nbsp;<i>Note:</i><span class='space'></span>
A specialization of a static data member template is a static data member.
A specialization of a member function template is a member function.
A specialization of a member class template is a nested class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-2'><div class='marginalizedparent'><a class='marginalized' href='#mem-2'>2</a></div><p >A <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> does not declare new members of the class
if it is
</p><ul ><li id='mem-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-2.1'>(2.1)</a></div><p >a friend declaration (<a href='class.friend'>[class.friend]</a>),
</p></li><li id='mem-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-2.2'>(2.2)</a></div><p >a <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>,
</p></li><li id='mem-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-2.3'>(2.3)</a></div><p >a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>), or
</p></li><li id='mem-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-2.4'>(2.4)</a></div><p >an <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i>.
</p></li></ul><p >For any other <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>,
each declared entity
that is not an unnamed bit-field (<a href='class.bit'>[class.bit]</a>)
is a member of the class,
and each such <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>
shall either
declare at least one member name of the class
or declare at least one unnamed bit-field.</p></div><div class='para' id='mem-3'><div class='marginalizedparent'><a class='marginalized' href='#mem-3'>3</a></div><p >A <a class='hidden_link' href='#def:data_member' id='def:data_member'><i>data member</i></a> is a non-function member introduced by a
<i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>.
A <a class='hidden_link' href='#def:member_function' id='def:member_function'><i>member function</i></a> is a member that is a function.
Nested types are classes (<a href='class.name'>[class.name]</a>, <a href='class.nest'>[class.nest]</a>) and
enumerations (<a href='dcl.enum'>[dcl.enum]</a>) declared in the class and arbitrary types
declared as members by use of a typedef declaration (<a href='dcl.typedef'>[dcl.typedef]</a>)
or <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>.
The enumerators of an unscoped enumeration (<a href='dcl.enum'>[dcl.enum]</a>) defined in the class
are members of the class.</p><p ><span class='indexparent'><a class='index' id='member,static'></a></span><span class='indexparent'><a class='index' id='member_function,static'></a></span><span class='indexparent'><a class='index' id='data_member,static'></a></span></p></div><div class='para' id='mem-4'><div class='marginalizedparent'><a class='marginalized' href='#mem-4'>4</a></div><p >A data member or member function
may be declared <span class='texttt'>static</span> in its <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>,
in which case it is a <a class='hidden_link' href='#def:static_member' id='def:static_member'><i>static member</i></a> (see <a href='class.static'>[class.static]</a>)
(a <a class='hidden_link' href='#def:static_data_member' id='def:static_data_member'><i>static data member</i></a> (<a href='class.static.data'>[class.static.data]</a>) or
<a class='hidden_link' href='#def:static_member_function' id='def:static_member_function'><i>static member function</i></a> (<a href='class.static.mfct'>[class.static.mfct]</a>), respectively)
of the class.
Any other data member or member function is a <a class='hidden_link' href='#def:non-static_member' id='def:non-static_member'><i>non-static member</i></a>
(a <a class='hidden_link' href='#def:non-static_data_member' id='def:non-static_data_member'><i>non-static data member</i></a> or
<a class='hidden_link' href='#def:non-static_member_function' id='def:non-static_member_function'><i>non-static member function</i></a> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>), respectively).
[&nbsp;<i>Note:</i><span class='space'></span> A non-static data member of non-reference
type is a member subobject of a class object (<a href='intro.object'>[intro.object]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-5'><div class='marginalizedparent'><a class='marginalized' href='#mem-5'>5</a></div><p >A member shall not be declared twice in the
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, except that
</p><ul ><li id='mem-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-5.1'>(5.1)</a></div><p >a nested class or member
class template can be declared and then later defined, and
</p></li><li id='mem-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-5.2'>(5.2)</a></div><p >an
enumeration can be introduced with an <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> and later
redeclared with an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
A single name can denote several member functions provided their types
are sufficiently different (Clause <a href='over'>[over]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-6'><div class='marginalizedparent'><a class='marginalized' href='#mem-6'>6</a></div><p ><span class='indexparent'><a class='index' id='completely_defined'></a></span>A class is considered a completely-defined object
type (<a href='basic.types'>[basic.types]</a>) (or complete type) at the closing <span class='texttt'>}</span> of
the <i ><a href='class#nt:class-specifier'>class-specifier</a></i>.
Within the class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, the class is regarded as complete
within function bodies, default arguments,
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i>, and
default member initializers
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>.</p></div><div class='para' id='mem-7'><div class='marginalizedparent'><a class='marginalized' href='#mem-7'>7</a></div><p >In a <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>,
an <span class='texttt'>=</span> immediately following the <i ><a href='dcl.decl#nt:declarator'>declarator</a></i>
is interpreted as introducing a <i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i>
if the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> has function type,
otherwise it is interpreted as introducing
a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S {
  using T = void();
  T * p = 0;        <span class='comment'>// OK: <span class='grammarterm'>brace-or-equal-initializer</span>
</span>  virtual T f = 0;  <span class='comment'>// OK: <span class='grammarterm'>pure-specifier</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-8'><div class='marginalizedparent'><a class='marginalized' href='#mem-8'>8</a></div><p >A <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> shall appear only in the
declaration of a data member. (For static data members,
see <a href='class.static.data'>[class.static.data]</a>; for non-static data members,
see <a href='class.base.init'>[class.base.init]</a> and <a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
A <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> for a non-static data member
<span class='indexparent'><a class='index' id='member,default_initializer'></a></span>specifies a <a class='hidden_link' href='#def:default_member_initializer' id='def:default_member_initializer'><i>default member initializer</i></a> for the member, and
shall not directly or indirectly cause the implicit definition of a
defaulted default constructor for the enclosing class or the
exception specification of that constructor.</p></div><div class='para' id='mem-9'><div class='marginalizedparent'><a class='marginalized' href='#mem-9'>9</a></div><p >A member shall not be declared with the <span class='texttt'>extern</span>
<span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i>. Within a class definition, a member shall not be declared with the <span class='texttt'>thread_local</span> <span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i> unless also declared <span class='texttt'>static</span>.</p></div><div class='para' id='mem-10'><div class='marginalizedparent'><a class='marginalized' href='#mem-10'>10</a></div><p >The <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall contain a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that is not a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i>.
The
<i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> can be omitted only after a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> or an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> or in a
<span class='texttt'>friend</span> declaration (<a href='class.friend'>[class.friend]</a>). A
<i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i> shall be used only in the declaration of a
virtual function (<a href='class.virtual'>[class.virtual]</a>)
that is not a <span class='texttt'>friend</span> declaration.</p></div><div class='para' id='mem-11'><div class='marginalizedparent'><a class='marginalized' href='#mem-11'>11</a></div><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>
appertains to each of the entities declared by the <i ><a href='class.mem#nt:member-declarator'>member-declarators</a></i>;
it shall not appear if the optional <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> is omitted.</p></div><div class='para' id='mem-12'><div class='marginalizedparent'><a class='marginalized' href='#mem-12'>12</a></div><p >A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> shall contain at most one of each
<i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>.
A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i>
shall appear only in the declaration of a virtual member
function (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='mem-13'><div class='marginalizedparent'><a class='marginalized' href='#mem-13'>13</a></div><p ><span class='indexparent'><a class='index' id='class_object,member'></a></span>Non-static data members shall not have
incomplete types. In particular, a class <span class='texttt'>C</span> shall not contain a
non-static member of class <span class='texttt'>C</span>, but it can contain a pointer or
reference to an object of class <span class='texttt'>C</span>.</p></div><div class='para' id='mem-14'><div class='marginalizedparent'><a class='marginalized' href='#mem-14'>14</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-15'><div class='marginalizedparent'><a class='marginalized' href='#mem-15'>15</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-16'><div class='marginalizedparent'><a class='marginalized' href='#mem-16'>16</a></div><p ><span class='indexparent'><a class='index' id='example,class_definition'></a></span>[&nbsp;<i>Example:</i><span class='space'></span>
A simple example of a class definition is</p><pre class='codeblock'>
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
</pre><p >which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration</p><pre class='codeblock'>
tnode s, *sp;
</pre><p >declares <span class='texttt'>s</span> to be a <span class='texttt'>tnode</span> and <span class='texttt'>sp</span> to be a pointer
to a <span class='texttt'>tnode</span>. With these declarations, <span class='texttt'>sp-&gt;count</span> refers to
the <span class='texttt'>count</span> member of the object to which <span class='texttt'>sp</span> points;
<span class='texttt'>s.left</span> refers to the <span class='texttt'>left</span> subtree pointer of the object
<span class='texttt'>s</span>; and <span class='texttt'>s.right-&gt;tword[0]</span> refers to the initial character
of the <span class='texttt'>tword</span> member of the <span class='texttt'>right</span> subtree of <span class='texttt'>s</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-17'><div class='marginalizedparent'><a class='marginalized' href='#mem-17'>17</a></div><p ><span class='indexparent'><a class='index' id='layout,class_object'></a></span>Non-static data members of a (non-union) class
with the same access control (Clause <a href='class.access'>[class.access]</a>)
are allocated so that later
members have higher addresses within a class object.
<span class='indexparent'><a class='index' id='allocation,unspecified'></a></span>The order of allocation of non-static data members
with different access control
is unspecified (Clause <a href='class.access'>[class.access]</a>).
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions (<a href='class.virtual'>[class.virtual]</a>) and
virtual base classes (<a href='class.mi'>[class.mi]</a>).</p></div><div class='para' id='mem-18'><div class='marginalizedparent'><a class='marginalized' href='#mem-18'>18</a></div><p >If <span class='texttt'>T</span> is the name of a class, then each of the following shall
have a name different from <span class='texttt'>T</span>:</p><ul ><li id='mem-18.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.1'>(18.1)</a></div><p >every static data member of class <span class='texttt'>T</span>;</p></li><li id='mem-18.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.2'>(18.2)</a></div><p >every member function of class <span class='texttt'>T</span>
[&nbsp;<i>Note:</i><span class='space'></span>
This restriction does not apply to constructors, which do not have
names (<a href='class.ctor'>[class.ctor]</a>)
<i>&nbsp;—&nbsp;end note</i>&nbsp;];</p></li><li id='mem-18.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.3'>(18.3)</a></div><p >every member of class <span class='texttt'>T</span> that is itself a type;</p></li><li id='mem-18.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.4'>(18.4)</a></div><p >every member template of class <span class='texttt'>T</span>;</p></li><li id='mem-18.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.5'>(18.5)</a></div><p >every enumerator of every member of class <span class='texttt'>T</span> that is an
unscoped enumerated type; and</p></li><li id='mem-18.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#mem-18.6'>(18.6)</a></div><p >every member of every anonymous union that is a member of class
<span class='texttt'>T</span>.
</p></li></ul></div><div class='para' id='mem-19'><div class='marginalizedparent'><a class='marginalized' href='#mem-19'>19</a></div><p >In addition, if class <span class='texttt'>T</span> has a user-declared
constructor (<a href='class.ctor'>[class.ctor]</a>), every non-static data member of class
<span class='texttt'>T</span> shall have a name different from <span class='texttt'>T</span>.</p></div><div class='para' id='mem-20'><div class='marginalizedparent'><a class='marginalized' href='#mem-20'>20</a></div><p >The <a class='hidden_link' href='#def:common_initial_sequence' id='def:common_initial_sequence'><i>common initial sequence</i></a> of two standard-layout struct (Clause <a href='class'>[class]</a>)
types is the longest sequence of non-static data
members and bit-fields in declaration order, starting with the first
such entity in each of the structs, such that corresponding entities
have layout-compatible types and either neither entity is a bit-field or
both are bit-fields with the same width.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  struct A { int a; char b; };
  struct B { const int b1; volatile char b2; };
  struct C { int c; unsigned : 0; char b; };
  struct D { int d; char b : 4; };
  struct E { unsigned int e; char b; };
</pre><p >The common initial sequence of <span class='texttt'>A</span> and <span class='texttt'>B</span> comprises all members
of either class. The common initial sequence of <span class='texttt'>A</span> and <span class='texttt'>C</span> and
of <span class='texttt'>A</span> and <span class='texttt'>D</span> comprises the first member in each case.
The common initial sequence of <span class='texttt'>A</span> and <span class='texttt'>E</span> is empty.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mem-21'><div class='marginalizedparent'><a class='marginalized' href='#mem-21'>21</a></div><p >Two standard-layout struct (Clause <a href='class'>[class]</a>) types are
<a class='hidden_link' href='#def:layout-compatible,class' id='def:layout-compatible,class'><i>layout-compatible classes</i></a> if
their common initial sequence comprises all members and bit-fields of
both classes (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='mem-22'><div class='marginalizedparent'><a class='marginalized' href='#mem-22'>22</a></div><p >Two standard-layout unions are layout-compatible if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='mem-23'><div class='marginalizedparent'><a class='marginalized' href='#mem-23'>23</a></div><p >In a standard-layout union with an active member (<a href='class.union'>[class.union]</a>)
of struct type <span class='texttt'>T1</span>, it is permitted to read a non-static
data member <span class='texttt'>m</span> of another union member of struct type <span class='texttt'>T2</span>
provided <span class='texttt'>m</span> is part of the common initial sequence of <span class='texttt'>T1</span> and <span class='texttt'>T2</span>;
the behavior is as if the corresponding member of <span class='texttt'>T1</span> were nominated.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct T1 { int a, b; };
struct T2 { int c; double d; };
union U { T1 t1; T2 t2; };
int f() {
  U u = { { 1, 2 } }; <span class='comment'>// active member is <span class='texttt'>t1</span>
</span>  return u.t2.c;      <span class='comment'>// OK, as if <span class='texttt'>u.t1.a</span> were nominated
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Reading a volatile object through a non-volatile glvalue has
undefined behavior (<a href='dcl.type.cv'>[dcl.type.cv]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mem-24'><div class='marginalizedparent'><a class='marginalized' href='#mem-24'>24</a></div><p >If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member. Otherwise, its
address is the same as the address of its first base class subobject (if any).
[&nbsp;<i>Note:</i><span class='space'></span>
There might therefore be unnamed padding within a standard-layout struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
The object and its first subobject are
pointer-interconvertible (<a href='basic.compound'>[basic.compound]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='mfct'><h3 ><a class='secnum' href='#mfct' style='min-width:103pt'>9.2.1</a> Member functions <a class='abbr_ref' href='class.mfct'>[class.mfct]</a></h3><p ><span class='indexparent'><a class='index' id='member_function,class'></a></span></p><div class='para' id='mfct-1'><div class='marginalizedparent'><a class='marginalized' href='#mfct-1'>1</a></div><p ><span class='indexparent'><a class='index' id='member_function,inline'></a></span><span class='indexparent'><a class='index' id='definition,member_function'></a></span>A member function may be defined (<a href='dcl.fct.def'>[dcl.fct.def]</a>) in its class
definition, in which case it is an <a class='hidden_link' href='#def:inline' id='def:inline'><i>inline</i></a> member
function (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>), or it may be defined outside of its class
definition if it has already been declared but not defined in its class
definition. A member function definition that appears outside of the
class definition shall appear in a namespace scope enclosing the class
definition. Except for member function definitions that appear outside
of a class definition, and except for explicit specializations of member
functions of class templates and member function
templates (<a href='temp.spec'>[temp.spec]</a>) appearing outside of the class definition, a
member function shall not be redeclared.</p></div><div class='para' id='mfct-2'><div class='marginalizedparent'><a class='marginalized' href='#mfct-2'>2</a></div><p >An inline member function (whether static or non-static) may
also be defined outside of its class definition provided either its
declaration in the class definition or its definition outside of the
class definition declares the function as <span class='texttt'>inline</span> or <span class='texttt'>constexpr</span>.
[&nbsp;<i>Note:</i><span class='space'></span>
Member functions of a class in namespace scope have the linkage of that class.
Member functions of a local class (<a href='class.local'>[class.local]</a>) have no linkage.
See <a href='basic.link'>[basic.link]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mfct-3'><div class='marginalizedparent'><a class='marginalized' href='#mfct-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
There can be at most one definition of a non-inline member function in
a program. There may be more than one
<span class='texttt'>inline</span> member function definition in a program.
See <a href='basic.def.odr'>[basic.def.odr]</a> and <a href='dcl.fct.spec'>[dcl.fct.spec]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mfct-4'><div class='marginalizedparent'><a class='marginalized' href='#mfct-4'>4</a></div><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span>If the definition of a member function is lexically outside its class
definition, the member function name shall be qualified by its class
name using the <span class='texttt'>::</span> operator.
[&nbsp;<i>Note:</i><span class='space'></span>
A name used in a member function definition (that is, in the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> including the default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>) or in the member function body) is looked up
as described in <a href='basic.lookup'>[basic.lookup]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  typedef int T;
  static T count;
  void f(T);
};
void X::f(T t = count) { }
</pre><p >The member function <span class='texttt'>f</span> of class <span class='texttt'>X</span> is defined in global
scope; the notation <span class='texttt'>X::f</span> specifies that the function <span class='texttt'>f</span>
is a member of class <span class='texttt'>X</span> and in the scope of class <span class='texttt'>X</span>. In
the function definition, the parameter type <span class='texttt'>T</span> refers to the
typedef member <span class='texttt'>T</span> declared in class <span class='texttt'>X</span> and the default
argument <span class='texttt'>count</span> refers to the static data member <span class='texttt'>count</span>
declared in class <span class='texttt'>X</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct-5'><div class='marginalizedparent'><a class='marginalized' href='#mfct-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A <span class='texttt'>static</span> local variable or local type in a member function always refers to
the same entity, whether or not the member function is <span class='texttt'>inline</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mfct-6'><div class='marginalizedparent'><a class='marginalized' href='#mfct-6'>6</a></div><p >Previously declared member functions may be mentioned in <span class='texttt'>friend</span> declarations.</p></div><div class='para' id='mfct-7'><div class='marginalizedparent'><a class='marginalized' href='#mfct-7'>7</a></div><p ><span class='indexparent'><a class='index' id='local_class,member_function_in'></a></span>Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.</p></div><div class='para' id='mfct-8'><div class='marginalizedparent'><a class='marginalized' href='#mfct-8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see <a href='dcl.fct'>[dcl.fct]</a>. For example,</p><pre class='codeblock'>
typedef void fv();
typedef void fvc() const;
struct S {
  fv memfunc1;      <span class='comment'>// equivalent to: <span class='texttt'>void memfunc1();</span>
</span>  void memfunc2();
  fvc memfunc3;     <span class='comment'>// equivalent to: <span class='texttt'>void memfunc3() const;</span>
</span>};
fv  S::* pmfv1 = &amp;S::memfunc1;
fv  S::* pmfv2 = &amp;S::memfunc2;
fvc S::* pmfv3 = &amp;S::memfunc3;
</pre><p >Also see <a href='temp.arg'>[temp.arg]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='mfct.non-static'><h3 ><a class='secnum' href='#mfct.non-static' style='min-width:103pt'>9.2.2</a> Non-static member functions <a class='abbr_ref' href='class.mfct.non-static'>[class.mfct.non-static]</a></h3><p ><span class='indexparent'><a class='index' id='member_function,non-static'></a></span></p><div class='para' id='mfct.non-static-1'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-1'>1</a></div><p >A non-static member function may be called for an object of
its class type, or for an object of a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from its class type, using the class member
access syntax (<a href='expr.ref'>[expr.ref]</a>, <a href='over.match.call'>[over.match.call]</a>). A non-static
member function may also be called directly using the function call
syntax (<a href='expr.call'>[expr.call]</a>, <a href='over.match.call'>[over.match.call]</a>) from within
the body of a member function of its class or of a class derived from
its class.</p></div><div class='para' id='mfct.non-static-2'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-2'>2</a></div><p ><span class='indexparent'><a class='index' id='member_function,call_undefined'></a></span>If a non-static member function of a class <span class='texttt'>X</span> is called for an
object that is not of type <span class='texttt'>X</span>, or of a type derived from
<span class='texttt'>X</span>, the behavior is undefined.</p></div><div class='para' id='mfct.non-static-3'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-3'>3</a></div><p >When an <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> (<a href='expr.prim'>[expr.prim]</a>) that is not part of a
class member access syntax (<a href='expr.ref'>[expr.ref]</a>) and not used to form a
pointer to member (<a href='expr.unary.op'>[expr.unary.op]</a>) is used in
a member of class <span class='texttt'>X</span> in a context where <span class='texttt'>this</span> can be
used (<a href='expr.prim.this'>[expr.prim.this]</a>),
if name
lookup (<a href='basic.lookup'>[basic.lookup]</a>) resolves the name in the
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> to a non-static non-type member of some class
<span class='texttt'>C</span>,
and if either the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is potentially evaluated or
<span class='texttt'>C</span> is <span class='texttt'>X</span> or a base class of <span class='texttt'>X</span>,
the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is transformed into a class
member access expression (<a href='expr.ref'>[expr.ref]</a>) using
<span class='texttt'>(*this)</span> (<a href='class.this'>[class.this]</a>) as the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
to the left of the <span class='texttt'>.</span> operator.
[&nbsp;<i>Note:</i><span class='space'></span>
If <span class='texttt'>C</span> is not <span class='texttt'>X</span> or a base class of <span class='texttt'>X</span>, the class
member access expression is ill-formed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Similarly during name lookup, when an
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) used in the definition of a
member function for class <span class='texttt'>X</span> resolves to a static member,
an enumerator or a nested type of class <span class='texttt'>X</span> or of a base class of
<span class='texttt'>X</span>, the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is transformed into a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> names the class of the member function.
These transformations do not apply in the
template definition context (<a href='temp.dep.type'>[temp.dep.type]</a>).
<span class='indexparent'><a class='index' id='example,member_function'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
  void set(const char*, tnode* l, tnode* r);
};

void tnode::set(const char* w, tnode* l, tnode* r) {
  count = strlen(w)+1;
  if (sizeof(tword)&lt;=count)
      perror("tnode string too long");
  strcpy(tword,w);
  left = l;
  right = r;
}

void f(tnode n1, tnode n2) {
  n1.set("abc",&amp;n2,0);
  n2.set("def",0,0);
}
</pre><p >In the body of the member function <span class='texttt'>tnode::set</span>, the member names
<span class='texttt'>tword</span>, <span class='texttt'>count</span>, <span class='texttt'>left</span>, and <span class='texttt'>right</span> refer to
members of the object for which the function is called. Thus, in the
call <span class='texttt'>n1.set("abc",&amp;n2,0)</span>, <span class='texttt'>tword</span> refers to
<span class='texttt'>n1.tword</span>, and in the call <span class='texttt'>n2.set("def",0,0)</span>, it refers
to <span class='texttt'>n2.tword</span>. The functions <span class='texttt'>strlen</span>, <span class='texttt'>perror</span>, and
<span class='texttt'>strcpy</span> are not members of the class <span class='texttt'>tnode</span> and should be
declared elsewhere.<a class='footnotenum' href='#footnote-110'>110</a>
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct.non-static-4'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-4'>4</a></div><p >A non-static member function may be declared <span class='texttt'>const</span>,
<span class='texttt'>volatile</span>, or <span class='texttt'>const</span> <span class='texttt'>volatile</span>. These
<span class='grammarterm'>cv-qualifiers</span> affect the type of the <span class='texttt'>this</span>
pointer (<a href='class.this'>[class.this]</a>). They also affect the function
type (<a href='dcl.fct'>[dcl.fct]</a>) of the member function; a member function declared
<span class='texttt'>const</span> is a <a class='hidden_link' href='#def:const' id='def:const'><i>const</i></a> member function, a member function
declared <span class='texttt'>volatile</span> is a <a class='hidden_link' href='#def:volatile' id='def:volatile'><i>volatile</i></a> member function and a
member function declared <span class='texttt'>const</span> <span class='texttt'>volatile</span> is a
<a class='hidden_link' href='#def:const_volatile' id='def:const_volatile'><i>const volatile</i></a> member function.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  void g() const;
  void h() const volatile;
};
</pre><p ><span class='texttt'>X::g</span> is a <span class='texttt'>const</span> member function and <span class='texttt'>X::h</span> is a
<span class='texttt'>const</span> <span class='texttt'>volatile</span> member function.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfct.non-static-5'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-5'>5</a></div><p >A non-static member function may be declared with a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (<a href='dcl.fct'>[dcl.fct]</a>); see <a href='over.match.funcs'>[over.match.funcs]</a>.</p></div><div class='para' id='mfct.non-static-6'><div class='marginalizedparent'><a class='marginalized' href='#mfct.non-static-6'>6</a></div><p >A non-static member function may be declared
<a class='hidden_link' href='#def:virtual' id='def:virtual'><i>virtual</i></a> (<a href='class.virtual'>[class.virtual]</a>) or <a class='hidden_link' href='#def:pure_virtual' id='def:pure_virtual'><i>pure virtual</i></a> (<a href='class.abstract'>[class.abstract]</a>).</p></div><div class='footnote' id='footnote-110'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-110'>110)</a></div><p >See, for example, <span class='texttt'>&lt;cstring&gt;</span> (<a href='c.strings'>[c.strings]</a>).</p></div><div id='this'><h4 ><a class='secnum' href='#this' style='min-width:118pt'>9.2.2.1</a> The <span class='texttt'>this</span> pointer <a class='abbr_ref' href='class.this'>[class.this]</a></h4><p ><span class='indexparent'><a class='index' id='this'></a></span>
<span class='indexparent'><a class='index' id='member_function,this'></a></span></p><div class='para' id='this-1'><div class='marginalizedparent'><a class='marginalized' href='#this-1'>1</a></div><p ><span class='indexparent'><a class='index' id='this_pointer'></a></span>In the body of a non-static (<a href='class.mfct'>[class.mfct]</a>) member function, the
keyword <span class='texttt'>this</span> is a prvalue expression whose value is the
address of the object for which the function is called.
<span class='indexparent'><a class='index' id='this,type_of'></a></span>The type of <span class='texttt'>this</span> in a member function of a class <span class='texttt'>X</span> is
<span class='texttt'>X*</span>.
<span class='indexparent'><a class='index' id='member_function,const'></a></span>If the member function is declared <span class='texttt'>const</span>, the type of
<span class='texttt'>this</span> is <span class='texttt'>const</span> <span class='texttt'>X*</span>,
<span class='indexparent'><a class='index' id='member_function,volatile'></a></span>if the member function is declared <span class='texttt'>volatile</span>, the type of
<span class='texttt'>this</span> is <span class='texttt'>volatile</span> <span class='texttt'>X*</span>, and if the member function
is declared <span class='texttt'>const</span> <span class='texttt'>volatile</span>, the type of <span class='texttt'>this</span> is
<span class='texttt'>const</span> <span class='texttt'>volatile</span> <span class='texttt'>X*</span>.
<span class='indexparent'><a class='index' id='member_function,const'></a></span>[&nbsp;<i>Note:</i><span class='space'></span> thus in a <span class='texttt'>const</span> member function, the object for which the function is
called is accessed through a <span class='texttt'>const</span> access path. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct s {
  int a;
  int f() const;
  int g() { return a++; }
  int h() const { return a++; } <span class='comment'>// error
</span>};

int s::f() const { return a; }
</pre><p >The <span class='texttt'>a++</span> in the body of <span class='texttt'>s::h</span> is ill-formed because it
tries to modify (a part of) the object for which <span class='texttt'>s::h()</span> is
called. This is not allowed in a <span class='texttt'>const</span> member function because
<span class='texttt'>this</span> is a pointer to <span class='texttt'>const</span>; that is, <span class='texttt'>*this</span> has
<span class='texttt'>const</span> type.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='this-2'><div class='marginalizedparent'><a class='marginalized' href='#this-2'>2</a></div><p >Similarly, <span class='texttt'>volatile</span> semantics (<a href='dcl.type.cv'>[dcl.type.cv]</a>) apply in
<span class='texttt'>volatile</span> member functions when accessing the object and its
non-static data members.</p></div><div class='para' id='this-3'><div class='marginalizedparent'><a class='marginalized' href='#this-3'>3</a></div><p >A cv-qualified member function can be called on an
object-expression (<a href='expr.ref'>[expr.ref]</a>) only if the object-expression is as
cv-qualified or less-cv-qualified than the member function.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void k(s&amp; x, const s&amp; y) {
  x.f();
  x.g();
  y.f();
  y.g();                        <span class='comment'>// error
</span>}
</pre><p >The call <span class='texttt'>y.g()</span> is ill-formed because <span class='texttt'>y</span> is <span class='texttt'>const</span>
and <span class='texttt'>s::g()</span> is a non-<span class='texttt'>const</span> member function, that is,
<span class='texttt'>s::g()</span> is less-qualified than the object-expression <span class='texttt'>y</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='this-4'><div class='marginalizedparent'><a class='marginalized' href='#this-4'>4</a></div><p ><span class='indexparent'><a class='index' id='const,constructor_and'></a></span><span class='indexparent'><a class='index' id='const,destructor_and'></a></span><span class='indexparent'><a class='index' id='volatile,constructor_and'></a></span><span class='indexparent'><a class='index' id='volatile,destructor_and'></a></span>Constructors (<a href='class.ctor'>[class.ctor]</a>) and destructors (<a href='class.dtor'>[class.dtor]</a>) shall
not be declared <span class='texttt'>const</span>, <span class='texttt'>volatile</span> or <span class='texttt'>const</span>
<span class='texttt'>volatile</span>. [&nbsp;<i>Note:</i><span class='space'></span> However, these functions can be invoked to
create and destroy objects with cv-qualified types,
see <a href='class.ctor'>[class.ctor]</a> and <a href='class.dtor'>[class.dtor]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='static'><h3 ><a class='secnum' href='#static' style='min-width:103pt'>9.2.3</a> Static members <a class='abbr_ref' href='class.static'>[class.static]</a></h3><p ><span class='indexparent'><a class='index' id='member,static'></a></span>
</p><div class='para' id='static-1'><div class='marginalizedparent'><a class='marginalized' href='#static-1'>1</a></div><p >A static member <span class='texttt'>s</span> of class <span class='texttt'>X</span> may be referred to
using the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> expression <span class='texttt'>X::s</span>; it is not
necessary to use the class member access syntax (<a href='expr.ref'>[expr.ref]</a>) to
refer to a static member. A static member may be
referred to using the class member access syntax, in which case the
object expression is evaluated.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct process {
  static void reschedule();
};
process&amp; g();

void f() {
  process::reschedule();        <span class='comment'>// OK: no object necessary
</span>  g().reschedule();             <span class='comment'>// <span class='texttt'>g()</span> is called
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='static-2'><div class='marginalizedparent'><a class='marginalized' href='#static-2'>2</a></div><p >A static member may be referred to directly in the scope of its
class or in the scope of a class derived (Clause <a href='class.derived'>[class.derived]</a>)
from its class; in this case, the static member is referred to
as if a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> expression was used, with the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> naming
the class scope from which the static member is referenced.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int g();
struct X {
  static int g();
};
struct Y : X {
  static int i;
};
int Y::i = g();                 <span class='comment'>// equivalent to <span class='texttt'>Y::g();</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='static-3'><div class='marginalizedparent'><a class='marginalized' href='#static-3'>3</a></div><p >If an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> (<a href='expr.prim'>[expr.prim]</a>) is used in the
definition of a static member following the member's
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>, and name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>)
finds that the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> refers to a static
member, enumerator, or nested type of the member's class (or of a base
class of the member's class), the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is
transformed into a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> expression in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> names the class scope from which the
member is referenced.
[&nbsp;<i>Note:</i><span class='space'></span>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static-4'><div class='marginalizedparent'><a class='marginalized' href='#static-4'>4</a></div><p >Static members obey the usual class member access rules
(Clause <a href='class.access'>[class.access]</a>). When used in the declaration of a class
member, the <span class='texttt'>static</span> specifier shall only be used in the member
declarations that appear within the <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> of
the class definition.
[&nbsp;<i>Note:</i><span class='space'></span>
It cannot be specified in member declarations that appear in namespace scope.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='static.mfct'><h4 ><a class='secnum' href='#static.mfct' style='min-width:118pt'>9.2.3.1</a> Static member functions <a class='abbr_ref' href='class.static.mfct'>[class.static.mfct]</a></h4><p ><span class='indexparent'><a class='index' id='member_function,static'></a></span>
</p><div class='para' id='static.mfct-1'><div class='marginalizedparent'><a class='marginalized' href='#static.mfct-1'>1</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The rules described in <a href='class.mfct'>[class.mfct]</a> apply to static member
functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static.mfct-2'><div class='marginalizedparent'><a class='marginalized' href='#static.mfct-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A static member function does not have a <span class='texttt'>this</span>
pointer (<a href='class.this'>[class.this]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
A static member function shall not be <span class='texttt'>virtual</span>. There
shall not be a static and a non-static member function with the
same name and the same parameter types (<a href='over.load'>[over.load]</a>). A
static member function shall not be declared <span class='texttt'>const</span>,
<span class='texttt'>volatile</span>, or <span class='texttt'>const volatile</span>.</p></div></div><div id='static.data'><h4 ><a class='secnum' href='#static.data' style='min-width:118pt'>9.2.3.2</a> Static data members <a class='abbr_ref' href='class.static.data'>[class.static.data]</a></h4><p ><span class='indexparent'><a class='index' id='member_data,static'></a></span>
</p><div class='para' id='static.data-1'><div class='marginalizedparent'><a class='marginalized' href='#static.data-1'>1</a></div><p >A static data member is not part of the subobjects of a class. If a
static data member is declared <span class='texttt'>thread_local</span> there is one copy of
the member per thread. If a static data member is not declared
<span class='texttt'>thread_local</span> there is one copy of the data member that is shared by all
the objects of the class.</p></div><div class='para' id='static.data-2'><div class='marginalizedparent'><a class='marginalized' href='#static.data-2'>2</a></div><p ><span class='indexparent'><a class='index' id='initialization,static_member'></a></span><span class='indexparent'><a class='index' id='definition,static_member'></a></span>The declaration of a non-inline
static data member in its class definition
is not a definition and may be of an incomplete type other than
<i>cv</i> <span class='texttt'>void</span>. The definition for a static data
member that is not defined inline in the class definition
shall appear in a namespace scope enclosing the member's class
definition.
<span class='indexparent'><a class='index' id='operator_use,scope_resolution'></a></span>In the definition at namespace scope, the name of the static
data member shall be qualified by its class name using the <span class='texttt'>::</span>
operator. The <i ><a href='dcl.init#nt:initializer'>initializer</a></i> expression in the definition of a
static data member is in the scope of its
class (<a href='basic.scope.class'>[basic.scope.class]</a>).
<span class='indexparent'><a class='index' id='example,static_member'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class process {
  static process* run_chain;
  static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
</pre><p >The static data member <span class='texttt'>run_chain</span> of class
<span class='texttt'>process</span> is defined in global scope; the notation
<span class='texttt'>process<span class='discretionary'></span>::<span class='discretionary'></span>run_chain</span> specifies that the member <span class='texttt'>run_chain</span>
is a member of class <span class='texttt'>process</span> and in the scope of class
<span class='texttt'>process</span>. In the static data member definition, the
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> expression refers to the static data
member <span class='texttt'>running</span> of class <span class='texttt'>process</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i><span class='space'></span>
Once the static data member has been defined, it exists even if
no objects of its class have been created.
[&nbsp;<i>Example:</i><span class='space'></span>
in the example above, <span class='texttt'>run_chain</span> and <span class='texttt'>running</span> exist even
if no objects of class <span class='texttt'>process</span> are created by the program.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static.data-3'><div class='marginalizedparent'><a class='marginalized' href='#static.data-3'>3</a></div><p >If a non-volatile non-inline <span class='texttt'>const</span> static data member is
of integral or enumeration type,
its declaration in the class definition can specify a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> in which every
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> that is an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is a constant expression (<a href='expr.const'>[expr.const]</a>).
The member shall still be defined in a namespace scope if
it is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in the program and the
namespace scope definition shall not contain an <i ><a href='dcl.init#nt:initializer'>initializer</a></i>.
An inline static data member may be defined in the class definition
and may specify a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>. If the
member is declared with the <span class='texttt'>constexpr</span> specifier, it may be
redeclared in namespace scope with no initializer (this usage is
deprecated; see <a href='depr.static_constexpr'>[depr.static_constexpr]</a>). Declarations of other
static data members shall not specify a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>.</p></div><div class='para' id='static.data-4'><div class='marginalizedparent'><a class='marginalized' href='#static.data-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
There shall be exactly one definition of a static data member
that is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in a program; no diagnostic is required.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Unnamed classes and classes contained directly
or indirectly within unnamed classes shall not contain static
data members.</p></div><div class='para' id='static.data-5'><div class='marginalizedparent'><a class='marginalized' href='#static.data-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Static data members of a class in namespace scope have the linkage of that class (<a href='basic.link'>[basic.link]</a>). A local class cannot have static data members (<a href='class.local'>[class.local]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static.data-6'><div class='marginalizedparent'><a class='marginalized' href='#static.data-6'>6</a></div><p >Static data members are initialized and destroyed exactly like
non-local variables (<a href='basic.start.static'>[basic.start.static]</a>, <a href='basic.start.dynamic'>[basic.start.dynamic]</a>,
<a href='basic.start.term'>[basic.start.term]</a>).</p></div><div class='para' id='static.data-7'><div class='marginalizedparent'><a class='marginalized' href='#static.data-7'>7</a></div><p >A static data member shall not be
<span class='texttt'>mutable</span> (<a href='dcl.stc'>[dcl.stc]</a>).</p></div></div></div><div id='bit'><h3 ><a class='secnum' href='#bit' style='min-width:103pt'>9.2.4</a> Bit-fields <a class='abbr_ref' href='class.bit'>[class.bit]</a></h3><p ><span class='indexparent'><a class='index' id='bit-field'></a></span></p><div class='para' id='bit-1'><div class='marginalizedparent'><a class='marginalized' href='#bit-1'>1</a></div><p >A <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i> of the form</p><pre class='bnf'><i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>  <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><p ><span class='indexparent'><a class='index' id=':,field_declaration'></a></span><span class='indexparent'><a class='index' id='declaration,bit-field'></a></span>specifies a bit-field;
its length is set off from the bit-field name by a colon. The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the entity being declared. The bit-field
attribute is not part of the type of the class member. The
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> shall be an integral constant expression
with a value greater than or equal to zero. The
value of the integral constant expression may
be larger than the number of bits in the object
representation (<a href='basic.types'>[basic.types]</a>) of the bit-field's type; in such
cases the extra bits are used as padding bits and do not participate in
the value representation (<a href='basic.types'>[basic.types]</a>) of the bit-field.
<span class='indexparent'><a class='index' id='allocation,implementation_defined_bit-field'></a></span>Allocation of bit-fields within a class object is
<span class='indexparent'><a class='index' id='allocation_of_bit-fields_within_a_class_object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='bit-field,implementation_defined_alignment_of'></a></span>Alignment of bit-fields is <span class='indexparent'><a class='index' id='alignment_of_bit-fields_within_a_class_object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='layout,bit-field'></a></span>Bit-fields are packed into some addressable allocation unit.
[&nbsp;<i>Note:</i><span class='space'></span>
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='bit-2'><div class='marginalizedparent'><a class='marginalized' href='#bit-2'>2</a></div><p ><span class='indexparent'><a class='index' id='bit-field,unnamed'></a></span>A declaration for a bit-field that omits the <i ><a href='lex.name#nt:identifier'>identifier</a></i>
declares an <span class='grammarterm'>unnamed</span> bit-field. Unnamed bit-fields are not
members and cannot be initialized.
[&nbsp;<i>Note:</i><span class='space'></span>
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='bit-field,zero_width_of'></a></span><span class='indexparent'><a class='index' id='bit-field,alignment_of'></a></span>As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the value of the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> be equal to zero.</p></div><div class='para' id='bit-3'><div class='marginalizedparent'><a class='marginalized' href='#bit-3'>3</a></div><p ><span class='indexparent'><a class='index' id='bit-field,type_of'></a></span>A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type (<a href='basic.fundamental'>[basic.fundamental]</a>).
<span class='indexparent'><a class='index' id='Boolean'></a></span>A <span class='texttt'>bool</span> value can successfully be stored in a bit-field of any
nonzero size.
<span class='indexparent'><a class='index' id='bit-field,address_of'></a></span>The address-of operator <span class='texttt'>&amp;</span> shall not be applied to a bit-field,
so there are no pointers to bit-fields.
<span class='indexparent'><a class='index' id='restriction,bit-field'></a></span><span class='indexparent'><a class='index' id='restriction,address_of_bit-field'></a></span><span class='indexparent'><a class='index' id='restriction,pointer_to_bit-field'></a></span>A non-const reference shall not be bound to a
bit-field (<a href='dcl.init.ref'>[dcl.init.ref]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
If the initializer for a reference of type <span class='texttt'>const</span> <span class='texttt'>T&amp;</span> is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See <a href='dcl.init.ref'>[dcl.init.ref]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='bit-4'><div class='marginalizedparent'><a class='marginalized' href='#bit-4'>4</a></div><p >If the value <span class='texttt'>true</span> or <span class='texttt'>false</span> is stored into a bit-field of
type <span class='texttt'>bool</span> of any size (including a one bit bit-field), the
original <span class='texttt'>bool</span> value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type (<a href='dcl.enum'>[dcl.enum]</a>),
the original enumerator value and the value of the bit-field shall
compare equal.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              <span class='comment'>// yields <span class='texttt'>true</span>
</span>    { <span class='comment'>/* ... */</span> }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='nest'><h3 ><a class='secnum' href='#nest' style='min-width:103pt'>9.2.5</a> Nested class declarations <a class='abbr_ref' href='class.nest'>[class.nest]</a></h3><p ><span class='indexparent'><a class='index' id='definition,nested_class'></a></span><span class='indexparent'><a class='index' id='class_local'></a></span><span class='indexparent'><a class='index' id='class_nested'></a></span></p><div class='para' id='nest-1'><div class='marginalizedparent'><a class='marginalized' href='#nest-1'>1</a></div><p >A class can be declared within another class. A class declared within
another is called a <span class='grammarterm'>nested</span> class. The name of a nested class
is local to its enclosing class.
<span class='indexparent'><a class='index' id='nested_class,scope_of'></a></span>The nested class is in the scope of its enclosing class.
[&nbsp;<i>Note:</i><span class='space'></span>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='example,nested_class'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x;
int y;

struct enclose {
  int x;
  static int s;

  struct inner {
    void f(int i) {
      int a = sizeof(x);        <span class='comment'>// OK: operand of sizeof is an unevaluated operand
</span>      x = i;                    <span class='comment'>// error: assign to <span class='texttt'>enclose::x</span>
</span>      s = i;                    <span class='comment'>// OK: assign to <span class='texttt'>enclose::s</span>
</span>      ::x = i;                  <span class='comment'>// OK: assign to global <span class='texttt'>x</span>
</span>      y = i;                    <span class='comment'>// OK: assign to global <span class='texttt'>y</span>
</span>    }
    void g(enclose* p, int i) {
      p-&gt;x = i;                 <span class='comment'>// OK: assign to <span class='texttt'>enclose::x</span>
</span>    }
  };
};

inner* p = 0;                   <span class='comment'>// error: <span class='texttt'>inner</span> not in scope
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-2'><div class='marginalizedparent'><a class='marginalized' href='#nest-2'>2</a></div><p >Member functions and static data members of a nested class can be
defined in a namespace scope enclosing the definition of their class.
<span class='indexparent'><a class='index' id='example,nested_class_definition'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct enclose {
  struct inner {
    static int x;
    void f(int i);
  };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { <span class='comment'>/* ... */</span> }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-3'><div class='marginalizedparent'><a class='marginalized' href='#nest-3'>3</a></div><p >If class <span class='texttt'>X</span> is defined in a namespace scope, a nested class
<span class='texttt'>Y</span> may be declared in class <span class='texttt'>X</span> and later defined in the
definition of class <span class='texttt'>X</span> or be later defined in a namespace scope
enclosing the definition of class <span class='texttt'>X</span>.
<span class='indexparent'><a class='index' id='example,nested_class_forward_declaration'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class E {
  class I1;                     <span class='comment'>// forward declaration of nested class
</span>  class I2;
  class I1 { };                 <span class='comment'>// definition of nested class
</span>};
class E::I2 { };                <span class='comment'>// definition of nested class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='nest-4'><div class='marginalizedparent'><a class='marginalized' href='#nest-4'>4</a></div><p ><span class='indexparent'><a class='index' id='friend_function,nested_class'></a></span>Like a member function, a friend function (<a href='class.friend'>[class.friend]</a>) defined
within a nested class is in the lexical scope of that class; it obeys
the same rules for name binding as a static member function of that
class (<a href='class.static'>[class.static]</a>), but it has no special access rights to
members of an enclosing class.</p></div></div><div id='nested.type'><h3 ><a class='secnum' href='#nested.type' style='min-width:103pt'>9.2.6</a> Nested type names <a class='abbr_ref' href='class.nested.type'>[class.nested.type]</a></h3><p ><span class='indexparent'><a class='index' id='type_name,nested'></a></span><span class='indexparent'><a class='index' id='type_name,nested,scope_of'></a></span>
</p><div class='para' id='nested.type-1'><div class='marginalizedparent'><a class='marginalized' href='#nested.type-1'>1</a></div><p >Type names obey exactly the same scope rules as other names. In
particular, type names defined within a class definition cannot be used
outside their class without qualification.
[&nbsp;<i>Example:</i><span class='space'></span></p><p ><span class='indexparent'><a class='index' id='example,nested_type_name'></a></span></p><pre class='codeblock'>
struct X {
  typedef int I;
  class Y { <span class='comment'>/* ... */</span> };
  I a;
};

I b;                            <span class='comment'>// error
</span>Y c;                            <span class='comment'>// error
</span>X::Y d;                         <span class='comment'>// OK
</span>X::I e;                         <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='class'></a></span></p></div></div></div><div id='union'><h2 ><a class='secnum' href='#union' style='min-width:88pt'>9.3</a> Unions <a class='abbr_ref' href='class.union'>[class.union]</a></h2><p ><span class='indexparent'><a class='index' id='union'></a></span></p><div class='para' id='union-1'><div class='marginalizedparent'><a class='marginalized' href='#union-1'>1</a></div><p >In a union,
a non-static data member is <a class='hidden_link' href='#def:active,union_member' id='def:active,union_member'><i>active</i></a>
if its name refers to an object
whose lifetime has begun and has not ended (<a href='basic.life'>[basic.life]</a>).
At most one of the non-static data members of an object of union type
can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. [&nbsp;<i>Note:</i><span class='space'></span> One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (<a href='class.mem'>[class.mem]</a>), and
if a non-static data member of an object of this standard-layout union type
is active and is one of the standard-layout structs,
it is permitted to inspect the common initial sequence
of any of the standard-layout struct members;
see <a href='class.mem'>[class.mem]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union-2'><div class='marginalizedparent'><a class='marginalized' href='#union-2'>2</a></div><p >The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct.
[&nbsp;<i>Note:</i><span class='space'></span>
A union object and its non-static data members are
pointer-interconvertible (<a href='basic.compound'>[basic.compound]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>).
As a consequence, all non-static data members of a
union object have the same address.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union-3'><div class='marginalizedparent'><a class='marginalized' href='#union-3'>3</a></div><p ><span class='indexparent'><a class='index' id='member_function,union'></a></span><span class='indexparent'><a class='index' id='constructor,union'></a></span><span class='indexparent'><a class='index' id='destructor,union'></a></span>A union can have member functions (including constructors and destructors),
<span class='indexparent'><a class='index' id='restriction,union'></a></span>but it shall not have virtual (<a href='class.virtual'>[class.virtual]</a>) functions. A union shall not have
base classes. A union shall not be used as a base class.
<span class='indexparent'><a class='index' id='restriction,union'></a></span>If a union contains a non-static data member of
reference type the program is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span> If any non-static data member of a union has a non-trivial
default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy constructor (<a href='class.copy'>[class.copy]</a>),
move constructor (<a href='class.copy'>[class.copy]</a>),
copy assignment operator (<a href='class.copy'>[class.copy]</a>),
move assignment operator (<a href='class.copy'>[class.copy]</a>),
or destructor (<a href='class.dtor'>[class.dtor]</a>), the corresponding member function
of the union must be user-provided or it will
be implicitly deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>) for the union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union-4'><div class='marginalizedparent'><a class='marginalized' href='#union-4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span> Consider the following union:</p><pre class='codeblock'>
union U {
  int i;
  float f;
  std::string s;
};
</pre><p >Since <span class='texttt'>std::string</span> (<a href='string.classes'>[string.classes]</a>) declares non-trivial versions of all of the special
member functions, <span class='texttt'>U</span> will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use <span class='texttt'>U</span>, some or all of these member functions
must be user-provided.<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union-5'><div class='marginalizedparent'><a class='marginalized' href='#union-5'>5</a></div><p >When the left operand of an assignment operator
involves a member access expression (<a href='expr.ref'>[expr.ref]</a>)
that nominates a union member,
it may begin the lifetime of that union member,
as described below.
For an expression <span class='texttt'>E</span>,
define the set <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span>
of subexpressions of <span class='texttt'>E</span>
as follows:
</p><ul ><li id='union-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#union-5.1'>(5.1)</a></div><p >If <span class='texttt'>E</span> is of the form <span class='texttt'>A.B</span>,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> contains the elements of <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>A</span>)</span>,
and also contains <span class='texttt'>A.B</span>
if <span class='texttt'>B</span> names a union member of a non-class, non-array type,
or of a class type with a trivial default constructor that is not deleted,
or an array of such types.
</p></li><li id='union-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#union-5.2'>(5.2)</a></div><p >If <span class='texttt'>E</span> is of the form <span class='texttt'>A[B]</span>
and is interpreted as a built-in array subscripting operator,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> is <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>A</span>)</span> if <span class='texttt'>A</span> is of array type,
<span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>B</span>)</span> if <span class='texttt'>B</span> is of array type,
and empty otherwise.
</p></li><li id='union-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#union-5.3'>(5.3)</a></div><p >Otherwise, <span class='math'><span class='mathalpha'>S</span>(<span class='mathtt'>E</span>)</span> is empty.
</p></li></ul><p >In an assignment expression of the form <span class='texttt'>E1 = E2</span>
that uses either the built-in assignment operator (<a href='expr.ass'>[expr.ass]</a>)
or a trivial assignment operator (<a href='class.copy'>[class.copy]</a>),
for each element <span class='texttt'>X</span> of <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>E1</span><span class='math'>)</span>,
if modification of <span class='texttt'>X</span> would have undefined behavior under <a href='basic.life'>[basic.life]</a>,
an object of the type of <span class='texttt'>X</span> is implicitly created
in the nominated storage;
no initialization is performed and
the beginning of its lifetime is sequenced after
the value computation of the left and right operands
and before the assignment.
[&nbsp;<i>Note:</i><span class='space'></span>
This ends the lifetime of the previously-active
member of the union, if any (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
union A { int x; int y[4]; };
struct B { A a; };
union C { B b; int k; };
int f() {
  C c;               <span class='comment'>// does not start lifetime of any union member
</span>  c.b.a.y[3] = 4;    <span class='comment'>// OK: <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>c.b.a.y[3]</span><span class='math'>)</span> contains <span class='texttt'>c.b</span> and <span class='texttt'>c.b.a.y</span>;
</span>                     <span class='comment'>// creates objects to hold union members <span class='texttt'>c.b</span> and <span class='texttt'>c.b.a.y</span>
</span>  return c.b.a.y[3]; <span class='comment'>// OK: <span class='texttt'>c.b.a.y</span> refers to newly created object (see <a href='basic.life'>[basic.life]</a>)
</span>}

struct X { const int a; int b; };
union Y { X x; int k; };
void g() {
  Y y = { { 1, 2 } }; <span class='comment'>// OK, <span class='texttt'>y.x</span> is active union member (<a href='class.mem'>[class.mem]</a>)
</span>  int n = y.x.a;
  y.k = 4;   <span class='comment'>// OK: ends lifetime of <span class='texttt'>y.x</span>, <span class='texttt'>y.k</span> is active member of union
</span>  y.x.b = n; <span class='comment'>// undefined behavior: <span class='texttt'>y.x.b</span> modified outside its lifetime,
</span>             <span class='comment'>// <span class='math'><span class='mathalpha'>S</span>(</span><span class='texttt'>y.x.b</span><span class='math'>)</span> is empty because <span class='texttt'>X</span>'s default constructor is deleted,
</span>             <span class='comment'>// so union member <span class='texttt'>y.x</span>'s lifetime does not implicitly start
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union-6'><div class='marginalizedparent'><a class='marginalized' href='#union-6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> In general, one must use explicit destructor calls and placement
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> to change the active member of a union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
Consider an object <span class='texttt'>u</span> of a <span class='texttt'>union</span> type <span class='texttt'>U</span> having non-static data members
<span class='texttt'>m</span> of type <span class='texttt'>M</span> and <span class='texttt'>n</span> of type <span class='texttt'>N</span>. If <span class='texttt'>M</span> has a non-trivial
destructor and <span class='texttt'>N</span> has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of <span class='texttt'>u</span> can be safely switched from <span class='texttt'>m</span> to
<span class='texttt'>n</span> using the destructor and placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> as follows:</p><pre class='codeblock'>
u.m.~M();
new (&amp;u.n) N;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='union.anon'><h3 ><a class='secnum' href='#union.anon' style='min-width:103pt'>9.3.1</a> Anonymous unions <a class='abbr_ref' href='class.union.anon'>[class.union.anon]</a></h3><p ><span class='indexparent'><a class='index' id='union,anonymous'></a></span>
</p><div class='para' id='union.anon-1'><div class='marginalizedparent'><a class='marginalized' href='#union.anon-1'>1</a></div><p >A union of the form</p><pre class='bnf'><span class='terminal'>union</span> <span class='terminal'>{</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> <span class='terminal'>}</span> <span class='terminal'>;</span></pre><p >is called an <a class='hidden_link' href='#def:anonymous_union' id='def:anonymous_union'><i>anonymous union</i></a>; it defines an unnamed object of unnamed
type. Each <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> in the <i ><a href='class.mem#nt:member-specification'>member-specification</a></i>
of an anonymous union shall either define a non-static data member or be a
<i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
Nested types, anonymous unions, and functions cannot be declared within an anonymous
union.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
<span class='indexparent'><a class='index' id='initialization,union'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
</pre><p >Here <span class='texttt'>a</span> and <span class='texttt'>p</span> are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='union.anon-2'><div class='marginalizedparent'><a class='marginalized' href='#union.anon-2'>2</a></div><p ><span class='indexparent'><a class='index' id='union,global_anonymous'></a></span><span class='indexparent'><a class='index' id='scope,anonymous_union_at_namespace'></a></span>Anonymous unions declared in a named namespace or in the global
namespace shall be declared <span class='texttt'>static</span>. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
<span class='indexparent'><a class='index' id='access_control,anonymous_union'></a></span><span class='indexparent'><a class='index' id='restriction,anonymous_union'></a></span>An anonymous union shall not have <span class='texttt'>private</span> or <span class='texttt'>protected</span>
members (Clause <a href='class.access'>[class.access]</a>). An anonymous union shall not have
member functions.</p></div><div class='para' id='union.anon-3'><div class='marginalizedparent'><a class='marginalized' href='#union.anon-3'>3</a></div><p >A union for which objects, pointers, or references are declared is not an anonymous union.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f() {
  union { int aa; char* p; } obj, *ptr = &amp;obj;
  aa = 1;                         <span class='comment'>// error
</span>  ptr-&gt;aa = 1;                    <span class='comment'>// OK
</span>}
</pre><p >The assignment to plain <span class='texttt'>aa</span> is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Initialization of unions with no user-declared constructors is described
in (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='union.anon-4'><div class='marginalizedparent'><a class='marginalized' href='#union.anon-4'>4</a></div><p ><span class='indexparent'><a class='index' id='class,union-like'></a></span><span class='indexparent'><a class='index' id='class,variant_member_of'></a></span>A <a class='hidden_link' href='#def:union-like_class' id='def:union-like_class'><i>union-like class</i></a> is a union or a class that has an anonymous union as a direct
member. A union-like class <span class='texttt'>X</span> has a set of <a class='hidden_link' href='#def:variant_member' id='def:variant_member'><i>variant member</i></a>s.
If <span class='texttt'>X</span> is a union, a non-static data member of <span class='texttt'>X</span> that is not an anonymous
union is a variant member of <span class='texttt'>X</span>. In addition, a non-static data member of an
anonymous union that is a member of <span class='texttt'>X</span> is also a variant member of <span class='texttt'>X</span>.
At most one variant member of a union may have a default member initializer.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
union U {
  int x = 0;
  union {
    int k;
  };
  union {
    int z;
    int y = 1; <span class='comment'>// error: initialization for second variant member of <span class='texttt'>U</span>
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='local'><h2 ><a class='secnum' href='#local' style='min-width:88pt'>9.4</a> Local class declarations <a class='abbr_ref' href='class.local'>[class.local]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,local_class'></a></span><span class='indexparent'><a class='index' id='definition,local_class'></a></span>
</p><div class='para' id='local-1'><div class='marginalizedparent'><a class='marginalized' href='#local-1'>1</a></div><p >A class can be declared within a function definition; such a class is
called a <span class='grammarterm'>local</span> class. The name of a local class is local to
its enclosing scope.
<span class='indexparent'><a class='index' id='local_class,scope_of'></a></span>The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function.
Declarations in a local class
shall not odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) a variable with automatic storage
duration from an
enclosing scope.
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='example,local_class'></a></span></p><pre class='codeblock'>
int x;
void f() {
  static int s;
  int x;
  const int N = 5;
  extern int q();

  struct local {
    int g() { return x; }       <span class='comment'>// error: odr-use of automatic variable <span class='texttt'>x</span>
</span>    int h() { return s; }       <span class='comment'>// OK
</span>    int k() { return ::x; }     <span class='comment'>// OK
</span>    int l() { return q(); }     <span class='comment'>// OK
</span>    int m() { return N; }       <span class='comment'>// OK: not an odr-use
</span>    int* n() { return &amp;N; }     <span class='comment'>// error: odr-use of automatic variable <span class='texttt'>N</span>
</span>  };
}

local* p = 0;                   <span class='comment'>// error: <span class='texttt'>local</span> not in scope
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='local-2'><div class='marginalizedparent'><a class='marginalized' href='#local-2'>2</a></div><p >An enclosing function has no special access to members of the local
class; it obeys the usual access rules (Clause <a href='class.access'>[class.access]</a>).
<span class='indexparent'><a class='index' id='member_function,local_class'></a></span>Member functions of a local class shall be defined within their class
definition, if they are defined at all.</p></div><div class='para' id='local-3'><div class='marginalizedparent'><a class='marginalized' href='#local-3'>3</a></div><p ><span class='indexparent'><a class='index' id='nested_class,local_class'></a></span>If class <span class='texttt'>X</span> is a local class a nested class <span class='texttt'>Y</span> may be
declared in class <span class='texttt'>X</span> and later defined in the definition of class
<span class='texttt'>X</span> or be later defined in the same scope as the definition of
class <span class='texttt'>X</span>.
<span class='indexparent'><a class='index' id='restriction,local_class'></a></span>A class nested within
a local class is a local class.</p></div><div class='para' id='local-4'><div class='marginalizedparent'><a class='marginalized' href='#local-4'>4</a></div><p ><span class='indexparent'><a class='index' id='restriction,static_member_local_class'></a></span>A local class shall not have static data members.
</p></div></div></div></div></body></html>