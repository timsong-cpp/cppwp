<!DOCTYPE html><html lang='en'><head><title>[atomics.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>32</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>32.2</a> Header <span class='texttt'>&lt;atomic&gt;</span> synopsis <a class='abbr_ref'>[atomics.syn]</a></h2><p ><span class='indexparent'><a class='index' id=':<atomic>'></a></span><span class='indexparent'><a class='index' id='lib:<atomic>'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='atomics.order'>[atomics.order]</a>, order and consistency
</span>  enum memory_order;
  template &lt;class T&gt;
    T kill_dependency(T y) noexcept;

  <span class='comment'>// <a href='atomics.lockfree'>[atomics.lockfree]</a>, lock-free property
</span>  #define ATOMIC_BOOL_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR16_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR32_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_WCHAR_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_SHORT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_INT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LLONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_POINTER_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>

  <span class='comment'>// <a href='atomics.types.generic'>[atomics.types.generic]</a>, generic types
</span>  template&lt;class T&gt; struct atomic;
  template&lt;&gt; struct atomic&lt;<span class='textit'>integral</span>&gt;;
  template&lt;class T&gt; struct atomic&lt;T*&gt;;

  <span class='comment'>// <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>, general operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='tcode_in_codeblock'><span class='textit'>atomic-type</span></span> is either <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='tcode_in_codeblock'>T</span> from Table <a href='atomics.types.generic#tab:atomics.integral'>138</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>139</a> or from <span class='tcode_in_codeblock'>bool</span>. If it is <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span>,
</span>  <span class='comment'>// then the declaration is a template declaration prefixed with <span class='tcode_in_codeblock'>template &lt;class T&gt;</span>.
</span>  bool atomic_is_lock_free(const volatile <span class='textit'>atomic-type</span>*) noexcept;
  bool atomic_is_lock_free(const <span class='textit'>atomic-type</span>*) noexcept;
  void atomic_init(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_init(<span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store(<span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store_explicit(volatile <span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  void atomic_store_explicit(<span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  T atomic_load(const volatile <span class='textit'>atomic-type</span>*) noexcept;
  T atomic_load(const <span class='textit'>atomic-type</span>*) noexcept;
  T atomic_load_explicit(const volatile <span class='textit'>atomic-type</span>*, memory_order) noexcept;
  T atomic_load_explicit(const <span class='textit'>atomic-type</span>*, memory_order) noexcept;
  T atomic_exchange(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  T atomic_exchange(<span class='textit'>atomic-type</span>*, T) noexcept;
  T atomic_exchange_explicit(volatile <span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  T atomic_exchange_explicit(<span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  bool atomic_compare_exchange_weak(volatile <span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak(<span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(volatile <span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(<span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak_explicit(volatile <span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_weak_explicit(<span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(volatile <span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(<span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.templ'>[atomics.types.operations.templ]</a>, templated operations on atomic types
</span>  template &lt;class T&gt;
    T atomic_fetch_add(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a>, arithmetic operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='tcode_in_codeblock'><span class='textit'>atomic-integral</span></span> is either <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='tcode_in_codeblock'>T</span> from Table <a href='atomics.types.generic#tab:atomics.integral'>138</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>139</a>. If it is <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span>, then the declaration
</span>  <span class='comment'>// is a template specialization declaration prefixed with <span class='tcode_in_codeblock'>template &lt;&gt;</span>.
</span>  <span class='textit'>integral</span> atomic_fetch_add(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a>, non-member overloads for atomic&lt;T*&gt;
</span>  template &lt;class T&gt;
    T* atomic_fetch_add(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.req'>[atomics.types.operations.req]</a>, initialization
</span>  #define ATOMIC_VAR_INIT(value) <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.flag'>[atomics.flag]</a>, flag type and operations
</span>  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.fences'>[atomics.fences]</a>, fences
</span>  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}</pre></div></body></html>