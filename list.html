<!DOCTYPE html><html lang='en'><head><title>[list]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>26.3</a> Sequence containers <a class='abbr_ref' href='sequences#list'>[sequences]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>26.3.10</a> Class template <span class='texttt'>list</span> <a class='abbr_ref'>[list]</a></h3><div id='overview'><h4 ><a class='secnum' href='#overview' style='min-width:118pt'>26.3.10.1</a> Class template <span class='texttt'>list</span> overview <a class='abbr_ref' href='list.overview'>[list.overview]</a></h4><div class='para' id='overview-1'><div class='marginalizedparent'><a class='marginalized' href='#overview-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4469'>#</a></div><p ><span class='indexparent'><a class='index' id='lib:list'></a></span>A
<span class='texttt'>list</span>
is a sequence container that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike <a href='vector'>vectors</a> and <a href='deque'>deques</a>,
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.</p></div><div class='para' id='overview-2'><div class='marginalizedparent'><a class='marginalized' href='#overview-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4480'>#</a></div><p >A <span class='texttt'>list</span> satisfies all of the requirements of a container, of
a reversible container (given in two tables in
<a href='container.requirements'>[container.requirements]</a>), of a sequence container,
including most of the
<a href='sequence.reqmts#tab:containers.sequence.optional'>optional sequence container requirements</a>,
and of an
<a href='container.requirements.general#tab:containers.allocatoraware'>allocator-aware container</a>.
The exceptions are the
<span class='texttt'>operator[]</span>
and
<span class='texttt'>at</span>
member functions, which are not provided.<a class='footnotenum' href='#footnote-258'>258</a>
Descriptions are provided here only for operations on
<span class='texttt'>list</span>
that are not described in one of these tables
or for operations where there is additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class list {
  public:
    <span class='comment'>// types:
</span>    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer          = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference              = value_type&amp;;
    using const_reference        = const value_type&amp;;
    using size_type              = <span class='textit'>implementation-defined</span>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using difference_type        = <span class='textit'>implementation-defined</span>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using iterator               = <span class='indexparent'><a class='index' id=':type_of_list::iterator'></a></span><span class='textit'>implementation-defined</span>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using const_iterator         = <span class='indexparent'><a class='index' id=':type_of_list::const_iterator'></a></span><span class='textit'>implementation-defined</span>; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;

    <span class='comment'>// <a href='list.cons'>[list.cons]</a>, construct/copy/destroy
</span>    list() : list(Allocator()) { }
    explicit list(const Allocator&amp;);
    explicit list(size_type n, const Allocator&amp; = Allocator());
    list(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      list(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
    list(const list&amp; x);
    list(list&amp;&amp; x);
    list(const list&amp;, const Allocator&amp;);
    list(list&amp;&amp;, const Allocator&amp;);
    list(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());
    ~list();
    list&amp; operator=(const list&amp; x);
    list&amp; operator=(list&amp;&amp; x)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    list&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; t);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='list.capacity'>[list.capacity]</a>, capacity
</span>    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);

    <span class='comment'>// element access:
</span>    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='list.modifiers'>[list.modifiers]</a>, modifiers
</span>    template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
    template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
    void push_front(const T&amp; x);
    void push_front(T&amp;&amp; x);
    void pop_front();
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);
    void pop_back();

    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
    iterator insert(const_iterator position, const T&amp; x);
    iterator insert(const_iterator position, T&amp;&amp; x);
    iterator insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert(const_iterator position, InputIterator first,
                      InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;T&gt; il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator position, const_iterator last);
    void     swap(list&amp;)
      noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    void     clear() noexcept;

    <span class='comment'>// <a href='list.ops'>[list.ops]</a>, list operations
</span>    void splice(const_iterator position, list&amp; x);
    void splice(const_iterator position, list&amp;&amp; x);
    void splice(const_iterator position, list&amp; x, const_iterator i);
    void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
    void splice(const_iterator position, list&amp; x,
                const_iterator first, const_iterator last);
    void splice(const_iterator position, list&amp;&amp; x,
                const_iterator first, const_iterator last);

    void remove(const T&amp; value);
    template &lt;class Predicate&gt; void remove_if(Predicate pred);

    void unique();
    template &lt;class BinaryPredicate&gt;
      void unique(BinaryPredicate binary_pred);

    void merge(list&amp; x);
    void merge(list&amp;&amp; x);
    template &lt;class Compare&gt; void merge(list&amp; x, Compare comp);
    template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);

    void sort();
    template &lt;class Compare&gt; void sort(Compare comp);

    void reverse() noexcept;
  };

  template&lt;class InputIterator,
           class Allocator = allocator&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;&gt;
    list(InputIterator, InputIterator, Allocator = Allocator())
      -&gt; list&lt;typename iterator_traits&lt;InputIterator&gt;::value_type, Allocator&gt;;

  template &lt;class T, class Allocator&gt;
    bool operator==(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);

  <span class='comment'>// <a href='list.special'>[list.special]</a>, specialized algorithms
</span>  template &lt;class T, class Allocator&gt;
    void swap(list&lt;T, Allocator&gt;&amp; x, list&lt;T, Allocator&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));
}</pre></div><div class='para' id='overview-3'><div class='marginalizedparent'><a class='marginalized' href='#overview-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4649'>#</a></div><p >An incomplete type <span class='texttt'>T</span> may be used when instantiating <span class='texttt'>list</span>
if the allocator satisfies the
<a href='allocator.requirements.completeness'>allocator completeness requirements</a>.
<span class='texttt'>T</span> shall be complete before any member of the resulting specialization
of <span class='texttt'>list</span> is referenced.</p></div><div class='footnote' id='footnote-258'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-258'>258)</a></div><p >These member functions
are only provided by containers whose iterators
are random access iterators.
</p></div></div><div id='cons'><h4 ><a class='secnum' href='#cons' style='min-width:118pt'>26.3.10.2</a> <span class='texttt'>list</span> constructors, copy, and assignment <a class='abbr_ref' href='list.cons'>[list.cons]</a></h4><p ><span class='indexparent'><a class='index' id='lib:list,constructor'></a></span></p><p ><code class='itemdecl'>explicit list(const Allocator&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4664'>#</a></div><p ><span class='textit'>Effects:</span> 
Constructs an empty list, using the specified allocator.</p></div></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4668'>#</a></div><p ><span class='textit'>Complexity:</span> 
Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:list,constructor_'></a></span></p><p ><code class='itemdecl'>explicit list(size_type n, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-3'><div class='marginalizedparent'><a class='marginalized' href='#cons-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4679'>#</a></div><p ><span class='textit'>Effects:</span> Constructs a <span class='texttt'>list</span> with
<span class='texttt'>n</span> default-inserted elements using the specified allocator.</p></div></div><div class='para' id='cons-4'><div class='marginalizedparent'><a class='marginalized' href='#cons-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4683'>#</a></div><p ><span class='textit'>Requires:</span> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='cons-5'><div class='marginalizedparent'><a class='marginalized' href='#cons-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4686'>#</a></div><p ><span class='textit'>Complexity:</span> 
Linear in
<span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:list,constructor__'></a></span></p><p ><code class='itemdecl'>list(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-6'><div class='marginalizedparent'><a class='marginalized' href='#cons-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4698'>#</a></div><p ><span class='textit'>Effects:</span> 
Constructs a
<span class='texttt'>list</span>
with
<span class='texttt'>n</span>
copies of
<span class='texttt'>value</span>,
using the specified allocator.</p></div></div><div class='para' id='cons-7'><div class='marginalizedparent'><a class='marginalized' href='#cons-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4708'>#</a></div><p ><span class='textit'>Requires:</span> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='cons-8'><div class='marginalizedparent'><a class='marginalized' href='#cons-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4711'>#</a></div><p ><span class='textit'>Complexity:</span> 
Linear in
<span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:list,constructor___'></a></span></p><p ><code class='itemdecl'>template &lt;class InputIterator&gt;
  list(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-9'><div class='marginalizedparent'><a class='marginalized' href='#cons-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4724'>#</a></div><p ><span class='textit'>Effects:</span> 
Constructs a
<span class='texttt'>list</span>
equal to the range
<span class='texttt'>[first, last)</span>.</p></div></div><div class='para' id='cons-10'><div class='marginalizedparent'><a class='marginalized' href='#cons-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4731'>#</a></div><p ><span class='textit'>Complexity:</span> 
Linear in
<span class='texttt'>distance(first, last)</span>.
</p></div></div></div><div id='capacity'><h4 ><a class='secnum' href='#capacity' style='min-width:118pt'>26.3.10.3</a> <span class='texttt'>list</span> capacity <a class='abbr_ref' href='list.capacity'>[list.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='lib:resize,list'></a></span></p><p ><code class='itemdecl'>void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#capacity-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4745'>#</a></div><p ><span class='textit'>Effects:</span> 
If <span class='texttt'>size() &lt; sz</span>,
appends <span class='texttt'>sz - size()</span> default-inserted elements to the
sequence.
If <span class='texttt'>sz &lt;= size()</span>, equivalent to:</p><pre class='codeblock'>
list&lt;T&gt;::iterator it = begin();
advance(it, sz);
erase(it, end());</pre></div></div><div class='para' id='capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#capacity-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4759'>#</a></div><p ><span class='textit'>Requires:</span> <span class='texttt'>T</span> shall be
<span class='texttt'>DefaultInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:resize,list_'></a></span></p><p ><code class='itemdecl'>void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#capacity-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4770'>#</a></div><p ><span class='textit'>Effects:</span> 
As if by:
</p><pre class='codeblock'>
if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 <span class='comment'>// do nothing
</span></pre></div></div><div class='para' id='capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#capacity-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4785'>#</a></div><p ><span class='textit'>Requires:</span> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div></div><div id='modifiers'><h4 ><a class='secnum' href='#modifiers' style='min-width:118pt'>26.3.10.4</a> <span class='texttt'>list</span> modifiers <a class='abbr_ref' href='list.modifiers'>[list.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='lib:insert,list'></a></span></p><p ><code class='itemdecl'>iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position, InputIterator first,
                  InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; reference emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; reference emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4811'>#</a></div><p ><span class='textit'>Remarks:</span> 
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.</p></div></div><div class='para' id='modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4816'>#</a></div><p ><span class='textit'>Complexity:</span> 
Insertion of a single element into a list takes constant time and
exactly one call to a constructor of
<span class='texttt'>T</span>. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor or move constructor of <span class='texttt'>T</span> is exactly equal
to the number of elements inserted.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:erase,list'></a></span></p><p ><code class='itemdecl'>iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4837'>#</a></div><p ><span class='textit'>Effects:</span> 
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4841'>#</a></div><p ><span class='textit'>Throws:</span> Nothing.</p></div></div><div class='para' id='modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4844'>#</a></div><p ><span class='textit'>Complexity:</span> 
Erasing a single element is a constant time operation with a single call to the destructor of
<span class='texttt'>T</span>.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
<span class='texttt'>T</span>
is exactly equal to the size of the range.
</p></div></div></div><div id='ops'><h4 ><a class='secnum' href='#ops' style='min-width:118pt'>26.3.10.5</a> <span class='texttt'>list</span> operations <a class='abbr_ref' href='list.ops'>[list.ops]</a></h4><div class='para' id='ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ops-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4856'>#</a></div><p >Since lists allow fast insertion and erasing from the middle of a list, certain
operations are provided specifically for them.<a class='footnotenum' href='#footnote-259'>259</a></p></div><div class='para' id='ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ops-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4862'>#</a></div><p ><span class='texttt'>list</span> provides three splice operations that destructively move elements from one list to
another. The behavior of splice operations is undefined if <span class='texttt'>get_&shy;allocator() !=
x.get_&shy;allocator()</span>.</p><p ><span class='indexparent'><a class='index' id='lib:splice,list'></a></span></p></div><p ><code class='itemdecl'>void splice(const_iterator position, list&amp; x);
void splice(const_iterator position, list&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ops-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4874'>#</a></div><p ><span class='textit'>Requires:</span> 
<span class='texttt'>&amp;x != this</span>.</p></div></div><div class='para' id='ops-4'><div class='marginalizedparent'><a class='marginalized' href='#ops-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4878'>#</a></div><p ><span class='textit'>Effects:</span> 
Inserts the contents of
<span class='texttt'>x</span>
before
<span class='texttt'>position</span>
and
<span class='texttt'>x</span>
becomes empty.
Pointers and references to the moved elements of
<span class='texttt'>x</span>
now refer to those same elements but as members of
<span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='ops-5'><div class='marginalizedparent'><a class='marginalized' href='#ops-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4897'>#</a></div><p ><span class='textit'>Throws:</span> Nothing.</p></div></div><div class='para' id='ops-6'><div class='marginalizedparent'><a class='marginalized' href='#ops-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4900'>#</a></div><p ><span class='textit'>Complexity:</span> 
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:splice,list_'></a></span><span class='indexparent'><a class='index' id='lib:list,splice'></a></span></p><p ><code class='itemdecl'>void splice(const_iterator position, list&amp; x, const_iterator i);
void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
</code></p><div class='itemdescr'></div><div class='para' id='ops-7'><div class='marginalizedparent'><a class='marginalized' href='#ops-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4912'>#</a></div><p ><span class='textit'>Requires:</span> 
<span class='texttt'>i</span>
is a valid dereferenceable iterator of
<span class='texttt'>x</span>.</p></div></div><div class='para' id='ops-8'><div class='marginalizedparent'><a class='marginalized' href='#ops-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4918'>#</a></div><p ><span class='textit'>Effects:</span> 
Inserts an element pointed to by
<span class='texttt'>i</span>
from list
<span class='texttt'>x</span>
before <span class='texttt'>position</span> and removes the element from
<span class='texttt'>x</span>.
The result is unchanged if
<span class='texttt'>position == i</span>
or
<span class='texttt'>position == ++i</span>.
Pointers and references to
<span class='texttt'>*i</span>
continue to refer to this same element but as a member of
<span class='texttt'>*this</span>.
Iterators
to
<span class='texttt'>*i</span>
(including
<span class='texttt'>i</span>
itself) continue to refer to the same element, but now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='ops-9'><div class='marginalizedparent'><a class='marginalized' href='#ops-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4944'>#</a></div><p ><span class='textit'>Throws:</span> Nothing.</p></div></div><div class='para' id='ops-10'><div class='marginalizedparent'><a class='marginalized' href='#ops-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4947'>#</a></div><p ><span class='textit'>Complexity:</span> 
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:splice,list__'></a></span><span class='indexparent'><a class='index' id='lib:list,splice_'></a></span></p><p ><code class='itemdecl'>void splice(const_iterator position, list&amp; x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&amp;&amp; x, const_iterator first,
            const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='ops-11'><div class='marginalizedparent'><a class='marginalized' href='#ops-11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4961'>#</a></div><p ><span class='textit'>Requires:</span> 
<span class='texttt'>[first, last)</span>
is a valid range in
<span class='texttt'>x</span>.
The program has undefined behavior if
<span class='texttt'>position</span>
is an iterator in the range
<span class='texttt'>[first, last)</span>.</p></div></div><div class='para' id='ops-12'><div class='marginalizedparent'><a class='marginalized' href='#ops-12'>12</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4971'>#</a></div><p ><span class='textit'>Effects:</span> 
Inserts elements in the range
<span class='texttt'>[first, last)</span>
before
<span class='texttt'>position</span>
and removes the elements from
<span class='texttt'>x</span>.
Pointers and references to the moved elements of
<span class='texttt'>x</span>
now refer to those same elements but as members of
<span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
<span class='texttt'>*this</span>,
not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='ops-13'><div class='marginalizedparent'><a class='marginalized' href='#ops-13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4989'>#</a></div><p ><span class='textit'>Throws:</span> Nothing.</p></div></div><div class='para' id='ops-14'><div class='marginalizedparent'><a class='marginalized' href='#ops-14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L4992'>#</a></div><p ><span class='textit'>Complexity:</span> 
Constant time if
<span class='texttt'>&amp;x == this</span>;
otherwise, linear time.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:remove,list'></a></span></p><p ><code class='itemdecl'>void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='ops-15'><div class='marginalizedparent'><a class='marginalized' href='#ops-15'>15</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5006'>#</a></div><p ><span class='textit'>Effects:</span> 
Erases all the elements in the list referred by a list iterator <span class='texttt'>i</span> for which the
following conditions hold: <span class='texttt'>*i == value</span>, <span class='texttt'>pred(*i) != false</span>.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='ops-16'><div class='marginalizedparent'><a class='marginalized' href='#ops-16'>16</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5012'>#</a></div><p ><span class='textit'>Throws:</span> 
Nothing unless an exception is thrown by
<span class='texttt'>*i == value</span>
or
<span class='texttt'>pred(*i) != false</span>.</p></div></div><div class='para' id='ops-17'><div class='marginalizedparent'><a class='marginalized' href='#ops-17'>17</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5019'>#</a></div><p ><span class='textit'>Remarks:</span> <a href='algorithm.stable'>Stable</a>.</p></div></div><div class='para' id='ops-18'><div class='marginalizedparent'><a class='marginalized' href='#ops-18'>18</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5022'>#</a></div><p ><span class='textit'>Complexity:</span> 
Exactly
<span class='texttt'>size()</span>
applications of the corresponding predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:unique,list'></a></span></p><p ><code class='itemdecl'>void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);
</code></p><div class='itemdescr'></div><div class='para' id='ops-19'><div class='marginalizedparent'><a class='marginalized' href='#ops-19'>19</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5036'>#</a></div><p ><span class='textit'>Effects:</span> 
Erases all but the first element from every
consecutive group of equal elements referred to by the iterator <span class='texttt'>i</span> in the range
<span class='texttt'>[first + 1, last)</span> for which <span class='texttt'>*i == *(i-1)</span> (for the version of
<span class='texttt'>unique</span> with no arguments) or <span class='texttt'>pred(*i, *(i - 1))</span> (for the version of
<span class='texttt'>unique</span> with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='ops-20'><div class='marginalizedparent'><a class='marginalized' href='#ops-20'>20</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5045'>#</a></div><p ><span class='textit'>Throws:</span> 
Nothing unless an exception is thrown by
<span class='texttt'>*i == *(i-1)</span>
or
<span class='texttt'>pred(*i, *(i - 1))</span></p></div></div><div class='para' id='ops-21'><div class='marginalizedparent'><a class='marginalized' href='#ops-21'>21</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5052'>#</a></div><p ><span class='textit'>Complexity:</span> 
If the range
<span class='texttt'>[first, last)</span>
is not empty, exactly
<span class='texttt'>(last - first) - 1</span>
applications of the corresponding predicate,
otherwise no applications of the predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:merge,list'></a></span></p><p ><code class='itemdecl'>void merge(list&amp; x);
void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='ops-22'><div class='marginalizedparent'><a class='marginalized' href='#ops-22'>22</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5071'>#</a></div><p ><span class='textit'>Requires:</span> 
<span class='texttt'>comp</span> shall define a <a href='alg.sorting'>strict weak ordering</a>, and both the list and the argument list shall be
sorted according to this ordering.</p></div></div><div class='para' id='ops-23'><div class='marginalizedparent'><a class='marginalized' href='#ops-23'>23</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5076'>#</a></div><p ><span class='textit'>Effects:</span> 
If <span class='texttt'>(&amp;x == this)</span> does nothing; otherwise, merges the two sorted ranges <span class='texttt'>[begin(),
end())</span> and <span class='texttt'>[x.&#x200b;begin(), x.end())</span>. The result is a range in which the elements
will be sorted in non-decreasing order according to the ordering defined by <span class='texttt'>comp</span>; that
is, for every iterator <span class='texttt'>i</span>, in the range other than the first, the condition
<span class='texttt'>comp(*i, *(i - 1))</span> will be <span class='texttt'>false</span>.
Pointers and references to the moved elements of <span class='texttt'>x</span> now refer to those same elements
but as members of <span class='texttt'>*this</span>. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into <span class='texttt'>*this</span>, not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='ops-24'><div class='marginalizedparent'><a class='marginalized' href='#ops-24'>24</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5088'>#</a></div><p ><span class='textit'>Remarks:</span> <a href='algorithm.stable'>Stable</a>. If <span class='texttt'>(&amp;x != this)</span> the range <span class='texttt'>[x.begin(), x.end())</span>
is empty after the merge.
No elements are copied by this operation. The behavior is undefined if
<span class='texttt'>get_&shy;allocator() != x.get_&shy;allocator()</span>.</p></div></div><div class='para' id='ops-25'><div class='marginalizedparent'><a class='marginalized' href='#ops-25'>25</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5094'>#</a></div><p ><span class='textit'>Complexity:</span> 
At most
<span class='texttt'>size() + x.size() - 1</span>
applications of <span class='texttt'>comp</span> if
<span class='texttt'>(&amp;x != this)</span>;
otherwise, no applications of <span class='texttt'>comp</span> are performed.
If an exception is thrown other than by a comparison there are no effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:reverse,list'></a></span></p><p ><code class='itemdecl'>void reverse() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ops-26'><div class='marginalizedparent'><a class='marginalized' href='#ops-26'>26</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5110'>#</a></div><p ><span class='textit'>Effects:</span> 
Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='ops-27'><div class='marginalizedparent'><a class='marginalized' href='#ops-27'>27</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5115'>#</a></div><p ><span class='textit'>Complexity:</span> 
Linear time.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:sort,list'></a></span></p><p ><code class='itemdecl'>void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='ops-28'><div class='marginalizedparent'><a class='marginalized' href='#ops-28'>28</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5127'>#</a></div><p ><span class='textit'>Requires:</span> 
<span class='texttt'>operator&lt;</span>
(for the first
version)
or
<span class='texttt'>comp</span>
(for the second version)
shall define a <a href='alg.sorting'>strict weak ordering</a>.</p></div></div><div class='para' id='ops-29'><div class='marginalizedparent'><a class='marginalized' href='#ops-29'>29</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5137'>#</a></div><p ><span class='textit'>Effects:</span> 
Sorts the list according to the <span class='texttt'>operator&lt;</span> or a <span class='texttt'>Compare</span> function object.
If an exception is thrown,
the order of the elements in <span class='texttt'>*this</span> is unspecified.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='ops-30'><div class='marginalizedparent'><a class='marginalized' href='#ops-30'>30</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5144'>#</a></div><p ><span class='textit'>Remarks:</span> <a href='algorithm.stable'>Stable</a>.</p></div></div><div class='para' id='ops-31'><div class='marginalizedparent'><a class='marginalized' href='#ops-31'>31</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5147'>#</a></div><p ><span class='textit'>Complexity:</span> 
Approximately
<span class="mjx-chtml"><span class="mjx-math"><span class="mjx-mrow"><span class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.446em; padding-bottom: 0.298em; padding-right: 0.085em;">N</span></span><span class="mjx-mi MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.372em; padding-bottom: 0.519em;">log</span></span><span class="mjx-mo"><span class="mjx-char"></span></span><span class="mjx-mi MJXc-space1"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.446em; padding-bottom: 0.298em; padding-right: 0.085em;">N</span></span></span></span></span>
comparisons, where
<span class='texttt'>N == size()</span>.
</p></div></div><div class='footnote' id='footnote-259'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-259'>259)</a></div><p >As specified
in <a href='allocator.requirements'>[allocator.requirements]</a>, the requirements in this Clause apply only to
lists whose allocators compare equal.</p></div></div><div id='special'><h4 ><a class='secnum' href='#special' style='min-width:118pt'>26.3.10.6</a> <span class='texttt'>list</span> specialized algorithms <a class='abbr_ref' href='list.special'>[list.special]</a></h4><p ><span class='indexparent'><a class='index' id='lib:swap,list'></a></span><span class='indexparent'><a class='index' id='lib:list,swap'></a></span></p><p ><code class='itemdecl'>template &lt;class T, class Allocator&gt;
  void swap(list&lt;T, Allocator&gt;&amp; x, list&lt;T, Allocator&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));
</code></p><div class='itemdescr'></div><div class='para' id='special-1'><div class='marginalizedparent'><a class='marginalized' href='#special-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e8e0fc6c0ec75b6ea4bbdc0134251bbc60870e25/source/containers.tex#L5165'>#</a></div><p ><span class='textit'>Effects:</span> 
As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div></body></html>