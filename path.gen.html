<!DOCTYPE html><html lang='en'><head><title>[path.gen]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>27</a> Input/output library <a class='abbr_ref' href='./#input.output'>[input.output]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>27.10</a> File systems <a class='abbr_ref' href='filesystems#path.gen'>[filesystems]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>27.10.8</a> Class <span class='texttt'>path</span> <a class='abbr_ref' href='class.path#path.gen'>[class.path]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>27.10.8.4</a> <span class='texttt'>path</span> members <a class='abbr_ref' href='path.member#path.gen'>[path.member]</a></h4><div id='path.gen'><h4 ><a class='secnum' style='min-width:133pt'>27.10.8.4.11</a> <span class='texttt'>path</span> generation <a class='abbr_ref'>[path.gen]</a></h4><p ><span class='indexparent'><a class='index' id='lexically_normal,path'></a></span><span class='indexparent'><a class='index' id='path,lexically_normal'></a></span><code class='itemdecl'>
path lexically_normal() const;
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span> in normal form (<a href='fs.def.normal.form'>[fs.def.normal.form]</a>).</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
assert(path("foo/./bar/..").lexically_normal() == "foo");
assert(path("foo/.///bar/../").lexically_normal() == "foo/.");
</pre><p >The above assertions will succeed.
The second example ends with a current directory (<i ><a href='path.generic#nt:dot'>dot</a></i>) element
appended to support operating systems
that use different syntax for directory names and regular file names.</p><p >On Windows, the returned path's <i ><a href='path.generic#nt:directory-separator'>directory-separator</a></i> characters
will be backslashes rather than slashes,
but that does not affect <span class='texttt'>path</span> equality.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='lexically_relative,path'></a></span><span class='indexparent'><a class='index' id='path,lexically_relative'></a></span><code class='itemdecl'>
path lexically_relative(const path&amp; base) const;
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span> made relative to <span class='texttt'>base</span>.
Does not resolve (<a href='fs.def.pathres'>[fs.def.pathres]</a>) symlinks.
Does not first normalize (<a href='fs.def.normal.form'>[fs.def.normal.form]</a>) <span class='texttt'>*this</span> or <span class='texttt'>base</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Determines the first mismatched element of <span class='texttt'>*this</span> and <span class='texttt'>base</span>
as if by:
</p><pre class='codeblock'>
auto [a, b] = mismatch(begin(), end(), base.begin(), base.end());
</pre><p >Then,
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >if <span class='texttt'>a == begin()</span> and <span class='texttt'>b == base.begin()</span>, returns <span class='texttt'>path()</span>; otherwise
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >if <span class='texttt'>a == end()</span> and <span class='texttt'>b == base.end()</span>, returns <span class='texttt'>path(".")</span>; otherwise
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >returns an object of class <span class='texttt'>path</span> that is default-constructed, followed by
</p><ul class='itemize'><li id='3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.1'>(3.3.1)</a></div><p >application of <span class='texttt'>operator/=(path(".."))</span>
  for each element in <span class='texttt'>[b, base.end())</span>, and then
</p></li><li id='3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.2'>(3.3.2)</a></div><p >application of <span class='texttt'>operator/=</span>
  for each element in <span class='texttt'>[a, end())</span>.
</p></li></ul></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
assert(path("/a/d").lexically_relative("/a/b/c") == "../../d");
assert(path("/a/b/c").lexically_relative("/a/d") == "../b/c");
assert(path("a/b/c").lexically_relative("a") == "b/c");
assert(path("a/b/c").lexically_relative("a/b/c/x/y") == "../..");
assert(path("a/b/c").lexically_relative("a/b/c") == ".");
assert(path("a/b").lexically_relative("c/d") == "");
</pre><p >The above assertions will succeed.
On Windows, the returned path's <i ><a href='path.generic#nt:directory-separator'>directory-separator</a></i> characters
will be backslashes rather than forward slashes,
but that does not affect <span class='texttt'>path</span> equality.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i> If symlink following semantics are desired,
  use the operational function <span class='texttt'>relative()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i> If normalization (<a href='fs.def.normal.form'>[fs.def.normal.form]</a>) is needed
  to ensure consistent matching of elements,
  apply <span class='texttt'>lexically_normal()</span> to
  <span class='texttt'>*this</span>, <span class='texttt'>base</span>, or both. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='lexically_proximate,path'></a></span><span class='indexparent'><a class='index' id='path,lexically_proximate'></a></span><code class='itemdecl'>
path lexically_proximate(const path&amp; base) const;
</code></p><div class='itemdescr'></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If the value of <span class='texttt'>lexically_relative(base)</span> is not an empty path,
  return it. Otherwise return <span class='texttt'>*this</span>.</p><p >[&nbsp;<i>Note:</i> If symlink following semantics are desired,
  use the operational function <span class='texttt'>proximate()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i> If normalization (<a href='fs.def.normal.form'>[fs.def.normal.form]</a>) is needed
  to ensure consistent matching of elements,
  apply <span class='texttt'>lexically_normal()</span> to
  <span class='texttt'>*this</span>, <span class='texttt'>base</span>, or both. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></body></html>