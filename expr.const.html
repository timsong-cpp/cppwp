<!DOCTYPE html><html lang='en'><head><title>[expr.const]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><div id='expr.const'><h2 ><a class='secnum' style='min-width:88pt'>5.20</a> Constant expressions <a class='abbr_ref'>[expr.const]</a></h2><p ><span class='indexparent'><a class='index' id='expression!constant'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Certain contexts require expressions that satisfy additional
requirements as detailed in this sub-clause; other contexts have different
semantics depending on whether or not an expression satisfies these requirements.
Expressions that satisfy these requirements,
assuming that copy elision is performed,
are called 
<span class='indexparent'><a class='index' id='expression!constant'></a></span><a id='constant expression'><i>constant expression</i></a>s. [&nbsp;<i>Note:</i><span class='space'></span> Constant expressions can be evaluated
during translation.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='bnf'><a id='constant-expression'>constant-expression:</a>
    <i ><a href='expr.cond#conditional-expression'>conditional-expression</a></i></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='expr.cond#conditional-expression'>conditional-expression</a></i> <span class='texttt'>e</span> is a
<a id='expression!core~constant'><i>core constant expression</i></a>
unless the evaluation of <span class='texttt'>e</span>, following the rules of the abstract
machine (<a href='intro.execution'>[intro.execution]</a>), would evaluate one of the following expressions:</p><ul ><li ><p ><span class='texttt'>this</span> (<a href='expr.prim.this'>[expr.prim.this]</a>), except in a <span class='texttt'>constexpr</span>
function or a <span class='texttt'>constexpr</span> constructor that is being evaluated as part
of <span class='texttt'>e</span>;</p></li><li ><p >an invocation of a function other than
a <span class='texttt'>constexpr</span> constructor for a literal class,
a <span class='texttt'>constexpr</span> function,
or an implicit invocation of a trivial destructor (<a href='class.dtor'>[class.dtor]</a>)
[&nbsp;<i>Note:</i><span class='space'></span> Overload resolution (<a href='over.match'>[over.match]</a>)
is applied as usual <i>&nbsp;—&nbsp;end note</i>&nbsp;];</p></li><li ><p >an invocation of an undefined <span class='texttt'>constexpr</span> function or an
undefined <span class='texttt'>constexpr</span> constructor;</p></li><li ><p >an invocation of an instantiated <span class='texttt'>constexpr</span> function or
<span class='texttt'>constexpr</span> constructor that fails to satisfy the requirements
for a <span class='texttt'>constexpr</span> function or
<span class='texttt'>constexpr</span> constructor (<a href='dcl.constexpr'>[dcl.constexpr]</a>);</p></li><li ><p >an expression that would exceed the implementation-defined
limits (see Annex <a href='implimits'>[implimits]</a>);</p></li><li ><p >an operation that would have undefined behavior
as specified in Clauses <a href='intro'>[intro]</a> through <a href='cpp'>[cpp]</a>
of this International Standard [&nbsp;<i>Note:</i><span class='space'></span> including,
for example, signed integer overflow (Clause <a href='expr'>[expr]</a>), certain
pointer arithmetic (<a href='expr.add'>[expr.add]</a>), division by
zero (<a href='expr.mul'>[expr.mul]</a>), or certain shift operations (<a href='expr.shift'>[expr.shift]</a>)
<i>&nbsp;—&nbsp;end note</i>&nbsp;];</p></li><li ><p >an lvalue-to-rvalue conversion (<a href='conv.lval'>[conv.lval]</a>) unless
it is applied to</p><ul ><li ><p >a non-volatile glvalue of integral or enumeration type that refers
  to a complete non-volatile const object with a preceding initialization,
  initialized with a constant expression, or</p></li><li ><p >a non-volatile glvalue that refers to a subobject of a string
  literal (<a href='lex.string'>[lex.string]</a>), or</p></li><li ><p >a non-volatile glvalue that refers to a non-volatile object
  defined with <span class='texttt'>constexpr</span>, or that refers to a non-mutable sub-object
  of such an object, or</p></li><li ><p >a non-volatile glvalue of literal type that refers to a non-volatile object
  whose lifetime began within the evaluation of <span class='texttt'>e</span>;
</p></li></ul></li><li ><p >an lvalue-to-rvalue conversion (<a href='conv.lval'>[conv.lval]</a>)
that is applied to a glvalue
that refers to a non-active member of a union or a subobject thereof;</p></li><li ><p >an assignment expression (<a href='expr.ass'>[expr.ass]</a>)
or invocation of an assignment operator (<a href='class.copy'>[class.copy]</a>)
that would change the active member of a union;</p></li><li ><p >an <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> that refers to a variable or
data member of reference type
unless the reference has a preceding initialization and either</p><ul ><li ><p >it is initialized with a constant expression or</p></li><li ><p >its lifetime began within the evaluation of <span class='texttt'>e</span>;
</p></li></ul></li><li ><p >in a <i ><a href='expr.prim.lambda#lambda-expression'>lambda-expression</a></i>,
a reference to <span class='texttt'>this</span> or to a variable with
automatic storage duration defined outside that
<i ><a href='expr.prim.lambda#lambda-expression'>lambda-expression</a></i>, where
the reference would be an odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>, <a href='expr.prim.lambda'>[expr.prim.lambda]</a>);
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
void g() {
  const int n = 0;
  [=] {
    constexpr int i = n;   <span class='comment'>// OK, <span class='texttt'>n</span> is not odr-used and not captured here
</span>    constexpr int j = *&amp;n; <span class='comment'>// ill-formed, <span class='texttt'>&amp;n</span> would be an odr-use of <span class='texttt'>n</span>
</span>  };
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
If the odr-use occurs in an invocation
of a function call operator of a closure type,
it no longer refers to <span class='texttt'>this</span> or to an enclosing automatic variable
due to the transformation (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>)
of the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> into
an access of the corresponding data member.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
auto monad = [](auto v) { return [=] { return v; }; };
auto bind = [](auto m) {
  return [=](auto fvm) { return fvm(m()); };
};

<span class='comment'>// OK to have captures to automatic objects created during constant expression evaluation.
</span>static_assert(bind(monad(2))(monad)() == monad(2)());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >a conversion from type <i>cv</i> <span class='texttt'>void *</span> to a pointer-to-object type;</p></li><li ><p >a dynamic cast (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>);</p></li><li ><p >a <span class='texttt'>reinterpret_cast</span> (<a href='expr.reinterpret.cast'>[expr.reinterpret.cast]</a>);</p></li><li ><p >a pseudo-destructor call (<a href='expr.pseudo'>[expr.pseudo]</a>);</p></li><li ><p >modification of an object (<a href='expr.ass'>[expr.ass]</a>, <a href='expr.post.incr'>[expr.post.incr]</a>,
<a href='expr.pre.incr'>[expr.pre.incr]</a>)
unless it is applied to a non-volatile lvalue of literal type
that refers to a non-volatile object
whose lifetime began within the evaluation of <span class='texttt'>e</span>;</p></li><li ><p >a typeid expression (<a href='expr.typeid'>[expr.typeid]</a>) whose operand is a glvalue of a
polymorphic class type;</p></li><li ><p >a <i ><a href='expr.new#new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>);</p></li><li ><p >a <i ><a href='expr.delete#delete-expression'>delete-expression</a></i> (<a href='expr.delete'>[expr.delete]</a>);</p></li><li ><p >a relational (<a href='expr.rel'>[expr.rel]</a>) or equality (<a href='expr.eq'>[expr.eq]</a>)
operator where the result is unspecified; or</p></li><li ><p >a <i ><a href='expr.throw#throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>).
</p></li></ul><p >If <span class='texttt'>e</span> satisfies the constraints of a core constant expression, but
evaluation of <span class='texttt'>e</span> would evaluate an operation that has undefined behavior
as specified in Clauses <a href='library'>[library]</a> through <a href='thread'>[thread]</a> of this
International Standard, it is unspecified whether <span class='texttt'>e</span> is a core constant
expression.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int x;                              <span class='comment'>// not constant
</span>struct A {
  constexpr A(bool b) : m(b?42:x) { }
  int m;
};
constexpr int v = A(true).m;        <span class='comment'>// OK: constructor call initializes
</span>                                    <span class='comment'>// <span class='texttt'>m</span> with the value <span class='texttt'>42</span>
</span>constexpr int w = A(false).m;       <span class='comment'>// error: initializer for <span class='texttt'>m</span> is
</span>                                    <span class='comment'>// <span class='texttt'>x</span>, which is non-constant
</span>
constexpr int f1(int k) {
  constexpr int x = k;              <span class='comment'>// error: <span class='texttt'>x</span> is not initialized by a
</span>                                    <span class='comment'>// constant expression because lifetime of <span class='texttt'>k</span>
</span>                                    <span class='comment'>// began outside the initializer of <span class='texttt'>x</span>
</span>  return x;
}
constexpr int f2(int k) {
  int x = k;                        <span class='comment'>// OK: not required to be a constant expression
</span>                                    <span class='comment'>// because <span class='texttt'>x</span> is not <span class='texttt'>constexpr</span>
</span>  return x;
}

constexpr int incr(int &amp;n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k);        <span class='comment'>// error: <span class='texttt'>incr(k)</span> is not a core constant
</span>                                    <span class='comment'>// expression because lifetime of <span class='texttt'>k</span>
</span>                                    <span class='comment'>// began outside the expression <span class='texttt'>incr(k)</span>
</span>  return x;
}
constexpr int h(int k) {
  int x = incr(k);                  <span class='comment'>// OK: <span class='texttt'>incr(k)</span> is not required to be a core
</span>                                    <span class='comment'>// constant expression
</span>  return x;
}
constexpr int y = h(1);             <span class='comment'>// OK: initializes <span class='texttt'>y</span> with the value <span class='texttt'>2</span>
</span>                                    <span class='comment'>// <span class='texttt'>h(1)</span> is a core constant expression because
</span>                                    <span class='comment'>// the lifetime of <span class='texttt'>k</span> begins inside <span class='texttt'>h(1)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >An <a id='expression!integral~constant'><i>integral constant expression</i></a>
is an expression of integral or
unscoped enumeration type, implicitly converted to a prvalue, where the converted expression is a core constant expression.
[&nbsp;<i>Note:</i><span class='space'></span>
Such expressions may be
used as bit-field lengths (<a href='class.bit'>[class.bit]</a>), as enumerator
initializers if the underlying type is not fixed (<a href='dcl.enum'>[dcl.enum]</a>),
and as alignments (<a href='dcl.align'>[dcl.align]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A <a id='expression!converted~constant'><i>converted constant expression</i></a>
of type <span class='texttt'>T</span> is an
expression, implicitly converted to type <span class='texttt'>T</span>, where
the converted expression is a constant expression and the
implicit conversion sequence contains only</p><ul ><li ><p >user-defined conversions,
</p></li><li ><p >lvalue-to-rvalue conversions (<a href='conv.lval'>[conv.lval]</a>),
</p></li><li ><p >array-to-pointer conversions (<a href='conv.array'>[conv.array]</a>),
</p></li><li ><p >function-to-pointer conversions (<a href='conv.func'>[conv.func]</a>),
</p></li><li ><p >qualification conversions (<a href='conv.qual'>[conv.qual]</a>),
</p></li><li ><p >integral promotions (<a href='conv.prom'>[conv.prom]</a>),
</p></li><li ><p >integral conversions (<a href='conv.integral'>[conv.integral]</a>) other than narrowing conversions (<a href='dcl.init.list'>[dcl.init.list]</a>),
</p></li><li ><p >null pointer conversions (<a href='conv.ptr'>[conv.ptr]</a>) from <span class='texttt'>std::nullptr_t</span>,
</p></li><li ><p >null member pointer conversions (<a href='conv.mem'>[conv.mem]</a>) from <span class='texttt'>std::nullptr_t</span>, and
</p></li><li ><p >function pointer conversions (<a href='conv.fctptr'>[conv.fctptr]</a>),
</p></li></ul><p >and where the reference binding (if any) binds directly.
[&nbsp;<i>Note:</i><span class='space'></span>
such expressions may be used in <span class='texttt'>new</span>
expressions (<a href='expr.new'>[expr.new]</a>), as case expressions (<a href='stmt.switch'>[stmt.switch]</a>),
as enumerator initializers if the underlying type is
fixed (<a href='dcl.enum'>[dcl.enum]</a>), as array bounds (<a href='dcl.array'>[dcl.array]</a>), and
as non-type template
arguments (<a href='temp.arg'>[temp.arg]</a>). 
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='contextually converted constant expression of type bool'></a></span><span class='indexparent'><a class='index' id='conversion!contextual to constant expression of type bool'></a></span>A <i>contextually converted constant expression of type <span class='texttt'>bool</span></i> is
an expression, contextually converted to <span class='texttt'>bool</span> (Clause<a href='conv'>[conv]</a>),
where the converted expression is a constant expression and
the conversion sequence contains only the conversions above.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='expression!constant'></a></span>A <i>constant expression</i> is either
a glvalue core constant expression whose value refers to
an entity that is a permitted result of a constant expression (as defined below), or
a prvalue core constant expression whose value
satisfies the following constraints:</p><ul ><li ><p >if the value is an object of class type,
  each non-static data member of reference type refers to
  an entity that is a permitted result of a constant expression,</p></li><li ><p >if the value is of pointer type, it contains
  the address of an object with static storage duration,
  the address past the end of such an object (<a href='expr.add'>[expr.add]</a>),
  the address of a function,
  or a null pointer value, and</p></li><li ><p >if the value is an object of class or array type,
  each subobject satisfies these constraints for the value.
</p></li></ul><p >An entity is a
<a id='constant expression!permitted result~of'><i>permitted result of a constant expression</i></a>
if it is an
object with static storage duration that is either not a temporary object or is
a temporary object whose value satisfies the above constraints, or it is a
function.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Since this International Standard
imposes no restrictions on the accuracy of floating-point operations, it is unspecified whether the
evaluation of a floating-point expression during translation yields the same result as the
evaluation of the same expression (or the same operations on the same values) during program
execution.<a class='footnotenum' href='#footnote-88'>88</a> [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
bool f() {
    char array[1 + int(1 + 0.2 - 0.1 - 0.1)];  <span class='comment'>// Must be evaluated during translation
</span>    int size = 1 + int(1 + 0.2 - 0.1 - 0.1);   <span class='comment'>// May be evaluated at runtime
</span>    return sizeof(array) == size;
}
</pre><p >It is unspecified whether the value of <span class='texttt'>f()</span> will be <span class='texttt'>true</span> or <span class='texttt'>false</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If an expression of literal class type is used in a context where an 
integral constant expression is required, then that expression is
contextually implicitly converted (Clause <a href='conv'>[conv]</a>) to an integral or unscoped
enumeration type 
and the selected conversion function shall be <span class='texttt'>constexpr</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { 
  constexpr A(int i) : val(i) { } 
  constexpr operator int() const { return val; }
  constexpr operator long() const { return 43; }
private: 
  int val; 
}; 
template&lt;int&gt; struct X { }; 
constexpr A a = 42; 
X&lt;a&gt; x;             <span class='comment'>// OK: unique conversion to <span class='texttt'>int</span>
</span>int ary[a];         <span class='comment'>// error: ambiguous conversion 
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='expression'></a></span>
</p></div><div class='footnote' id='footnote-88'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-88'>88)</a></div><p >Nonetheless, implementations are encouraged to provide consistent results,
irrespective of whether the evaluation was performed during translation and/or during program
execution.</p></div></div></div></body></html>