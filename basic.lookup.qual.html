<!DOCTYPE html><html lang='en'><head><title>[basic.lookup.qual]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.4</a> Name lookup <a class='abbr_ref' href='basic.lookup#qual'>[basic.lookup]</a></h2><div id='basic.lookup.qual'><h3 ><a class='secnum' style='min-width:103pt'>3.4.3</a> Qualified name lookup <a class='abbr_ref'>[basic.lookup.qual]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1579'>#</a></div><p ><span class='indexparent'><a class='index' id='lookup,qualified_name'></a></span><span class='indexparent'><a class='index' id='name,qualified'></a></span><span class='indexparent'><a class='index' id='qualification,explicit'></a></span>The name of a class or namespace member
or enumerator can be referred to after the
<span class='texttt'>::</span> scope resolution operator (<a href='expr.prim'>[expr.prim]</a>) applied to a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> that denotes its class,
namespace, or enumeration.
If a
<span class='texttt'>::</span> scope resolution
operator
in a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is not preceded by a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>,
lookup of the name preceding that <span class='texttt'>::</span> considers only namespaces, types, and
templates whose specializations are types. If the
name found does not designate a namespace or a class, enumeration, or dependent type,
the program is ill-formed. [ <i>Example:</i></p><pre class='codeblock'>
class A {
public:
  static int n;
};
int main() {
  int A;
  A::n = 42;        <span class='comment'>// OK
</span>  A b;              <span class='comment'>// ill-formed: <span class='texttt'>A</span> does not name a type
</span>}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1610'>#</a></div><p >[ <i>Note:</i> Multiply qualified names, such as <span class='texttt'>N1::N2::N3::n</span>, can
be used to refer to members of nested classes (<a href='class.nest'>[class.nest]</a>) or
members of nested namespaces. <i> — end note</i> ]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1615'>#</a></div><p >In a declaration in which the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, names used before the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
being declared are looked up in the defining namespace scope; names
following the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> are looked up in the scope of the
member's class or namespace. [ <i>Example:</i></p><pre class='codeblock'>
class X { };
class C {
  class X { };
  static const int number = 50;
  static X arr[number];
};
X C::arr[number];   <span class='comment'>// ill-formed:
</span>                    <span class='comment'>// equivalent to <span class='texttt'>::X</span> <span class='texttt'>C::arr[C::number];</span>
</span>                    <span class='comment'>// and not to <span class='texttt'>C::X</span> <span class='texttt'>C::arr[C::number];</span>
</span></pre><p ><i> — end example</i> ]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1635'>#</a></div><p ><span class='indexparent'><a class='index' id='operator,scope_resolution'></a></span><span class='indexparent'><a class='index' id='scope_resolution_operator'></a></span>A name prefixed by the unary scope operator <span class='texttt'>::</span> (<a href='expr.prim'>[expr.prim]</a>)
is looked up in global scope, in the translation unit where it is used.
The name shall be declared in global namespace scope or shall be a name
whose declaration is visible in global scope because of a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> (<a href='namespace.qual'>[namespace.qual]</a>). The use of <span class='texttt'>::</span>
allows a global name to be referred to even if its identifier has been
hidden (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1646'>#</a></div><p >A name prefixed by a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> that
nominates an enumeration type shall represent an <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i>
of that enumeration.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1651'>#</a></div><p >If a <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i> (<a href='expr.pseudo'>[expr.pseudo]</a>) contains a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, the <i ><a href='dcl.type.simple#nt:type-name'>type-names</a></i> are looked
up as types in the scope designated by the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. Similarly, in a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> of the form:</p><pre class='bnf'><i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-name'>class-name</a></i> <span class='terminal'>::</span> <span class='terminal'>~</span> <i ><a href='class#nt:class-name'>class-name</a></i></pre><p >the second <i ><a href='class#nt:class-name'>class-name</a></i> is looked up in the same scope as the
first. [ <i>Example:</i></p><pre class='codeblock'>
struct C {
  typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
p-&gt;C::I::~I();      <span class='comment'>// <span class='texttt'>I</span> is looked up in the scope of <span class='texttt'>C</span>
</span>q-&gt;I1::~I2();       <span class='comment'>// <span class='texttt'>I2</span> is looked up in the scope of the postfix-expression
</span>
struct A {
  ~A();
};
typedef A AB;
int main() {
  AB* p;
  p-&gt;AB::~AB();     <span class='comment'>// explicitly calls the destructor for <span class='texttt'>A</span>
</span>}</pre><p ><i> — end example</i> ] [ <i>Note:</i> <a href='basic.lookup.classref'>[basic.lookup.classref]</a> describes how name
lookup proceeds after the <span class='texttt'>.</span> and <span class='texttt'>-&gt;</span> operators. <i> — end note</i> ]</p></div><div id='class.qual'><h4 ><a class='secnum' href='#class.qual' style='min-width:118pt'>3.4.3.1</a> Class members <a class='abbr_ref' href='class.qual'>[class.qual]</a></h4><div class='para' id='class.qual-1'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1689'>#</a></div><p ><span class='indexparent'><a class='index' id='lookup,class_member'></a></span>If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
nominates a class, the name specified after the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is looked up in the scope of the
class (<a href='class.member.lookup'>[class.member.lookup]</a>), except for the cases listed below.
The name shall represent one or more members of that class or of one of
its base classes (Clause <a href='class.derived'>[class.derived]</a>). [ <i>Note:</i> A class member
can be referred to using a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> at any point in its
potential scope (<a href='basic.scope.class'>[basic.scope.class]</a>). <i> — end note</i> ] The exceptions to
the name lookup rule above are the following:
</p><ul class='itemize'><li id='class.qual-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-1.1'>(1.1)</a></div><p >the lookup for a destructor is as specified
in <a href='basic.lookup.qual'>[basic.lookup.qual]</a>;</p></li><li id='class.qual-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-1.2'>(1.2)</a></div><p >a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> of a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i> is looked up
in the same manner as a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> in a class member
access (see <a href='basic.lookup.classref'>[basic.lookup.classref]</a>);</p></li><li id='class.qual-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-1.3'>(1.3)</a></div><p >the names in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> of a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> are looked up in the context in which the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></li><li id='class.qual-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-1.4'>(1.4)</a></div><p >the lookup for a name specified in a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) also finds class or
enumeration names hidden within the same
scope (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).
</p></li></ul></div><div class='para' id='class.qual-2'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1719'>#</a></div><p >In a lookup in which function names are not ignored<a class='footnotenum' href='#footnote-34'>34</a>
and the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> nominates a class <span class='texttt'>C</span>:
</p><ul class='itemize'><li id='class.qual-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-2.1'>(2.1)</a></div><p >if the name specified after the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
when looked up in <span class='texttt'>C</span>, is the injected-class-name of <span class='texttt'>C</span> (Clause <a href='class'>[class]</a>), or
</p></li><li id='class.qual-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class.qual-2.2'>(2.2)</a></div><p >in a <i ><a href='namespace.udecl#nt:using-declarator'>using-declarator</a></i> of
a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) that is a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>,
if the name specified after the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is the same as the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> or the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>'s
<i ><a href='temp.names#nt:template-name'>template-name</a></i> in the last component of the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
</p></li></ul><p >the name is instead considered to name the
constructor of class <span class='texttt'>C</span>. [ <i>Note:</i> For example, the constructor
is not an acceptable lookup result in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> so the constructor would not be
used in place of the injected-class-name. <i> — end note</i> ] Such a constructor
name shall be used only in the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of a declaration
that names a constructor or in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>.
[ <i>Example:</i>
</p><pre class='codeblock'>
struct A { A(); };
struct B: public A { B(); };

A::A() { }
B::B() { }

B::A ba;            <span class='comment'>// object of type <span class='texttt'>A</span>
</span>A::A a;             <span class='comment'>// error, <span class='texttt'>A::A</span> is not a type name
</span>struct A::A a2;     <span class='comment'>// object of type <span class='texttt'>A</span>
</span></pre><p ><i> — end example</i> ]</p></div><div class='para' id='class.qual-3'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1756'>#</a></div><p >A class member name hidden by a name in a nested declarative region or
by the name of a derived class member can still be found if qualified by
the name of its class followed by the <span class='texttt'>::</span> operator.</p></div><div class='footnote' id='footnote-34'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-34'>34)</a></div><p >Lookups in which
function names are ignored include names appearing in a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, or a <i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>.</p></div></div><div id='namespace.qual'><h4 ><a class='secnum' href='#namespace.qual' style='min-width:118pt'>3.4.3.2</a> Namespace members <a class='abbr_ref' href='namespace.qual'>[namespace.qual]</a></h4><div class='para' id='namespace.qual-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1763'>#</a></div><p ><span class='indexparent'><a class='index' id='lookup,namespace_member'></a></span>If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
nominates a namespace (including the case where the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is <span class='texttt'>::</span>, i.e., nominating
the global namespace), the name specified after the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is looked up in the scope of the
namespace.
The names in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> of a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> are looked up in the context in which the
entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></div><div class='para' id='namespace.qual-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1775'>#</a></div><p >For a namespace <span class='texttt'>X</span> and name <span class='texttt'>m</span>, the namespace-qualified lookup set
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is defined as follows: Let <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> be the set of all
declarations of <span class='texttt'>m</span> in <span class='texttt'>X</span> and the inline namespace set of
<span class='texttt'>X</span> (<a href='namespace.def'>[namespace.def]</a>). If <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is not empty, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>; otherwise, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the union of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub>, <span class='mathalpha'>m</span>)</span> for
all namespaces <span class='math'><span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub></span> nominated by <span class='grammarterm'>using-directives</span> in
<span class='texttt'>X</span> and its inline namespace set.</p></div><div class='para' id='namespace.qual-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1784'>#</a></div><p >Given <span class='texttt'>X::m</span> (where <span class='texttt'>X</span> is a user-declared namespace), or
given <span class='texttt'>::m</span> (where X is the global namespace), if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the empty set, the program is ill-formed. Otherwise, if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> has exactly one member, or if the context of the reference is
a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>), <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is the
required set of declarations of <span class='texttt'>m</span>. Otherwise if the use of
<span class='texttt'>m</span> is not one that allows a unique declaration to be chosen from
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>, the program is ill-formed. [ <i>Example:</i></p><pre class='codeblock'>
int x;
namespace Y {
  void f(float);
  void h(int);
}

namespace Z {
  void h(double);
}

namespace A {
  using namespace Y;
  void f(int);
  void g(int);
  int i;
}

namespace B {
  using namespace Z;
  void f(char);
  int i;
}

namespace AB {
  using namespace A;
  using namespace B;
  void g();
}

void h(){
  AB::g();          <span class='comment'>// <span class='texttt'>g</span> is declared directly in <span class='texttt'>AB</span>, therefore <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>AB::g()</span></span> }</span> and <span class='texttt'>AB::g()</span> is chosen
</span>
  AB::f(1);         <span class='comment'>// <span class='texttt'>f</span> is not declared directly in <span class='texttt'>AB</span> so the rules are applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B</span>;
</span>                    <span class='comment'>// namespace <span class='texttt'>Y</span> is not searched and <span class='texttt'>Y::f(float)</span> is not considered;
</span>                    <span class='comment'>// <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::f(int)</span></span>, <span class='text'><span class='texttt'>B::f(char)</span></span> }</span> and overload resolution chooses <span class='texttt'>A::f(int)</span>
</span>
  AB::f('c');       <span class='comment'>// as above but resolution chooses <span class='texttt'>B::f(char)</span>
</span>
  AB::x++;          <span class='comment'>// <span class='texttt'>x</span> is not declared directly in <span class='texttt'>AB</span>, and is not declared in <span class='texttt'>A</span> or <span class='texttt'>B</span>, so the rules
</span>                    <span class='comment'>// are applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>, <span class='texttt'>S</span> is <span class='math'>{ }</span> so the program is ill-formed
</span>
  AB::i++;          <span class='comment'>// <span class='texttt'>i</span> is not declared directly in <span class='texttt'>AB</span> so the rules are applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::i</span></span>, <span class='text'><span class='texttt'>B::i</span></span> }</span> so the use is ambiguous and the program is ill-formed
</span>
  AB::h(16.8);      <span class='comment'>// <span class='texttt'>h</span> is not declared directly in <span class='texttt'>AB</span> and not declared directly in <span class='texttt'>A</span> or <span class='texttt'>B</span> so the rules
</span>                    <span class='comment'>// are applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>, <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>Y::h(int)</span></span>, <span class='text'><span class='texttt'>Z::h(double)</span></span> }</span> and
</span>                    <span class='comment'>// overload resolution chooses <span class='texttt'>Z::h(double)</span>
</span>}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='namespace.qual-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1848'>#</a></div><p >[ <i>Note:</i>
The same declaration found more than once is not an ambiguity (because
it is still a unique declaration).
[ <i>Example:</i>
</p><pre class='codeblock'>
namespace A {
  int a;
}

namespace B {
  using namespace A;
}

namespace C {
  using namespace A;
}

namespace BC {
  using namespace B;
  using namespace C;
}

void f(){
  BC::a++;          <span class='comment'>// OK: <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::a</span></span>, <span class='text'><span class='texttt'>A::a</span></span> }</span>
</span>}

namespace D {
  using A::a;
}

namespace BD {
  using namespace B;
  using namespace D;
}

void g(){
  BD::a++;          <span class='comment'>// OK: <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::a</span></span>, <span class='text'><span class='texttt'>A::a</span></span> }</span>
</span>}</pre><p ><i> — end example</i> ]
<i> — end note</i> ]</p></div><div class='para' id='namespace.qual-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1893'>#</a></div><p >[ <i>Example:</i>
Because each referenced namespace is searched at most once, the
following is well-defined:</p><pre class='codeblock'>
namespace B {
  int b;
}

namespace A {
  using namespace B;
  int a;
}

namespace B {
  using namespace A;
}

void f(){
  A::a++;           <span class='comment'>// OK: <span class='texttt'>a</span> declared directly in <span class='texttt'>A</span>, <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::a</span></span> }</span>
</span>  B::a++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>A::a</span></span> }</span>
</span>  A::b++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>B::b</span></span> }</span>
</span>  B::b++;           <span class='comment'>// OK: <span class='texttt'>b</span> declared directly in <span class='texttt'>B</span>, <span class='texttt'>S</span> is <span class='math'>{ <span class='text'><span class='texttt'>B::b</span></span> }</span>
</span>}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='namespace.qual-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1922'>#</a></div><p >During the lookup of a qualified namespace member name, if the lookup
finds more than one declaration of the member, and if one declaration
introduces a class name or enumeration name and the other declarations
either introduce the same variable, the same enumerator or a set of
functions, the non-type name hides the class or enumeration name if and
only if the declarations are from the same namespace; otherwise (the
declarations are from different namespaces), the program is ill-formed.
[ <i>Example:</i></p><pre class='codeblock'>
namespace A {
  struct x { };
  int x;
  int y;
}

namespace B {
  struct y { };
}

namespace C {
  using namespace A;
  using namespace B;
  int i = C::x;     <span class='comment'>// OK, <span class='texttt'>A::x</span> (of type <span class='texttt'>int</span>)
</span>  int j = C::y;     <span class='comment'>// ambiguous, <span class='texttt'>A::y</span> or <span class='texttt'>B::y</span>
</span>}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='namespace.qual-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/basic.tex#L1952'>#</a></div><p >In a declaration for a namespace member in which the
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, given that the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> for the namespace member has the form</p><pre class='bnf'><i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i></pre><p >the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> shall name a member of the namespace
designated by the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
or of an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>) of that namespace.
[ <i>Example:</i></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
  using namespace B;
}
void A::f1(int){ }  <span class='comment'>// ill-formed, <span class='texttt'>f1</span> is not a member of <span class='texttt'>A</span>
</span></pre><p ><i> — end example</i> ] However, in such namespace member declarations, the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> may rely on <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>
to implicitly provide the initial part of the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. [ <i>Example:</i></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
}

namespace C {
  namespace D {
    void f1(int);
  }
}

using namespace A;
using namespace C::D;
void B::f1(int){ }  <span class='comment'>// OK, defines <span class='texttt'>A::B::f1(int)</span>
</span></pre><p ><i> — end example</i> ]
<span class='indexparent'><a class='index' id='lookup,qualified_name'></a></span>
</p></div></div></div></div></body></html>